<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>设计模式的C++实现(4)——迭代器Iterator | supdriver的博客</title><meta name="author" content="副驾supdriver"><meta name="copyright" content="副驾supdriver"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="模式名称: 迭代器-Iterator类型: 行为模式问题-使用场景: 提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示解决方案： 将对列表（对象集合）的访问和遍历从具体对象中分离出来，并放入一个迭代器对象中，由它负责实现访问和遍历功能效果： 提供了统一的遍历成员的方法，降低了用户的使用难度，提高了代码的封装性和可扩展性。代价是增加了代码复杂性，增加了更多的类，提高了代">
<meta property="og:type" content="article">
<meta property="og:title" content="设计模式的C++实现(4)——迭代器Iterator">
<meta property="og:url" content="http://supdriver.top/2024/10/15/DP-iterator/index.html">
<meta property="og:site_name" content="supdriver的博客">
<meta property="og:description" content="模式名称: 迭代器-Iterator类型: 行为模式问题-使用场景: 提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示解决方案： 将对列表（对象集合）的访问和遍历从具体对象中分离出来，并放入一个迭代器对象中，由它负责实现访问和遍历功能效果： 提供了统一的遍历成员的方法，降低了用户的使用难度，提高了代码的封装性和可扩展性。代价是增加了代码复杂性，增加了更多的类，提高了代">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202409052350711.jpg">
<meta property="article:published_time" content="2024-10-15T12:00:25.000Z">
<meta property="article:modified_time" content="2024-10-21T07:00:09.169Z">
<meta property="article:author" content="副驾supdriver">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202409052350711.jpg"><link rel="shortcut icon" href="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/sup_avator.webp"><link rel="canonical" href="http://supdriver.top/2024/10/15/DP-iterator/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":230},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '设计模式的C++实现(4)——迭代器Iterator',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-10-21 15:00:09'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/universe.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-categories-card@1.0.0/lib/categorybar.css"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">78</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">21</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202409052350711.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="supdriver的博客"><span class="site-name">supdriver的博客</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">设计模式的C++实现(4)——迭代器Iterator</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-10-15T12:00:25.000Z" title="发表于 2024-10-15 20:00:25">2024-10-15</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-10-21T07:00:09.169Z" title="更新于 2024-10-21 15:00:09">2024-10-21</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">2.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>10分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="设计模式的C++实现(4)——迭代器Iterator"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><blockquote>
<p><strong>模式名称</strong>: 迭代器-Iterator<br><strong>类型</strong>: 行为模式<br><strong>问题-使用场景</strong>: 提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示<br><strong>解决方案</strong>： 将对列表（对象集合）的访问和遍历从具体对象中分离出来，并放入一个迭代器对象中，由它负责实现访问和遍历功能<br><strong>效果</strong>： 提供了统一的遍历成员的方法，降低了用户的使用难度，提高了代码的封装性和可扩展性。代价是增加了代码复杂性，增加了更多的类，提高了代码的设计难度</p>
</blockquote>
<p><em>注：本文的迭代器风格更偏向<code>STL库</code>中的迭代器，而不是《设计模式》中的抽象迭代器</em></p>
<p><strong>灵感来源</strong>：某种意义上将，<code>Iterator</code>要做的事就是模仿数组中的<code>指针</code>,指针可以前后移动，<em>方便地</em>遍历数组，还可以用指针访问数组元素。我们希望把这种指针特性也用在其它数据结构上(<strong>特指组织管理多个对象的聚合体</strong>)，但可惜的是原生指针的这种<em>方便</em>依赖于数组的地址是连续的。因此为了实现遍历和访问功能，我们需要把这些功能封装在<code>Iterator</code>类中，让它实例化出的对象来行使<code>数组指针</code>一样的行为。</p>
<h1 id="类层次设计"><a href="#类层次设计" class="headerlink" title="类层次设计"></a>类层次设计</h1><p>我们先来设计一个抽象迭代器类来规定迭代器应有哪些行为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Ptr, <span class="keyword">typename</span> Ref&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">__base_iterator</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	__base_iterator() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">	__base_iterator(<span class="type">const</span> __base_iterator&lt;T, T*, T&amp;&gt;&amp; it)&#123;&#125;;<span class="comment">//要支持普通迭代器构造const迭代器</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">virtual</span> __base_iterator&lt;T, Ptr, Ref&gt;&amp; <span class="keyword">operator</span>++() = <span class="number">0</span>;<span class="comment">//向前遍历</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//不是所有容器都支持反向迭代器，所以这里根据具体情况声明函数</span></span><br><span class="line">	<span class="comment">//__base_iterator&lt;T&gt;&amp; operator--() = 0; </span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">virtual</span> Ptr <span class="keyword">operator</span>-&gt;() = <span class="number">0</span>;<span class="comment">//重载-&gt;操作，使其部分实现指针功能</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">virtual</span> Ref <span class="keyword">operator</span>*() = <span class="number">0</span>;<span class="comment">//重载解引用，部分实现指针功能</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">virtual</span> <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> __base_iterator&lt;T,Ptr,Ref&gt;&amp;)<span class="type">const</span> = <span class="number">0</span>;<span class="comment">//应当支持迭代器的不等比较</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ValueType&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">ListNode</span>(<span class="type">const</span> ValueType&amp; val = <span class="built_in">ValueType</span>()) :_val(val), _next(<span class="literal">nullptr</span>), _prev(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">	ValueType _val;</span><br><span class="line">	ListNode&lt;ValueType&gt;* _next;</span><br><span class="line">	ListNode&lt;ValueType&gt;* _prev;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>接下来我们逐步解释一下为什么要这么设计。</p>
<h2 id="三个模板参数"><a href="#三个模板参数" class="headerlink" title="三个模板参数"></a>三个模板参数</h2><p><em>为什么要用三个模板参数，一个不行吗，看起来三个更复杂了？</em></p>
<p>因为迭代器分<code>普通迭代器</code>和<code>const迭代器</code>，二者权限不同，在重载<code>operator-&gt;()</code>和<code>operator*()</code>时的返回值类型不同，把两种迭代器分开来声明，代码冗余太多了。为了使代码简洁，并提高代码复用性，这里选择了使用三个模板类的方式，大大提高了代码复用性。</p>
<h2 id="操作符重载"><a href="#操作符重载" class="headerlink" title="操作符重载"></a>操作符重载</h2><p>我们规定了哪些操作符需要重载，来更好地模仿链表指针</p>
<ul>
<li><code>operator++()</code>重载前置++，模仿数组指针的遍历功能</li>
<li><code>operator-&gt;()</code>重载-&gt;,模仿指针的访问成员功能</li>
<li><code>operator*()</code>重载*,模仿指针的访问内存功能</li>
</ul>
<h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><p>先准备一个勉强能用的链表类（没有提供迭代器）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ValueType&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">ListNode</span>(<span class="type">const</span> ValueType&amp; val = <span class="built_in">ValueType</span>()) :_val(val), _next(<span class="literal">nullptr</span>), _prev(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">	ValueType _val;</span><br><span class="line">	ListNode&lt;ValueType&gt;* _next;</span><br><span class="line">	ListNode&lt;ValueType&gt;* _prev;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Type&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">List</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">typedef</span> ListNode&lt;Type&gt; Node;<span class="comment">//简化代码</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">List</span>() :_head(<span class="keyword">new</span> Node) &#123; _head-&gt;_next = _head; _head-&gt;_prev = _head; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">push_front</span><span class="params">(<span class="type">const</span> Type&amp; val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		Node* newnode = <span class="keyword">new</span> <span class="built_in">Node</span>(val);</span><br><span class="line">		Node* prev = _head;</span><br><span class="line">		Node* next = _head-&gt;_next;</span><br><span class="line"></span><br><span class="line">		prev-&gt;_next = newnode;</span><br><span class="line">		next-&gt;_prev = newnode;</span><br><span class="line"></span><br><span class="line">		newnode-&gt;_prev = prev;</span><br><span class="line">		newnode-&gt;_next = next;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> Type&amp; val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		Node* newnode = <span class="keyword">new</span> <span class="built_in">Node</span>(val);</span><br><span class="line">		Node* next = _head;</span><br><span class="line">		Node* prev = _head-&gt;_prev;</span><br><span class="line"></span><br><span class="line">		prev-&gt;_next = newnode;</span><br><span class="line">		next-&gt;_prev = newnode;</span><br><span class="line"></span><br><span class="line">		newnode-&gt;_prev = prev;</span><br><span class="line">		newnode-&gt;_next = next;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">inorder</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		Node* cur = _head-&gt;_next;</span><br><span class="line">		<span class="keyword">while</span> (cur != _head)</span><br><span class="line">		&#123;</span><br><span class="line">			std::cout &lt;&lt; cur-&gt;_val &lt;&lt; <span class="string">&quot;-&gt;&quot;</span>;</span><br><span class="line">			cur = cur-&gt;_next;</span><br><span class="line">		&#125;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;_head\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Node* _head;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后我们来继承一下<code>__base_iterator</code>抽象类并实现相关接口</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Ptr, <span class="keyword">typename</span> Ref&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">__base_iterator</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	__base_iterator() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">	__base_iterator(<span class="type">const</span> __base_iterator&lt;T, T*, T&amp;&gt;&amp; it)&#123;&#125;;<span class="comment">//要支持普通迭代器构造const迭代器</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">virtual</span> __base_iterator&lt;T, Ptr, Ref&gt;&amp; <span class="keyword">operator</span>++() = <span class="number">0</span>;<span class="comment">//向前遍历</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//不是所有容器都支持反向迭代器，所以这里根据具体情况声明函数</span></span><br><span class="line">	<span class="comment">//__base_iterator&lt;T&gt;&amp; operator--() = 0; </span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">virtual</span> Ptr <span class="keyword">operator</span>-&gt;() = <span class="number">0</span>;<span class="comment">//重载-&gt;操作，使其部分实现指针功能</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">virtual</span> Ref <span class="keyword">operator</span>*() = <span class="number">0</span>;<span class="comment">//重载解引用，部分实现指针功能</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">virtual</span> <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> __base_iterator&lt;T,Ptr,Ref&gt;&amp;)<span class="type">const</span> = <span class="number">0</span>;<span class="comment">//应当支持迭代器的不等比较</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ValueType&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">ListNode</span>(<span class="type">const</span> ValueType&amp; val = <span class="built_in">ValueType</span>()) :_val(val), _next(<span class="literal">nullptr</span>), _prev(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">	ValueType _val;</span><br><span class="line">	ListNode&lt;ValueType&gt;* _next;</span><br><span class="line">	ListNode&lt;ValueType&gt;* _prev;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> Ptr,<span class="keyword">typename</span> Ref&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">__list_iterator</span> :<span class="keyword">public</span> __base_iterator&lt;T,Ptr,Ref&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">typedef</span> __list_iterator&lt;T, Ptr, Ref&gt; Self;</span><br><span class="line">	<span class="keyword">typedef</span> __list_iterator&lt;T, T*, T&amp;&gt; iterator;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	__list_iterator(ListNode&lt;T&gt;* ptr) :_ptr(ptr) &#123;&#125;</span><br><span class="line"></span><br><span class="line">	__list_iterator(<span class="type">const</span> iterator&amp; it) :_ptr(it._ptr) &#123;&#125;</span><br><span class="line"></span><br><span class="line">	__base_iterator&lt;T, Ptr, Ref&gt;&amp; <span class="keyword">operator</span>++() <span class="keyword">override</span></span><br><span class="line">	&#123;</span><br><span class="line">		_ptr = _ptr-&gt;_next;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Ptr <span class="keyword">operator</span>-&gt;() <span class="keyword">override</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> &amp;(_ptr-&gt;_val);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Ref <span class="keyword">operator</span>*() <span class="keyword">override</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> _ptr-&gt;_val;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> __base_iterator&lt;T,Ptr,Ref&gt;&amp;it)<span class="type">const</span> </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">const</span> Self* pit = <span class="built_in">dynamic_cast</span>&lt;<span class="type">const</span> Self*&gt;(&amp;it);<span class="comment">//指针的(父类子类间)动态转换</span></span><br><span class="line">		<span class="keyword">if</span> (pit)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> _ptr != pit-&gt;_ptr;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//类型不匹配,认为不相等</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	ListNode&lt;T&gt;* _ptr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>实现难点分析</strong>:</p>
<ul>
<li><code>operator++()</code>使用了在多态中，父类引用作为返回值时，函数的重载可以返回子类的引用</li>
<li><code>operator!=()</code>中因为父类对接口的规定，传参使用了父类的引用，所以要用<code>dynamic_cast</code>做动态的指针转换。</li>
</ul>
<p>以上就是对<code>List</code>类的迭代器的封装，很明显这是一种<code>外部迭代器</code>：<strong>由客户控制迭代</strong>。所以为了能够让客户操作，<code>List</code>类应当提供相关的接口。</p>
<p>不同于书本中的简单工厂设计模式，这里参照的是<code>STL</code>的接口标准，即提供<code>begin()</code> <code>end()</code> <code>begin() const</code> <code>end() const</code>创建<code>iterator</code>或<code>const iterator</code>对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Type&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">List</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">typedef</span> ListNode&lt;Type&gt; Node;<span class="comment">//简化代码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> __list_iterator&lt;Type, Type*, Type&amp;&gt; iterator;</span><br><span class="line">	<span class="keyword">typedef</span> __list_iterator&lt;Type, <span class="type">const</span> Type*, <span class="type">const</span> Type&amp;&gt; const_iterator;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">List</span>() :_head(<span class="keyword">new</span> Node) &#123; _head-&gt;_next = _head; _head-&gt;_prev = _head; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">iterator <span class="title">begin</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> _head-&gt;_next;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">iterator <span class="title">end</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> _head;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">const_iterator <span class="title">begin</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> _head-&gt;_next;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">const_iterator <span class="title">end</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> _head;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//..........下面代码略</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="功能总结与拓展"><a href="#功能总结与拓展" class="headerlink" title="功能总结与拓展"></a>功能总结与拓展</h1><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>经过上面的初步设计，我们的迭代器已经能支持如下功能了：</p>
<ul>
<li>支持按程序员自定义的方式遍历一个<code>聚合体</code></li>
<li>简化了<code>聚合体</code>的接口，<code>聚合体</code>本身不需要提供逐步遍历或自动遍历的接口了</li>
<li>在<strong>同一个</strong>聚合体上，可以同时进行多个遍历。<em>实例化多个迭代器对象即可</em></li>
</ul>
<h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><p>作为一种设计模式，上面的功能还不能算是一种完整的设计模式，<code>Iterator</code>的可扩展性和功能不应该仅局限于简单的遍历</p>
<h3 id="由谁控制迭代"><a href="#由谁控制迭代" class="headerlink" title="由谁控制迭代"></a>由谁控制迭代</h3><p>关于这个问题，迭代器分为了两种</p>
<ul>
<li><code>外部迭代器</code>：由客户来控制迭代</li>
<li><code>内部迭代器</code>：由迭代器自身来控制迭代</li>
</ul>
<p><strong>外部迭代器比内部迭代器更灵活，对客户来说也更易于控制</strong>。尽管<code>C++11</code>以后的<code>lambda表达式</code>支持了<code>匿名函数</code>和<code>闭包</code>，内部迭代器可能比书本中描述的要好用一些，内部迭代器的弱点依然显著。<em>为数不多的好处之一就是它们已经定义好了迭代逻辑，客户用起来比较简单</em></p>
<h3 id="由谁定义遍历-迭代算法"><a href="#由谁定义遍历-迭代算法" class="headerlink" title="由谁定义遍历&#x2F;迭代算法"></a>由谁定义遍历&#x2F;迭代算法</h3><p>实际上迭代器不一定是唯一定义遍历算法的地方。</p>
<p>可以由<strong>聚合体本身定义遍历算法</strong>，由迭代器负责调用算法和<code>储存迭代</code>状态。这样的迭代器我们称其为<code>指针Cursor</code>，因为它仅仅用于指示当前位置。</p>
<p>当然，由<strong>迭代器实现遍历算法</strong>才是最常用的。这样可以提供很大的灵活性。比如在相同的聚合体上提供不同的遍历算法，或者在不同的聚合体上重用相同的算法。<strong>但代价是</strong>,迭代器可能需要访问聚合体的私有变量，这在一定程度上破坏了封装性</p>
<h3 id="迭代器的健壮性和迭代器失效问题"><a href="#迭代器的健壮性和迭代器失效问题" class="headerlink" title="迭代器的健壮性和迭代器失效问题"></a>迭代器的健壮性和迭代器失效问题</h3><p>在使用迭代器遍历时，<strong>插入或是删除操作都是十分危险的</strong>，因为这很可能使迭代器<code>两次访问同一个元素</code>或<code>漏掉某一个元素</code>，这就造成了所谓的<code>迭代器失效问题</code>。</p>
<p>一种简单的解决方法是在开始遍历时，拷贝一整个聚合体用于安全遍历，但这样实在是太浪费资源了</p>
<p>或者参照<code>STL</code>的做法，让聚合体提供的插入或删除的接口能够<strong>返回新的迭代器对象</strong>,这样旧的迭代器失效了也没关系，可以继续使用更新后的<strong>新的迭代器</strong>继续遍历了。比如<code>std::vector</code>中的<code>erase()</code>函数的返回值描述如下</p>
<blockquote>
<h3 id="Return-Value"><a href="#Return-Value" class="headerlink" title="Return Value"></a>Return Value</h3><p>An iterator pointing to the new location of the element that followed the last element erased by the function call. This is the container end if the operation erased the last element in the sequence.<br>返回一个指向被删除元素的后继的迭代器。如果被删除的是最后一个迭代器，则返回表示结尾的迭代器</p>
</blockquote>
<h3 id="多种迭代器"><a href="#多种迭代器" class="headerlink" title="多种迭代器"></a>多种迭代器</h3><p>迭代器也不一定只有一种，可以按不同的遍历方式，声明并实现不同的迭代器，最经典的就是<code>普通迭代器</code>与<code>const 迭代器</code>,<code>正向迭代器</code>与<code>反向迭代器</code>。它们都是不同的类，会实例化出不同的迭代器对象。在这里对类的继承体系并不关心</p>
<h3 id="使用多态的迭代器"><a href="#使用多态的迭代器" class="headerlink" title="使用多态的迭代器"></a>使用多态的迭代器</h3><p>就像上面的示例代码，实际的迭代器类都继承自一个抽象父类<code>__base_iterator</code>，都继承了父类的抽象接口，显然这已经满足了多态的使用条件。</p>
<p>然而<strong>使用多态是有代价的</strong>,客户可能需要通过<code>工厂方法设计模式</code>获取迭代器对象，而且还需要客户<code>手动释放迭代器对象</code>，然而客户常常会漏掉或忘记对象的释放，尤其是<code>堆区上的对象</code>。当然，现在有<code>shared_ptr</code>智能指针来减少这种情况的出现。</p>
<h3 id="空迭代器"><a href="#空迭代器" class="headerlink" title="空迭代器"></a>空迭代器</h3><p>一个空的迭代器不能实现遍历功能，但是它可以用来标识一次遍历的结尾。这种功能在单向链表，树的遍历就尤为有用，当遍历到<code>nullptr</code>时，返回一个空迭代器即可</p>
<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><ul>
<li>C++中的STL库中的容器都支持迭代器，使其能够方便地遍历</li>
<li>MySQL提供的C语言接口库中提供的<code>mysql_fetch_row()</code>函数，每一次调用都会获取下一行，行为就和迭代器很像</li>
<li>还有更多聚合体可以使用迭代器设计模式，比如可视化控件类的遍历等</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://supdriver.top">副驾supdriver</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://supdriver.top/2024/10/15/DP-iterator/">http://supdriver.top/2024/10/15/DP-iterator/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://supdriver.top" target="_blank">supdriver的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202409052350711.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/10/10/DP-whatis/" title="设计模式的C++实现(0)——初识设计模式"><img class="cover" src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/6d98b25ed940e1702fd7023bd166babf.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">设计模式的C++实现(0)——初识设计模式</div></div></a></div><div class="next-post pull-right"><a href="/2024/10/22/mysql-users/" title="MySQL用户管理"><img class="cover" src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/0a175c01fefe6b016d5da64c655b1cee.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">MySQL用户管理</div></div></a></div></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">副驾supdriver</div><div class="author-info__description">动物界 脊索动物门 哺乳纲 灵长目 人科 人属 智人种</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">78</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">21</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/sis-shen"><i class="fab fa-github"></i><span>我github还蛮大的</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/sis-shen" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content"><center>主域名：<br><a target="_blank" rel="noopener" href="https://www.supdriver.top"><b><font color="#5ea6e5">supdriver.top</font></b></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB%E5%B1%82%E6%AC%A1%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.</span> <span class="toc-text">类层次设计</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E4%B8%AA%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0"><span class="toc-number">1.1.</span> <span class="toc-text">三个模板参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-number">1.2.</span> <span class="toc-text">操作符重载</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.2.1.</span> <span class="toc-text">代码示例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8A%9F%E8%83%BD%E6%80%BB%E7%BB%93%E4%B8%8E%E6%8B%93%E5%B1%95"><span class="toc-number">2.</span> <span class="toc-text">功能总结与拓展</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">2.1.</span> <span class="toc-text">小结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%93%E5%B1%95"><span class="toc-number">2.2.</span> <span class="toc-text">拓展</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%B1%E8%B0%81%E6%8E%A7%E5%88%B6%E8%BF%AD%E4%BB%A3"><span class="toc-number">2.2.1.</span> <span class="toc-text">由谁控制迭代</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%B1%E8%B0%81%E5%AE%9A%E4%B9%89%E9%81%8D%E5%8E%86-%E8%BF%AD%E4%BB%A3%E7%AE%97%E6%B3%95"><span class="toc-number">2.2.2.</span> <span class="toc-text">由谁定义遍历&#x2F;迭代算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E5%81%A5%E5%A3%AE%E6%80%A7%E5%92%8C%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98"><span class="toc-number">2.2.3.</span> <span class="toc-text">迭代器的健壮性和迭代器失效问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Return-Value"><span class="toc-number">2.2.4.</span> <span class="toc-text">Return Value</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%A7%8D%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">2.2.5.</span> <span class="toc-text">多种迭代器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%A4%9A%E6%80%81%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">2.2.6.</span> <span class="toc-text">使用多态的迭代器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A9%BA%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">2.2.7.</span> <span class="toc-text">空迭代器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BA%94%E7%94%A8"><span class="toc-number">3.</span> <span class="toc-text">应用</span></a></li></ol></div></div></div></div></main><footer id="footer" style="background: rgba(0,0,0,0)"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2025 By 副驾supdriver</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">I wish you to become your own sun, no need to rely on who's light.<p><a target="_blank" href="https://hexo.io/"><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&logo=hexo" title="博客框架为Hexo"></a>&nbsp;<a target="_blank" href="https://butterfly.js.org/"><img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&logo=bitdefender" title="主题采用butterfly"></a>&nbsp;<a target="_blank" href="https://www.jsdelivr.com/"><img src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&logo=jsDelivr" title="本站使用JsDelivr为静态资源提供CDN加速"></a> &nbsp;<a target="_blank" href="https://vercel.com/ "><img src="https://img.shields.io/badge/Hosted-Vervel-brightgreen?style=flat&logo=Vercel" title="本站采用双线部署，默认线路托管于Vercel"></a>&nbsp;<a target="_blank" href="https://vercel.com/ "><img src="https://img.shields.io/badge/Hosted-Coding-0cedbe?style=flat&logo=Codio" title="本站采用双线部署，联通线路托管于Coding"></a>&nbsp;<a target="_blank" href="https://github.com/"><img src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&logo=GitHub" title="本站项目由Gtihub托管"></a>&nbsp;<a target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&logo=Claris" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"></a></p></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(()=>{
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://hbcom.supdriver.top/',
      region: '',
      onCommentLoaded: function () {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://hbcom.supdriver.top/',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      countELement.textContent = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const runFn = () => {
    init()
    GLOBAL_CONFIG_SITE.isPost && getCount()
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') {
      setTimeout(runFn,0)
      return
    } 
    getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(runFn)
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script async src="/js/title.js"></script><canvas id="universe"></canvas><script defer src="/js/universe.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><!-- hexo injector body_end start --><script data-pjax>
    function butterfly_categories_card_injector_config(){
      var parent_div_git = document.getElementById('recent-posts');
      var item_html = '<style>li.categoryBar-list-item{width:32.3%;}.categoryBar-list{max-height: 380px;overflow:auto;}.categoryBar-list::-webkit-scrollbar{width:0!important}@media screen and (max-width: 650px){.categoryBar-list{max-height: 320px;}}</style><div class="recent-post-item" style="height:auto;width:100%;padding:0px;"><div id="categoryBar"><ul class="categoryBar-list"></ul></div></div>';
      console.log('已挂载butterfly_categories_card')
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      }
    if( document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    butterfly_categories_card_injector_config()
    }
  </script><!-- hexo injector body_end end --></body></html>