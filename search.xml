<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>=C语言=把玩文件操作系列函数（实验向）</title>
      <link href="/2023/12/18/file-ex/"/>
      <url>/2023/12/18/file-ex/</url>
      
        <content type="html"><![CDATA[<p>C语言的<code>stdio</code>头文件提供了一系列用于<code>文件操作</code>的函数，本篇文章将以偏向实验的方式玩玩这些函数</p><p><em>注：这里使用vs2022编译器，所有文件均已显示后缀名</em></p><p><em>下图为初始的源文件和普通文件目录</em><br><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2023-12-18_11-35-37.png"></p><h1 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h1><p>咱们话不多说，赶紧打开一个 <code>文件</code><strong>看看</strong>。如何打开？就用<code>fopen</code>函数吧</p><h4 id="r-只读模式"><a href="#r-只读模式" class="headerlink" title="r-只读模式"></a>r-只读模式</h4><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2023-12-19_09-17-49.png"></p><p>诶呀，出错了，<code>不存在这样的文件</code>,不要慌，我们再仔细看看代码和文件名，发现<strong>少写了文件后缀</strong>，由此得出结论，只读模式打开不仅只能打开<strong>已存在</strong>的文件，而且对文件<strong>后缀</strong>也相当严格</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>vim基础指令集</title>
      <link href="/2023/12/11/vim-cmd/"/>
      <url>/2023/12/11/vim-cmd/</url>
      
        <content type="html"><![CDATA[<p><code>Vim</code>是一款文本编辑器,下面介绍在vim界面中的常用指令</p><p><strong>三种模式</strong>:<code>命令模式(Command Mode)</code> <code>插入模式（Insert Mode</code> <code>命令行模式（Command-Line Mode）</code>（这里称命令行模式为<code>底行模式</code>）</p><p>三者关系如下图</p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2023-12-11_10-39-04.png"></p><h1 id="底行模式"><a href="#底行模式" class="headerlink" title="底行模式"></a>底行模式</h1><p><code>tips</code>:不管目前是什么模式,先狂按<code>ESC</code>,回到<code>命令模式</code>,然后输入<code>:</code>进入<code>底行模式</code>,准备开始输命令</p><p><code>命令组成</code><br><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2023-12-11_12-48-54.png"></p><ul><li>保存<code>:w</code>-&gt;强制保存</li></ul><h1 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux中vim的配置和插件安装</title>
      <link href="/2023/12/11/linux-vim-set-plug/"/>
      <url>/2023/12/11/linux-vim-set-plug/</url>
      
        <content type="html"><![CDATA[<p><strong>权限</strong>: 要改配置或插件的用户<code>user</code>(强烈不建议用root)</p><p><em>注:本篇博客的用户名均用<code>supdriver</code>替代，包括用户的工作目录</em></p><p><strong>vim配置文件</strong><code>/home/supdriver/.vimrc</code></p><p><strong>vim插件安装文件夹</strong><code>/home/supdriver/.vim</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux指令集</title>
      <link href="/2023/12/11/linux-cmd1/"/>
      <url>/2023/12/11/linux-cmd1/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>从构建一个Date类入门C++类与对象</title>
      <link href="/2023/12/07/cpp-class/"/>
      <url>/2023/12/07/cpp-class/</url>
      
        <content type="html"><![CDATA[<h1 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">(<span class="type">int</span> year = <span class="number">1</span>,<span class="type">int</span> month = <span class="number">1</span>,<span class="type">int</span> day = <span class="number">1</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _year = year;</span><br><span class="line">        _month = month;</span><br><span class="line">        _day = day;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; _year &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; _month &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; _day &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _year;</span><br><span class="line">    <span class="type">int</span> _month;</span><br><span class="line">    <span class="type">int</span> _day;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="抽象数据类型-类"><a href="#抽象数据类型-类" class="headerlink" title="抽象数据类型(类)"></a>抽象数据类型(类)</h2><p>通过如上代码，我们就在源代码中通过<code>class</code>声明了一个抽象数据类型<code>Date</code>,简称<code>类</code>，那么封装一个类有什么好处呢？<br>好处是类把相关的操作分为<strong>两类</strong>:</p><ul><li>类的<strong>设计者</strong>:负责考虑类的具体实现，提供类的接口，成员变量等</li><li>类的<strong>使用者</strong>:只关心类<strong>提供</strong>了哪些功能，而不关心具体实现，从而简化思路</li></ul><p>以上面的<code>Date</code>类为例</p><blockquote><p>对设计者</p></blockquote><ul><li>要考虑实现<code>Date</code>,就需要声明<strong>成员变量</strong><code>_year</code> <code>_month</code> <code>_day</code>,以及声明及实现<strong>成员函数</strong><code>Init</code>和<code>Print</code></li></ul><blockquote><p>对使用者</p></blockquote><ul><li>只需知道可以调用<code>Date</code>的<strong>成员函数</strong><code>Init</code>和<code>Print</code>,以及知道它们的用处即可</li></ul><h2 id="实例化-–-将类真正投入使用"><a href="#实例化-–-将类真正投入使用" class="headerlink" title="实例化 – 将类真正投入使用"></a>实例化 – 将类真正投入使用</h2><p>类也可以用于声明变量，例如<code>Date d</code>就声明了一个变量<code>d</code>,但由于是由<code>类</code>声明的,我们将这一过程称为<code>实例化</code>,其中<code>Date</code>这样的抽象数据类型称为<code>类</code>，像<code>d</code>这样的变量称为<code>对象</code></p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-04-16_11-19-21.png"></p><p>实例化后的对象拥有<strong>私有</strong>的<code>成员变量</code>和整个类<strong>公有</strong>的<code>成员函数</code>,接下来对<code>对象</code>的操作都是对<code>成员变量</code>和<code>成员函数</code>的操作</p><h2 id="访问成员函数-变量"><a href="#访问成员函数-变量" class="headerlink" title="访问成员函数&#x2F;变量"></a>访问成员函数&#x2F;变量</h2><h3 id="在类的内部"><a href="#在类的内部" class="headerlink" title="在类的内部"></a>在<code>类的内部</code></h3><p>对于类的成员函数，除了显式声明的<code>函数参数</code>外,还有<strong>隐式</strong>传入的<code>this</code>指针，这是个<strong>默认<code>非const</code>修饰</strong>的,指向调用该成员函数的<strong>对象的指针</strong>,编译器可以通过这个指针访问该对象的<code>成员变量</code>和<code>成员函数</code>。</p><p>而我们作为类的<strong>设计者</strong>，既然语法都<strong>隐式</strong>地传入<code>this</code>指针了，自然也可以<strong>隐式</strong>地调用<code>成员</code>,即<strong>直接写</strong>变量名&#x2F;函数名调用</p><p><em>当然，手动显式调用this指针也是可以的</em></p><blockquote><p>以<code>Date</code>为例</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该函数声明在Date类中，成员变量见文章开头</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestPrint</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _year = <span class="number">2024</span>;<span class="comment">//隐式调用this访问成员变量</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;_month = <span class="number">4</span>;<span class="comment">//显式调用this</span></span><br><span class="line">    _day = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">Print</span>();<span class="comment">//隐式调用this来调用成员函数Print()</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">Print</span>();<span class="comment">//显式调用this，效果与上一句相同</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但由于<code>const</code>修饰的<code>对象</code>传出的是<code>const</code>修饰的<code>this</code>指针，普通的<code>this</code>形参无法接收。<br>那么如何让<code>成员函数</code>传入<code>const</code>修饰的<code>this</code>指针,来使<code>const</code>修饰的<code>对象</code>有成员函数可调用呢？</p><p>语法规定，在函数的参数列表(<em>圆括号后面</em>)紧跟一个<code>const</code>可使函数传入<code>const</code>修饰的<code>this</code>指针</p><p><em>这种函数称为常量成员函数</em></p><blockquote><p><em>举个例子</em></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="comment">//该函数声明在类中</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">constPrint</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在类的外部"><a href="#在类的外部" class="headerlink" title="在类的外部"></a>在<code>类的外部</code></h3><p>和C语言的结构体一样，访问对象内的成员有两种方式</p><ul><li><em>对象名</em> + <code>.</code> + 成员名 ： 用<code>.</code>操作符访问对应成员</li><li><em>对象的指针</em> + <code>-&gt;</code> + 成员名 : 用<code>-&gt;</code>操作符访问指针<strong>指向对象</strong>的对应成员</li></ul><blockquote><p>以<code>Date</code>实例化一个<code>d</code>为例</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// class Date</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     ....</span></span><br><span class="line"><span class="comment">// &#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Date d;</span><br><span class="line">    Date* pd = &amp;d;</span><br><span class="line">    d.<span class="built_in">Init</span>(<span class="number">2024</span>,<span class="number">4</span>,<span class="number">1</span>);<span class="comment">// . 操作符调用Init成员函数来初始化对象</span></span><br><span class="line">    pd-&gt;<span class="built_in">Print</span>();<span class="comment">//-&gt;操作符调用Print成员函数来打印内容</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Date d;</span><br><span class="line">    d._year = <span class="number">2024</span>;<span class="comment">//试图访问成员变量_year,但是访问权限冲突</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test1输出</span></span><br><span class="line"><span class="number">2024</span>:<span class="number">4</span>:<span class="number">1</span></span><br><span class="line"><span class="comment">//test2输出</span></span><br><span class="line">报错，无输出，因为访问权限冲突</span><br></pre></td></tr></table></figure><p>代码如上，<code>test1</code>运行的很好，但<code>test2</code>报错了，原因在于<code>test2</code>作为<strong>非成员函数</strong>访问了访问限定符<code>private</code>控制的成员<code>_year</code>,权限冲突，就会报错。</p><p>由此，C++类和对象还有一个重要概念需要强调–<strong>访问控制</strong></p><h2 id="访问权限控制与封装"><a href="#访问权限控制与封装" class="headerlink" title="访问权限控制与封装"></a>访问权限控制与封装</h2><p>使用类和对象编程的一大优点就是类可以<code>封装</code>代码，让使用者只能使用公有的接口和成员变量，而对内部的具体实现不可见，来提高类的<code>易用性</code>和<code>安全性</code></p><p>所以C++语法提供了三种<code>访问说明符</code>(<em>access specifiers</em>)</p><ul><li>public: 该说明符之后的成员在整个程序内可被访问</li><li>private: 之后的成员仅可被该类的的类域里（<em>如成员函数</em>）访问</li><li>protected: 一般同<code>private</code>,主要特点体现在类的继承，这里<strong>不作讨论</strong></li></ul><h3 id="作用范围"><a href="#作用范围" class="headerlink" title="作用范围"></a>作用范围</h3><p>某一<code>访问说明符</code>的作用范围开始于它的<code>冒号</code>,终止于下一个<code>访问说明符</code>或<code>类的结尾</code>,而<code>类的开始</code>到第一个<code>访问说明符</code>前的访问权限取决于<strong>声明</strong>类的<code>关键字</code>,分类如下</p><ul><li><code>class</code>默认为<code>private</code>权限</li><li><code>struct</code>默认为<code>public</code>权限</li></ul><blockquote><p>图例如下</p></blockquote><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-04-18_14-15-40.png"></p><p>实际上<code>class</code>和<code>struct</code>除了默认权限不一样，基本<strong>没有差别</strong>。</p><p>所以为了防止误读，<strong>提高可读性</strong>,<strong>不建议</strong>在<code>默认区</code>写代码,而是保证每段语句前都有合适的<code>访问限定符</code></p><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>作为类的设计者，一个类按<code>访问权限</code>可以分为两个区</p><ul><li><code>public</code>: 将提供给<code>使用者</code>的<code>接口（函数）</code>和<code>成员变量</code>声明在此，用于外部调用接口和修改非私有的成员函数</li><li><code>private</code>: 用于存放<strong>受保护</strong>的<code>成员变量</code>和<code>成员函数</code>,防止外部使用者<em>意外</em>或<em>恶意</em>调用或修改,造成类的内部结构被破坏等<strong>安全问题</strong>,所以特别重要的成员变量，和不希望被外部调用的函数声明在这里</li></ul><blockquote><p>例如在声明<code>Date</code>类时，我们将<code>Init</code>和<code>Print</code>接口提供给使用者，用<code>public</code>控制；<code>_year</code>等成员变量不希望被外部随意修改，就用<code>private</code>控制</p></blockquote><h1 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h1><p>学完以上内容，不过是会写个高级点的<code>结构体</code>而已，要写一个完整的类，还需要学习更多的语法知识</p><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>像本篇的<code>Date</code>类那样显式地调用<code>Init</code>函数来初始化是非常挫的，既然语言本身的<code>内置类型</code>可以在声明的时候初始化，那么类的设计者设计出来的类也应当提供<code>初始化的接口</code>,而支持这一功能的接口便是<code>构造函数</code></p><p>按语法规定，<code>构造函数</code>的函数名必须是<code>类名</code>,<strong>没有返回值</strong>，<code>const</code>修饰的成员变量必须位于<code>初始化列表</code>,其它则可省略。<em>关于初始化列表，稍后详细解释</em></p><blockquote><p>以<code>Date</code>类为例</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//一个普通的构造函数</span></span><br><span class="line">    <span class="built_in">Date</span>(<span class="type">int</span> year,<span class="type">int</span> month,<span class="type">int</span> day)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//进入括号时成员变量已经声明，且未初始化</span></span><br><span class="line">        _year = year;<span class="comment">//这是一个赋值操作，而不是初始化</span></span><br><span class="line">        _month = month;</span><br><span class="line">        _day = day;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _year;</span><br><span class="line">    <span class="type">int</span> _month;</span><br><span class="line">    <span class="type">int</span> _day;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Date <span class="title">d</span><span class="params">(<span class="number">2024</span>,<span class="number">4</span>,<span class="number">1</span>)</span></span>;<span class="comment">//使用构造函数声明了一个d对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以上的构造函数基本能用了,但还有两个问题</p><ul><li>构造函数没有初始化成员变量，而是采用赋值操作,无法初始化<code>const</code>修饰的成员变量</li><li>使用<code>Date d</code>是会报错的，因为没有提供<code>默认构造函数</code></li></ul><p>对于<strong>第一个问题</strong>，就要引入<code>初始化列表</code>这一概念，让初始化函数直接拥有<code>初始化成员变量</code>的功能</p><p>初始化列表位于构造函数的参数列表之后，花括号之前，以<code>:</code>开头，用<code>,</code>分隔成员变量</p><blockquote><p>以<code>Date</code>为例</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Date</span>(<span class="type">int</span> year,<span class="type">int</span> month,<span class="type">int</span> day):_year(year) , _month(month) , _day(day) &#123;&#125;</span><br><span class="line"><span class="comment">//或者换个书写格式（二者完全等价）</span></span><br><span class="line"><span class="built_in">Date</span>(<span class="type">int</span> year,<span class="type">int</span> month,<span class="type">int</span> day):_year(year) </span><br><span class="line">, _month(month) </span><br><span class="line">, _day(day) </span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure><p>通过这样<code>初始化列表</code>,便能在声明对象时，<strong>直接</strong>初始化成员变量</p><p>对于<strong>问题二</strong>，我们开启另一个个小专题</p><h3 id="构造函数的重载和缺省参数"><a href="#构造函数的重载和缺省参数" class="headerlink" title="构造函数的重载和缺省参数"></a>构造函数的重载和缺省参数</h3><p>没错，构造函数和函数一样，也是能<code>重载</code>和给参数传<code>缺省值</code>的</p><p><em>也就是说我们能写好几个构造函数</em></p><p>下面特别说明几个<strong>特殊</strong>的构造函数</p><h4 id="默认构造函数"><a href="#默认构造函数" class="headerlink" title="默认构造函数"></a>默认构造函数</h4><p>原则上对于每一个类，都应该提供<strong>有且仅有一个</strong>默认构造函数（*多个<code>默认构造函数</code>会报错!*）</p><p>而要<strong>声明</strong>默认构造函数，只需声明<code>无参数</code>构造函数，或者<code>全缺省参数</code>构造函数即可</p><blockquote><p>以<code>Date</code>为例</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Date</span>():_year(<span class="number">2024</span>),_month(<span class="number">4</span>),_day(<span class="number">1</span>)&#123;&#125;</span><br><span class="line"><span class="comment">//====分割线=======</span></span><br><span class="line"><span class="comment">//或者全缺省，两个函数不能同时声明</span></span><br><span class="line"><span class="built_in">Date</span>(<span class="type">int</span> year = <span class="number">2024</span>,<span class="type">int</span> month = <span class="number">4</span>,<span class="type">int</span> day = <span class="number">1</span>): _year(year),_month(month),_day(day)&#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以上就是两种默认构造函数的声明形式</p><h4 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h4><p>有时候我们会希望用<strong>现有的</strong>的对象去初始化一个<strong>新</strong>对象,此时对应的构造函数就称为<code>拷贝构造（函数）</code></p><p><code>拷贝构造</code>的声明方式为<code>构造函数</code>+参数类型为<code>类本身的引用传参</code>,不加<code>&amp;</code>的话就会死递归报错,有无<code>const</code>皆可，但由于是实现<code>拷贝功能</code>，一般是加<code>const</code>的</p><blockquote><p>以<code>Date</code>为例</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Date</span>(<span class="type">const</span> Date&amp; d):_year(d._year),_month(d._month),_day(d._day)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用示例</span></span><br><span class="line"><span class="function">Date <span class="title">d</span><span class="params">(<span class="number">2024</span>,<span class="number">4</span>,<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="function">Date <span class="title">copy1</span><span class="params">(d)</span></span>;<span class="comment">//调用方式一</span></span><br><span class="line">Date copy2 = d;<span class="comment">//调用方式二,此时不会调用operator=()</span></span><br><span class="line"></span><br><span class="line">copy1 = copy2;<span class="comment">//这种并不会调用拷贝构造,而是调用operator=()</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="使用模板的类的函数缺省值"><a href="#使用模板的类的函数缺省值" class="headerlink" title="使用模板的类的函数缺省值"></a>使用模板的类的函数缺省值</h4><p>有时我们在使用类模板来设计类时，需要给<code>模版类</code>类型的形参提供一个缺省值，有些人可能会写个<code>0</code>,但是其实是<strong>错的</strong>，正确的做法是传一个<code>临时变量</code></p><p>但此时要求<code>模板参数中的类</code>有可用的<code>默认构造函数</code>和<code>拷贝构造</code>用于调用</p><blockquote><p>以链表节点<code>Node</code>为例</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">value_type</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    value_type _val;</span><br><span class="line">    Node&lt;value_type&gt;* _next;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">const</span> value_type&amp; val = <span class="built_in">value_type</span>()):_val(val),_next(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以用本文的Date实例化为例</span></span><br><span class="line">Node&lt;Date&gt; node;</span><br><span class="line"><span class="comment">//会发现node中的val已经调用了默认构造函数</span></span><br><span class="line">node.val.<span class="built_in">TestPrint</span>();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>指针详解(修改中)</title>
      <link href="/2023/11/23/pointer/"/>
      <url>/2023/11/23/pointer/</url>
      
        <content type="html"><![CDATA[<p><em>这篇质量不太行:（</em></p><h1 id="内存和地址"><a href="#内存和地址" class="headerlink" title="内存和地址"></a>内存和地址</h1><p>在了解指针之前，先讲讲内存是如何管理的</p><p>首先因为内存很大（一般有几个G）,所以为了高效管理，有了<code>内存单元</code>的概念。而这个单元的大小，正好是一个字节。</p><p>因为一个<code>比特位</code>就是一个二进制位，太小了，超过一个字节，在处理<code>char</code>这样一个字节长的变量很麻烦。</p><p>定下长度后，就可以给内存单元编号，而每个内存单元获得的独一无二的编号，便是它的<strong>地址</strong>,以声明了一个变量a为例,示意图如下</p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-23_09-59-30.png"></p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-23_10-21-48.png"></p><h2 id="变量的地址"><a href="#变量的地址" class="headerlink" title="变量的地址"></a>变量的地址</h2><p>上图中<code>a</code>占4个字节，每个字节都有自己的地址，但要找到<code>a</code>其实只需要找到第一个地址就行了，实际上在<code>C语言</code>中也是如此,<code>a</code>的地址就是<code>首字节地址</code>,即图中的<code>0x000000AF88DFF6A4</code></p><h2 id="关于几个名词"><a href="#关于几个名词" class="headerlink" title="关于几个名词"></a>关于几个名词</h2><p>在<code>C语言</code>中称<code>地址</code>为<code>指针</code>,<strong>储存</strong>地址的变量叫<code>指针变量</code>,平时也<strong>简称</strong><code>指针</code>,此时强调的是<code>指针变量</code>里储存的地址，而不是这个变量。</p><h2 id="指针变量的组成"><a href="#指针变量的组成" class="headerlink" title="指针变量的组成"></a>指针变量的组成</h2><p>指针变量也要<strong>拆成两部分</strong>来看</p><p>一个是变量的<code>值</code>,在同一个程序中，所有指针变量的值的<code>长度</code>都是一样的，都指向了某<strong>一</strong>个内存中的<code>字节</code>, 至于具体多长，取决于环境:<code>32位程序是4个字节</code>,<code>64位程序是8个字节</code></p><p>另一个是变量的<code>类型</code>,类型决定编译器从<code>值</code>所指向的字节，向后总共读<strong>几个</strong>字节，以及用<strong>什么方式</strong>读取内存里的内容。以下图的代码为例</p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-23_11-36-47.png"></p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-23_11-29-53.png"></p><p>可以看到三种指针指向了<strong>同一个</strong>字节，即它们的值是相等的，但<code>指针类型</code>不同，解引用之后得到的<code>值</code>也不同,</p><p><code>char</code>比<code>int</code>短，所以<code>*p_char</code>只能取到<code>00</code>,</p><p>而虽然<code>float</code>和<code>int</code>一样长，但对内存的<strong>读法不同</strong>，所以<code>*p_float</code>和<code>*p_int</code>依然不同</p><h1 id="指针-变量-的使用"><a href="#指针-变量-的使用" class="headerlink" title="指针(变量)的使用"></a>指针(变量)的使用</h1><h2 id="声明指针变量"><a href="#声明指针变量" class="headerlink" title="声明指针变量"></a>声明指针变量</h2><p>指针变量也是变量，在没有结合性问题时，和一般变量的声明方式差不多。</p><p>变量的声明:<code>变量类型</code> + <code>变量名</code></p><p>指针的声明:<code>指向的变量类型</code> + <code>*</code> + <code>变量名</code></p><p>以下以声明一个字符指针为例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* pointer = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-24_10-02-19.png"></p><p><em>变量的声明逻辑如上图</em></p><h3 id="进阶：二级指针-N级指针"><a href="#进阶：二级指针-N级指针" class="headerlink" title="进阶：二级指针-&gt;N级指针"></a>进阶：二级指针-&gt;N级指针</h3><p>我们可以用同样的逻辑声明更高级的指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* *ppstr = <span class="literal">NULL</span>;<span class="comment">//ppstr是一个二级指针</span></span><br><span class="line"><span class="type">char</span>** *ppstr = <span class="literal">NULL</span>;<span class="comment">//pppstr是一个三级指针</span></span><br></pre></td></tr></table></figure><p>在声明中,前面的<code>char*</code>声明了<code>ppstr</code><strong>指向</strong>的变量类型,后面的<code>*</code>与<code>变量名</code>结合，声明<code>ppstr</code>是一个指针.</p><p>此处，称指向<code>一级指针</code>的指针为<code>二级指针</code>,同理有<code>三级指针</code>,至<code>N级指针</code>.</p><h2 id="指针的解引用"><a href="#指针的解引用" class="headerlink" title="指针的解引用"></a>指针的解引用</h2><p>指针最常见的用处就是通过变量里<strong>储存的地址</strong>，通过直接修改目标变量的<strong>内存</strong>来修改变量的值 ， 当然还有强制转换指针类型来读取目标变量的<strong>一部分</strong>内存 之类的骚操作</p><h3 id="函数的传址调用"><a href="#函数的传址调用" class="headerlink" title="函数的传址调用"></a>函数的传址调用</h3><p>在遇到指针前，使用函数时，由于实参传到函数里都变成了<strong>形参</strong>,无法通过形参（<em>包括修改形参的值</em>）来改变实参的值，因为形参终究只是实参的一份<strong>临时拷贝</strong>.</p><p>而有了指针之后，函数的实参，形参关系不变，但我们有了<strong>更高端</strong>的形参,也就是<code>指针</code>, 尽管<code>函数内的指针</code>依旧是<code>函数外的指针</code>的<strong>临时拷贝</strong>,但我们已经能通过其储存的<strong>值</strong>访问<code>函数外变量</code>的内存了,同时包括<code>读取</code>和<code>修改</code>, 这种通过传入指针来修改外部变量的函数调用，便称为<code>函数的传址调用</code></p><p><em>以如下代码为例</em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Swap_int</span><span class="params">(<span class="type">int</span>*a,<span class="type">int</span>*b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//给我两个整型的地址，我就能 真·交换它们的值</span></span><br><span class="line">    <span class="type">int</span> tmp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="提问-如何修改函数外的指针的值"><a href="#提问-如何修改函数外的指针的值" class="headerlink" title="提问?如何修改函数外的指针的值?"></a>提问?如何修改函数外的指针的值?</h4><p>依然还是把这一<strong>指针的地址</strong>传进去，而函数的形参写成<strong>更高一级</strong>的指针</p><p><em>如下代码，例如我想在函数里把外部的指针置空</em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Reset</span><span class="params">(<span class="type">char</span>* *pstr)</span> </span><br><span class="line">&#123;</span><br><span class="line">    *pstr = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span>* str;</span><br><span class="line">    Reset(&amp;str)<span class="comment">//对一级指针取地址，传入二级指针</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="有关指针的危险操作"><a href="#有关指针的危险操作" class="headerlink" title="有关指针的危险操作"></a>有关指针的危险操作</h1><h2 id="野指针的解引用"><a href="#野指针的解引用" class="headerlink" title="野指针的解引用"></a>野指针的解引用</h2><p>有些指针因为错误操作，指向了不能访问的内存，一旦解引用，就有可能使程序崩溃</p><p><em>情形如下</em></p><h3 id="使用了-未初始化-赋值-的指针"><a href="#使用了-未初始化-赋值-的指针" class="headerlink" title="使用了 未初始化&#x2F;赋值 的指针"></a>使用了 未初始化&#x2F;赋值 的指针</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* pa;<span class="comment">//未初始化，pa的值为随机值</span></span><br><span class="line">*pa = <span class="number">0</span> ;<span class="comment">//野指针的解引用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//正确的用法</span></span><br><span class="line"><span class="type">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* pa;</span><br><span class="line">pa = arr;<span class="comment">//立即初始化</span></span><br><span class="line"><span class="type">int</span>* pb = <span class="literal">NULL</span>;<span class="comment">//初始化</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>所以声明指针时最好初始化,如果不知道初始化成什么，就用<code>NULL</code>空指针初始化</p><h3 id="指向了-已回收的-内存空间"><a href="#指向了-已回收的-内存空间" class="headerlink" title="指向了 已回收的 内存空间"></a>指向了 已回收的 内存空间</h3><p>有的函数<strong>错误</strong>*地返回了内部临时变量的地址， 在<strong>外面</strong>使用返回的指针，因为此时函数的栈帧已经<strong>销毁</strong>，会发生野指针的解引用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">fun</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span>* pa = &amp;a;</span><br><span class="line">    <span class="keyword">return</span> pa;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//情形一</span></span><br><span class="line">    <span class="type">char</span>* pa = fun();</span><br><span class="line">    *pa = <span class="number">1</span>;<span class="comment">//此时变量a已经销毁，发生野指针的解引用，即非法访问</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//情形二</span></span><br><span class="line">    <span class="type">char</span>* str = (<span class="type">char</span>*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>) *<span class="number">10</span>) <span class="comment">//在堆区开辟10个字节的空间</span></span><br><span class="line">    <span class="built_in">free</span>(str);<span class="comment">//然后释放掉</span></span><br><span class="line">    str[<span class="number">0</span>] = <span class="string">&#x27;A&#x27;</span>;<span class="comment">//试图访问已free的内存，并写入，发生非法访问</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="空指针的解引用"><a href="#空指针的解引用" class="headerlink" title="空指针的解引用"></a>空指针的解引用</h2><p>空指针<code>NULL</code>,<code>值</code>为<code>0</code>,一旦解引用就会报错，所以在解引用陌生指针时一定要注意判空</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//情形一</span></span><br><span class="line"><span class="type">char</span>* <span class="title function_">func</span><span class="params">(<span class="type">char</span>* str)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(str == <span class="literal">NULL</span>)<span class="comment">//防止使用者错误传入空指针</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//情形二</span></span><br><span class="line"><span class="type">char</span>* <span class="title function_">InitArray</span><span class="params">(<span class="type">char</span>** pstr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(pstr == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    *pstr = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>) * <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">if</span>(*ptr == <span class="literal">NULL</span>)<span class="comment">//malloc一旦失败就会返回NULL,所以调用后一定要判空</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>=C入门=深入研究 字符串与字符数组</title>
      <link href="/2023/11/08/str-arr/"/>
      <url>/2023/11/08/str-arr/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是字符串"><a href="#什么是字符串" class="headerlink" title="什么是字符串"></a>什么是字符串</h1><h2 id="初见字符串"><a href="#初见字符串" class="headerlink" title="初见字符串"></a>初见字符串</h2><p>我们最先遇到的字符串,一般是<code>hello_world</code>程序中用到的<code>&quot;hello world&quot;</code>,也就是<strong>两个双引号括起来的一串字符</strong>,输出时的占位符是<code>%s</code>,可以直接拿去传值，代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,<span class="string">&quot;hello world&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="声明字符串变量"><a href="#声明字符串变量" class="headerlink" title="声明字符串变量"></a>声明字符串变量</h2><p>有时我们想要先把字符串存起来，再进行操作，那么就使用<strong>字符数组</strong>，并在<strong>初始化</strong>的时候把字符串传给它,这样在<strong>创建数组</strong>时会编译器会自动分配内存给它，代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[] = <span class="string">&quot;abcdef&quot;</span>;</span><br></pre></td></tr></table></figure><p>此时我们也可以开启VS的<strong>调试</strong>，并打开<strong>内存</strong>和<strong>监视</strong>窗口观察字符串是如何在内存中储存的,如下图</p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-09_10-06-06.jpg"></p><p>通过观察可以发现，C语⾔字符串的字符串有个<code>规定</code>(特点)，就是以字符<code>\0</code>结尾，无论是初始化数组时，还是在分配内存时，都有<code>\0</code>的位置。</p><h3 id="strlen-函数"><a href="#strlen-函数" class="headerlink" title="strlen()函数"></a>strlen()函数</h3><p>依据以<code>\0</code>为字符串结尾的规则，<code>strlen</code>函数就可以计算字符串的长度，它会从字符串的第一个字符向后扫描，直到遇到<code>\0</code>结束,且<code>\0</code>不进入计数，最后返回字符串的长度,代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span> <span class="comment">//需要引对应的头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> len = <span class="built_in">strlen</span>(<span class="string">&quot;abcdef&quot;</span>);<span class="comment">//len的值为6</span></span><br><span class="line"><span class="type">int</span> sz = <span class="keyword">sizeof</span>(<span class="string">&quot;abcdef&quot;</span>);<span class="comment">//sz的大小为7(\0被计入总数)</span></span><br></pre></td></tr></table></figure><h3 id="验证字符串的结尾"><a href="#验证字符串的结尾" class="headerlink" title="验证字符串的结尾"></a>验证字符串的结尾</h3><h4 id="正向验证"><a href="#正向验证" class="headerlink" title="正向验证"></a>正向验证</h4><p>我们做在字符数组里插入一个<code>\0</code>,来看看函数<code>printf</code>和<code>strlen</code>找到的结尾在哪里,如下图</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[] = &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;\0&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;f&#x27;</span>,<span class="string">&#x27;\0&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-09_11-01-35.jpg"></p><p>可以看到字符数组似乎被“截断”了，<code>printf</code>只输出了<code>\0</code>前面的内容, <code>strlen</code>算出来的长度也只有<code>3</code>,可见插入的<code>\0</code>被作为了<strong>字符串</strong>的结尾，字符串提前中指,而没到达<strong>字符数组</strong>的结尾</p><h4 id="反向验证"><a href="#反向验证" class="headerlink" title="反向验证"></a>反向验证</h4><p>我们来<strong>反向</strong>验证一下，<code>\0</code>是字符串结尾的标志,如下图，我们声明一个<strong>没有</strong><code>\0</code>结尾的字符数组，看看函数<code>printf</code>和<code>strlen</code>还找不找得到我们“认为”的结尾</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[] = &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;f&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-09_14-02-07.jpg"></p><p>可以看到函数对字符串的判断出现了严重<strong>失误</strong>，所以<strong>字符数组</strong>里没有<code>\0</code>标记结尾是非常严重的问题，不光是找不到字符串的结尾，而且会<strong>越界访问</strong>！危险操作，写代码的时候一定要注意</p><hr><h2 id="从字符串到字符数组"><a href="#从字符串到字符数组" class="headerlink" title="从字符串到字符数组"></a>从字符串到字符数组</h2><p>虽然上面已经用到了字符数组，但主要还是为了方便讨论<strong>字符串</strong>,接下来着重研究字符数组。</p><h3 id="先整清楚几个概念"><a href="#先整清楚几个概念" class="headerlink" title="先整清楚几个概念"></a>先整清楚几个概念</h3><p><code>什么是数组</code>：数组是⼀组相同类型元素的集合,会在内存中开辟一段连续的空间，将元素储存在那段内存中</p><p><code>什么是数组元素</code>：存放在数组的值被称为数组的元素，数组在创建的时候可以指定数组的⼤⼩和数组的元素类型。</p><p>所以<code>字符数组</code>是一组<code>字符</code>的集合，字符数组里的<code>元素</code>都是<code>字符</code>!,访问到的字符数组里的<strong>元素</strong>都是<strong>字符</strong>，像<code>&#39;a&#39;</code>,<code>&#39;b&#39;</code>,<code>&#39;c&#39;</code>这种的单个的字符,别和<code>字符串</code>混为一谈！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="type">int</span> sz = <span class="keyword">sizeof</span>(str);<span class="comment">//这里str代表了整个数组,所以包括\0</span></span><br><span class="line">,sz的值为<span class="number">4</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="字符数组的声明"><a href="#字符数组的声明" class="headerlink" title="字符数组的声明"></a>字符数组的声明</h3><p>字符数组的声明和其他类型的数组差不多，有<strong>初始化</strong>，<strong>不完全初始化</strong>，<strong>声明长度</strong>，<strong>不声明长度</strong></p><p><em>正确的声明代码如下</em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str1[] = <span class="string">&quot;abc&quot;</span>;<span class="comment">//初始化,不声明长度</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> str2[] = &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;\0&#x27;</span>&#125;;<span class="comment">//这也是初始化，且不声明长度</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> str3[<span class="number">10</span>] = &#123; <span class="number">0</span> &#125;;<span class="comment">//初始化，用值0(等价于`\0`)填充</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> str4[<span class="number">10</span>] = <span class="string">&quot;abc&quot;</span>;<span class="comment">//不完全初始化，存入字符串&quot;abc&quot;,后面都用&#x27;\0&#x27;填充</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> str5[<span class="number">10</span>] = &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>&#125;;<span class="comment">//不完全初始化,从下标为0开始，依次往后填充字符 a,b,c,\0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><em>错误的声明代码</em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str1[<span class="number">3</span>] = <span class="string">&quot;abc&quot;</span>;<span class="comment">//数组声明短了，放不下结尾的\0,编译过不了</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> str2[<span class="number">3</span>] = &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>&#125;;<span class="comment">//同上,放不下</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> str3[] = &#123; <span class="number">0</span> &#125;;<span class="comment">//能声明，但是字符数组长度为1，这个数组大概率是用不了的/会被拿去错误使用的</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="来看看这些声明方式在内存中的表现"><a href="#来看看这些声明方式在内存中的表现" class="headerlink" title="来看看这些声明方式在内存中的表现"></a>来看看这些声明方式在内存中的表现</h3><h4 id="不初始化的声明-极度不推荐"><a href="#不初始化的声明-极度不推荐" class="headerlink" title="不初始化的声明(极度不推荐)"></a>不初始化的声明(极度不推荐)</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[];<span class="comment">//这个不加长度，直接编译失败（如下图）</span></span><br></pre></td></tr></table></figure><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-10_11-39-10.jpg"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">10</span>];<span class="comment">//语法没有问题，来看看此时数组里存了什么</span></span><br></pre></td></tr></table></figure><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-10_11-46-49.jpg"><br>可以看到全都存了<code>-52</code>,对应的中文字符是<code>烫</code>，这样<strong>不好</strong>，请在声明字符数组的时候<strong>初始化数组</strong></p><h4 id="不声明长度的数组声明"><a href="#不声明长度的数组声明" class="headerlink" title="不声明长度的数组声明"></a>不声明长度的数组声明</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str1[] = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> str2[] = &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;\0&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-09_14-59-34.jpg"></p><p>如上图，不声明长度时，编译器自动给字符数组分配内存，既不给多，也不给少，初始化给的<code>字符串</code>或者<code>&#123;...&#125;</code>多长，创建的数组就多长。</p><p><strong>注意红框</strong>，再强调一遍，字符串以<code>\0</code>结尾,看到双引号括起来的字符串，要记得最后隐藏了一个<code>\0</code>,用字符数组储存的时候一定要留足空间</p><h4 id="声明长度的数组声明"><a href="#声明长度的数组声明" class="headerlink" title="声明长度的数组声明"></a>声明长度的数组声明</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str3[<span class="number">10</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> str4[<span class="number">10</span>] = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> str5[<span class="number">10</span>] = &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-09_15-25-54.jpg"></p><p>可以看到，在声明的长度<strong>足够长</strong>时，你初始化的时候给它多少字符，它就从<code>下标0</code>处开始<strong>按顺序</strong>存进去多少,剩下的部分<strong>自动</strong>用<code>&#39;\0&#39;</code>填充,</p><p>所以实际上上面代码中的<code>str5</code>因为长度<code>10</code>&gt;初始化给的<code>4</code>个字符，后面六个元素用<code>\0</code>填充了，所以<code>str5</code>里存了有<strong>结尾</strong>的完整字符串</p><h4 id="错误声明"><a href="#错误声明" class="headerlink" title="错误声明"></a>错误声明</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str1[<span class="number">3</span>] = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="type">char</span> str2[<span class="number">3</span>] = &#123; <span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span> &#125;;</span><br></pre></td></tr></table></figure><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-10_07-44-57.jpg"></p><p>可以看到上面两种错误的声明方式，甚至直接<strong>编译失败</strong>,所以声明字符数组的时候一定要<strong>留足空间</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str3[] = &#123; <span class="number">0</span> &#125;;</span><br></pre></td></tr></table></figure><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-10_07-51-55.jpg"></p><p>如上图，可以看到这样写还是编译成功了，但是在监视查看<strong>数组长度</strong>的时候，发现长度为<code>1</code>,里面存了一个<code>\0</code>,这么<strong>短</strong>的数组能用吗？只能<strong>用一点点</strong>，甚至还不如直接声明一个<code>char</code>类型的字符变量</p><h2 id="当字符数组加上const"><a href="#当字符数组加上const" class="headerlink" title="当字符数组加上const"></a>当字符数组加上const</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> str[<span class="number">5</span>] = <span class="string">&quot;abc&quot;</span>;</span><br></pre></td></tr></table></figure><h3 id="一些性质"><a href="#一些性质" class="headerlink" title="一些性质"></a>一些性质</h3><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-10_18-55-52.jpg"></p><p>可以看到，声明时加了<code>const</code>之后，字符数组<code>str</code>在声明时的<strong>初始化</strong>之后便不可更改了，只能<strong>访问</strong>其元素,而<strong>不能通过访问元素来改变数组内容</strong></p><p>那么<code>scanf</code>还能写入内容吗？答案是<strong>可以</strong>!<em>(如下图)</em></p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-10_19-10-43.jpg"></p><p>那它能拿来初始化别的数组吗？很遗憾，<strong>不能</strong><br><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-10_19-05-15.jpg"></p><h3 id="对应的指针类型"><a href="#对应的指针类型" class="headerlink" title="对应的指针类型"></a>对应的指针类型</h3><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-10_19-15-32.jpg"></p><p>可以看到，这里得用<code>const char*</code>来储存字符数组的地址，而使用<code>char*</code>就会报错</p><p>那么用<code>双引号括起来的字符串</code>，是否也有地址，能用指针储存它的地址呢？</p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-10_19-21-10.jpg"></p><p>如图，可以看到,字符串<code>&quot;abc&quot;</code>是属于<code>const char</code>类型的数组，对应的指针是<code>const char*</code>,不能通过访问元素来改变内部的值，也不能用<code>char*</code>来储存地址</p><h4 id="在内存中的表现"><a href="#在内存中的表现" class="headerlink" title="在内存中的表现"></a>在内存中的表现</h4><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/const_str.gif"></p><p>可以看到哪怕是字符串<code>&quot;abc&quot;</code>,也是在内存中开辟了一段空间，并把字符<strong>储存在内存中</strong>了的</p><p>但是，<strong>不要</strong>试图用<code>scanf</code>去改变字符串的值<br><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/const_strrrr.gif"></p><hr><h2 id="如何向字符数组里添加内容"><a href="#如何向字符数组里添加内容" class="headerlink" title="如何向字符数组里添加内容"></a>如何向字符数组里添加内容</h2><p>添加的方法多种多样，搞不好可能还会出错，所以把字符数组<strong>学明白</strong>很重要！</p><p>以下使用的数组样例声明如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">10</span>] = &#123; <span class="number">0</span> &#125;;</span><br></pre></td></tr></table></figure><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>在初始化的时候就把值传进去，有哪些初始化方式<strong>上面</strong>已经介绍过了，这里不多赘述</p><h3 id="访问数组元素"><a href="#访问数组元素" class="headerlink" title="访问数组元素"></a>访问数组元素</h3><p>通过<code>[]</code>可以访问数组元素，并对没有<code>const</code>修饰的数组，修改其元素,例如:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str[<span class="number">0</span>] = <span class="string">&#x27;A&#x27;</span>;<span class="comment">//将数组的第一个元素改成字符A</span></span><br></pre></td></tr></table></figure><p>我们也可以通过循环的方式，将数组的所有元素填充为某个字符</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> place_holder = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span> ; i++)<span class="comment">//这里使用左闭右开区间，10为数组的大小</span></span><br><span class="line">&#123;</span><br><span class="line">    str[i] = place_holder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用scanf函数"><a href="#使用scanf函数" class="headerlink" title="使用scanf函数"></a>使用<code>scanf</code>函数</h3><p>由上面的探究已知：对于已声明的字符数组，<strong>无论</strong>有没有<code>const</code>修饰，都可已用<code>scanf</code>修改内容,那么<code>scanf</code>怎么用，又具体怎么工作的，我们接着往下探究</p><h4 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">10</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str);<span class="comment">//占位符是 %s ,右边的参数是 str ,也就是数组名</span></span><br><span class="line"><span class="comment">//或者 scanf(&quot;%s&quot;,&amp;str)</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>！这边的数组名<code>str</code>储存的是<strong>数组首元素的地址</strong>，而<code>&amp;str</code>储存的是<code>整个数组的地址</code>，值是一样的，两者皆可用于传参，但<strong>指针类型不一样</strong>，要做好区分</p><h4 id="scanf都做了什么"><a href="#scanf都做了什么" class="headerlink" title="scanf都做了什么"></a><code>scanf</code>都做了什么</h4><p>先来看看它分别对用<code>&#123; 0 &#125;</code><strong>初始化</strong>和<strong>不初始化</strong>的数组做了什么</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str1[<span class="number">10</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str1);</span><br><span class="line"><span class="type">char</span> str2[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str2);</span><br></pre></td></tr></table></figure><p><em>两个数组的输入均为abc</em><br><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-11_19-09-50.jpg"></p><p>可以看到，对<code>str1</code>,字符非常正常地填充进去了，因为整个数组原本是用<code>\0</code>填充的,看不出什么端倪</p><p>而对于<code>str2</code>,观察发现，除了输入进去的字符<code>a</code>,<code>b</code>,<code>c</code>,它还自动在结尾补了一个<code>\0</code>,使<code>str2</code>里储存了一个完整的字符串。<strong>但是</strong>，剩下的部分还是用<strong>值</strong><code>-52</code>填充，即未初始化的状态，所以依然<strong>不提倡</strong>声明的时候没有初始化</p><p>然后是在字符数组内已有内容的情况下，再次使用<code>scanf</code>的情况</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str1[<span class="number">5</span>] = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="type">char</span> str2[<span class="number">5</span>] = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s %s&quot;</span>,str1,str2);</span><br></pre></td></tr></table></figure><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-12_09-33-02.jpg"></p><p>如图，<code>scanf</code>做的是把输入的字符串<code>覆盖</code>式存入字符数组，比原来长，就完全覆盖，比原来短，就部分覆盖，未覆盖的部分无改动</p><h4 id="关于scanf的危险操作"><a href="#关于scanf的危险操作" class="headerlink" title="关于scanf的危险操作"></a>关于<code>scanf</code>的危险操作</h4><p>由于<code>scanf</code>无法预测<strong>字符数组</strong>能否存下输入的<strong>字符串</strong>，如果<strong>字符数组</strong>声明的长度不够，就可能出现<strong>越界访问</strong>,随之而来的便是奇奇怪怪的<code>bug</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">4</span>] = &#123; <span class="number">0</span> &#125;;<span class="comment">//先声明一个长度为4的数组</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str);<span class="comment">//这次输入abcdef试试</span></span><br></pre></td></tr></table></figure><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-12_09-47-00.jpg"></p><p>可以看到，确实<strong>越界访问</strong>了，所以声明字符数组的时候，建议比预计最大输入，在多些长度，防止越界访问。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>=C语言实践= 手把手教你做高端cmd简单扫雷</title>
      <link href="/2023/10/30/mine-clearance/"/>
      <url>/2023/10/30/mine-clearance/</url>
      
        <content type="html"><![CDATA[<h1 id="直接开始吧！"><a href="#直接开始吧！" class="headerlink" title="直接开始吧！"></a>直接开始吧！</h1><h2 id="多文件项目"><a href="#多文件项目" class="headerlink" title="多文件项目"></a>多文件项目</h2><p>扫雷项目内容较多，需要调用的<strong>函数</strong>也较多，采用多文件的方式，可以使代码<strong>条理清晰</strong>，并且<strong>易于管理和维护</strong>。文件如下</p><p><code>game.h</code>用于宏定义，函数声明，引入头文件等</p><p><code>game.c</code>用于<strong>函数的具体实现</strong></p><p><code>front.c</code>用于实现程序的<strong>主干部分</strong></p><p><code>other.c</code>用于实现其他杂项函数，这里我用于实现<code>menu()</code>函数，<del>主要内容太花了</del></p><p><strong>注</strong>  <code>.c</code>结尾的源文件均需加一句<code>#include &quot;game.h&quot;</code></p><h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><p>本次用到的头文件有<code>stdio.h</code> <code>stdlib.h</code> <code>time.h</code> <code>windows.h</code><br>和自己建的<code>game.h</code></p><p><strong>均在</strong>文件<code>game.h</code>中<code>#include</code></p><h2 id="define宏定义"><a href="#define宏定义" class="headerlink" title="define宏定义"></a>define宏定义</h2><p>为了便于<strong>阅读和维护</strong>代码,在<code>game.h</code>中的宏定义如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//显示行列</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ROW 9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COL 9</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//实际数组大小</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ROWS ROW+2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COLS COL + 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//地雷信息</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Bomb <span class="string">&#x27;*&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Blank <span class="string">&#x27; &#x27;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//难度</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EZ_RANK 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HD_RANK 15</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//显示区</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UN <span class="string">&#x27;&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Flag <span class="string">&#x27;!&#x27;</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="为什么实际数组要大一圈？"><a href="#为什么实际数组要大一圈？" class="headerlink" title="为什么实际数组要大一圈？"></a>为什么实际数组要大一圈？</h3><p>如图，采用九宫格式访问时，大出来的一圈能有效<strong>防止越界访问</strong></p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-02_11-23-51.jpg"></p><h2 id="构建main函数"><a href="#构建main函数" class="headerlink" title="构建main函数"></a>构建main函数</h2><p>内容不多，主要是与菜单配合食用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//用time()获取时间戳，传给srand设置(随机值生成器的)种子</span></span><br><span class="line">srand((<span class="type">unsigned</span> <span class="type">int</span>)time(<span class="literal">NULL</span>));</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)<span class="comment">//循环游玩</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> input = <span class="number">0</span>;</span><br><span class="line">Menu();<span class="comment">//打印菜单</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入:&gt;&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;input);<span class="comment">//获取指令</span></span><br><span class="line"><span class="keyword">switch</span> (input)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">Sleep(<span class="number">250</span>);</span><br><span class="line">game();<span class="comment">//开始游戏,游戏具体在game()函数中实现</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;游戏结束\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//结束程序</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;输入错误,请重试\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="打印菜单"><a href="#打印菜单" class="headerlink" title="打印菜单"></a>打印菜单</h2><p>还在做静态菜单?<del>弱爆了！</del>来试试<strong>动态出现</strong>的菜单！</p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/menu.gif"></p><p>原理很<strong>简单</strong>，就是<code>打印空白数组</code>-&gt;<code>向内逐个替换两侧元素</code>-&gt;<code>清屏</code>-&gt;<code>再打印</code>-&gt;<code>再替换</code>-&gt;<code>...</code></p><p><em>接下来的代码写在<code>other.c</code>中</em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//动态打印菜单</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Menu</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> cover[]  =  <span class="string">&quot;=======================&quot;</span>;</span><br><span class="line"><span class="type">char</span> option1[] = <span class="string">&quot;======  play (1) ======&quot;</span>;</span><br><span class="line"><span class="type">char</span> option2[] = <span class="string">&quot;======  exit (2) ======&quot;</span>; </span><br><span class="line"><span class="type">char</span> empty_c[] = <span class="string">&quot;                       &quot;</span>;</span><br><span class="line"><span class="type">char</span> empty_1[] = <span class="string">&quot;                       &quot;</span>;</span><br><span class="line"><span class="type">char</span> empty_2[] = <span class="string">&quot;                       &quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> right = <span class="number">22</span>;</span><br><span class="line"><span class="keyword">while</span> (left &lt; right)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">//内容替换</span></span><br><span class="line">empty_c[left] = cover[left];</span><br><span class="line">empty_c[right] = cover[right];</span><br><span class="line">empty_1[left] = option1[left];</span><br><span class="line">empty_1[right] = option1[right];</span><br><span class="line">empty_2[left] = option2[left];</span><br><span class="line">empty_2[right] = option2[right];</span><br><span class="line"></span><br><span class="line">Sleep(<span class="number">50</span>);</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);<span class="comment">//清屏</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n%s\n%s\n%s\n&quot;</span>,empty_c,empty_1,empty_2,empty_c);<span class="comment">//打印菜单</span></span><br><span class="line"></span><br><span class="line">left++;</span><br><span class="line">right--;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (left == right)<span class="comment">//打印最终菜单</span></span><br><span class="line">&#123;</span><br><span class="line">Sleep(<span class="number">50</span>);</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">empty_c[left] = cover[left];</span><br><span class="line">empty_1[left] = option1[left];</span><br><span class="line">empty_2[left] = option2[left];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n%s\n%s\n%s\n&quot;</span>, empty_c, empty_1, empty_2, empty_c);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现game-函数"><a href="#实现game-函数" class="headerlink" title="实现game()函数"></a>实现game()函数</h2><p><em>游戏的主要逻辑在game()中实现</em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">game</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> mine[ROWS][COLS] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="type">char</span> show[ROWS][COLS] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="type">char</span> check[ROWS][COLS] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化棋盘，其实就是用第二个形参填充二维数组</span></span><br><span class="line">InitBoard(mine, Blank);</span><br><span class="line">InitBoard(show, UN);</span><br><span class="line"></span><br><span class="line">InitCheck(check);<span class="comment">//初始化check数组，逻辑与上面的初始化不同</span></span><br><span class="line"></span><br><span class="line">SetMine(mine,EZ_RANK);<span class="comment">//设置地雷</span></span><br><span class="line">SetNum(mine);<span class="comment">//设置雷周围的数字</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//DisplayBoard(mine); //用于开发时检查棋盘布局</span></span><br><span class="line"><span class="comment">//DisplayBoard(show); //同上，不使用时注释掉</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//以上是前期准备</span></span><br><span class="line">OPMine(mine,show, check);<span class="comment">//开始排雷</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;敲击enter以继续\n&quot;</span>);</span><br><span class="line">getchar();</span><br><span class="line">getchar();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="为什么用三个二维数组？"><a href="#为什么用三个二维数组？" class="headerlink" title="为什么用三个二维数组？"></a>为什么用三个二维数组？</h3><p>扫雷需要实现的功能较多，显然一个二维数组是不足以满足需求的，所以这里采用<strong>三个</strong>数组相叠加的方式，各自实现功能，并整合到一起。</p><p>数组<code>mine</code>用于存放<code>雷</code>和雷周围的<code>计数数字</code></p><p>数组<code>show</code>用于储存给<code>用户</code>看到的内容，可以是<code>Unkown</code>,<code>空白</code>，<code>数字</code>，<code>旗帜</code></p><p>数组<code>check</code>用于记录棋盘的哪些地块被检查过了，防止后面用<strong>递归</strong>打开成片的空白区时，出现无限递归。</p><p><strong>规定</strong>：检查过的坐标储存<code>字符1</code>,没检查过的坐标储存<code>字符0</code>,大出来的<strong>一圈</strong>默认储存<code>字符1</code></p><h2 id="实现游戏用的函数"><a href="#实现游戏用的函数" class="headerlink" title="实现游戏用的函数"></a>实现游戏用的函数</h2><h3 id="先看看有哪些要声明在game-h里的"><a href="#先看看有哪些要声明在game-h里的" class="headerlink" title="先看看有哪些要声明在game.h里的"></a>先看看有哪些要声明在<code>game.h</code>里的</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Menu</span><span class="params">()</span>;<span class="comment">//这个在上文实现过了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//一下函数将在下文实现</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化棋盘</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitBoard</span><span class="params">(<span class="type">char</span> board[ROWS][COLS], <span class="type">char</span> sign)</span>;</span><br><span class="line"><span class="comment">//展示棋盘</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DisplayBoard</span><span class="params">(<span class="type">char</span> board[ROWS][COLS])</span>;</span><br><span class="line"><span class="comment">//初始化check棋盘</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitCheck</span><span class="params">(<span class="type">char</span> check[ROWS][COLS])</span>;</span><br><span class="line"><span class="comment">//设置地雷/数字</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SetMine</span><span class="params">(<span class="type">char</span> board[ROWS][COLS],<span class="type">int</span> rank)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">SetNum</span><span class="params">(<span class="type">char</span> board[ROWS][COLS])</span>;</span><br><span class="line"><span class="comment">//玩家排雷用的函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OPMine</span><span class="params">(<span class="type">char</span> mine[ROWS][COLS],<span class="type">char</span> show[ROWS][COLS],<span class="type">char</span> check[ROWS][COLS])</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><em>好，有了目标，接下来就去一个一个实现</em></p><p><strong>注</strong>：以下代码均写在<code>game.c</code>文件里</p><h3 id="InitBoard"><a href="#InitBoard" class="headerlink" title="InitBoard()"></a>InitBoard()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InitBoard</span><span class="params">(<span class="type">char</span> board[ROWS][COLS],<span class="type">char</span> sign)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ROWS; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; COLS; j++)</span><br><span class="line">&#123;</span><br><span class="line">board[i][j] = sign;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里初始化的方式比较简单粗暴，就是用形参<code>sign</code>填充整个二维数组</p><h3 id="DisplayBoard-函数"><a href="#DisplayBoard-函数" class="headerlink" title="DisplayBoard()函数"></a>DisplayBoard()函数</h3><p>这里采用的展示方式是带横纵坐标的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">DisplayBoard</span><span class="params">(<span class="type">char</span> board[ROWS][COLS])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//打印一排列坐标</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt;= COL; k++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="comment">//打印一排横分割线</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt;= COL; k++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;--&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= ROW; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d|&quot;</span>, i);<span class="comment">//这句话打印横排坐标和竖分割线</span></span><br><span class="line"><span class="comment">//打印一排棋盘内容</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= COL; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, board[i][j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="InitCheck-函数"><a href="#InitCheck-函数" class="headerlink" title="InitCheck()函数"></a>InitCheck()函数</h3><p>这里复用了<code>InitBoard()</code>函数，是在其基础上增加了内容</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InitCheck</span><span class="params">(<span class="type">char</span> check[ROWS][COLS])</span></span><br><span class="line">&#123;</span><br><span class="line">InitBoard(check, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将边缘大出来的一圈改为&#x27;1&#x27;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; COLS; k++)</span><br><span class="line">&#123;</span><br><span class="line">check[<span class="number">0</span>][k] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">check[ROWS - <span class="number">1</span>][k] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; ROWS <span class="number">-1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">check[i][<span class="number">0</span>] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">check[i][COLS - <span class="number">1</span>] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="SetMine-函数"><a href="#SetMine-函数" class="headerlink" title="SetMine()函数"></a>SetMine()函数</h3><p>这里要使用<code>rand()</code>函数搭配<code>%</code>运算，来随机生成雷的坐标</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SetMine</span><span class="params">(<span class="type">char</span> board[ROWS][COLS],<span class="type">int</span> rank)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> y = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> count = <span class="number">0</span>;count &lt; rank;)</span><br><span class="line">&#123;</span><br><span class="line">x = rand() % ROW + <span class="number">1</span>;<span class="comment">//x的范围是1~ROW</span></span><br><span class="line">y = rand() % COL + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (board[x][y] == Blank)</span><br><span class="line">&#123;</span><br><span class="line">count++;</span><br><span class="line">board[x][y] = Bomb;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="SetNum-函数"><a href="#SetNum-函数" class="headerlink" title="SetNum()函数"></a>SetNum()函数</h3><p>这里遍历一遍数组并采用<code>九宫格式</code>计数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该函数用于九宫格式计数，并在下个函数中被调用</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">CountMine</span><span class="params">(<span class="type">char</span> board[ROWS][COLS], <span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = x - <span class="number">1</span>; i &lt;= x + <span class="number">1</span>; i++)<span class="comment">//上中下三行</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = y - <span class="number">1</span>; j &lt;= y + <span class="number">1</span>; j++)<span class="comment">//左中右三列</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i != x || j != y)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (board[i][j] == Bomb)</span><br><span class="line">&#123;</span><br><span class="line">sum++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SetNum</span><span class="params">(<span class="type">char</span> board[ROWS][COLS])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//遍历二维数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= ROW; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= COLS; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (board[i][j] == Blank)<span class="comment">//仅操作非雷的格子</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (CountMine(board, i, j))</span><br><span class="line">&#123;</span><br><span class="line">board[i][j] = <span class="string">&#x27;0&#x27;</span> + CountMine(board, i, j);<span class="comment">//将返回的数字转化成字符</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="OPMine-函数–核心函数"><a href="#OPMine-函数–核心函数" class="headerlink" title="OPMine()函数–核心函数"></a>OPMine()函数–核心函数</h3><p>该函数为游戏的<code>核心函数</code>，有内置菜单，且多次调用其它函数，其中<code>函数</code>的具体实现见<code>四级标题</code>处</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">OPMine</span><span class="params">(<span class="type">char</span> mine[ROWS][COLS],<span class="type">char</span> show[ROWS][COLS],<span class="type">char</span> check[ROWS][COLS])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> x = <span class="number">0</span>;<span class="comment">//横纵坐标</span></span><br><span class="line"><span class="type">int</span> y = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> flag = <span class="number">1</span>;<span class="comment">//用于菜单选项</span></span><br><span class="line"><span class="type">int</span> cont = <span class="number">1</span>;<span class="comment">//cont为0时游戏结束</span></span><br><span class="line"><span class="keyword">while</span> (cont)</span><br><span class="line">&#123;</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">DisplayBoard(show);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;排雷(1)\n插旗/拔旗(2)\n请输入:&gt;&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;flag);</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (flag)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//排雷</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;坐标格式,例&gt;2(空格)2\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入坐标:&gt;&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line"><span class="keyword">if</span> (show[x][y] == Flag)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;此处为旗帜，不可排雷\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (show[x][y] != UN)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;不可重复排查\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体排雷操作</span></span><br><span class="line">cont = FindMine(mine,show,check, x, y);</span><br><span class="line"><span class="keyword">if</span> (cont)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//检查是否赢得游戏</span></span><br><span class="line">cont = CheckWin(mine,show);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//插旗</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;坐标格式,例&gt;2(空格)2\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入坐标:&gt;&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">SetFlag(show, x, y);<span class="comment">//插旗函数</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">&#123;</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n输入错误(恼\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="SetFlag-函数"><a href="#SetFlag-函数" class="headerlink" title="SetFlag()函数"></a>SetFlag()函数</h4><p>先捏软柿子，插旗函数比较简单</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SetFlag</span><span class="params">(<span class="type">char</span> show[ROWS][COLS], <span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (show[x][y] == UN)<span class="comment">//插旗</span></span><br><span class="line">&#123;</span><br><span class="line">show[x][y] = Flag;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (show[x][y] == Flag)<span class="comment">//拔旗</span></span><br><span class="line">&#123;</span><br><span class="line">show[x][y] = UN;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;报错\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="ExpandBlank-函数"><a href="#ExpandBlank-函数" class="headerlink" title="ExpandBlank()函数"></a>ExpandBlank()函数</h4><p>这个函数用于打开成片的<code>空白区</code>,因为要从连着的空白连续开下去，所以要用到<code>函数递归</code>,此时<code>二维数组check</code>用于防止死递归</p><p><strong>注</strong>：这个函数一定要写在下一个函数(FindMine)前</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ExpandBlank</span><span class="params">(<span class="type">char</span> mine[ROWS][COLS], <span class="type">char</span> show[ROWS][COLS], <span class="type">char</span> check[ROWS][COLS],<span class="type">int</span> x,<span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">show[x][y] = mine[x][y];<span class="comment">//将用户看到的格子改成mine中的格子,包括空白和数字格子</span></span><br><span class="line">check[x][y] = <span class="string">&#x27;1&#x27;</span>;<span class="comment">//探测过的格子放`1`</span></span><br><span class="line"><span class="keyword">if</span> (mine[x][y] == Blank)<span class="comment">//仅空白格子会触发递归，数字格子不会</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//九宫格式探测</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = x - <span class="number">1</span>; i &lt;= x + <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = y - <span class="number">1</span>; j &lt;= y + <span class="number">1</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (check[i][j] == <span class="string">&#x27;0&#x27;</span> &amp;&amp; mine[i][j] != Bomb &amp;&amp; show[i][j] != Flag)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//含雷的格子不会执行ExpandBlank函数，就不会把雷放出来给用户看，但数字格子会</span></span><br><span class="line">ExpandBlank(mine, show, check, i, j);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="FindMine-函数"><a href="#FindMine-函数" class="headerlink" title="FindMine()函数"></a>FindMine()函数</h4><p>排雷用的函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">FindMine</span><span class="params">(<span class="type">char</span> mine[ROWS][COLS], <span class="type">char</span> show[ROW][COLS],<span class="type">char</span> check[ROWS][COLS], <span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (mine[x][y] == Bomb)</span><br><span class="line">&#123;</span><br><span class="line">DisplayBoard(mine);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;炸死，游戏结束:)\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//返回0来结束游戏</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (mine[x][y] != Blank)</span><br><span class="line">&#123;</span><br><span class="line">show[x][y] = mine[x][y];</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//返回1来继续游戏</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//这里有对上一个函数的调用</span></span><br><span class="line">ExpandBlank(mine, show, check,x,y);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="CheckWin-函数"><a href="#CheckWin-函数" class="headerlink" title="CheckWin()函数"></a>CheckWin()函数</h4><p>用于检查玩家是否完全排雷，赢得游戏</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">CheckWin</span><span class="params">(<span class="type">char</span> mine[ROWS][COLS], <span class="type">char</span> show[ROWS][COLS])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;<span class="comment">//统计没排雷的格子数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= ROW; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= COL; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (show[i][j] == UN || show[i][j] == Flag)</span><br><span class="line">&#123;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (count == EZ_RANK)<span class="comment">//统计数==雷数</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;恭喜排雷成功!\n&quot;</span>);</span><br><span class="line">DisplayBoard(mine);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//返回0，停止游戏</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>至此游戏所需的代码全部完成，已经可以编译出来玩耍啦。</p><p>该实践项目主要练习了<code>二维数组</code>,<code>函数</code>,<code>函数递归</code>,<code>宏定义</code>等内容，代码量在入门学习中算较大的，本人在初次编写的时候也写出了不少bug，debug的过程是相当<del>快乐</del></p><p>建议多多画示意图，<strong>耐下性子</strong>写代码和debug,哪怕是实现这样的小游戏项目，也是颇有意义的</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>玩转N组输入和多组输入</title>
      <link href="/2023/10/18/mutiInput/"/>
      <url>/2023/10/18/mutiInput/</url>
      
        <content type="html"><![CDATA[<h1 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h1><p>当我们在写IO型OJ时，<code>多组输入</code>便是我们绕过不开的话题了，但<strong>不用担心</strong>，可能初见多组输入会觉得难以理解，但用多了之后就会发现，<code>多组输入</code> 花样并不多，混熟了就<strong>很简单了</strong></p><h2 id="先看看一组输入输出如何完成的"><a href="#先看看一组输入输出如何完成的" class="headerlink" title="先看看一组输入输出如何完成的"></a>先看看一组输入输出如何完成的</h2><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-10-19_17-06-13.jpg"></p><p><em>如图</em>：一组输入时，用<code>scanf</code>获取一组输入，并在主体部分完成数据的处理，产生结果，最后用<code>printf</code>输出产生的一组结果。</p><p><em>以下用实现加法的程序做演示</em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a,b;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;a,&amp;b);<span class="comment">//获取一组输入</span></span><br><span class="line">    <span class="type">int</span> sum = a + b;<span class="comment">//产生结果</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,sum);<span class="comment">//输出结果</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="然后升级到N组输入"><a href="#然后升级到N组输入" class="headerlink" title="然后升级到N组输入"></a>然后升级到N组输入</h1><p>有的OJ题在一个测试文件中会先输入一个<code>n</code>,告诉你接下来有<code>n</code>组输入，你就要产生<code>n</code>组输出,也就是说要将<code>一组输入输出</code><strong>重复性地</strong>完成<code>n次</code>。难道我们要把代码重复<code>n次</code>吗？显然不现实。</p><p>所以是时候使用<strong>循环</strong>了，具体用法如下</p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-10-20_07-34-35.jpg"></p><p>如图，先用一个<code>scanf</code>获取循环次数<code>n</code>,然后创建一个循环，将<code>一组输入输出</code>放入循环体，一次一次循环处理即可</p><h2 id="变量的重置"><a href="#变量的重置" class="headerlink" title="变量的重置"></a>变量的重置</h2><p>为防止前后两次循环产生干扰，有两种处理<code>变量</code>的方式</p><p>1.(推荐)除了输入的变量，<strong>其它所有变量</strong>在循环体内声明，这些变量会在一次循环后<em>销毁</em>，下一次循环开始时<strong>自动</strong><em>重新声明</em>，从而完成<strong>变量的自动重置</strong></p><p><em>以下面这个一次求和3个数的程序为例</em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);<span class="comment">//获取循环次数n</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;n;i++)<span class="comment">//创建循环</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//以下完成一组输入输出</span></span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;<span class="comment">//声明一个局部变量，下次循环时会自动重声明</span></span><br><span class="line">        <span class="type">int</span> num = <span class="number">0</span>;<span class="comment">//储存输入的数字</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j =<span class="number">0</span>;j&lt;<span class="number">3</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;num);</span><br><span class="line">            sum+=num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,sum);<span class="comment">//完成输出</span></span><br><span class="line">        <span class="comment">//本次循环走完后变量sum被销毁，然后进入下一次循环,完成重置</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2.在循环外部声明变量，然后在<strong>循环末尾</strong>手动重置变量</p><p><em>以下面这个一次求和3个数的程序为例</em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;<span class="comment">//声明在循环外部</span></span><br><span class="line">    <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);<span class="comment">//获取循环次数n</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;n;i++)<span class="comment">//创建循环</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//以下完成一组输入输出</span></span><br><span class="line">        <span class="type">int</span> num = <span class="number">0</span>;<span class="comment">//储存输入的数字</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j =<span class="number">0</span>;j&lt;<span class="number">3</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;num);</span><br><span class="line">            sum+=num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,sum);<span class="comment">//完成输出</span></span><br><span class="line">        sum = <span class="number">0</span>;<span class="comment">//重置sum</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="要不要用数组储存输入，或储存结果再一次性输出？"><a href="#要不要用数组储存输入，或储存结果再一次性输出？" class="headerlink" title="要不要用数组储存输入，或储存结果再一次性输出？"></a>要不要用数组储存输入，或储存结果再一次性输出？</h2><p>答案是：<strong>可以，但没必要</strong>。</p><p>只需要像上图那么写即可，因为输入是一次性喂进去的 。存数组再输出，和每产生一个结果就输出一次，最终呈现出来是一样的（如下图）</p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/%E5%A4%9A%E7%BB%84%E8%BE%93%E5%87%BA.gif"></p><h1 id="现在，勇士，来挑战多组输入吧"><a href="#现在，勇士，来挑战多组输入吧" class="headerlink" title="现在，勇士，来挑战多组输入吧"></a>现在，勇士，来挑战多组输入吧</h1><h2 id="scanf的返回值"><a href="#scanf的返回值" class="headerlink" title="scanf的返回值"></a>scanf的返回值</h2><p>多组输入时，究竟会输入多少组数据，也不告诉你了，<strong>但是</strong>，此时<code>scanf</code>的返回值就派上用场了。和我们在终端手打输入不同,OJ的输入是喂一个文件进去，所以当<strong>输入结束时</strong>，<code>scanf</code>的返回值是<code>EOF</code><em>(意为文件结尾end of file)</em>,而当成功输入数据时，则会返回输入数据的个数(文档截图如下)</p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-10-20_20-46-54.jpg"></p><h2 id="结合循环"><a href="#结合循环" class="headerlink" title="结合循环"></a>结合循环</h2><p>那么就把<code>scanf</code>放入<code>while</code>循环吧,每次试图获取下一组输入时，检测是否返回值为<code>EOF</code>,若是，则跳出循环，结束程序；若否，则继续循环</p><p><em>以下面这个一次求和3个数的程序为例</em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;<span class="comment">//先声明至少一个待输入的变量</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n) != EOF)<span class="comment">//创建循环，每次循环开始时scanf一次，并检测是否返回EOF</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//开始构建循坏体</span></span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        sum+=n;</span><br><span class="line">        <span class="comment">//完成剩下的两次输入</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>; i &lt; <span class="number">3</span> - <span class="number">1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">            sum+=n</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,sum);<span class="comment">//完成一次输出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//scanf返回EOF后跳出循环</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="基本架构"><a href="#基本架构" class="headerlink" title="基本架构"></a>基本架构</h2><p>以后再要写<code>多组输入</code>，基本就像上面那个程序一样</p><p>1.先声明至少一个待输入的变量</p><p>2.创建循环，每次循环开始时scanf一次，并检测是否返回EOF</p><p>3.开始构建循坏体(包括完成剩下的输入,完成一组输出)<strong>别忘了回车！！！</strong></p><p>4.直至scanf返回EOF后跳出循环</p><h1 id="想模拟一下多组输入看看？"><a href="#想模拟一下多组输入看看？" class="headerlink" title="想模拟一下多组输入看看？"></a>想模拟一下多组输入看看？</h1><p>像下图一样每组数据间加个<code>空格</code>就行，什么？题目的样例输入有<code>回车</code>？不用管它，放心大胆地<code>换成空格</code>就行。自己<code>测试</code>程序，只需要<strong>输出</strong>一样就行，至于怎么输入，<strong>没必要</strong>和题目一模一样</p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/mutiInpuut.gif"></p><h1 id="注意！！！不要试图在终端停止程序"><a href="#注意！！！不要试图在终端停止程序" class="headerlink" title="注意！！！不要试图在终端停止程序"></a>注意！！！不要试图在终端停止程序</h1><p>因为和OJ不同，在本地运行程序时，不是文件输入，而是终端输入,没法让<code>scanf</code>返回<code>EOF</code>,<del>炫迈，根本停不来</del></p><p>你要是想立即<code>中断</code>程序，那就按<code>ctrl+c</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>=C语言= 整型变量与过大的整数</title>
      <link href="/2023/10/14/BiiigInt/"/>
      <url>/2023/10/14/BiiigInt/</url>
      
        <content type="html"><![CDATA[<h2 id="整型家族"><a href="#整型家族" class="headerlink" title="整型家族"></a>整型家族</h2><p>在使用C语言写程序时，会储存各种长度的整型,而在整型家族中，长度的比较如下</p><p><code>char &lt; short &lt;= int &lt;= long &lt;long long </code></p><h2 id="整型是如何储存在内存中的"><a href="#整型是如何储存在内存中的" class="headerlink" title="整型是如何储存在内存中的"></a>整型是如何储存在内存中的</h2><p><em>以<code>char</code>为例</em><br><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-10-14_15-33-30.jpg" alt="char"></p><p><code>char</code>的长度为1个<code>字节</code>，8个<code>比特位</code>,其中<strong>最高位</strong>是<strong>符号位</strong>,<code>0</code>表示正数，<code>1</code>表示负数，剩下的位数用于储存变量的<strong>绝对值</strong></p><hr><p>而当使用无符号整型(带前缀<code>unsigned</code>)时，只需把符号位也用于存值即可</p><h2 id="能够储存的最大正整数"><a href="#能够储存的最大正整数" class="headerlink" title="能够储存的最大正整数"></a>能够储存的最大正整数</h2><p><code>int</code>长度为4<code>字节</code>,能够储存的最大值为<code>2的31次方-1</code>,即<strong>2,147,483,647</strong></p><p><code>unsigned int</code>能够储存的最大值为<strong>4294967295</strong></p><p><code>unsigned long long</code>长度为8<code>字节</code>,能够储存的最大值为<code>2的64次方-1</code>,即<strong>18,446,744,073,709,551,615</strong></p><hr><h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><p>虽然<code>unsigned long long</code>已经很大了，但当遇到<code>指数</code>,<code>阶乘</code>之类的运算时仍然可能<strong>存不下!</strong>(光<code>21!</code>就比<code>unsigned long long</code>长了)</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>过大的整数，可能出现在<strong>程序的过程</strong>中，也可能出现在<strong>输出</strong>中，对于过程，可以尝试<strong>改变实现思路</strong>，让过程中不出现过大的整数；对于输出，可以尝试<strong>改变输出的类型</strong>，采用输出<strong>字符或字符串</strong></p><h1 id="以下皆为例题"><a href="#以下皆为例题" class="headerlink" title="以下皆为例题"></a>以下皆为例题</h1><h2 id="1-求n-的结尾有多少个0"><a href="#1-求n-的结尾有多少个0" class="headerlink" title="1.求n!的结尾有多少个0"></a>1.求n!的结尾有多少个0</h2><p>最直白的思路就是把<code>n!</code>算出来，然后用<code>%10</code>再<code>/=10</code>的方法统计末尾的<code>0</code>,想法很简单，“实现”起来也不难，<strong>但不幸的是</strong>，<code>21!</code>就已经储存不了了，所以不能暴力求解</p><p>所以要<strong>改变思路</strong>，先从末尾0是怎么来的下手。末尾的n个0来自因式分解后10的n次方，而采用质因数分解的方法，可以发现<code>0</code>来自分解后<code>2的n次方</code>和<code>5的n次方</code>,而一个数分解后<code>2的n次方</code>必定比<code>5的n次方</code> 多，所以只需统计<code>5的n次方</code>。<strong>注意</strong>：就别再倒回去，想着先算出阶乘再求<code>5的n次方</code>了。</p><p><strong>这里采用逐步计数的方法</strong>：结果中的<code>5的n次方</code>来自各个因数中<code>5的N次方</code>的累乘,所以只需要历遍每个因数，并统计其中<code>因数5</code>的次数。这样过程中就不会有过大的数字了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码实现</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">count_num0</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> copy = i<span class="comment">//防止改变循环变量</span></span><br><span class="line">        <span class="keyword">while</span>(copy%<span class="number">5</span> == <span class="number">0</span>)<span class="comment">//统计因数5的出现次数</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(copy%<span class="number">5</span> == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            copy/=<span class="number">5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="快速输出1-2-……-10-n"><a href="#快速输出1-2-……-10-n" class="headerlink" title="快速输出1+2+……+10^n"></a>快速输出1+2+……+10^n</h2><p><em>如下图</em>：当我们试图算一算答案时，发现<code>n</code>到了<code>10</code>时就已经算不出答案了</p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/gao_si.png" alt="计算结果"></p><p>所以要<strong>改变输出答案答案的方式</strong>,观察一下<code>n</code>在<code>1~9</code>时的输出</p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-10-19_07-26-54.jpg" alt="输出"></p><p>这时我们发现<strong>答案颇有规律</strong>：每个输出都是<strong>两段</strong><code>先一个5，然后n-1个0</code>！</p><p>这样我们只需<strong>从最高位往最低位</strong>逐位打印即可,代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">printChar</span><span class="params">(<span class="type">int</span> n)</span><span class="comment">//版本一，逐位打印字符(串)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;5&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//再重复一段</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;5&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printNum</span><span class="params">(<span class="type">int</span> n)</span><span class="comment">//版本二，逐位打印整型</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//再重复一段</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>=数据结构=循环链表/链表带环(修改中)</title>
      <link href="/2023/10/08/cycle-linkedList/"/>
      <url>/2023/10/08/cycle-linkedList/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>如何在VS里使用scanf</title>
      <link href="/2023/10/05/useScanf/"/>
      <url>/2023/10/05/useScanf/</url>
      
        <content type="html"><![CDATA[<h1 id="VS里怎么连scanf都用不了？"><a href="#VS里怎么连scanf都用不了？" class="headerlink" title="VS里怎么连scanf都用不了？"></a>VS里怎么连scanf都用不了？</h1><p>不少刚接触<a href="https://visualstudio.microsoft.com/zh-hans/free-developer-offers/">Visual Studio</a>的可能发现使用scanf会报错(如下)</p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/VS_scanf.jpg" alt="报错图片"></p><p>vs告诉你说<code>scanf</code>不安全，然后你会发现vs给你提供了<code>scanf_s</code>去代替<code>scanf</code>,<strong>但是</strong>,只有vs能编译<code>scanf_s</code>,<strong>可移植性</strong>太差了，所以我们要用回<code>scanf</code>,所以要怎么不让它报错呢？<strong>可以在源文件开头添加一行宏定义(如下)</strong></p><p><code>#define  _CRT_SECURE_NO_WARNINGS 1</code></p><p>这样就能<strong>关闭报错</strong>了,但请先<strong>别急着走</strong>,每次都要复制粘贴一句宏定义太麻烦了，想<strong>一劳永逸</strong>的请往下看。</p><h1 id="修改newc-file-cpp来自动添加宏定义"><a href="#修改newc-file-cpp来自动添加宏定义" class="headerlink" title="修改newc++file.cpp来自动添加宏定义"></a>修改newc++file.cpp来自动添加宏定义</h1><p><strong>先来看怎么做：</strong>首先搜索找到电脑中叫做<code>newc++file.cpp</code>的文件。（这里推荐使用<a href="https://www.voidtools.com/zh-cn/downloads/">everything</a>）</p><hr><p><em>后半段路径应与图片一致，注意不是快捷方式</em></p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/newcppfile.jpg" alt="c++文件的位置"></p><hr><p><strong>注意</strong>：由于权限原因，<strong>无法</strong>直接修改此文件</p><p>所以先将这个文件复制粘贴到别处，例如桌面，下文用<code>副本</code>代称。</p><p>用记事本类软件(记事本就行)打开<code>副本</code>,在第一行输入上文提到的宏定义代码<code>#define  _CRT_SECURE_NO_WARNINGS 1</code>,然后<code>ctrl+s</code>保存。</p><p><strong>关闭编辑窗口</strong>，将该<code>副本</code>移动到原始文件所在文件夹，弹出如下窗口，然后选择<strong>替换文件</strong></p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-10-08_12-28-18.jpg"></p><p>接着弹出下一个提示，点<strong>接续</strong></p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-10-08_12-28-33.jpg"></p><p>等待它替换完成，然后<strong>大功告成！</strong>。之后新建的每一个<code>.c</code>或<code>.cpp</code> 文件都会自带那段宏定义，于是<code>scanf</code>从此任君使用。<del>当然平时删代码的时候记得别把那段宏定义删了</del></p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>VS所新建的<code>.c</code>和<code>.cpp</code>文件都源自于对上文<code>newc++file.cpp</code>文件的拷贝，通过修改它就能改变<code>VS新建文件</code>的初始内容</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>=回顾-前端=从简陋的html到单网页再到全栈开发</title>
      <link href="/2023/09/23/vueTheRoad/"/>
      <url>/2023/09/23/vueTheRoad/</url>
      
        <content type="html"><![CDATA[<p><a href="https://picbed.supdriver.top/html/prj_basis++/index.html">👉点我去作业一</a></p><p><a href="https://picbed.supdriver.top/html/adc_v2/index.html">👉点我去作业二</a></p><p><a href="http://localhost:5173/">👉点我去作业三</a>(抱歉，还没部署到服务器里，这个只能在我自己的电脑里用)</p><p><a href="https://picbed.supdriver.top/video/never.mp4">👉点我去作业四</a></p><p><del>其实这依然是个博客</del></p><hr><h1 id="粗糙的作业一"><a href="#粗糙的作业一" class="headerlink" title="粗糙的作业一"></a>粗糙的作业一</h1><p>当时只学过html,css,js的快速入门，对盒子<code>&lt;div&gt;</code>的玩法还不太熟，还只会用浮动盒子<code>float</code>和绝对定位,结局就是写两句html就得清除浮动<del>233</del>,甚至<code>&lt;lenged&gt;</code>也不认识，结果手动用css给实现了。总之就挺简陋的</p><h1 id="精致-并不-作业二"><a href="#精致-并不-作业二" class="headerlink" title="精致(并不)作业二"></a>精致<del>(并不)</del>作业二</h1><p>用vscode写作业二的时候，写一半发现鼠标悬停在<code>tag</code>时，它会给出去往<a href="https://developer.mozilla.org/zh-CN/"><em>MDN</em></a>对应参考页的连接,然后就开始一边写一边阅读MDN,结果一发不可收拾，开始读的时间比写的时间还长。最后成功学到神器<del>bushi</del><code>flex</code><strong>弹性盒子模型。</strong>。</p><p>但还没完，除了参阅文档，我还多次在B站首页和MC百度百科首页打开<code>F12</code>,查看，学习他们是如何布局盒子的，别说，学成品也挺有用的，对盒子的排版，嵌套的想法成熟多了</p><p>结合二者，照着图片做一个网页便没什么问题了。那个作业二我甚至直接弃掉了初版（已经把顶部做好了）version2基本完全采用<code>flex盒子</code>。比较遗憾的是，虽然每个菜单按钮都加了超链接，但是对应的网页并没有做出来（创作力有限）。但至少是个合格的花瓶，嘿嘿</p><h1 id="速成作业三"><a href="#速成作业三" class="headerlink" title="速成作业三"></a>速成作业三</h1><p>因为作业三没部署到服务器上，只能文字描述了（悲）</p><p>作业三我选的是用<code>vue</code>搭建个人博客，我先是自学了几天vue,结果发现光学vue就做不了个人博客，于是在B站上找了个时长6小时的全栈开发，用<code>js</code>写的服务端，数据库用<code>sqlite</code>,前端框架是<code>vue</code>.</p><p>好家伙，5天爆肝项目（包括但不限于<em>抄代码</em>,<em>找bug</em>,<em>找bug</em>,<em>找bug</em>），成功把博客的基本功能写完了。除了<code>Naive UI</code>的代码是复制<strong>组件库</strong>里的，剩下的代码基本都是我<strong>手打</strong>的，可以说忙得不亦乐乎，而且当时我并不太懂<code>js语法</code>，体验可以说是相当刺激了。</p><p>但<strong>回报不小</strong>，就算不能说入门吧，到时候自己加功能，照葫芦画瓢，自己写<code>js</code>的能力还是有了滴。而且这也是我首次<strong>接触数据库</strong>,混个脸熟，嘿嘿。而且<strong>最重要</strong>的一点，我成功增加了一个<strong>高自由度的个人博客</strong>，<del>讲真hexo的各自魔改我不太玩的懂</del>。</p><h2 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h2><p>作业三部曲之后，我大概就不太去碰前端了，至少一周爆肝一个全栈开发项目这种疯狂的行为不会再有了，权当是一次挑战罢，一次冒险，一次对边界的探索罢。重心很明确，对前端顶多写写像这篇博客一样的感悟，技术博客主要还是在后端语言，算法，数据结构之类</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>=算法=双指针的种种应用(更新中)</title>
      <link href="/2023/09/12/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
      <url>/2023/09/12/%E5%8F%8C%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<p><em>本文章将涉及C语言数组至数据结构的链表</em></p><h2 id="Q-为什么要用双指针"><a href="#Q-为什么要用双指针" class="headerlink" title="Q:为什么要用双指针?"></a>Q:为什么要用双指针?</h2><p>A:因为<br>通过使用双指针可以使算法的<strong>时间复杂度降低</strong>(或者降低遍历次数),有时也能<strong>降低空间复杂度</strong></p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>根据双指针的用法，可分为<strong>前后双指针</strong>,<strong>头尾双指针</strong>,<strong>快慢双指针</strong>…..</p><hr><h1 id="以下为各种双指针的应用及介绍"><a href="#以下为各种双指针的应用及介绍" class="headerlink" title="以下为各种双指针的应用及介绍"></a>以下为各种双指针的应用及介绍</h1><h2 id="前后双指针"><a href="#前后双指针" class="headerlink" title="前后双指针"></a>前后双指针</h2><h4 id="应用一-删除排序数组中的重复项"><a href="#应用一-删除排序数组中的重复项" class="headerlink" title="应用一 删除排序数组中的重复项"></a>应用一 删除排序数组中的重复项</h4><p><strong>要求</strong>:原地删除,并返回新数组的长度，不需要考虑数组中超出新长度后面的元素。</p><p><strong>思路</strong>:通过创建一前一后两个指针，<strong>前指针</strong>指向<strong>上一个元素</strong>，<strong>后指针</strong>向后历遍,一旦<strong>找到</strong>不同的元素,前指针指向<strong>下一个位置，并视为空位</strong>，通过<strong>后指针</strong>找到目标元素,并存入前指针目前所指向的<strong>空位</strong>。然后<strong>后指针</strong>接着遍历，直至遍历整个数组.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码实现</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span>&#123;</span><br><span class="line">    <span class="type">int</span>* left = nums;</span><br><span class="line">    <span class="type">int</span>*right = nums+<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//遍历数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;numsSize<span class="number">-1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(*left != *right)</span><br><span class="line">        &#123;</span><br><span class="line">            left++;</span><br><span class="line">            *left = *right;</span><br><span class="line">            right++;</span><br><span class="line">            ret++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>分析</strong>:这个函数只遍历的一遍数组，没有复制数组,所以<strong>时间复杂度</strong>为<code>O(n)</code>,<strong>空间复杂度</strong>为<code>O(1)</code>;</p><hr><h2 id="头尾双指针"><a href="#头尾双指针" class="headerlink" title="头尾双指针"></a>头尾双指针</h2><h4 id="应用一-翻转数组-字符串"><a href="#应用一-翻转数组-字符串" class="headerlink" title="应用一 翻转数组&#x2F;字符串"></a>应用一 翻转数组&#x2F;字符串</h4><p>关于翻转，首先想到的应该是创建一个<strong>等长的空数组</strong>，再同时顺序遍历<strong>原数组</strong>和逆序遍历<strong>空数组</strong>，逐位储存到空数组，然后再同时顺序遍历两个数组，将<strong>已逆序</strong>的数组拷贝至原数组</p><p><strong>缺点</strong>：需要<strong>多次</strong>遍历，且<strong>空间复杂度</strong>为O(n)</p><p><strong>使用双指针优化</strong>：整个数组的翻转可逐步拆解为：第一个和最后一个互换、第二个和倒数第二个互换、、、第N个数和倒数第N个数互换，直至中间。此处便可使用<strong>双指针</strong>，头尾指针各自一边<strong>交换</strong>所指向的内容，一边<strong>向中间靠近</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码实现-这里是翻转字符串</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">reverseString</span><span class="params">(<span class="type">char</span>* s, <span class="type">int</span> sSize)</span>&#123;</span><br><span class="line">    <span class="type">int</span> *left = s;<span class="comment">//头指针</span></span><br><span class="line">    <span class="type">int</span> *right = s + sSize<span class="number">-1</span>;<span class="comment">//尾指针</span></span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)<span class="comment">//尚未到达中间时</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> tmp = *left;</span><br><span class="line">        *left = *right;</span><br><span class="line">        *right = tmp;</span><br><span class="line">        left++;</span><br><span class="line">        right--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="快慢双指针"><a href="#快慢双指针" class="headerlink" title="快慢双指针"></a>快慢双指针</h2><h4 id="应用一-删除链表倒数第K个节点"><a href="#应用一-删除链表倒数第K个节点" class="headerlink" title="应用一 删除链表倒数第K个节点"></a>应用一 删除链表倒数第K个节点</h4><p><strong>一般解法</strong>：先遍历一遍链表获得链表总数N,再二次遍历到N-K处的节点，并执行删除</p><p><strong>如何优化</strong>：使用快慢双指针，仅需遍历一次，就能用慢指针定位目标节点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码实现</span></span><br><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">removeNthFromEnd</span><span class="params">(<span class="keyword">struct</span> ListNode* head, <span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="comment">//创建哨兵位解决头删问题</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">dummy</span> =</span> (<span class="keyword">struct</span> ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> ListNode));</span><br><span class="line">    dummy-&gt;val = <span class="number">0</span>;</span><br><span class="line">    dummy-&gt;next = head;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">slow</span> =</span> dummy;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">fast</span> =</span> dummy;</span><br><span class="line">    <span class="keyword">while</span> (<span class="type">int</span> i = <span class="number">0</span>;i&lt;n+<span class="number">1</span>;n++)<span class="comment">//移动fast</span></span><br><span class="line">    &#123;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(fast != <span class="literal">NULL</span>)<span class="comment">//同时遍历</span></span><br><span class="line">    &#123;</span><br><span class="line">        fast= fast-&gt;next;</span><br><span class="line">        slow= slow-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//此时slow指向目标节点的前一个节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">tmp</span> =</span> slow-&gt;next;</span><br><span class="line">    slow-&gt;next = slow-&gt;next-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(tmp);</span><br><span class="line">    <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="应用二-找出并返回链表中间的节点"><a href="#应用二-找出并返回链表中间的节点" class="headerlink" title="应用二 找出并返回链表中间的节点"></a>应用二 找出并返回链表中间的节点</h4><p><strong>注</strong>:偶数个节点时删除<strong>前一个</strong>中间节点</p><p><strong>一般解法</strong>：依然是先遍历一遍链表，然后定位中间的节点,二次遍历</p><p><strong>如何优化</strong>：使用<strong>慢指针</strong>(一步走一个节点)和<strong>快指针</strong>(一步走两个节点)，二者同时遍历，直至<strong>快指针</strong>指向<code>NULL</code>或快指针指向<code>尾节点</code></p><p>当遍历结束时，慢指针指向目标中间节点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码实现</span></span><br><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">middleNode</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">slow</span> =</span> head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">fast</span> =</span> head;</span><br><span class="line">    <span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next-&gt;next; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="应用三-循环链表问题"><a href="#应用三-循环链表问题" class="headerlink" title="应用三 循环链表问题"></a>应用三 循环链表问题</h2>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>=算法=按位异或^的种种玩法</title>
      <link href="/2023/09/04/%E7%AE%97%E6%B3%95_%E6%8C%89%E4%BD%8D%E5%BC%82%E6%88%96/"/>
      <url>/2023/09/04/%E7%AE%97%E6%B3%95_%E6%8C%89%E4%BD%8D%E5%BC%82%E6%88%96/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是按位异或"><a href="#什么是按位异或" class="headerlink" title="什么是按位异或^"></a>什么是按位异或<code>^</code></h2><p>首先将不同数制的数写成<strong>二进制</strong>,例如<code>9-&gt;0b1001</code>.<br>然后最末位对齐，依次<strong>按位异或</strong>.<br>规则:<code>0 ^ 0= 0 ; 1 ^ 1 = 0; 1 ^ 0 = 1</code><br>推论:任意整数<code>x</code>,都有<code>0^x = x</code>  ;   <code>x ^ x = 0</code>\</p><hr><p><strong>来看看应用</strong></p><h2 id="寻找一个单身狗数"><a href="#寻找一个单身狗数" class="headerlink" title="寻找一个单身狗数"></a>寻找一个单身狗数</h2><p>像<code>[1,3,2,2,3]</code>这样除了某一个数<code>1</code>,剩下的数字都是成对的,也就是说遍历一次数组，把所有的元素<strong>按位异或</strong>在一起，结果便是落单的那个<code>1</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码实现</span></span><br><span class="line"><span class="type">int</span> arr[] = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span> sz = <span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);<span class="comment">//求数组大小</span></span><br><span class="line"><span class="type">int</span> ret  = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i =<span class="number">0</span>;i&lt;sz;i++)</span><br><span class="line">&#123;</span><br><span class="line">    ret^=arr[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret; <span class="comment">//此时ret即为落单的那个数</span></span><br></pre></td></tr></table></figure><p><strong><em>变形</em></strong></p><h2 id="消失的数"><a href="#消失的数" class="headerlink" title="消失的数"></a>消失的数</h2><p>已知一个由0~n(缺失一个数)填充的数组，例<code>[0,6,4,2,3,1]</code>,例中的数组少了一个<code>5</code>,而我们已知数组包含0~6中的5个数，就可以将数组元素与0~6<strong>按位异或</strong>到一起，将问题<em>消失的数</em>转化为问题<em>寻找单身狗</em>,消失的数变成剩下的那个单身狗</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码实现</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">missingNumber</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;numsSize;i++&gt;)</span><br><span class="line">    &#123;</span><br><span class="line">        ret^=nums[i];<span class="comment">//历遍nums的所有元素</span></span><br><span class="line">        ret^=i;<span class="comment">//历遍0~numsSize-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    ret^=numsSize;<span class="comment">//补上numsSize;</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>进阶</em></strong></p><h2 id="找到两个单身狗"><a href="#找到两个单身狗" class="headerlink" title="找到两个单身狗"></a>找到两个单身狗</h2><p>数组再升级，单身狗变成了<strong>两个</strong>，导致不能粗暴地把所有元素按位异或来求出两个数,但我们仍可以将问题简化：能否将两个单身狗分到两个数组，使之转化为两个独立的<em>求单个单身狗问题</em>。于是难点来到了如何<strong>分组</strong></p><h3 id="方案之一便是运用按位异或和右移运算符"><a href="#方案之一便是运用按位异或和右移运算符" class="headerlink" title="方案之一便是运用按位异或和右移运算符"></a>方案之一便是运用<strong>按位异或</strong>和<strong>右移运算符</strong></h3><p>因为两个不同的数，在二进制上作比较，就至少有一位是不同的，以那一位为<code>0</code>或<code>1</code>分成两组，便可将两个单身狗分开.而若要查找具体是哪一位，将列表中<strong>所有元素</strong>（就包括了两数）<strong>按位异或</strong>后再用<strong>右移运算符</strong>逐位检验是否为<code>1</code>,之后便可轻松分组，并直接<strong>按位异或</strong>得出结果</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码实现</span></span><br><span class="line"><span class="type">int</span>* <span class="title function_">singleNumber</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> ret[<span class="number">2</span>])</span>&#123;</span><br><span class="line">    <span class="type">int</span> ret1 = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> ret2 = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">0</span>;<span class="comment">//用于记录&quot;1&quot;在哪一位</span></span><br><span class="line">    <span class="type">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;numsSize;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp^=nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>((tmp&gt;&gt;n) !=<span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        n++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;nums;i++&gt;)<span class="comment">//再次历遍</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((nums[i]&gt;&gt;n ==<span class="number">1</span>))<span class="comment">//分组1</span></span><br><span class="line">        &#123;</span><br><span class="line">            ret1^=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>  <span class="comment">//分组2</span></span><br><span class="line">        &#123;</span><br><span class="line">            ret2^=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ret[<span class="number">0</span>] = ret1;</span><br><span class="line">    ret[<span class="number">1</span>] = ret2;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>思考:3个，4个….N个单身狗时呢？</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>=C语言=动态内存分配遇上函数-经典错误纠错</title>
      <link href="/2023/08/28/mistake1/"/>
      <url>/2023/08/28/mistake1/</url>
      
        <content type="html"><![CDATA[<h3 id="直接完整代码"><a href="#直接完整代码" class="headerlink" title="直接完整代码"></a>直接完整代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">GetMemory</span><span class="params">(<span class="type">char</span>* p)</span>   <span class="comment">//申请内存</span></span><br><span class="line">&#123;</span><br><span class="line">p = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="number">100</span>);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Test</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span>* str = <span class="literal">NULL</span>;</span><br><span class="line">GetMemory(str);</span><br><span class="line"><span class="built_in">strcpy</span>(str, <span class="string">&quot;hello world&quot;</span>); <span class="comment">//复制字符串</span></span><br><span class="line"><span class="built_in">printf</span>(str);  <span class="comment">//输出字符串</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">Test();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>推测这段代码的的目的是通过<code>GetMemory</code>函数申请内存，然后把返回的地址存入指针变量<code>str</code>,再把字符串<code>&quot;hello world&quot;</code>复制到<code>str</code>所指向的内存中，最后<code>printf</code>输出</p><h4 id="逐步纠错"><a href="#逐步纠错" class="headerlink" title="逐步纠错"></a>逐步纠错</h4><h5 id="GetMemory"><a href="#GetMemory" class="headerlink" title="GetMemory"></a><code>GetMemory</code></h5><ol><li>首先是传参错误。若在函数内修改外部的一级指针，不能直接将外部一级指针作为<strong>实参</strong>传入：因为函数会将<strong>实参</strong>赋给<strong>形参</strong>，程序运行到大括号外面后，<strong>形参</strong>被销毁，<strong>实参</strong>没有变化。所以应该使用<code>char** p</code>二级指针作为<strong>形参</strong>,储存地址时使用<code>*p</code>\</li><li>其次是内存泄漏。开辟的内存的地址并没有传递给实参，形参又最后销毁了，同时没有释放内存，函数运行完后申请的内存无法找到，导致最终无法释放，造成内存泄漏</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//更合适的代码</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GetMenmory</span><span class="params">(<span class="type">char</span>** p)</span></span><br><span class="line">&#123;</span><br><span class="line">    *p = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="Test"><a href="#Test" class="headerlink" title="Test"></a><code>Test</code></h5><ol><li>NULL的大问题。假设<code>malloc</code>返回的地址已经存入<code>str</code>,但任然缺少对空指针的判断,导致<code>strcmp</code>中传入了空指针-&gt;报错;<code>printf</code>中传入空指针-&gt;报错</li><li>没有释放内存-&gt;内存泄漏。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//更适合的代码</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Test</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span>* str = <span class="literal">NULL</span>;</span><br><span class="line">    GetMemory(str);</span><br><span class="line">    <span class="keyword">if</span>(str == MULL)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">strcpy</span>(str,<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,str);</span><br><span class="line">    <span class="built_in">free</span>(str); <span class="comment">//防止内存泄漏</span></span><br><span class="line">    str = <span class="literal">NULL</span>; <span class="comment">//清除野指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
