<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>高并发内存池--C++项目实践</title>
      <link href="/2024/10/29/tcmalloc/"/>
      <url>/2024/10/29/tcmalloc/</url>
      
        <content type="html"><![CDATA[<h1 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>这是一款高并发的C++内存管理项目，原型是google的一个开源项目<code>tcmalloc</code>,全称<code>Thread_Caching Malloc</code>,即线程缓存的malloc，<code>tcmalloc</code>实现了高效的多线程内存管理，可以用于替代系统的内存分配的相关的函数<code>malloc,new,free,delete</code>等</p><p>实际上原型项目内容很多，但本着渐进学习的理念，我们可以先把<code>tcmalloc</code>最核心的框架简化，模拟实现出一个自己的高并发内存池。在掌握了其中的精华的设计思想和编程技巧后，我们可以再进一步实现或改造原本的<code>tcmalloc</code>项目，或者将学习成果用于其它项目或者更多用途</p><h2 id="应用背景"><a href="#应用背景" class="headerlink" title="应用背景"></a>应用背景</h2><p><code>tcmalloc</code>是一项十分常用的技术，很多对性能要求较高的场景都能用到它</p><ol><li>高性能服务器<ul><li><code>TCMalloc</code>被广泛应用于高并发的服务器程序中，如<code>Web</code>服务器和数据库服务器。这些场景下，需要快速分配和释放内存，<code>TCMalloc</code>通过线程缓存机制减少了锁的竞争，提升了性能。</li></ul></li><li>游戏开发<ul><li>游戏引擎通常需要频繁分配和释放内存，尤其是在运行时动态创建和销毁对象。<code>TCMalloc</code>的低延迟和高吞吐量使其成为游戏开发的理想选择。</li></ul></li><li>大数据处理<ul><li>在处理大数据时，内存管理效率至关重要。许多大数据框架（如<code>TensorFlow</code>和<code>Apache Beam</code>）采用<code>TCMalloc</code>作为内存分配器，以提高性能和降低内存碎片。</li></ul></li><li>机器学习和深度学习<ul><li>在训练和推理过程中，机器学习和深度学习模型通常需要频繁地进行内存分配。<code>TCMalloc</code>s能够有效管理这些内存请求，提升模型的训练和推理效率。</li></ul></li><li>微服务架构<ul><li>在微服务架构中，服务之间的请求通常会涉及大量的内存分配。使用<code>TCMalloc</code>可以减少内存分配的延迟，提高服务的响应速度。</li></ul></li><li>高性能计算（HPC）<br>在高性能计算环境中，内存分配的效率直接影响计算性能。<code>TCMalloc</code>的设计使其能够在这种环境中表现出色，提供更快的内存管理。</li><li>C++ 应用程序<br>TCMalloc 是 C++ 应用程序中常用的内存分配器之一，特别是在需要处理大量小对象的情况下。它可以替代默认的<code>malloc</code>和<code>free</code>函数，提高内存分配的效率。</li><li>实时系统<br>在实时系统中，内存分配的确定性和性能至关重要。<code>TCMalloc</code>提供了较低的延迟和稳定的性能，使其适合用于此类应用。</li></ol><ul><li>总结<ul><li>TCMalloc 的高效性能和线程安全特性使其在多线程应用、服务器、游戏、数据处理和高性能计算等领域得到了广泛应用。选择 TCMalloc 作为内存分配器，可以显著提高应用程序的性能和响应能力。</li></ul></li></ul><h2 id="技能应用"><a href="#技能应用" class="headerlink" title="技能应用"></a>技能应用</h2><p>在本次项目，您将应用如下技能甚至更多</p><ul><li>C++面向对象设计</li><li>链表、哈希表等数据结构</li><li>操作系统内存管理</li><li>单例模式</li><li>多线程</li><li>互斥锁</li></ul><p>以及本次项目的<strong>核心技术: 池化技术</strong></p><h2 id="池化技术介绍"><a href="#池化技术介绍" class="headerlink" title="池化技术介绍"></a>池化技术介绍</h2><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202410292014754.png"></p><p>很多情况下，不论资源是否稀缺，以及申请资源的操作是否成功，前往<strong>申请资源这一操作本身就消耗了不少性能&#x2F;其它资源（尤其时间）</strong>。此时采用池化技术，一次性申请一大块资源，然后优先使用提前申请好的资源，这样可以就可以提高运行效率，减小不必要的额外开销。</p><p>实际上在计算机领域已经有很多应用池化技术的地方了。举例如下图</p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202410292031101.png"></p><p>当然，我们要着重实现的就是<strong>内存池</strong></p><h2 id="内存池介绍"><a href="#内存池介绍" class="headerlink" title="内存池介绍"></a>内存池介绍</h2><p>内存池是池化技术在内存管理上的具体应用。程序预先从操作系统申请一块足够大的内存，此后，当程序中需要申请内存时，不需要直接向操作系统申请，而是直接从内存池中获取；同理，当程序释放内存时，并不是真正将内存返回给操作系统，而是返回给内存池。内存池充当了程序和操作系统的内存交互的中间人，由它负责从操作系统申请的内存的管理</p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202410292052909.png"></p><p>但是实际应用中的<strong>内存池还要解决一个问题–内存碎片化</strong>。内存碎片又分为<code>外碎片</code>和<code>内碎片</code>。</p><p>外碎片是指申请了一些离散的内存后,在<strong>未分配的内存中</strong>，存在一部分空闲的连续内存区域太小，利用不上，导致合计的内存足够的同时，却不能满足部分内存分配的请求。</p><p>内碎片则是由于出于一些对齐的需求，在<strong>分配出去的内存中</strong>,存在多分配出去的内存无法被利用。关于如何缓解内碎片的问题，我们会在后面的代码部分进行更详细的介绍</p><h2 id="项目设计"><a href="#项目设计" class="headerlink" title="项目设计"></a>项目设计</h2><p>针对多核多线程运行环境下，申请内存会发生严重锁竞争的问体i，我们的<code>concurrent memory pool</code>主要从以下几个问题出发，设计实际的模块结构</p><ol><li>内存申请的性能问题</li><li>多线程环境下锁竞争的问题</li><li>内存碎片问题</li></ol><p>针对性能问题，我们可以用池化技术解决；而锁竞争问题，可以通过给每一个线程一个独享的线程池来避免锁竞争；至于内存碎片问题，则是通过多层内存池解决。</p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202410300819196.png"></p><p>三者的关系如上图：</p><ol><li><code>thread cache</code>:线程缓存是每个线程独享的，用小于<code>256KB</code>的内存分配。线程只从这里申请内存，而由于这部分内存是<strong>线程独享的，所以不需要加锁，避免了锁竞争，使线程的内存分配更为高效</strong></li><li><code>central cache</code>:中央缓冲则是由所有线程下的线程级内存池<code>thread cache</code>共享，<code>thread cache</code>从<code>central cache</code>中按需获取<code>内存对象</code>。而<code>central cache</code>负责在合适的时机回收<code>thread cache</code>中的对象，避免一个线程占用了太多空闲内存，而其它线程分配内存不足的情况。这样就能达到负载均衡的效果，使内存分配在多个线程中更能按需分配。显然<code>central cache</code>是一种临界资源，所以从<code>central cache</code>获取内存的过程是需要加锁的。但是不一定要整个内存池要加锁，实际上我们这里用的是<code>桶锁</code>,<code>只给所需要用到的指定哈希桶加锁</code>,能减少锁竞争，其次只有<code>thread cache</code>申请的内存不足以消耗时，才会向<code>central cache</code>申请内存，所以时间上的锁竞争机会更少了。</li><li><code>page cache</code>:页缓存作为<code>central cache</code>的上级缓存，存储的内存对象是以页为单位的，向下分配也是以页为单位的。当<code>central cache</code>申请内存时，<code>page cache</code>负责分配出一定数量的<code>page</code>,并<code>切割</code>成定长大小的内存块分配给<code>central cache</code>。<strong>特别的，当一个<code>span</code>的几个跨度页的对象都回收以后，<code>page cache</code>会回收<code>central cache</code>满足条件的<code>span</code>对象，并合并相邻的页，组成更大的页，缓解内存碎片问题</strong></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>设计模式的C++实现(5)——原型模式</title>
      <link href="/2024/10/29/DP-prototype/"/>
      <url>/2024/10/29/DP-prototype/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>模式名称</strong>: 原型模式-Prototype<br><strong>类型</strong>: 创建型模式<br><strong>问题-使用场景</strong>: 当创建不同对象的过程过于复杂，或者需要隐藏&#x2F;封装创建对象的具体过程，或者<strong>组织项目需要创建过多的子类，类的数目需要优化减少时</strong>，亦或者需要<strong>动态类</strong>时，可以由<strong>原型对象</strong>来执行类的功能<br><strong>解决方案</strong>： 用原型实例指定创建对象的种类，并通过<strong>拷贝</strong>这些原型来创建新的对象<br><strong>效果</strong>： 相比其它模式，用户只需考虑怎么检索到所需要的<code>原型对象</code>来拷贝出新的对象给自己用，而不用考虑如何构造。这样的设计能简化用户操作，且能极大地增加扩展性。</p></blockquote><h1 id="概念抽象"><a href="#概念抽象" class="headerlink" title="概念抽象"></a>概念抽象</h1><p>原型模式旨在通过使用不同的<strong>原型对象</strong>来克隆获取不同的实例，而不是声明许多派生类，再通过派生类来实例化出不同的对象。这样减少类总数的设计方式，可以很好地简化整个项目的<strong>类的结构设计</strong>,毕竟类总数越多，要维护的类关系就越复杂,理解成本就越高。</p><p>原型模式抽象出的参与者有如下三种</p><ol><li><code>Client</code>:负责找到指定原型，并调用其克隆接口，克隆出一个对象</li><li><code>Prototype</code>:抽象类，声明一个抽象接口</li><li><code>ConcretePrototype</code>:实现具体的克隆操作</li></ol><p>三者的类图关系如下：</p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202410301057940.png"></p><h1 id="具体使用"><a href="#具体使用" class="headerlink" title="具体使用"></a>具体使用</h1><p>我们来举一个具体一点的例子来体现原型模式的思想。</p><p>接下来来我们设计一个乐谱编辑-绘制系统，让它能够动态地注册音符、添加音符到乐谱，绘制乐谱。于是我们在类的设计上有决策</p><ol><li><code>MusicNoteDrawer</code>类负责注册原型，管理原型和绘制乐谱</li><li><code>MusicNote</code>抽象类规定音符派生类的接口，尤其是<code>Clone</code>接口</li><li><code>音符派生类</code>，可以每一个音符都设计一个派生类，但我们也可以使用原型的思想，设计一个更为复杂的<code>WholeNote</code>类和<code>HalfNote</code>类，让它们在实例化时调整不同的参数来表示不同的音符。这样我们就把众多音符派生类压缩成了两大类，而不同的音符对象依然能够正确表示</li></ol><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202410301010763.png"></p><p>类图设计如上，按照上面的设计，我们编写如下C++代码示例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MusicNote</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> MusicNote* <span class="title">clone</span><span class="params">()</span> </span>= <span class="number">0</span>;<span class="comment">//规定提供克隆接口</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> </span>= <span class="number">0</span>;<span class="comment">//规定提供绘制自身的接口</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WholeNote</span>:<span class="keyword">public</span> MusicNote<span class="comment">//继承</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">WholeNote</span>(<span class="type">int</span> level) :_level(level) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">WholeNote* <span class="title">clone</span><span class="params">()</span><span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">WholeNote</span>(_level);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span><span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;WholeNote(&quot;</span> &lt;&lt; _level &lt;&lt; <span class="string">&quot;) &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> _level;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HalfNote</span> :<span class="keyword">public</span> MusicNote<span class="comment">//继承</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">HalfNote</span>(<span class="type">int</span> level) :_level(level) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">HalfNote* <span class="title">clone</span><span class="params">()</span><span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">HalfNote</span>(_level);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span><span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;HalfNote(&quot;</span> &lt;&lt; _level &lt;&lt; <span class="string">&quot;) &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> _level;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MusicNoteDrawer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">MusicNoteDrawer</span>():_index() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">registerNote</span><span class="params">(<span class="type">const</span> string&amp; name, <span class="type">int</span> level)</span><span class="comment">//提供动态注册功能</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">string fullName = name + <span class="built_in">to_string</span>(level);</span><br><span class="line"><span class="keyword">if</span> (_index.<span class="built_in">count</span>(fullName))<span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//已存在</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (name == <span class="string">&quot;WholeNote&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">_index[fullName] = <span class="keyword">new</span> <span class="built_in">WholeNote</span>(level);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (name == <span class="string">&quot;HalfNote&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">_index[fullName] = <span class="keyword">new</span> <span class="built_in">HalfNote</span>(level);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;unkown Note :&quot;</span> &lt;&lt; fullName &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为乐谱添加音符</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">addNote</span><span class="params">(<span class="type">const</span> string&amp; name, <span class="type">int</span> level)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">string fullName = name + <span class="built_in">to_string</span>(level);</span><br><span class="line"><span class="keyword">if</span> (_index.<span class="built_in">count</span>(fullName))</span><br><span class="line">&#123;</span><br><span class="line">_music.<span class="built_in">push_back</span>(_index[fullName]-&gt;<span class="built_in">clone</span>());<span class="comment">//调用克隆接口</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;unkown Note :&quot;</span> &lt;&lt; fullName &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//绘制乐谱</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> ptr : _music)</span><br><span class="line">&#123;</span><br><span class="line">ptr-&gt;<span class="built_in">draw</span>();</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">MusicNoteDrawer</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; p : _index)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> p.second;</span><br><span class="line">p.second = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> ptr : _music)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> ptr;</span><br><span class="line">ptr = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">vector&lt;MusicNote*&gt;_music;<span class="comment">//储存乐谱</span></span><br><span class="line">unordered_map&lt;string, MusicNote*&gt; _index;<span class="comment">//实现索引原型</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">MusicNoteDrawer* mnd = <span class="keyword">new</span> MusicNoteDrawer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//注册各种音符</span></span><br><span class="line">mnd-&gt;<span class="built_in">registerNote</span>(<span class="string">&quot;WholeNote&quot;</span>, i);</span><br><span class="line">mnd-&gt;<span class="built_in">registerNote</span>(<span class="string">&quot;HalfNote&quot;</span>, i);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//制作乐谱</span></span><br><span class="line">mnd-&gt;<span class="built_in">addNote</span>(<span class="string">&quot;HalfNote&quot;</span>, <span class="number">1</span>);</span><br><span class="line">mnd-&gt;<span class="built_in">addNote</span>(<span class="string">&quot;HalfNote&quot;</span>, <span class="number">1</span>);</span><br><span class="line">mnd-&gt;<span class="built_in">addNote</span>(<span class="string">&quot;WholeNote&quot;</span>, <span class="number">5</span>);</span><br><span class="line">mnd-&gt;<span class="built_in">addNote</span>(<span class="string">&quot;WholeNote&quot;</span>, <span class="number">5</span>);</span><br><span class="line">mnd-&gt;<span class="built_in">addNote</span>(<span class="string">&quot;WholeNote&quot;</span>, <span class="number">6</span>);</span><br><span class="line">mnd-&gt;<span class="built_in">addNote</span>(<span class="string">&quot;WholeNote&quot;</span>, <span class="number">6</span>);</span><br><span class="line">mnd-&gt;<span class="built_in">addNote</span>(<span class="string">&quot;HalfNote&quot;</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">mnd-&gt;<span class="built_in">draw</span>();<span class="comment">//绘制</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，当我们想要添加<code>MusicNote</code>派生类时，不需要从类示例化出对象，而是找到对于的原型调用它的<code>clone()</code>接口来获取对象，这就是原型模式的工作方式</p><p>实际上，我们还可以把类的数量再压缩一下，把<code>WholeNote</code>和<code>HalfNote</code>合并到同一个更复杂的类中,类图如下:</p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202410301134316.png"></p><h1 id="功能总结"><a href="#功能总结" class="headerlink" title="功能总结"></a>功能总结</h1><h2 id="适用性"><a href="#适用性" class="headerlink" title="适用性"></a>适用性</h2><ul><li>当一个系统应该<strong>独立于</strong>它的产品创建、构成和表示时，要使用<code>Prototype</code>模式</li><li>需要的原型是要再运行时刻动态指定的，使用<code>Prototype</code>模式十分合适</li><li>需要避免创建一个与产品类层次平行的工厂类层次时，也可以用此种模式</li><li>当一个类的示例限定只能从几个人为指定的状态组合中选择一种时，建立相应数目的原型，并只用它们的克隆接口，可能比每次使用合适的状态手工实例化该类要更方便一些。</li></ul><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li><code>Prototype</code>有许多和<code>Abstract Factory</code>和<code>Builder</code>一样的效果：它对客户隐藏了具体的产品类，因此减少了客户需要知道的参数的数目。</li><li><code>运行时动态增加和删除产品</code>：<code>Prototype</code>运行客户注册原型实例，就可以将新的具体产品类并入系统（这个原型执行了类的功能）。这使得它比别的创建型模式更为灵活，提供了更多的运行时的动态性</li><li><code>将原型作为一个动态类来使用</code>： 通过在运行时动态地指定原型对象的一些参数，我们就可以获得一个动态变化的原型来执行动态类的功能，而不是在编译前声明更多的类</li><li><code>提高对象的复用性</code>：许多应用由部件和子部件来创建复杂对象。为用户提供注册这样复杂对象的原型，可以提高其复用性，减少用户创建复杂对象的代价。比如在电路设计编辑器中，一个电路由多个电子器件相互连接构成，编辑器应当为用户提供注册用户自定义的电路对象原型的接口，并且让用户能够方便地复用 </li><li><code>减少子类的构造</code> <code>Factory Method</code>经常产生一个与产品类层次平行的<code>Creator</code>类层次。<code>Prototype</code>模式是的你克隆一个原型而不是请求一个工厂方法去产生一个新的对象。因此更不不需要<code>Creator</code>类层次。这对于像<code>C++</code>这样不将类作为一级类对象的语言受益颇多</li><li><code>用类动态配置应用</code>：<code>Prototype</code>模式允许动态将类(原型对象执行类的功能)装载到应用中,在C++这样的语言中，<code>Prototype</code>是利用这种功能的关键</li></ul><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul><li><code>Prototype</code>的主要缺陷是每一个<code>Prototype</code>子类都必须实现<code>Clone操作</code>，有时这可能很困难。例如，当对象内部包括一些不支持拷贝或有循环引用的对象时，实现克隆可能会很困难</li><li><code>派生类复杂化和聚合化</code>,<code>ConcretePrototype</code>作为<code>Prototype</code>的派生类，要使实例化出的原型能够执行类的功能，往往需要将许多属性和接口聚合在同一个类中，这将使这个类的复杂度大大提升</li></ul><h1 id="使用要点"><a href="#使用要点" class="headerlink" title="使用要点"></a>使用要点</h1><h2 id="原型管理器-Prototype-Manager"><a href="#原型管理器-Prototype-Manager" class="headerlink" title="原型管理器 Prototype Manager"></a>原型管理器 Prototype Manager</h2><p>当一个系统中原型数目不固定时，或者说当向客户开放了创建和销毁原型的接口时，需要保持一个可用原型的注册表。因为尽管客户不会自己来管理原型，但是会在注册表中储存和检索原型。客户在克隆一个原型前需要向注册表请求该原型，我们可以形象地把这个注册表称为原型管理器</p><h2 id="克隆操作时的-深拷贝-与-浅拷贝-问题"><a href="#克隆操作时的-深拷贝-与-浅拷贝-问题" class="headerlink" title="克隆操作时的 深拷贝 与 浅拷贝 问题"></a>克隆操作时的 深拷贝 与 浅拷贝 问题</h2><p>一旦涉及到对象的拷贝时，就绕不开深拷贝与浅拷贝问题。克隆出的对象究竟和原型共享某些资源呢，还是深度拷贝一份，这都是需要好好考虑的问题</p><h2 id="维护Clone接口统一性"><a href="#维护Clone接口统一性" class="headerlink" title="维护Clone接口统一性"></a>维护Clone接口统一性</h2><p>有时客户可能想要在克隆原型时传入参数来进行初始化，但是如果通过<code>Clone</code>接口传参，这将会破坏克隆接口的统一性。如果想要提供传参功能，应当提供额外的接口，例如<code>Initialize</code>接口</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Python特殊函数设计</title>
      <link href="/2024/10/29/python-sp-function/"/>
      <url>/2024/10/29/python-sp-function/</url>
      
        <content type="html"><![CDATA[<h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><h1 id="Reduce"><a href="#Reduce" class="headerlink" title="Reduce"></a>Reduce</h1><h1 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h1><h1 id="iter"><a href="#iter" class="headerlink" title="iter"></a>iter</h1><h1 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【补丁更新v1.2】同步&amp;异步⽇志系统的问题优化与异常处理</title>
      <link href="/2024/10/24/MDPLS-v1-re2/"/>
      <url>/2024/10/24/MDPLS-v1-re2/</url>
      
        <content type="html"><![CDATA[<h1 id="解决异步日志器黏包问题"><a href="#解决异步日志器黏包问题" class="headerlink" title="解决异步日志器黏包问题"></a>解决异步日志器黏包问题</h1><p>由于原本的设计是一股脑直接把日志信息送进了缓冲区，导致输出的时候会产生黏包问题。但是为什么一开始没在意呢？因为标准输出和文件输出都不在意黏包问题，同时输出多条日志是没问题的。</p><p>但是！一旦要开始插入数据库，问题就很严重了。日志信息必须一行一行储存。原本的黏包问题会导致日志信息的解析不可解，所以我们需要修改原本的代码使其能够解决黏包问题</p><h2 id="分隔符"><a href="#分隔符" class="headerlink" title="分隔符"></a>分隔符</h2><p>用<strong>特定的分隔符</strong>标记一次日志的头尾是最容易想到的解决方案。</p><p>然而日志信息是字符串,<strong>任何字符都有可能出现</strong>,导致找不到特定的分隔符可以安全地分隔日志信息</p><p>分隔符只适用于待封装信息的字符在限定范围内时使用。</p><h2 id="封装报头"><a href="#封装报头" class="headerlink" title="封装报头"></a>封装报头</h2><p><em>假如我们能获得一段日志的长度就好了</em>。</p><p>这样的愿望可以封装报头实现。在获取一长段数据时，我们规定最前面的是报头，包含第一段报文的信息(在这个项目里只简单的包括长度信息)。这样我们就能先读取信息再读取报文了。</p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202410251626680.png"></p><p>那么怎么标定报头的范围呢？</p><ul><li>约定使用定长报头</li><li>约定使用分隔符</li></ul><p>定长报头很好理解，而这里又能用分隔符了是因为报头在一段信息的最前面，最先遇到的<strong>特殊字符</strong>必定是作为分隔符存在的</p><p>这里因为没太多信息需要封装进报头，所以我们采用定长报头。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>既然我们选择用定长报头表示储存报文长度，那么我们就得考虑空间利用效率的问题了。直接使用十进制确实挺好，但是密度似乎还是有些低。这里我们选择使用更高的进制来提高空间利用效率。又考虑到易用性和易读性的问题，我们选择了十六进制，因为<code>STL库</code>提供了方便的接口进行数制转换</p><p>为了提高代码复用性，我们把封装报头相关的函数封装进<code>suplog::util</code>里的<code>header</code>类域里</p><blockquote><p>util.hpp</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//v1.2中额外添加</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> suplog&#123;</span><br><span class="line">    <span class="keyword">namespace</span> util&#123;</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">header</span></span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> HEADER_LEN = <span class="number">8</span>;</span><br><span class="line">            <span class="function"><span class="type">static</span> std::string <span class="title">addHeader</span><span class="params">(<span class="type">const</span> std::string&amp;raw_str)</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                <span class="comment">//生成长度固定为8的十六进制报头</span></span><br><span class="line">                <span class="type">int</span> len = raw_str.<span class="built_in">size</span>();</span><br><span class="line">                std::ostringstream oss;</span><br><span class="line">                oss&lt;&lt; std::hex &lt;&lt; std::uppercase &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">8</span>) &lt;&lt; std::<span class="built_in">setfill</span>(<span class="string">&#x27;0&#x27;</span>) &lt;&lt; len;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> oss.<span class="built_in">str</span>()+raw_str;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="type">static</span> std::string <span class="title">delHeader</span><span class="params">(<span class="type">const</span> std::string&amp;pack_str,<span class="type">int</span>* real_len)</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                std::string head = pack_str.<span class="built_in">substr</span>(<span class="number">0</span>,HEADER_LEN);</span><br><span class="line">                <span class="type">int</span> len = <span class="built_in">stoi</span>(head,<span class="literal">nullptr</span>,<span class="number">16</span>);</span><br><span class="line">                <span class="keyword">if</span>(real_len != <span class="literal">nullptr</span>)</span><br><span class="line">                    *real_len = len;</span><br><span class="line">                <span class="keyword">return</span> pack_str.<span class="built_in">substr</span>(<span class="number">8</span>,len);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//读取报头中的长度</span></span><br><span class="line">            <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">readHeader</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str,<span class="type">size_t</span> len)</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(len &lt; <span class="number">8</span>) <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//越界访问</span></span><br><span class="line"></span><br><span class="line">                <span class="function">std::string <span class="title">num_str</span><span class="params">(str,HEADER_LEN)</span></span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> ch:num_str)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(!((<span class="string">&#x27;0&#x27;</span>&lt;=ch &amp;&amp; ch&lt;=<span class="string">&#x27;9&#x27;</span>) || (<span class="string">&#x27;A&#x27;</span>&lt;=ch &amp;&amp; ch&lt;=<span class="string">&#x27;F&#x27;</span>)))</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//非法字符</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">stoi</span>(num_str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>准备好工具后，我们就要着手调整原本的业务流程了</p><p>原本的业务流程如下，搞清楚哪些业务流程要改动，有助于帮我定位需要修改的代码位置</p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202410251702608.png"></p><p>期望修改的新业务流程如下</p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202410251705691.png"></p><p>接下来我们修改一下代码</p><blockquote><p>AsyncLogger</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">logIt</span><span class="params">(<span class="type">const</span> std::string &amp;msg)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//v1.2增加报头封装</span></span><br><span class="line">        std::string header_str = suplog::util::header::<span class="built_in">addHeader</span>(msg);</span><br><span class="line">        _looper-&gt;<span class="built_in">push</span>(header_str);<span class="comment">//推送消息</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//_looper所用的回调函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">readLog</span><span class="params">(Buffer&amp; msg_line)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(_sinks.<span class="built_in">empty</span>())&#123; <span class="keyword">return</span>; &#125;<span class="comment">//判空</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur &lt; msg_line.<span class="built_in">readAbleSize</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//v1.2增加报头解析和字符串拆分</span></span><br><span class="line">            <span class="type">int</span> header_len = suplog::util::header::HEADER_LEN;</span><br><span class="line">            <span class="type">int</span> len = suplog::util::header::<span class="built_in">readHeader</span>(msg_line.<span class="built_in">begin</span>()+cur,header_len);<span class="comment">//读取长度</span></span><br><span class="line">            cur+=header_len;<span class="comment">//跳过报头</span></span><br><span class="line">            <span class="function">std::string <span class="title">msg</span><span class="params">(msg_line.begin()+cur,len)</span></span>;<span class="comment">//提取报文</span></span><br><span class="line">            cur+=len;<span class="comment">//跳过报文</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;it:_sinks)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//调用落地功能</span></span><br><span class="line">                it-&gt;<span class="built_in">log</span>(msg.<span class="built_in">c_str</span>(),msg.<span class="built_in">size</span>());<span class="comment">//直接一次性输出所有缓存的日志</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>经过如上处理，黏包问题便顺利解决了。</p><h1 id="添加异常处理"><a href="#添加异常处理" class="headerlink" title="添加异常处理"></a>添加异常处理</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C++连接MySQL常见接口/类介绍</title>
      <link href="/2024/10/22/mysql-cppConnector/"/>
      <url>/2024/10/22/mysql-cppConnector/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL准备"><a href="#MySQL准备" class="headerlink" title="MySQL准备"></a>MySQL准备</h1><p>为了便于测试，我们专门创建一个用于测试的用户和数据库，并给予相关权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create user &#x27;conn&#x27;@&#x27;localhost&#x27; identified by &#x27;12345678&#x27;;</span><br><span class="line"></span><br><span class="line">create database testDB;</span><br><span class="line"></span><br><span class="line">grant all privileges on testDB.* to &#x27;conn&#x27;@&#x27;localhost&#x27;;</span><br></pre></td></tr></table></figure><h1 id="认识接口-类"><a href="#认识接口-类" class="headerlink" title="认识接口&#x2F;类"></a>认识接口&#x2F;类</h1><p>我们将逐个介绍如下类及其相关接口</p><ul><li><code>sql::SQLString</code></li><li><code>sql::mysql::MySQL_Driver</code>    –<em><code>&lt;mysql_driver.h&gt;</code></em><ul><li><code>sql::mysql::get_mysql_driver_instance()</code></li></ul></li><li><code>sql::Connection</code>   –<em><code>&lt;mysql_connection.h&gt;</code></em></li><li><code>sql::Statement</code>    –<em><code>&lt;cppconn/statement.h&gt;</code></em></li><li><code>sql::ResultSet</code>    –<em><code>&lt;cppconn/resultset.h&gt;</code></em></li><li><code>sql::SQLException</code> –<em><code>&lt;cppconn/exception.h&gt;</code></em></li></ul><h2 id="sql-SQLString"><a href="#sql-SQLString" class="headerlink" title="sql::SQLString"></a>sql::SQLString</h2><p>从名字就能看出，这是<code>SQL</code>语言所用的字符串类。主要用于对<code>SQL</code>语句的字符串操作。我们来看看它的特点</p><h3 id="构造函数的支持"><a href="#构造函数的支持" class="headerlink" title="构造函数的支持"></a>构造函数的支持</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//访问限定符是博客作者手动加的，与源码的位置和数量略有差异</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SQLString</span>() &#123;&#125;<span class="comment">//默认构造函数</span></span><br><span class="line">    <span class="comment">//拷贝构造</span></span><br><span class="line">    <span class="built_in">SQLString</span>(<span class="type">const</span> SQLString &amp; other) : <span class="built_in">realStr</span>(other.realStr) &#123;&#125;</span><br><span class="line">    <span class="comment">//std::string构造</span></span><br><span class="line">    <span class="built_in">SQLString</span>(<span class="type">const</span> std::string &amp; other) : <span class="built_in">realStr</span>(other) &#123;&#125;</span><br><span class="line">    <span class="comment">//原生字符串构造</span></span><br><span class="line">    <span class="built_in">SQLString</span>(<span class="type">const</span> <span class="type">char</span> other[]) : <span class="built_in">realStr</span>(other) &#123;&#125;</span><br><span class="line">    <span class="comment">//指定长度构造</span></span><br><span class="line">    <span class="built_in">SQLString</span>(<span class="type">const</span> <span class="type">char</span> * s, <span class="type">size_t</span> n) : <span class="built_in">realStr</span>(s, n) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string realStr;</span><br></pre></td></tr></table></figure><p>可以看到<code>SQLString</code>的构造已经支持了常用的字符串结构,尤其是<code>std::string</code>和<code>C语言字符串</code></p><p>接下来我们看看它的其它比较特别的接口</p><h2 id="隐式类型转换重载"><a href="#隐式类型转换重载" class="headerlink" title="隐式类型转换重载"></a>隐式类型转换重载</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">operator</span> <span class="type">const</span> std::string &amp;() <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> realStr;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这种类型的重载函数可能比较少见，但是它出现于<code>C++98</code>，且在后续版本没有改变，都是支持的。</p><p>它的效果是为自定义类型提供了自定义的隐式类型转换。有了上述代码的重载后，<code>sql::SQLString</code>就支持了以下写法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sql::SQLString <span class="title">sql_str</span><span class="params">(<span class="string">&quot;这原本是一条SQLString类型的字符串！&quot;</span>)</span></span>;</span><br><span class="line">std::String std_string = sql_str;<span class="comment">//sql_str发生隐式类型转换，转换成const std::string类型,由`realStr`构造</span></span><br></pre></td></tr></table></figure><h3 id="字符串比较函数"><a href="#字符串比较函数" class="headerlink" title="字符串比较函数"></a>字符串比较函数</h3><p>首先是严格比较的函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> SQLString&amp; str)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> realStr.<span class="built_in">compare</span>(str.realStr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * s)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> realStr.<span class="built_in">compare</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">size_t</span> pos1, <span class="type">size_t</span> n1, <span class="type">const</span> <span class="type">char</span> * s)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> realStr.<span class="built_in">compare</span>(pos1, n1, s);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这三个比较函数会对两个字符串进行<strong>严格的大小比较</strong>,唯一的区别就是传参不同，<strong>后续统一以<code>SQLString</code>为例介绍字符串相关的操作，但是要知道它也支持另外两种类型的字符串</strong></p><p>接下来介绍不严格比较（忽略大小写）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">caseCompare</span><span class="params">(<span class="type">const</span> SQLString &amp;s)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="function">std::string <span class="title">tmp</span><span class="params">(realStr)</span>, <span class="title">str</span><span class="params">(s)</span></span>;</span><br><span class="line">      std::<span class="built_in">transform</span>(tmp.<span class="built_in">begin</span>(), tmp.<span class="built_in">end</span>(), tmp.<span class="built_in">begin</span>(), ::tolower);</span><br><span class="line">      std::<span class="built_in">transform</span>(str.<span class="built_in">begin</span>(), str.<span class="built_in">end</span>(), str.<span class="built_in">begin</span>(), ::tolower);</span><br><span class="line">      <span class="keyword">return</span> tmp.<span class="built_in">compare</span>(str);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到这个函数拷贝了两个字符串，并全都统一转换成了小写，这样就可以忽略大小写进行比较了</p><h3 id="重载流插入"><a href="#重载流插入" class="headerlink" title="重载流插入"></a>重载流插入</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// operator &lt;&lt; for SQLString output</span></span><br><span class="line">  <span class="keyword">inline</span> ostream &amp; <span class="keyword">operator</span> &lt;&lt; (ostream &amp; os, <span class="type">const</span> sql::SQLString &amp; str )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> os &lt;&lt; str.<span class="built_in">asStdString</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到它直接支持流插入。</p><h2 id="sql-mysql-MySQL-Driver"><a href="#sql-mysql-MySQL-Driver" class="headerlink" title="sql::mysql::MySQL_Driver"></a>sql::mysql::MySQL_Driver</h2><p>来自头文件<code>&lt;mysql_driver.h&gt;</code></p><p>这是一种<code>MySQL 驱动程序类</code>，它主要用于创建连接对象来<code>连接数据库</code>并返回<code>sql::Connection*</code>,在代码上就是实例化出了一个对象并返回它的指针。</p><p>至于获取driver实例，可以通过命名空间内提供的全局函数获取: <code>sql::mysql::get_mysql_driver_instance();</code>。这个函数会返回一个<code>sql::mysql::MySQL_Driver *</code>指针</p><p>示例如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sql::mysql::MySQL_Driver *driver;<span class="comment">//声明指针</span></span><br><span class="line">driver = sql::mysql::<span class="built_in">get_mysql_driver_instance</span>();<span class="comment">//获取实例</span></span><br></pre></td></tr></table></figure><p>主要用途:这个对象提供了一个<code>connect()</code>方法来创建连接对象并连接到数据库,参数要先后提供<code>ip地址</code>,<code>用户名</code>,<code>用户密码</code></p><p><code>sql::Connection * connect(const sql::SQLString&amp; hostName, const sql::SQLString&amp; userName, const sql::SQLString&amp; password);</code></p><p>创建连接</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;sql::Connection&gt; <span class="title">con</span><span class="params">(driver-&gt;connect(<span class="string">&quot;tcp://127.0.0.1:3306&quot;</span>, <span class="string">&quot;conn&quot;</span>, <span class="string">&quot;12345678&quot;</span>))</span></span>;</span><br></pre></td></tr></table></figure><h2 id="sql-Connection"><a href="#sql-Connection" class="headerlink" title="sql::Connection"></a>sql::Connection</h2><p><code>sql::Connection</code>这个类用于表示与数据库的连接，提供了多种方法来执行 SQL 查询、管理事务、以及处理与数据库交互的各种操作。以下是关于 sql::Connection 的一些关键点</p><h3 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h3><ul><li><strong>连接管理</strong>: <code>sql::Connection</code> 负责管理与数据库的连接，包括建立和关闭连接。</li><li><strong>执行查询</strong>: 通过该类，可以执行 <code>SQL语句</code>（如 <code>SELECT</code>、<code>INSERT</code>、<code>UPDATE</code> 和 <code>DELETE</code>）。</li><li><strong>事务控制</strong>: 支持事务处理，可以<strong>开始、提交和回滚事务</strong>。</li></ul><h3 id="主要成员函数"><a href="#主要成员函数" class="headerlink" title="主要成员函数"></a>主要成员函数</h3><ul><li><code>setSchema</code>: <strong>设置数据库</strong>，传入名称即可,无返回值</li><li><code>reconnect</code>: 用于以相同的连接参数重连</li><li><code>createStatement</code>: 创建一个用于执行 SQL 语句的 <code>sql::Statement</code> 对象。并返回一个<code>sql::Statement*</code>指针</li><li><code>prepareStatement</code>: 创建一个用于执行<strong>预处理</strong> SQL 语句的 <code>sql::PreparedStatement</code> 对象。并返回一个<code>sql::PreparedStatement*</code>指针</li><li><code>setAutoCommit</code>: 设置<strong>是否自动提交事务</strong>。传入一个<code>bool</code>类型的参数</li><li><code>commit</code>: 提交当前事务的更改。</li><li><code>setSavepoint</code>: 创建存档点。会产生一个<code>sql::Savepoint</code>对象并返回一个<code>sql::Savepoint*</code>指针<ul><li>有两种重载，可以不传参，也可以传字符串作为存档点的名称</li></ul></li><li><code>rollback</code>: 回滚当前事务的更改。<ul><li>有两种重载，可以不传参，也可以传入<code>sql::Savepoint*</code>指针,回滚到存档点</li></ul></li><li><code>close</code>: 关闭与数据库的连接。</li></ul><p>这里只使演示一下<code>createStatement</code>获取<code>sql::Statement*</code>用于后文使用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;sql::Statement&gt; <span class="title">stmt</span><span class="params">(con-&gt;createStatement())</span></span>;</span><br></pre></td></tr></table></figure><h2 id="sql-Statement"><a href="#sql-Statement" class="headerlink" title="sql::Statement"></a>sql::Statement</h2><p>主要用于执行静态 <code>SQL</code> 语句,通过调用成员函数,并传入一个字符串</p><p>主要方法如下</p><ul><li><code>execute</code>: 返回值为<code>bool</code>类型，可以执行任意类型的 <code>SQL</code> 语句，如 <code>SELECT</code>、<code>INSERT</code>、<code>UPDATE</code> 和 <code>DELETE</code>。如果执行的是查询语句，则返回 <code>true</code>；如果执行的是更新语句，则返回 <code>false</code>。</li><li><code>executeQuery</code>: 专门用于<strong>执行查询语句</strong>（如 <code>SELECT</code>），并返回一个 <code>sql::ResultSet</code> 对象的指针。</li><li><code>executeUpdate</code>: 专门用于执行更新语句（如 <code>INSERT</code>、<code>UPDATE</code> 和 <code>DELETE</code>），并返回受影响的行数。返回值为<code>int</code>类型</li><li><code>getConnection</code>: 返回创建这个 <code>sql::Statement</code> 的 <code>sql::Connection</code> 对象。</li><li><code>close</code>: 关闭 <code>sql::Statement</code>，<strong>释放其占用的资源</strong>。</li></ul><p>这里写一个获取查询结果的示例代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;sql::Statement&gt; <span class="title">stmt</span><span class="params">(con-&gt;createStatement())</span></span>;</span><br><span class="line"><span class="function">std::unique_ptr&lt;sql::ResultSet&gt; <span class="title">res</span><span class="params">(stmt-&gt;executeQuery(<span class="string">&quot;SELECT VERSION()&quot;</span>))</span></span>;</span><br></pre></td></tr></table></figure><h2 id="sql-ResultSet"><a href="#sql-ResultSet" class="headerlink" title="sql::ResultSet"></a>sql::ResultSet</h2><p>它用于处理 SQL 查询返回的结果集，行为上可以认为它是个<code>单向迭代器</code>,一次只指向查询结果的<strong>某一行</strong></p><p>主要接口有:</p><ul><li><code>next</code>: <ul><li><code>bool next()</code></li><li>将游标从当前位置向前移动一行。如果新的当前行有效，则返回 <code>true</code>；如果没有更多的行，则返回 <code>false</code>。</li></ul></li><li><code>getString</code>: <ul><li><code>SQLString getString(uint32_t columnIndex) const</code></li><li><code>SQLString getString(const sql::SQLString&amp; columnLabel) const</code></li><li><em>下面的两种get方法均有两种重载</em></li><li>获取当前行指定列的 std::string 值。</li></ul></li><li><code>getInt</code>: 获取当前行指定列的 int 值。</li><li><code>getDouble</code>: 获取当前行指定列的 double 值。</li><li><code>getRow</code><ul><li><code>size_t getRow() const</code></li><li>获取行号，从<code>1</code>开始</li></ul></li><li><code>getMetaData</code>: <ul><li><code>ResultSetMetaData * getMetaData() const</code></li><li>返回一个 <code>sql::ResultSetMetaData</code> 对象指针，包含结果集的元数据信息。</li></ul></li><li><code>close</code>: 关闭 sql::ResultSet，释放其占用的资源</li></ul><p>如果要遍历所有行，只需要像使用迭代器一样使用<code>sql::ResultSet</code>即可。示例如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (res-&gt;<span class="built_in">next</span>()) &#123;</span><br><span class="line">        <span class="comment">//输出每一行的行号</span></span><br><span class="line">        std::cout&lt;&lt;res-&gt;<span class="built_in">getRow</span>()&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里再简单介绍一下<code>getMetaData</code>获得的<code>ResultSetMetaData</code>对象提供了哪些接口，可以获得哪些信息</p><p><strong>注意</strong>⚠️,不能用只能指针储存<code>sql:ResultSetMetaData*</code>指针,因为它的析构函数是<code>portected</code>的，由别的对象自动释放，而智能指针没有权限自动释放。</p><p>它的源码及本文作者注释如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> sql</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ResultSetMetaData</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">enum</span></span><br><span class="line">  &#123;</span><br><span class="line">    columnNoNulls,</span><br><span class="line">    columnNullable,</span><br><span class="line">    columnNullableUnknown</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> SQLString <span class="title">getCatalogName</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> column)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">getColumnCount</span><span class="params">()</span> </span>= <span class="number">0</span>;<span class="comment">//获取列总数</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">getColumnDisplaySize</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> column)</span> </span>= <span class="number">0</span>;<span class="comment">//获取指定列的最大字符跨度</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> SQLString <span class="title">getColumnLabel</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> column)</span> </span>= <span class="number">0</span>;<span class="comment">//获取列标签</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> SQLString <span class="title">getColumnName</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> column)</span> </span>= <span class="number">0</span>;<span class="comment">//获取列名称</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">getColumnType</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> column)</span> </span>= <span class="number">0</span>;<span class="comment">//获取列类型</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> SQLString <span class="title">getColumnTypeName</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> column)</span> </span>= <span class="number">0</span>;<span class="comment">//获取列类型名称</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> SQLString <span class="title">getColumnCharset</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> columnIndex)</span> </span>= <span class="number">0</span>;<span class="comment">//获取列字符集</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> SQLString <span class="title">getColumnCollation</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> columnIndex)</span> </span>= <span class="number">0</span>;<span class="comment">//获取列字符集排列规则</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">getPrecision</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> column)</span> </span>= <span class="number">0</span>;<span class="comment">//获取指定列的精度</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">getScale</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> column)</span> </span>= <span class="number">0</span>;<span class="comment">//获取指定列的小树位数</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> SQLString <span class="title">getSchemaName</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> column)</span> </span>= <span class="number">0</span>;<span class="comment">//获取数据库名称</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> SQLString <span class="title">getTableName</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> column)</span> </span>= <span class="number">0</span>;<span class="comment">//获取表名称</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">isAutoIncrement</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> column)</span> </span>= <span class="number">0</span>;<span class="comment">//获取指定列是否有自动增加</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">isCaseSensitive</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> column)</span> </span>= <span class="number">0</span>;<span class="comment">//获取指定列是否大小写敏感</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">isCurrency</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> column)</span> </span>= <span class="number">0</span>;<span class="comment">//判断指定类是否为货币类型</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">isDefinitelyWritable</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> column)</span> </span>= <span class="number">0</span>;<span class="comment">//判断指定列在操作时是否一定会成功</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">isNullable</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> column)</span> </span>= <span class="number">0</span>;<span class="comment">//是否可为空</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">isNumeric</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> column)</span> </span>= <span class="number">0</span>;<span class="comment">//判断是否为数值类型</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">isReadOnly</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> column)</span> </span>= <span class="number">0</span>;<span class="comment">//是否只读</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">isSearchable</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> column)</span> </span>= <span class="number">0</span>;<span class="comment">//是否可供查询，即在where中使用</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">isSigned</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> column)</span> </span>= <span class="number">0</span>;<span class="comment">//是否有符号</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">isWritable</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> column)</span> </span>= <span class="number">0</span>;<span class="comment">//是否可写入</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">isZerofill</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> column)</span> </span>= <span class="number">0</span>;<span class="comment">//是否有前导零填充</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">ResultSetMetaData</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="sql-SQLException"><a href="#sql-SQLException" class="headerlink" title="sql::SQLException"></a>sql::SQLException</h2><p>用于表示在执行 <code>SQL</code> 操作时发生的异常。这个类继承自标准 C++ 异常类<code>std::runtime_error</code>，因此它可以被 <code>try-catch</code> 块捕获并处理</p><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><ul><li><code>getMessage</code>: 返回异常的详细描述信息。</li><li><code>getSQLState</code>: 返回 <code>SQL</code> 标准的状态码（通常是一个五字符的字符串）。</li><li><code>getErrorCode</code>: 返回数据库特有的错误代码。</li></ul><p>下面是一个简单示例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mysql_driver.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mysql_connection.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cppconn/statement.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cppconn/resultset.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cppconn/exception.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        sql::mysql::MySQL_Driver* driver = sql::mysql::<span class="built_in">get_mysql_driver_instance</span>();</span><br><span class="line">        <span class="function">std::unique_ptr&lt;sql::Connection&gt; <span class="title">conn</span><span class="params">(driver-&gt;connect(<span class="string">&quot;tcp://127.0.0.1:3306&quot;</span>, <span class="string">&quot;user&quot;</span>, <span class="string">&quot;password&quot;</span>))</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="function">std::unique_ptr&lt;sql::Statement&gt; <span class="title">stmt</span><span class="params">(conn-&gt;createStatement())</span></span>;</span><br><span class="line">        <span class="function">std::unique_ptr&lt;sql::ResultSet&gt; <span class="title">res</span><span class="params">(stmt-&gt;executeQuery(<span class="string">&quot;SELECT * FROM non_existent_table&quot;</span>))</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (res-&gt;<span class="built_in">next</span>()) &#123;</span><br><span class="line">            <span class="comment">// Process the result set</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (sql::SQLException&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;SQL Exception: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;SQL State: &quot;</span> &lt;&lt; e.<span class="built_in">getSQLState</span>() &lt;&lt; std::endl;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Error Code: &quot;</span> &lt;&lt; e.<span class="built_in">getErrorCode</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (std::exception&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Standard Exception: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (...) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Unknown exception occurred!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL用户管理</title>
      <link href="/2024/10/22/mysql-users/"/>
      <url>/2024/10/22/mysql-users/</url>
      
        <content type="html"><![CDATA[<h1 id="为什么有用户管理"><a href="#为什么有用户管理" class="headerlink" title="为什么有用户管理"></a>为什么有用户管理</h1><p>类比<code>Linux</code>中只有<code>root</code>用户过于危险，因为root能随意地增删查改计算机上的任意文件</p><p><code>MySQL</code>只有<code>root</code>用户登录也是十分危险的，因为<code>root</code>有增删查改<strong>所有数据库和表</strong>的权限，数据安全得不到保障，所以<code>MySQL</code>有自己的用户管理系统</p><h1 id="用户管理的使用"><a href="#用户管理的使用" class="headerlink" title="用户管理的使用"></a>用户管理的使用</h1><h2 id="用户信息"><a href="#用户信息" class="headerlink" title="用户信息"></a>用户信息</h2><p>显然用户信息是需要组织和管理的，所以按照<code>先描述，再组织</code>的原则，我们来思考一下用户信息在逻辑上是什么样的管理思路</p><h3 id="描述用户"><a href="#描述用户" class="headerlink" title="描述用户"></a>描述用户</h3><p>只需略微思考一下在<code>MySQL</code>中描述一个对象怎么样最方便准确，很明显，就是它自带的<code>表结构</code>。</p><p>实际上也确实是这样，<code>MySQL</code>用了一个在<code>mysql</code>数据库中的<code>user</code>表用来描述所有的用户</p><figure class="highlight plaintext"><figcaption><span>client</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; use mysql</span><br><span class="line">Database changed</span><br><span class="line">mysql&gt; select host,user,authentication_string from user;</span><br><span class="line">+-----------+------------------+------------------------------------------------------------------------+</span><br><span class="line">| host      | user             | authentication_string                                                  |</span><br><span class="line">+-----------+------------------+------------------------------------------------------------------------+</span><br><span class="line">| %         | stocer           | $A$005$KKu&#123;+%S+?WLyONB^/UZBeHZsE.i2wvJl.wpcoThot.3TydQQeUXmS1fiWoAV4   |</span><br><span class="line">| localhost | debian-sys-maint | $A$005$lTTz`zNMG&amp;^%%^=Okj/cVfbYBZw3XgJ1Fl3CxH/MRwfNhOa/CE6HHJaag1      |</span><br><span class="line">| localhost | mysql.infoschema | $A$005$THISISACOMBINATIONOFINVALIDSALTANDPASSWORDTHATMUSTNEVERBRBEUSED |</span><br><span class="line">| localhost | mysql.session    | $A$005$THISISACOMBINATIONOFINVALIDSALTANDPASSWORDTHATMUSTNEVERBRBEUSED |</span><br><span class="line">| localhost | mysql.sys        | $A$005$THISISACOMBINATIONOFINVALIDSALTANDPASSWORDTHATMUSTNEVERBRBEUSED |</span><br><span class="line">| localhost | root             | *B8B414B84C3D3937BE77A1BA84B2DF8DA83AA442                              |</span><br><span class="line">+-----------+------------------+------------------------------------------------------------------------+</span><br><span class="line">7 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; desc user;</span><br><span class="line">+--------------------------+-----------------------------------+------+-----+-----------------------+-------+</span><br><span class="line">| Field                    | Type                              | Null | Key | Default               | Extra |</span><br><span class="line">+--------------------------+-----------------------------------+------+-----+-----------------------+-------+</span><br><span class="line">| Host                     | char(255)                         | NO   | PRI |                       |       |</span><br><span class="line">| User                     | char(32)                          | NO   | PRI |                       |       |</span><br><span class="line">| Select_priv              | enum(&#x27;N&#x27;,&#x27;Y&#x27;)                     | NO   |     | N                     |       |</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">| Password_reuse_time      | smallint unsigned                 | YES  |     | NULL                  |       |</span><br><span class="line">| Password_require_current | enum(&#x27;N&#x27;,&#x27;Y&#x27;)                     | YES  |     | NULL                  |       |</span><br><span class="line">| User_attributes          | json                              | YES  |     | NULL                  |       |</span><br><span class="line">+--------------------------+-----------------------------------+------+-----+-----------------------+-------+</span><br><span class="line">51 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>通过上述指令，可以看到有51个<code>column</code>来描述一个具体用户。其中<code>host</code>、<code>user</code>、<code>authentication_string</code>是最常查询的。（大小写不区分）</p><ul><li><code>host</code>：表示数据库能够从哪个ip登录，<code>localhost</code>只能从本机登录，<code>%</code>则是任意主机</li><li><code>user</code>: 用户名</li><li><code>authentication_string</code>: 用户密码<strong>单向加密</strong>后形成的字符串，用于登录时匹配</li></ul><h3 id="组织用户"><a href="#组织用户" class="headerlink" title="组织用户"></a>组织用户</h3><p>既然我们能在表中描述用户了，那么该怎么组织维护用户系统呢？</p><p>很明显，得益于表结构，对用户的<code>增删查改</code>操作转化为了对<code>user表</code>的<code>增删查改</code>操作。</p><p>不过我们也看到了，一个用户表有多达<code>51</code>个属性，<code>删查改</code>似乎还能做到，那用<code>insert into</code>增加条目时难道得一个一个输进去吗？很明显这太麻烦了</p><p>所幸<code>MySQL</code>人性化地提供了<code>MySQL指令</code>用于方便的维护用户表，当然底层还是有<code>MySQL</code>自动地对用户表进行增删查改</p><h2 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h2><p>语法格式如下（<strong>使用时替换中文，保留引号</strong>,<em>密码可为空</em>）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create user &#x27;用户名&#x27;@&#x27;登陆主机/ip&#x27; identified by &#x27;密码&#x27;;</span><br></pre></td></tr></table></figure><h3 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create user &#x27;tester&#x27;@&#x27;localhost&#x27; identified by &#x27;12354678&#x27;;</span><br><span class="line">Query OK, 0 rows affected (0.06 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select user,host,authentication_string from user;</span><br><span class="line">+------------------+-----------+------------------------------------------------------------------------+</span><br><span class="line">| user             | host      | authentication_string                                                  |</span><br><span class="line">+------------------+-----------+------------------------------------------------------------------------+</span><br><span class="line">| stocer           | %         | $A$005$KKu&#123;+%S+?WLyONB^/UZBeHZsE.i2wvJl.wpcoThot.3TydQQeUXmS1fiWoAV4 |</span><br><span class="line">| debian-sys-maint | localhost | $A$005$lTTz`zNMG&amp;^%%^=Okj/cVfbYBZw3XgJ1Fl3CxH/MRwfNhOa/CE6HHJaag1 |</span><br><span class="line">| mysql.infoschema | localhost | $A$005$THISISACOMBINATIONOFINVALIDSALTANDPASSWORDTHATMUSTNEVERBRBEUSED |</span><br><span class="line">| mysql.session    | localhost | $A$005$THISISACOMBINATIONOFINVALIDSALTANDPASSWORDTHATMUSTNEVERBRBEUSED |</span><br><span class="line">| mysql.sys        | localhost | $A$005$THISISACOMBINATIONOFINVALIDSALTANDPASSWORDTHATMUSTNEVERBRBEUSED |</span><br><span class="line">| root             | localhost | *B8B414B84C3D3937BE77A1BA84B2DF8DA83AA442                              |</span><br><span class="line">| tester           | localhost | $A$005$0A_&quot;#,1%*ws+nj^/pEbdS/7ZobqwWK1XRiiozLvuUT/FPxzEwB3zCjBKaK2 |</span><br><span class="line">+------------------+-----------+------------------------------------------------------------------------+</span><br><span class="line">8 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>可以看到在结果的最后一行多出了一个用户<code>tester</code></p><h3 id="密码级别问题"><a href="#密码级别问题" class="headerlink" title="密码级别问题"></a>密码级别问题</h3><p>可能实际在设置密码的时候，因为mysql本身的认证等级比较高，一些简单的密码无法设置，会爆出如下报错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERROR 1819 (HY000): Your password does not satisfy the current policy requirements</span><br></pre></td></tr></table></figure><p>不用担心，<code>MySQL</code>对新用户的密码强度限制也是可以配置的。</p><p>查看当前配置:<code>show variables like &#39;validate_password%&#39;;</code></p><h4 id="没有配置"><a href="#没有配置" class="headerlink" title="没有配置"></a>没有配置</h4><p>可能有人和我一样，返回了空集合</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &#x27;validate_password%&#x27;;</span><br><span class="line">Empty set (0.01 sec)</span><br></pre></td></tr></table></figure><p>此时，可以检查一下 <code>validate_password</code> 插件是否已启用</p><ul><li>语句为<code>show plugins</code>或<code>SHOW PLUGINS</code></li></ul><p>如果找不到<code>validate_password</code>插件，那它就是未启用的状态，此时我们执行如下语句</p><ul><li><code>install plugin validate_password soname &#39;validate_password.so&#39;;</code> 安装插件</li><li><code>show plugins</code> 再查看一次插件状态</li></ul><p>如果看到<code>validate_password</code>并且是<code>ACTIVE</code>状态时，就可以继续配置密码策略了</p><h4 id="配置密码策略"><a href="#配置密码策略" class="headerlink" title="配置密码策略"></a>配置密码策略</h4><p>我们再查看一次当前配置</p><p>查看当前配置:<code>show variables like &#39;validate_password%&#39;;</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &#x27;validate_password%&#x27;;</span><br><span class="line">+--------------------------------------+--------+</span><br><span class="line">| Variable_name                        | Value  |</span><br><span class="line">+--------------------------------------+--------+</span><br><span class="line">| validate_password_check_user_name    | ON     |</span><br><span class="line">| validate_password_dictionary_file    |        |</span><br><span class="line">| validate_password_length             | 8      |</span><br><span class="line">| validate_password_mixed_case_count   | 1      |</span><br><span class="line">| validate_password_number_count       | 1      |</span><br><span class="line">| validate_password_policy             | MEDIUM |</span><br><span class="line">| validate_password_special_char_count | 1      |</span><br><span class="line">+--------------------------------------+--------+</span><br></pre></td></tr></table></figure><p>字段解释：</p><table><thead><tr><th>Variable_name</th><th>Value</th><th>描述</th></tr></thead><tbody><tr><td><code>validate_password_check_user_name</code></td><td><code>ON</code>&#x2F;<code>OFF</code></td><td><strong>是否检查密码中是否包含用户的用户名</strong>。设置为 <code>ON</code> 时，密码不得包含用户的名称。</td></tr><tr><td><code>validate_password_dictionary_file</code></td><td>&lt;文件路径&gt;</td><td><strong>用于指定密码字典文件的路径</strong>。如果设置了这个值，密码将与字典中的词汇进行比较，以防止使用常见密码。</td></tr><tr><td><code>validate_password_length</code></td><td>&gt;&#x3D;1</td><td><strong>设置密码的最小长度</strong>。此值指定用户创建密码时，密码<strong>至少</strong>需要包含多少个字符。没有最大长度限制，但是建议在<code>8~128</code>之间</td></tr><tr><td><code>validate_password_mixed_case_count</code></td><td>&gt;&#x3D;0</td><td><strong>指定密码中至少需要包含一个大写字母和一个小写字母的数量</strong>。设置为 1 表示密码必须至少包含一个大写字母和一个小写字母。</td></tr><tr><td><code>validate_password_number_count</code></td><td>&gt;&#x3D;0</td><td><strong>指定密码中至少需要包含一个数字的数量</strong>。设置为 1 表示密码必须包含至少一个数字。</td></tr><tr><td><code>validate_password_policy</code></td><td><code>LOW</code>、<code>MEDIUM</code> 或 <code>STRONG</code></td><td>设置密码复杂性策略。值为 <code>LOW</code>、<code>MEDIUM</code> 或 <code>STRONG</code>，指示密码的复杂性要求。等级越低，<strong>被忽略</strong>的密码要求越多</td></tr><tr><td><code>validate_password_special_char_count</code></td><td>&gt;&#x3D;0</td><td><strong>指定密码中至少需要包含一个特殊字符的数量</strong>。设置为 1 表示密码必须包含至少一个特殊字符（如 <code>!@#$%^&amp;*</code> 等）。</td></tr></tbody></table><p>对于三种密码策略的预设，介绍如下：</p><ol><li><code>LOW</code><ul><li>要求：<ul><li>只需要密码的长度达到最低要求（默认是 8 个字符）。</li><li><em>其余要求的设置会被忽略</em></li></ul></li><li>限制：没有其他复杂性要求，即可以使用任意字符组合（包括字母、数字和特殊字符）。</li><li>适用场景：适合对安全性要求不高的应用场景。</li></ul></li><li><code>MEDIUM</code><ul><li>要求：除了满足最低长度要求外，密码还需要包含：<ul><li>至少一个大写字母</li><li>至少一个小写字母</li><li>至少一个数字</li><li>至少一个特殊字符（如 <code>!@#$%^&amp;*</code>）</li><li>以上均为默认设置，均可配置，<em>其余要求的设置会被忽略</em><br>适用场景：适合对安全性有中等要求的应用场景。</li></ul></li></ul></li><li><code>STRONG</code><ul><li>要求：需要更高的密码复杂性，必须满足以下条件：<ul><li>至少 8 个字符的长度（可通过设置 validate_password_length 自定义）。</li><li>至少一个大写字母</li><li>至少一个小写字母</li><li>至少一个数字</li><li>至少一个特殊字符</li><li>不能包含用户名或其反转的形式</li><li>不能包含容易猜测的密码（如字典单词）</li><li><em>以上均为默认设置，均可配置</em><br>适用场景：适合对安全性要求较高的应用场景，尤其是在生产环境中。</li></ul></li></ul></li></ol><p>解释完成后，我们来着手配置策略,可选的代码如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">set global validate_password_policy = &#x27;LOW&#x27;;    -- 低级别策略</span><br><span class="line">set global validate_password_policy = &#x27;MEDIUM&#x27;; -- 中级别策略</span><br><span class="line">set global validate_password_policy = &#x27;STRONG&#x27;;  -- 高级别策略</span><br><span class="line"></span><br><span class="line">set global validate_password_length = 10;         -- 设置最小密码长度</span><br><span class="line">set global validate_password_mixed_case_count = 1; -- 设置至少要有一个大写字母和一个小写字母</span><br><span class="line">set global validate_password_number_count = 1;     -- 设置至少要有一个数字</span><br><span class="line">set global validate_password_special_char_count = 1; -- 设置至少要有一个特殊字符</span><br></pre></td></tr></table></figure><p>就比如我们现在把密码策略设置成<code>LOW</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set global validate_password_policy = &#x27;LOW&#x27;; </span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show variables like &#x27;validate_password%&#x27;;</span><br><span class="line">+--------------------------------------+-------+</span><br><span class="line">| Variable_name                        | Value |</span><br><span class="line">+--------------------------------------+-------+</span><br><span class="line">| validate_password_check_user_name    | ON    |</span><br><span class="line">| validate_password_dictionary_file    |       |</span><br><span class="line">| validate_password_length             | 8     |</span><br><span class="line">| validate_password_mixed_case_count   | 1     |</span><br><span class="line">| validate_password_number_count       | 1     |</span><br><span class="line">| validate_password_policy             | LOW   |</span><br><span class="line">| validate_password_special_char_count | 1     |</span><br><span class="line">+--------------------------------------+-------+</span><br><span class="line">7 rows in set (0.03 sec)</span><br></pre></td></tr></table></figure><p><strong>持久化操作</strong>：</p><p>要使这些设置在 MySQL 重启后依然有效，需要在 MySQL 配置文件中添加以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">validate_password_policy = MEDIUM</span><br><span class="line">validate_password_length = 10</span><br><span class="line">validate_password_mixed_case_count = 1</span><br><span class="line">validate_password_number_count = 1</span><br><span class="line">validate_password_special_char_count = 1</span><br></pre></td></tr></table></figure><h2 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h2><p>使用如下语句删除用户</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop user &#x27;用户名&#x27;@&#x27;主机名&#x27;</span><br></pre></td></tr></table></figure><p>但如果不加后面的<code>@&#39;主机名&#39;</code>,它的缺省值为<code>@&#39;%&#39;</code>，可能会出现<code>误删</code>，<code>用户不存在</code>等问题</p><blockquote><p>失败样例</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select user,host from user;</span><br><span class="line">+------------------+-----------+</span><br><span class="line">| user             | host      |</span><br><span class="line">+------------------+-----------+</span><br><span class="line">| stocer           | %         |</span><br><span class="line">| supdriver        | %         |</span><br><span class="line">| debian-sys-maint | localhost |</span><br><span class="line">| mysql.infoschema | localhost |</span><br><span class="line">| mysql.session    | localhost |</span><br><span class="line">| mysql.sys        | localhost |</span><br><span class="line">| root             | localhost |</span><br><span class="line">| tester           | localhost |</span><br><span class="line">+------------------+-----------+</span><br><span class="line">8 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; drop user &#x27;tester&#x27;;</span><br><span class="line">ERROR 1396 (HY000): Operation DROP USER failed for &#x27;tester&#x27;@&#x27;%&#x27;</span><br></pre></td></tr></table></figure><h2 id="修改用户密码"><a href="#修改用户密码" class="headerlink" title="修改用户密码"></a>修改用户密码</h2><ul><li>自己修改自己的密码<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set password=password(&#x27;新的密码&#x27;);</span><br></pre></td></tr></table></figure></li><li>root用户修改其它用户的密码<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set password for &#x27;用户名&#x27;@&#x27;主机名&#x27;=password(&#x27;新的密码&#x27;)；</span><br></pre></td></tr></table></figure></li></ul><h2 id="用户对数据库的权限管理"><a href="#用户对数据库的权限管理" class="headerlink" title="用户对数据库的权限管理"></a>用户对数据库的权限管理</h2><p>就好比Linux文件系统中文件有<code>读写可执行</code>三种权限，数据库也是有诸多权限的,如下是主要的权限列表</p><ol><li>数据库级权限<ul><li><code>ALL PRIVILEGES</code>: 授予所有权限。</li><li><code>CREATE</code>: 创建新数据库和表。</li><li><code>DROP</code>: 删除数据库和表。</li><li><code>INDEX</code>: 创建和删除索引。</li><li><code>ALTER</code>: 修改数据库和表的结构。</li></ul></li><li>表级权限<ul><li><code>SELECT</code>: 读取表中的数据。</li><li><code>INSERT</code>: 向表中插入数据。</li><li><code>UPDATE</code>: 修改表中的数据。</li><li><code>DELETE</code>: 从表中删除数据。</li><li><code>EXECUTE</code>: 执行存储过程。</li></ul></li><li>列级权限<ul><li><code>GRANT OPTION</code>: 允许用户将自己拥有的权限授予其他用户。</li><li><code>CREATE TEMPORARY TABLES</code>: 创建临时表。</li></ul></li><li>其他权限<ul><li><code>FILE</code>: 读取和写入文件。</li><li><code>PROCESS</code>: 查看其他用户的线程。</li><li><code>SHUTDOWN</code>: 关闭服务器。</li><li><code>RELOAD</code>: 重新加载权限、日志和其他配置。</li><li><code>SUPER</code>: 执行某些管理操作，如杀死线程、设置全局系统变量等。</li><li><code>REPLICATION SLAVE</code>: 复制从服务器的权限。</li><li><code>REPLICATION CLIENT</code>: 查看复制状态。</li><li><code>EVENT</code>: 创建和删除事件。</li></ul></li><li>特殊权限<ul><li><code>LOCK TABLES</code>: 锁定表。</li><li><code>CREATE ROUTINE</code>: 创建存储过程和函数。</li><li><code>ALTER ROUTINE</code>: 修改存储过程和函数。</li><li><code>CREATE VIEW</code>: 创建视图。</li><li><code>SHOW VIEW</code>: 查看视图的定义。</li><li><code>CREATE TRIGGER</code>: 创建触发器。</li><li><code>SHOW DATABASES</code>: 查看数据库列表。</li></ul></li></ol><h3 id="授予用户权限"><a href="#授予用户权限" class="headerlink" title="授予用户权限"></a>授予用户权限</h3><p>刚创建的用户默认没有任何权限，还需要手动授予</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grant 权限列表 on 库.对象名 to &#x27;用户名&#x27;@&#x27;登陆位置&#x27; [identified by &#x27;密码&#x27;]</span><br></pre></td></tr></table></figure><ul><li><code>权限列表</code>,多个权限用<code>,</code>分开<ul><li>特别的，<code>ALL PRIVILEGES</code>会直接授予所有权限</li></ul></li><li><code>库.对象名</code>指定权限的作用范围在哪个数据的哪个对象上(对象有<code>表</code>，<code>视图</code>，<code>存储过程</code>等)<ul><li><code>*.*</code>表示所有数据库的所有对象</li><li><code>库.*</code>表示指定数据库下的所有对象</li></ul></li><li><code>identified by</code>可选。 如果用户存在，赋予权限的<strong>同时修改密码</strong>,如果该用户不存在，就是<strong>创建用户</strong></li></ul><p>如果发现新授予的权限没有生效，可以刷新一下权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flush privileges;</span><br></pre></td></tr></table></figure><h3 id="回收权限"><a href="#回收权限" class="headerlink" title="回收权限"></a>回收权限</h3><p>使用<code>revoke</code>即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">revoke 权限列表 on 库.对象名 from &#x27;用户名&#x27;@&#x27;登陆位置&#x27;；</span><br></pre></td></tr></table></figure><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>以上便是用户管理的全部内容了,这一篇是mysql相关开发的铺垫，要认真看完哦</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>设计模式的C++实现(4)——迭代器Iterator</title>
      <link href="/2024/10/15/DP-iterator/"/>
      <url>/2024/10/15/DP-iterator/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>模式名称</strong>: 迭代器-Iterator<br><strong>类型</strong>: 行为模式<br><strong>问题-使用场景</strong>: 提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示<br><strong>解决方案</strong>： 将对列表（对象集合）的访问和遍历从具体对象中分离出来，并放入一个迭代器对象中，由它负责实现访问和遍历功能<br><strong>效果</strong>： 提供了统一的遍历成员的方法，降低了用户的使用难度，提高了代码的封装性和可扩展性。代价是增加了代码复杂性，增加了更多的类，提高了代码的设计难度</p></blockquote><p><em>注：本文的迭代器风格更偏向<code>STL库</code>中的迭代器，而不是《设计模式》中的抽象迭代器</em></p><p><strong>灵感来源</strong>：某种意义上将，<code>Iterator</code>要做的事就是模仿数组中的<code>指针</code>,指针可以前后移动，<em>方便地</em>遍历数组，还可以用指针访问数组元素。我们希望把这种指针特性也用在其它数据结构上(<strong>特指组织管理多个对象的聚合体</strong>)，但可惜的是原生指针的这种<em>方便</em>依赖于数组的地址是连续的。因此为了实现遍历和访问功能，我们需要把这些功能封装在<code>Iterator</code>类中，让它实例化出的对象来行使<code>数组指针</code>一样的行为。</p><h1 id="类层次设计"><a href="#类层次设计" class="headerlink" title="类层次设计"></a>类层次设计</h1><p>我们先来设计一个抽象迭代器类来规定迭代器应有哪些行为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Ptr, <span class="keyword">typename</span> Ref&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">__base_iterator</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">__base_iterator() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">__base_iterator(<span class="type">const</span> __base_iterator&lt;T, T*, T&amp;&gt;&amp; it)&#123;&#125;;<span class="comment">//要支持普通迭代器构造const迭代器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">virtual</span> __base_iterator&lt;T, Ptr, Ref&gt;&amp; <span class="keyword">operator</span>++() = <span class="number">0</span>;<span class="comment">//向前遍历</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//不是所有容器都支持反向迭代器，所以这里根据具体情况声明函数</span></span><br><span class="line"><span class="comment">//__base_iterator&lt;T&gt;&amp; operator--() = 0; </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">virtual</span> Ptr <span class="keyword">operator</span>-&gt;() = <span class="number">0</span>;<span class="comment">//重载-&gt;操作，使其部分实现指针功能</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">virtual</span> Ref <span class="keyword">operator</span>*() = <span class="number">0</span>;<span class="comment">//重载解引用，部分实现指针功能</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> __base_iterator&lt;T,Ptr,Ref&gt;&amp;)<span class="type">const</span> = <span class="number">0</span>;<span class="comment">//应当支持迭代器的不等比较</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ValueType&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">ListNode</span>(<span class="type">const</span> ValueType&amp; val = <span class="built_in">ValueType</span>()) :_val(val), _next(<span class="literal">nullptr</span>), _prev(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">ValueType _val;</span><br><span class="line">ListNode&lt;ValueType&gt;* _next;</span><br><span class="line">ListNode&lt;ValueType&gt;* _prev;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接下来我们逐步解释一下为什么要这么设计。</p><h2 id="三个模板参数"><a href="#三个模板参数" class="headerlink" title="三个模板参数"></a>三个模板参数</h2><p><em>为什么要用三个模板参数，一个不行吗，看起来三个更复杂了？</em></p><p>因为迭代器分<code>普通迭代器</code>和<code>const迭代器</code>，二者权限不同，在重载<code>operator-&gt;()</code>和<code>operator*()</code>时的返回值类型不同，把两种迭代器分开来声明，代码冗余太多了。为了使代码简洁，并提高代码复用性，这里选择了使用三个模板类的方式，大大提高了代码复用性。</p><h2 id="操作符重载"><a href="#操作符重载" class="headerlink" title="操作符重载"></a>操作符重载</h2><p>我们规定了哪些操作符需要重载，来更好地模仿链表指针</p><ul><li><code>operator++()</code>重载前置++，模仿数组指针的遍历功能</li><li><code>operator-&gt;()</code>重载-&gt;,模仿指针的访问成员功能</li><li><code>operator*()</code>重载*,模仿指针的访问内存功能</li></ul><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><p>先准备一个勉强能用的链表类（没有提供迭代器）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ValueType&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">ListNode</span>(<span class="type">const</span> ValueType&amp; val = <span class="built_in">ValueType</span>()) :_val(val), _next(<span class="literal">nullptr</span>), _prev(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">ValueType _val;</span><br><span class="line">ListNode&lt;ValueType&gt;* _next;</span><br><span class="line">ListNode&lt;ValueType&gt;* _prev;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Type&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">List</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">typedef</span> ListNode&lt;Type&gt; Node;<span class="comment">//简化代码</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">List</span>() :_head(<span class="keyword">new</span> Node) &#123; _head-&gt;_next = _head; _head-&gt;_prev = _head; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_front</span><span class="params">(<span class="type">const</span> Type&amp; val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Node* newnode = <span class="keyword">new</span> <span class="built_in">Node</span>(val);</span><br><span class="line">Node* prev = _head;</span><br><span class="line">Node* next = _head-&gt;_next;</span><br><span class="line"></span><br><span class="line">prev-&gt;_next = newnode;</span><br><span class="line">next-&gt;_prev = newnode;</span><br><span class="line"></span><br><span class="line">newnode-&gt;_prev = prev;</span><br><span class="line">newnode-&gt;_next = next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> Type&amp; val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Node* newnode = <span class="keyword">new</span> <span class="built_in">Node</span>(val);</span><br><span class="line">Node* next = _head;</span><br><span class="line">Node* prev = _head-&gt;_prev;</span><br><span class="line"></span><br><span class="line">prev-&gt;_next = newnode;</span><br><span class="line">next-&gt;_prev = newnode;</span><br><span class="line"></span><br><span class="line">newnode-&gt;_prev = prev;</span><br><span class="line">newnode-&gt;_next = next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inorder</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Node* cur = _head-&gt;_next;</span><br><span class="line"><span class="keyword">while</span> (cur != _head)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; cur-&gt;_val &lt;&lt; <span class="string">&quot;-&gt;&quot;</span>;</span><br><span class="line">cur = cur-&gt;_next;</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;_head\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Node* _head;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后我们来继承一下<code>__base_iterator</code>抽象类并实现相关接口</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Ptr, <span class="keyword">typename</span> Ref&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">__base_iterator</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">__base_iterator() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">__base_iterator(<span class="type">const</span> __base_iterator&lt;T, T*, T&amp;&gt;&amp; it)&#123;&#125;;<span class="comment">//要支持普通迭代器构造const迭代器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">virtual</span> __base_iterator&lt;T, Ptr, Ref&gt;&amp; <span class="keyword">operator</span>++() = <span class="number">0</span>;<span class="comment">//向前遍历</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//不是所有容器都支持反向迭代器，所以这里根据具体情况声明函数</span></span><br><span class="line"><span class="comment">//__base_iterator&lt;T&gt;&amp; operator--() = 0; </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">virtual</span> Ptr <span class="keyword">operator</span>-&gt;() = <span class="number">0</span>;<span class="comment">//重载-&gt;操作，使其部分实现指针功能</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">virtual</span> Ref <span class="keyword">operator</span>*() = <span class="number">0</span>;<span class="comment">//重载解引用，部分实现指针功能</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> __base_iterator&lt;T,Ptr,Ref&gt;&amp;)<span class="type">const</span> = <span class="number">0</span>;<span class="comment">//应当支持迭代器的不等比较</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ValueType&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">ListNode</span>(<span class="type">const</span> ValueType&amp; val = <span class="built_in">ValueType</span>()) :_val(val), _next(<span class="literal">nullptr</span>), _prev(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">ValueType _val;</span><br><span class="line">ListNode&lt;ValueType&gt;* _next;</span><br><span class="line">ListNode&lt;ValueType&gt;* _prev;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> Ptr,<span class="keyword">typename</span> Ref&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">__list_iterator</span> :<span class="keyword">public</span> __base_iterator&lt;T,Ptr,Ref&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">typedef</span> __list_iterator&lt;T, Ptr, Ref&gt; Self;</span><br><span class="line"><span class="keyword">typedef</span> __list_iterator&lt;T, T*, T&amp;&gt; iterator;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">__list_iterator(ListNode&lt;T&gt;* ptr) :_ptr(ptr) &#123;&#125;</span><br><span class="line"></span><br><span class="line">__list_iterator(<span class="type">const</span> iterator&amp; it) :_ptr(it._ptr) &#123;&#125;</span><br><span class="line"></span><br><span class="line">__base_iterator&lt;T, Ptr, Ref&gt;&amp; <span class="keyword">operator</span>++() <span class="keyword">override</span></span><br><span class="line">&#123;</span><br><span class="line">_ptr = _ptr-&gt;_next;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Ptr <span class="keyword">operator</span>-&gt;() <span class="keyword">override</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> &amp;(_ptr-&gt;_val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Ref <span class="keyword">operator</span>*() <span class="keyword">override</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> _ptr-&gt;_val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> __base_iterator&lt;T,Ptr,Ref&gt;&amp;it)<span class="type">const</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="type">const</span> Self* pit = <span class="built_in">dynamic_cast</span>&lt;<span class="type">const</span> Self*&gt;(&amp;it);<span class="comment">//指针的(父类子类间)动态转换</span></span><br><span class="line"><span class="keyword">if</span> (pit)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> _ptr != pit-&gt;_ptr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//类型不匹配,认为不相等</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">ListNode&lt;T&gt;* _ptr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>实现难点分析</strong>:</p><ul><li><code>operator++()</code>使用了在多态中，父类引用作为返回值时，函数的重载可以返回子类的引用</li><li><code>operator!=()</code>中因为父类对接口的规定，传参使用了父类的引用，所以要用<code>dynamic_cast</code>做动态的指针转换。</li></ul><p>以上就是对<code>List</code>类的迭代器的封装，很明显这是一种<code>外部迭代器</code>：<strong>由客户控制迭代</strong>。所以为了能够让客户操作，<code>List</code>类应当提供相关的接口。</p><p>不同于书本中的简单工厂设计模式，这里参照的是<code>STL</code>的接口标准，即提供<code>begin()</code> <code>end()</code> <code>begin() const</code> <code>end() const</code>创建<code>iterator</code>或<code>const iterator</code>对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Type&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">List</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">typedef</span> ListNode&lt;Type&gt; Node;<span class="comment">//简化代码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">typedef</span> __list_iterator&lt;Type, Type*, Type&amp;&gt; iterator;</span><br><span class="line"><span class="keyword">typedef</span> __list_iterator&lt;Type, <span class="type">const</span> Type*, <span class="type">const</span> Type&amp;&gt; const_iterator;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">List</span>() :_head(<span class="keyword">new</span> Node) &#123; _head-&gt;_next = _head; _head-&gt;_prev = _head; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">iterator <span class="title">begin</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _head-&gt;_next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">iterator <span class="title">end</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">const_iterator <span class="title">begin</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _head-&gt;_next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">const_iterator <span class="title">end</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//..........下面代码略</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="功能总结与拓展"><a href="#功能总结与拓展" class="headerlink" title="功能总结与拓展"></a>功能总结与拓展</h1><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>经过上面的初步设计，我们的迭代器已经能支持如下功能了：</p><ul><li>支持按程序员自定义的方式遍历一个<code>聚合体</code></li><li>简化了<code>聚合体</code>的接口，<code>聚合体</code>本身不需要提供逐步遍历或自动遍历的接口了</li><li>在<strong>同一个</strong>聚合体上，可以同时进行多个遍历。<em>实例化多个迭代器对象即可</em></li></ul><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><p>作为一种设计模式，上面的功能还不能算是一种完整的设计模式，<code>Iterator</code>的可扩展性和功能不应该仅局限于简单的遍历</p><h3 id="由谁控制迭代"><a href="#由谁控制迭代" class="headerlink" title="由谁控制迭代"></a>由谁控制迭代</h3><p>关于这个问题，迭代器分为了两种</p><ul><li><code>外部迭代器</code>：由客户来控制迭代</li><li><code>内部迭代器</code>：由迭代器自身来控制迭代</li></ul><p><strong>外部迭代器比内部迭代器更灵活，对客户来说也更易于控制</strong>。尽管<code>C++11</code>以后的<code>lambda表达式</code>支持了<code>匿名函数</code>和<code>闭包</code>，内部迭代器可能比书本中描述的要好用一些，内部迭代器的弱点依然显著。<em>为数不多的好处之一就是它们已经定义好了迭代逻辑，客户用起来比较简单</em></p><h3 id="由谁定义遍历-迭代算法"><a href="#由谁定义遍历-迭代算法" class="headerlink" title="由谁定义遍历&#x2F;迭代算法"></a>由谁定义遍历&#x2F;迭代算法</h3><p>实际上迭代器不一定是唯一定义遍历算法的地方。</p><p>可以由<strong>聚合体本身定义遍历算法</strong>，由迭代器负责调用算法和<code>储存迭代</code>状态。这样的迭代器我们称其为<code>指针Cursor</code>，因为它仅仅用于指示当前位置。</p><p>当然，由<strong>迭代器实现遍历算法</strong>才是最常用的。这样可以提供很大的灵活性。比如在相同的聚合体上提供不同的遍历算法，或者在不同的聚合体上重用相同的算法。<strong>但代价是</strong>,迭代器可能需要访问聚合体的私有变量，这在一定程度上破坏了封装性</p><h3 id="迭代器的健壮性和迭代器失效问题"><a href="#迭代器的健壮性和迭代器失效问题" class="headerlink" title="迭代器的健壮性和迭代器失效问题"></a>迭代器的健壮性和迭代器失效问题</h3><p>在使用迭代器遍历时，<strong>插入或是删除操作都是十分危险的</strong>，因为这很可能使迭代器<code>两次访问同一个元素</code>或<code>漏掉某一个元素</code>，这就造成了所谓的<code>迭代器失效问题</code>。</p><p>一种简单的解决方法是在开始遍历时，拷贝一整个聚合体用于安全遍历，但这样实在是太浪费资源了</p><p>或者参照<code>STL</code>的做法，让聚合体提供的插入或删除的接口能够<strong>返回新的迭代器对象</strong>,这样旧的迭代器失效了也没关系，可以继续使用更新后的<strong>新的迭代器</strong>继续遍历了。比如<code>std::vector</code>中的<code>erase()</code>函数的返回值描述如下</p><blockquote><h3 id="Return-Value"><a href="#Return-Value" class="headerlink" title="Return Value"></a>Return Value</h3><p>An iterator pointing to the new location of the element that followed the last element erased by the function call. This is the container end if the operation erased the last element in the sequence.<br>返回一个指向被删除元素的后继的迭代器。如果被删除的是最后一个迭代器，则返回表示结尾的迭代器</p></blockquote><h3 id="多种迭代器"><a href="#多种迭代器" class="headerlink" title="多种迭代器"></a>多种迭代器</h3><p>迭代器也不一定只有一种，可以按不同的遍历方式，声明并实现不同的迭代器，最经典的就是<code>普通迭代器</code>与<code>const 迭代器</code>,<code>正向迭代器</code>与<code>反向迭代器</code>。它们都是不同的类，会实例化出不同的迭代器对象。在这里对类的继承体系并不关心</p><h3 id="使用多态的迭代器"><a href="#使用多态的迭代器" class="headerlink" title="使用多态的迭代器"></a>使用多态的迭代器</h3><p>就像上面的示例代码，实际的迭代器类都继承自一个抽象父类<code>__base_iterator</code>，都继承了父类的抽象接口，显然这已经满足了多态的使用条件。</p><p>然而<strong>使用多态是有代价的</strong>,客户可能需要通过<code>工厂方法设计模式</code>获取迭代器对象，而且还需要客户<code>手动释放迭代器对象</code>，然而客户常常会漏掉或忘记对象的释放，尤其是<code>堆区上的对象</code>。当然，现在有<code>shared_ptr</code>智能指针来减少这种情况的出现。</p><h3 id="空迭代器"><a href="#空迭代器" class="headerlink" title="空迭代器"></a>空迭代器</h3><p>一个空的迭代器不能实现遍历功能，但是它可以用来标识一次遍历的结尾。这种功能在单向链表，树的遍历就尤为有用，当遍历到<code>nullptr</code>时，返回一个空迭代器即可</p><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><ul><li>C++中的STL库中的容器都支持迭代器，使其能够方便地遍历</li><li>MySQL提供的C语言接口库中提供的<code>mysql_fetch_row()</code>函数，每一次调用都会获取下一行，行为就和迭代器很像</li><li>还有更多聚合体可以使用迭代器设计模式，比如可视化控件类的遍历等</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>设计模式的C++实现(0)——初识设计模式</title>
      <link href="/2024/10/10/DP-whatis/"/>
      <url>/2024/10/10/DP-whatis/</url>
      
        <content type="html"><![CDATA[<blockquote><p>《设计模式的C++实现》为作者对<strong>系列博客</strong>的又一次尝试：在开发过<a href="https://www.supdriver.top/2024/09/24/muiltiDesignPatternsLogSystem/">C++基于多设计模式下的同步&amp;异步⽇志系统🔗</a>后，作者接触到了《设计模式》这本书，颇有感触，于是决定写博客来记录读后的灵感，然而随着博客内容的不断丰富，单篇的博客已经承载不下如此多样的内容，各种各样的设计模式便是一个典例，所以我决定将<code>设计模式</code>相关的博客拆成一个系列博客</p></blockquote><blockquote><p>目录:<br><em>TODO</em></p></blockquote><h1 id="知识基础"><a href="#知识基础" class="headerlink" title="知识基础"></a>知识基础</h1><p>本系列博客着重于经典设计模式的介绍和运用C++类和对象技术将其实现，所以要求读者已经能够熟练掌握C++类和对象技术。并且当我们提及<code>抽象类</code>，<code>多态</code>,或者<code>继承</code>，<code>虚函数的声明与实现</code>等概念时，你应当已经对这些概念了然于心，而不是一知半解，还要查资料复习</p><h1 id="设计模式从何而来"><a href="#设计模式从何而来" class="headerlink" title="设计模式从何而来"></a>设计模式从何而来</h1><p><strong>设计模式</strong>描述了在面向对象软件设计过程中针对特定问题的<strong>简洁而优雅的</strong>解决方案。设计模式捕获了<strong>随时间</strong>进化与发展的问题的求解方法，因此它们往往并不是人们从一开始就采用的设计方案，它们反映了不为人知的<strong>重新设计和重新编码的成果</strong>,而这些都来自软件开发者为了设计出灵活可复用的软件而长时间进行的艰苦努力。<strong>设计模式所做的事，就是捕获这些解决方案，并用简洁易用的方式表达出来。</strong></p><h1 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h1><p>设计模式针对的是使用<strong>标准的面向对象语言实现</strong>，所以并不要求使用独特的语言特性，所以我们既用<code>C++</code>实现设计模式，也可以用其它面向对象语言实现，这里使用C++实现仅仅是为了更加具体和直观，同时对C++类和对象有更深入的了解和掌握</p><p>以上是对语言的要求，那么<strong>设计模式</strong>要学到什么地步呢？我们希望在学习了设计模式后，能够在实际开发中对设计模式有一种<code>&quot;Aha!&quot;</code>而不是<code>&quot;Huh?&quot;</code>的应用技术和体验。在此之后，你将能用一种非同寻常的方式思考面向对象设计。<strong>你将拥有一种深刻的洞察力，以帮助你设计出更加灵活的、模块化的、可复用的和易理解的软件</strong>。<em>优雅永不过时</em></p><h1 id="什么是设计模式"><a href="#什么是设计模式" class="headerlink" title="什么是设计模式"></a>什么是设计模式</h1><p>Christopher Alexander说过：“每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的解决方案的核心。这样，你就能一次又一次地使用该方案而不必做重复劳动”</p><p>尽管Alexander所指的是城市和建筑模式，但他的思想<strong>也适用于面向对象设计模式</strong>。设计模式就是这样一种注重解决实际开发中<strong>重复出现</strong>的问题，提供一种<strong>简洁而优雅的设计方案</strong>的经验总结。为什么它能帮助我们减少不必做的重复劳动？因为一个优秀的设计者&#x2F;开发者能够在遇到问题时，善于找出其中与已解决的问题中重复的部分，优先<strong>复用</strong>以往的成功经验，而不是每个新问题都要创造一个新的解决方法，一方面是<strong>低效</strong>，不光是动手开发，往往还要在决策方面耗费不少时间；另一方面是不可靠，新的方法与成熟的解决方案相比，难以对所有情况考虑周全，迭代次数也相应地较少。</p><p>所以学好设计模式，可以大大减少在设计决策方面的代价。使程序员能够在设计合理的前提下，更专注于代码实现。</p><h2 id="设计模式的构成"><a href="#设计模式的构成" class="headerlink" title="设计模式的构成"></a>设计模式的构成</h2><p>一般而言，一个模式有四个基本要素</p><ol><li>模式名称(<code>pattern name</code>) ： 一个助记名，它能用一两个词来描述模式的问题、解决方案和效果。</li><li>问题（<code>problem</code>） ：描述了应该在何时使用模式。</li><li>解决方案（<code>solution</code>） ：描述了设计的组成成分，它们之间的相互关系及各自的职责和协作方式。因为模式就像一个模板，所以有时解决方案可能比较抽象，而不是某种具体实现</li><li>效果（<code>consequences</code>） ：描述了模式应用的效果及使用模式应权衡的问题。<em>我们几乎可以认为，在计算机领域中没有完美的方案。凡事都是需要权衡得失的</em></li></ol><p>出发点的不同会产生对什么是模式而什么不是模式的理解不同。一个人的模式对另一个人来说可能只是基本构造部件。</p><p>我们这里对设计模式的定义为：<code>对被用来在特定场景下解决一般设计问题的类和互相通信的对象的描述</code></p><h2 id="设计模式的六大原则"><a href="#设计模式的六大原则" class="headerlink" title="设计模式的六大原则"></a>设计模式的六大原则</h2><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202409241738553.png"></p><ul><li>单一职责原则(Single Responsibility Principle)<ul><li><code>解释</code>：<strong>类的职责应该单一</strong>，一个方法只做一件事。职责划分清晰明了，每次改动划分到最小单位的方法或类</li><li><code>具体使用建议</code>：两个完全不一样的功能不应该放在一个类中。一个好的类中应该是一组相关性很高的函数和数据的封装<ul><li><em>用例</em>：网络聊天中要实现<code>网络通信</code>&amp;<code>聊天</code>,在这一层次上应分割为<code>网络通信类</code>和<code>聊天类</code>，像<code>网络通信类</code>还能接着划分出<code>套接字类</code>等下一级的分割</li></ul></li></ul></li><li>开闭原则(Open Closed Pinciple)<ul><li><code>解释</code>：<strong>对扩展开放，对修改单一</strong></li><li><code>使用建议</code>：对软件实体的改动，最好用扩展而非修改的方式<ul><li><em>用例</em>：超市卖货促销–不是修改商品原来的价格，而是新增促销价格</li></ul></li></ul></li><li>里氏替换原则(Liskov Substitution Principle)<ul><li>通俗点讲，就是只要父类能出现的地方，子类就可以出现，而且替换为子类也不会产生任何错误或异常</li><li>在继承类时，务必重写⽗类中所有的⽅法，尤其需要注意 <strong>⽗类</strong>的<code>protected</code>⽅法，<strong>⼦类</strong>尽量不要暴露⾃⼰的<code>public</code>⽅法供外界调⽤。</li><li>使用建议：子类必须完全实现父类的方法，孩⼦类可以有⾃⼰的个性。覆盖或实现⽗类的⽅法时，输⼊参数可以被放⼤，输出可以缩⼩</li><li>用例：父类跑步运动员类-<code>会跑步</code>，子类长跑运动员-<code>会跑步</code>且<code>擅长长跑</code>,另一个子类短跑运动员-<code>会跑步</code>且<code>擅长短跑</code></li></ul></li><li>依赖倒置(Dependence Inversion Principle)<ul><li><code>解释</code>:⾼层模块不应该依赖低层模块，两者都应该依赖其抽象. 不可分割的原⼦逻辑就是低层模式，原⼦逻辑组装成的就是⾼层模块</li><li>模块间依赖通过抽象（<strong>接⼝</strong>）发⽣，具体类之间不直接依赖</li><li>使⽤建议：每个类都尽量有抽象类，任何类都不应该从具体类派⽣。尽量不要重写基类的⽅法。结合⾥⽒替换原则使⽤。</li></ul></li><li>迪米特法则(Law of Demeter) <em>又称：”最少知道法则”</em><ul><li><code>解释</code>:尽量减少对象之间的交互，从而减小类之间的耦合。⼀个对象应该对其他对象有最少的了解。对类的低耦合提出了明确的要求：<ul><li>只和直接的朋友交流， 朋友之间也是有距离的。⾃⼰的就是⾃⼰的（如果⼀个⽅法放在本类中，既不增加类间关系，也对本类不产⽣负⾯影响，那就放置在本类中）。</li></ul></li><li><code>用例</code>:⽼师让班⻓点名–⽼师给班⻓⼀个名单，班⻓完成点名勾选，返回结果，⽽不是班⻓点名，⽼师勾选</li></ul></li><li>接口隔离原则(Interface Segregation Principle)<ul><li><code>解释</code>:客⼾端不应该依赖它不需要的接⼝，类间的依赖关系应该建⽴在最⼩的接⼝上</li><li><code>使⽤建议</code>：接⼝设计尽量精简单⼀，但是不要对外暴露没有实际意义的接⼝。</li><li><code>⽤例</code>：修改密码，不应该提供修改⽤⼾信息接⼝，⽽就是单⼀的最⼩修改密码接⼝，更不要暴露数据库操作</li></ul></li></ul><p>从整体上来理解六⼤设计原则，可以简要的概括为⼀句话，⽤抽象构建框架，⽤实现扩展细节，具体到每⼀条设计原则，则对应⼀条注意事项：</p><ul><li><code>单⼀职责原则</code>告诉我们实现类要职责单⼀</li><li><code>⾥⽒替换原则</code>告诉我们不要破坏继承体系</li><li><code>依赖倒置原则</code>告诉我们要⾯向接⼝编程</li><li><code>接⼝隔离原则</code>告诉我们在设计接⼝的时候要精简单⼀</li><li><code>迪⽶特法则</code>告诉我们要降低耦合</li><li><code>开闭原则</code>是总纲，告诉我们要对扩展开放，对修改关闭</li></ul><h1 id="怎样选择设计模式"><a href="#怎样选择设计模式" class="headerlink" title="怎样选择设计模式"></a>怎样选择设计模式</h1><p>设计模式可以多达几十种，分成<code>创建型</code>、<code>结构型</code>、<code>行为型</code>三大类，但要从中找出一个针对特定设计问题的模式可能还是很困难的，尤其是当面对一组新模式，你还不怎么熟悉它的时候。所以对<strong>设计模式的熟悉程度和开发经验很重要</strong>，但经验也是从无到有基类出来的。这里给出几个不同的方法，希望有助于发现时候手头问题的设计模式:</p><ul><li>考虑设计模式是怎样解决设计问题的</li><li>浏览模式的意图(<code>intent</code>)部分,从模式的目的角度考察其关联性。</li><li>研究模式怎样互相关联，有时模式之间会互相关联协作</li><li>研究目的相似的模式。通过对细节的辨析，加深对模式的理解</li><li>检查重新设计的原因。实际上设计模式也会面临重新设计的问题，可以与自己遇到的问题比较是否有相似性</li><li>考虑你的设计中哪些是可变的。这一点与上一点想法，这点着重于考虑你想要什么变化却又不会引起重新设计。可以思考这一要求与哪个设计模式的想法相近</li></ul><h1 id="怎样使用设计模式"><a href="#怎样使用设计模式" class="headerlink" title="怎样使用设计模式"></a>怎样使用设计模式</h1><p>选择了设计模式后该怎么使用它呢？这里给出一个有效应用设计模式的循序渐进的方法。</p><ol><li><strong>大致浏览一边模式</strong>  特别注意其适用性部分和效果部分，确定它适合你的问题</li><li><strong>回头研究结构部分、参与者部分和协作部分</strong>   设计模式之间往往不是孤立的，要确保你理解这个模式的类和对象以及它们是怎样关联的</li><li><strong>看代码示例部分</strong>，看看这个模式代码形式的具体例子   研究具体的代码也有助于着手实现模式</li><li><strong>选择模式参与者的名字，使它们在应用上下文中有意义</strong>     这一点更倾向于从代码规范的角度出发，设计模式参与者的名字通常过于抽象而不会直接出现在应用中，此时通过命名更有利于在形式上增强系统的关联性</li><li><strong>定义类</strong>   声明它们的接口，建立它们的继承关系，组织好类内成员。</li><li><strong>定义模式中专门用于应用的操作名称</strong>     这里再一次体现出，接口的名字一般依赖于应用。</li><li><strong>实现执行模式中责任和协作的操作</strong>   到这一步就要把设计模式的具体实现整合到整个项目代码中，规划如何调用接口。</li></ol><p>设计模式的使用没有标准范式，这里只是作指导作用，探索出适合自己的使用方法才是最好的。</p><p>这里再强调一次<strong>使用设计模式所造成的得失问题，必须要权衡到位</strong></p><ul><li>引入设计模式所<strong>带来的灵活性和可变性</strong>是否刚好符合要求，还是太多余或者还不够</li><li>引入设计模式使得<strong>设计变得更复杂</strong>，是否使项目过于难理解了</li><li>引入设计模式所造成的<strong>性能牺牲</strong>是否在可接受的范围</li></ul><p>所以一定权衡好，一个设计模式所带来的灵活性，是否是你真正需要的</p>]]></content>
      
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【代码整理】同步&amp;异步⽇志系统的代码复盘</title>
      <link href="/2024/10/09/MDPLS-redesign/"/>
      <url>/2024/10/09/MDPLS-redesign/</url>
      
        <content type="html"><![CDATA[<p>在项目的<a href="https://www.supdriver.top/2024/09/24/muiltiDesignPatternsLogSystem/">介绍博客🔗</a>中，我们着重于代码功能的实现，<br>而对项目代码整体的结构和风格欠缺重视，使其<strong>可读性有所欠缺</strong>,<strong>代码规范性也有所不足</strong>。所以在这篇博客中，我们将按上篇博客编写代码的顺序，<br>再一次回顾写好的代码，并着重于：</p><ul><li>调整代码结构</li><li>增加必要注释，删除冗余注释</li><li>添加必要的小括号，突出优先级</li><li>将代码的简便写法改写回易读的写法</li></ul><h1 id="实用类"><a href="#实用类" class="headerlink" title="实用类"></a>实用类</h1><ul><li>增加功能简介</li><li>增加注释</li><li>增加空行<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//提供各种实用类，内部封装了实用接口</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> suplog&#123;</span><br><span class="line">    <span class="keyword">namespace</span> util&#123;</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">date</span></span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="comment">//获取当前时间戳--秒级</span></span><br><span class="line">            <span class="function"><span class="type">static</span> <span class="type">size_t</span> <span class="title">now</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> (<span class="type">size_t</span>)<span class="built_in">time</span>(<span class="literal">nullptr</span>);&#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">file</span>&#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">exists</span><span class="params">(<span class="type">const</span> std::string&amp;name)</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                <span class="comment">//struct stat配合stat函数作为输出型参数</span></span><br><span class="line">                <span class="keyword">struct</span> <span class="title class_">stat</span> st;</span><br><span class="line">                <span class="comment">//stat获取文件的状态，若成功获取，就会返回0，可用于判断文件是否存在,stat函数是系统调用接口</span></span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">stat</span>(name.<span class="built_in">c_str</span>(),&amp;st) == <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="type">static</span> std::string <span class="title">path</span><span class="params">(<span class="type">const</span> std::string &amp;name)</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                <span class="comment">//规定找不到就返回&quot;.&quot;&quot;</span></span><br><span class="line">                <span class="keyword">if</span>(name.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="string">&quot;.&quot;</span>;</span><br><span class="line"></span><br><span class="line">                <span class="type">size_t</span> pos = name.<span class="built_in">find_last_of</span>(<span class="string">&quot;/\\&quot;</span>);<span class="comment">//找到最后一个&quot;/&quot;或&quot;\\&quot;</span></span><br><span class="line">                <span class="keyword">return</span> name.<span class="built_in">substr</span>(<span class="number">0</span>,pos+<span class="number">1</span>);<span class="comment">//取得目录的路径</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">create_directory</span><span class="params">(<span class="type">const</span> std::string &amp;path)</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(path.<span class="built_in">empty</span>()) <span class="keyword">return</span>;<span class="comment">//路径为空</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">exists</span>(path)) <span class="keyword">return</span>;<span class="comment">//路径不存在-使用系统调用接口</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//逐级创建目录</span></span><br><span class="line">                <span class="type">size_t</span> pos,index = <span class="number">0</span>;<span class="comment">//pos标记所要创建的目录，index用于找&quot;/&quot;</span></span><br><span class="line">                <span class="keyword">while</span>(index&lt;path.<span class="built_in">size</span>())</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//找到index及以后的&quot;/&quot;</span></span><br><span class="line">                    pos = path.<span class="built_in">find_first_of</span>(<span class="string">&quot;/\\&quot;</span>,index);</span><br><span class="line">                    <span class="keyword">if</span>(pos == std::string::npos)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">//创建最后一层目录</span></span><br><span class="line">                        <span class="built_in">mkdir</span>(path.<span class="built_in">c_str</span>(),<span class="number">0755</span>);</span><br><span class="line">                        <span class="comment">//函数出口</span></span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//二者重叠时，跳到下一次循环</span></span><br><span class="line">                    <span class="keyword">if</span>(pos ==index) &#123;index = pos+<span class="number">1</span>;<span class="keyword">continue</span>;&#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//准备创建目录，准备路径</span></span><br><span class="line">                    std::string subdir = path.<span class="built_in">substr</span>(<span class="number">0</span>,pos);</span><br><span class="line">                    <span class="comment">//文件夹已存在，不用创建，跳到下一段即可</span></span><br><span class="line">                    <span class="keyword">if</span>(subdir == <span class="string">&quot;.&quot;</span> || subdir == <span class="string">&quot;..&quot;</span>)</span><br><span class="line">                        &#123;index = pos + <span class="number">1</span>;<span class="keyword">continue</span>;&#125;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">exists</span>(subdir))<span class="comment">//理由同上</span></span><br><span class="line">                        &#123;index = pos + <span class="number">1</span>;<span class="keyword">continue</span>;&#125;</span><br><span class="line">                    <span class="comment">//创建目录文件，权限为0755</span></span><br><span class="line">                    <span class="built_in">mkdir</span>(subdir.<span class="built_in">c_str</span>(),<span class="number">0755</span>);</span><br><span class="line">                    index = pos + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="日志等级类"><a href="#日志等级类" class="headerlink" title="日志等级类"></a>日志等级类</h1><ul><li>提供功能描述</li><li>增加注释</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//提供日志等级服务</span></span><br><span class="line"><span class="comment">//提供日志等级枚举</span></span><br><span class="line"><span class="comment">//提供日志等级转字符串</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> suplog&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">LogLevel</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">//枚举所有的日志等级</span></span><br><span class="line">        <span class="keyword">enum class</span> <span class="title class_">Level</span></span><br><span class="line">        &#123;</span><br><span class="line">            DEBUG = <span class="number">1</span>,</span><br><span class="line">            INFO,</span><br><span class="line">            WARN,</span><br><span class="line">            ERROR,</span><br><span class="line">            FATAL,</span><br><span class="line">            OFF</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//提供日志等级转换成字符串的静态成员函数</span></span><br><span class="line">        <span class="function"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">toString</span><span class="params">(LogLevel::Level lv)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">switch</span>(lv)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//在内部定义一个宏函数,把变量名name变成字符串</span></span><br><span class="line">                <span class="comment">//宏函数能较少函数调用，提高运行效率</span></span><br><span class="line">                <span class="meta">#<span class="keyword">define</span> TOSTRING(name) #name</span></span><br><span class="line">                <span class="keyword">case</span> LogLevel::Level::DEBUG: <span class="keyword">return</span> <span class="built_in">TOSTRING</span>(DEBUG);<span class="comment">//直接返回，不加用break</span></span><br><span class="line">                <span class="keyword">case</span> LogLevel::Level::INFO: <span class="keyword">return</span> <span class="built_in">TOSTRING</span>(INFO);</span><br><span class="line">                <span class="keyword">case</span> LogLevel::Level::WARN: <span class="keyword">return</span> <span class="built_in">TOSTRING</span>(WARN);</span><br><span class="line">                <span class="keyword">case</span> LogLevel::Level::ERROR: <span class="keyword">return</span> <span class="built_in">TOSTRING</span>(ERROR);</span><br><span class="line">                <span class="keyword">case</span> LogLevel::Level::FATAL: <span class="keyword">return</span> <span class="built_in">TOSTRING</span>(FATAL);</span><br><span class="line">                <span class="keyword">case</span> LogLevel::Level::OFF: <span class="keyword">return</span> <span class="built_in">TOSTRING</span>(OFF);</span><br><span class="line">                <span class="meta">#<span class="keyword">undef</span> TOSTRING <span class="comment">//取消宏函数</span></span></span><br><span class="line">                <span class="keyword">default</span>: <span class="keyword">return</span> <span class="string">&quot;UNKOWN&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//提供默认返回值</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;UNKNOWN&quot;</span>;<span class="comment">//防止编译报错</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="日志消息类"><a href="#日志消息类" class="headerlink" title="日志消息类"></a>日志消息类</h1><ul><li>增加功能描述</li><li>增加注释</li></ul><h2 id="注释勘误"><a href="#注释勘误" class="headerlink" title="注释勘误"></a>注释勘误</h2><ul><li>对<code>shared_ptr</code>的注释有误，不是全局唯一，是全局引用计数的智能指针</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;util.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;level.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span><span class="comment">//c++多线程库</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//实现LogMsg类，将日志消息封装起来，用于组织管理</span></span><br><span class="line"><span class="comment">//且自动生成时间戳和tid，简化用户操作</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> suplog&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">LogMsg</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//声明一个全局引用计数的智能指针</span></span><br><span class="line">        <span class="keyword">using</span> ptr = std::shared_ptr&lt;LogMsg&gt;;</span><br><span class="line"></span><br><span class="line">        std::string _name;  <span class="comment">//日志器名称</span></span><br><span class="line">        std::string _file;  <span class="comment">//文件名</span></span><br><span class="line">        <span class="type">size_t</span> _line;       <span class="comment">//行号</span></span><br><span class="line">        std::string _payload;<span class="comment">//日志消息</span></span><br><span class="line">        <span class="type">size_t</span> _ctime;      <span class="comment">//时间-时间戳</span></span><br><span class="line">        std::thread::id _tid;<span class="comment">//线程id</span></span><br><span class="line">        LogLevel::Level _level;<span class="comment">//日志等级</span></span><br><span class="line">        <span class="comment">//默认构造函数</span></span><br><span class="line">        <span class="built_in">LogMsg</span>()&#123;&#125;</span><br><span class="line">        <span class="comment">//构造函数</span></span><br><span class="line">        <span class="built_in">LogMsg</span>(</span><br><span class="line">            std::string name,</span><br><span class="line">            std::string file,</span><br><span class="line">            <span class="type">size_t</span> line,</span><br><span class="line">            std::string payload,</span><br><span class="line">            LogLevel::Level level</span><br><span class="line">        ):</span><br><span class="line">        _name(name),</span><br><span class="line">        _file(file),</span><br><span class="line">        _payload(payload),</span><br><span class="line">        _level(level),</span><br><span class="line">        _line(line),</span><br><span class="line">        _ctime(util::date::<span class="built_in">now</span>()),</span><br><span class="line">        _tid(std::this_thread::<span class="built_in">get_id</span>())</span><br><span class="line">        &#123;&#125;<span class="comment">//默认构造函数结尾</span></span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="日志输出格式化类"><a href="#日志输出格式化类" class="headerlink" title="日志输出格式化类"></a>日志输出格式化类</h1><ul><li>修改每个<code>FormatItem</code><ul><li>增加注释对功能的描述</li><li>增加<code>override</code>标记为虚函数重写</li><li>增加<code>return</code>强调成员函数的函数身份</li></ul></li><li>增加对<code>Foramtter</code>类的更详细注释</li><li>调整私有成员到类的最后，把共有成员提前</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;util.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;level.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;message.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span> <span class="comment">//提供一种存储一组不同类型变量的容器</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//提供日志信息嵌入格式化字符串的类实现</span></span><br><span class="line"><span class="comment">//FormatItem抽象类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> suplog&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*=========FormatItem及其派生类===========*/</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">FormatItem</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">using</span> ptr = std::shared_ptr&lt;FormatItem&gt;;</span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="built_in">FormatItem</span>()&#123;&#125;</span><br><span class="line">        <span class="comment">//规定统一实现format接口</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">format</span><span class="params">(std::ostream&amp; os,<span class="type">const</span> LogMsg&amp; msg)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//日志消息输出</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">MsgFormatItem</span>:<span class="keyword">public</span> FormatItem</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">MsgFormatItem</span>(<span class="type">const</span> std::string&amp; str = <span class="string">&quot;&quot;</span>)&#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">format</span><span class="params">(std::ostream&amp; os,<span class="type">const</span> LogMsg&amp; msg)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            os&lt;&lt;msg._payload;</span><br><span class="line">            <span class="keyword">return</span>;<span class="comment">//没有实际意义，只是标记函数结束</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//日志等级输出</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">LevelFormatItem</span>:<span class="keyword">public</span> FormatItem&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">LevelFormatItem</span>(<span class="type">const</span> std::string&amp; str = <span class="string">&quot;&quot;</span>)&#123;&#125;;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">format</span><span class="params">(std::ostream&amp; os,<span class="type">const</span> LogMsg&amp; msg)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            os&lt;&lt;LogLevel::<span class="built_in">toString</span>(msg._level);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//日志器名称输出</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">NameFormatItem</span>:<span class="keyword">public</span> FormatItem&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">NameFormatItem</span>(<span class="type">const</span> std::string&amp; str=<span class="string">&quot;&quot;</span>)&#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">format</span><span class="params">(std::ostream&amp; os,<span class="type">const</span> LogMsg&amp; msg)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            os&lt;&lt;msg._name;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//线程td输出</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">ThreadFormatItem</span>:<span class="keyword">public</span> FormatItem&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">ThreadFormatItem</span>(<span class="type">const</span> std::string&amp; str=<span class="string">&quot;&quot;</span>)&#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">format</span><span class="params">(std::ostream&amp; os,<span class="type">const</span> LogMsg&amp; msg)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            os&lt;&lt;msg._tid;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//格式化时间输出</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">TimeFormatItem</span>:<span class="keyword">public</span> FormatItem&#123;</span><br><span class="line">    <span class="keyword">public</span>:<span class="comment">//共有接口写在最前面</span></span><br><span class="line">        <span class="built_in">TimeFormatItem</span>(<span class="type">const</span> std::string&amp; format=<span class="string">&quot;%H:%M:%S&quot;</span>):_format(format)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(format.<span class="built_in">empty</span>()) _format = &#123;<span class="string">&quot;%H:%M:%S&quot;</span>&#125;;<span class="comment">//这里要获取格式串</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">format</span><span class="params">(std::ostream&amp; os,<span class="type">const</span> LogMsg&amp; msg)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="type">time_t</span> t = msg._ctime;</span><br><span class="line">            <span class="keyword">struct</span> <span class="title class_">tm</span> lt;</span><br><span class="line">            <span class="built_in">localtime_r</span>(&amp;t,&amp;lt);<span class="comment">//从时间戳t中提取时间信息到结构体lt中</span></span><br><span class="line">            <span class="type">char</span> tmp[<span class="number">128</span>];</span><br><span class="line">            <span class="built_in">strftime</span>(tmp,<span class="number">127</span>,_format.<span class="built_in">c_str</span>(),&amp;lt);<span class="comment">//格式化日期信息到字符串</span></span><br><span class="line">            os&lt;&lt;tmp;<span class="comment">//最后输出</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:<span class="comment">//私有接口写在后面</span></span><br><span class="line">        std::string _format;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//日志调用者的文件名输出</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">CFileFormatItem</span>:<span class="keyword">public</span> FormatItem&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">CFileFormatItem</span>(<span class="type">const</span> std::string&amp; str=<span class="string">&quot;&quot;</span>)&#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">format</span><span class="params">(std::ostream&amp; os,<span class="type">const</span> LogMsg&amp; msg)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            os&lt;&lt;msg._file;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//日志调用行号输出</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">CLineFormatItem</span>:<span class="keyword">public</span> FormatItem&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">CLineFormatItem</span>(<span class="type">const</span> std::string&amp; str=<span class="string">&quot;&quot;</span>)&#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">format</span><span class="params">(std::ostream&amp; os,<span class="type">const</span> LogMsg&amp; msg)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            os&lt;&lt;msg._line;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Tab输出</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">TabFormatItem</span>:<span class="keyword">public</span> FormatItem&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">TabFormatItem</span>(<span class="type">const</span> std::string&amp; str=<span class="string">&quot;&quot;</span>)&#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">format</span><span class="params">(std::ostream&amp; os,<span class="type">const</span> LogMsg&amp; msg)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            os&lt;&lt;<span class="string">&#x27;\t&#x27;</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;        </span><br><span class="line"></span><br><span class="line">    <span class="comment">//换行符输出</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">NLineFormatItem</span>:<span class="keyword">public</span> FormatItem&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">NLineFormatItem</span>(<span class="type">const</span> std::string&amp; str=<span class="string">&quot;&quot;</span>)&#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">format</span><span class="params">(std::ostream&amp; os,<span class="type">const</span> LogMsg&amp; msg)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            os&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//其它日志信息输出</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">OtherFormatItem</span>:<span class="keyword">public</span> FormatItem&#123;</span><br><span class="line">    <span class="keyword">public</span>:<span class="comment">//公共接口写在前面</span></span><br><span class="line">        <span class="built_in">OtherFormatItem</span>(<span class="type">const</span> std::string &amp;str=<span class="string">&quot;&quot;</span>):_str(str)&#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">format</span><span class="params">(std::ostream&amp; os,<span class="type">const</span> LogMsg&amp; msg)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            os&lt;&lt;_str;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        std::string _str;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*====End==Of==FormatItem及其派生类===========*/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Formatter</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">using</span> ptr = std::shared_ptr&lt;Formatter&gt;;<span class="comment">//内置一个指针类</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            %d ⽇期</span></span><br><span class="line"><span class="comment">            %T 缩进</span></span><br><span class="line"><span class="comment">            %t 线程id</span></span><br><span class="line"><span class="comment">            %p ⽇志级别</span></span><br><span class="line"><span class="comment">            %c ⽇志器名称</span></span><br><span class="line"><span class="comment">            %f ⽂件名</span></span><br><span class="line"><span class="comment">            %l ⾏号</span></span><br><span class="line"><span class="comment">            %m ⽇志消息</span></span><br><span class="line"><span class="comment">            %n 换⾏</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//使用格式串初始化,规则如上</span></span><br><span class="line">        <span class="built_in">Formatter</span>(<span class="type">const</span> std::string&amp; pattern = <span class="string">&quot;[%d&#123;%H:%M:%S&#125;][%t][%p][%c][%f:%l] %m%n&quot;</span>)</span><br><span class="line">        :_pattern(pattern)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">assert</span>(<span class="built_in">parsePattern</span>());<span class="comment">//调用成员函数，后面声明</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//简单的查看pattern的接口</span></span><br><span class="line">        <span class="function"><span class="type">const</span> std::string <span class="title">pattern</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _pattern; &#125;</span><br><span class="line">        <span class="comment">//最后实现，但是是最常用的接口，故写在前面</span></span><br><span class="line">        <span class="comment">//使用LogMsg对象生成日志字符串</span></span><br><span class="line">        <span class="function">std::string <span class="title">format</span><span class="params">(<span class="type">const</span> LogMsg&amp; msg)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            std::stringstream ss;<span class="comment">//创建string流</span></span><br><span class="line">            <span class="comment">//按格式串生成日志信息</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; it: _items)</span><br><span class="line">            &#123;</span><br><span class="line">                it-&gt;format(ss,msg);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ss.<span class="built_in">str</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建FormatItem(给调用者使用多态)</span></span><br><span class="line">        <span class="function">FormatItem::ptr <span class="title">createItem</span><span class="params">(<span class="type">const</span> std::string&amp; fc,<span class="type">const</span> std::string&amp; subfmt)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="comment">//根据传入的format character选择创建的FormatItem类</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(fc == <span class="string">&quot;m&quot;</span>) <span class="keyword">return</span> FormatItem::<span class="built_in">ptr</span>(<span class="keyword">new</span> <span class="built_in">MsgFormatItem</span>(subfmt));</span><br><span class="line">            <span class="keyword">if</span>(fc == <span class="string">&quot;p&quot;</span>) <span class="keyword">return</span> FormatItem::<span class="built_in">ptr</span>(<span class="keyword">new</span> <span class="built_in">LevelFormatItem</span>(subfmt));</span><br><span class="line">            <span class="keyword">if</span>(fc == <span class="string">&quot;c&quot;</span>) <span class="keyword">return</span> FormatItem::<span class="built_in">ptr</span>(<span class="keyword">new</span> <span class="built_in">NameFormatItem</span>(subfmt));</span><br><span class="line">            <span class="keyword">if</span>(fc == <span class="string">&quot;t&quot;</span>) <span class="keyword">return</span> FormatItem::<span class="built_in">ptr</span>(<span class="keyword">new</span> <span class="built_in">ThreadFormatItem</span>(subfmt));</span><br><span class="line">            <span class="keyword">if</span>(fc == <span class="string">&quot;n&quot;</span>) <span class="keyword">return</span> FormatItem::<span class="built_in">ptr</span>(<span class="keyword">new</span> <span class="built_in">NLineFormatItem</span>(subfmt));</span><br><span class="line">            <span class="keyword">if</span>(fc == <span class="string">&quot;d&quot;</span>) <span class="keyword">return</span> FormatItem::<span class="built_in">ptr</span>(<span class="keyword">new</span> <span class="built_in">TimeFormatItem</span>(subfmt));</span><br><span class="line">            <span class="keyword">if</span>(fc == <span class="string">&quot;f&quot;</span>) <span class="keyword">return</span> FormatItem::<span class="built_in">ptr</span>(<span class="keyword">new</span> <span class="built_in">CFileFormatItem</span>(subfmt));</span><br><span class="line">            <span class="keyword">if</span>(fc == <span class="string">&quot;l&quot;</span>) <span class="keyword">return</span> FormatItem::<span class="built_in">ptr</span>(<span class="keyword">new</span> <span class="built_in">CLineFormatItem</span>(subfmt));</span><br><span class="line">            <span class="keyword">if</span>(fc == <span class="string">&quot;T&quot;</span>) <span class="keyword">return</span> FormatItem::<span class="built_in">ptr</span>(<span class="keyword">new</span> <span class="built_in">TabFormatItem</span>(subfmt));</span><br><span class="line">            <span class="keyword">return</span> FormatItem::<span class="built_in">ptr</span>();<span class="comment">//未知fc</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//pattern解析</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//每个要素分为三部分：</span></span><br><span class="line">        <span class="comment">// 格式化字符 : %d %T %p...</span></span><br><span class="line">        <span class="comment">// 对应的输出⼦格式 ： &#123;%H:%M:%S&#125;</span></span><br><span class="line">        <span class="comment">// 对应数据的类型 ： 0-表⽰原始字符串，也就是⾮格式化字符，1-表⽰格式化数据类型</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//默认格式&quot;[%d&#123;%H:%M:%S&#125;][%t][%p][%c][%f:%l] %m%n&quot;</span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">parsePattern</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="comment">//储存分割好的字符串,是否为原始字符串由int指示</span></span><br><span class="line">            std::vector&lt;std::tuple&lt;std::string,std::string,<span class="type">int</span>&gt;&gt; arry;<span class="comment">//储存分析后的原素材</span></span><br><span class="line">            std::string format_key;<span class="comment">//存放%之后的格式化字符</span></span><br><span class="line">            std::string format_val;<span class="comment">//存放格式化字符串后边&#123;&#125;中的子格式化字符串</span></span><br><span class="line">            std::string string_row;<span class="comment">//存放原始的非格式化字符串</span></span><br><span class="line">            <span class="type">bool</span> sub_format_error = <span class="literal">false</span>;</span><br><span class="line">            <span class="type">int</span> pos = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(pos &lt; _pattern.<span class="built_in">size</span>())<span class="comment">//开始扫描格式串</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//储存原始字符</span></span><br><span class="line">                <span class="keyword">if</span>(_pattern[pos] != <span class="string">&#x27;%&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    string_row.<span class="built_in">push_back</span>(_pattern[pos++]);</span><br><span class="line">                    <span class="keyword">continue</span>;<span class="comment">//跳过循环的后半部分,创建尽可能长的原始字符串</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(pos+<span class="number">1</span>&lt;_pattern.<span class="built_in">size</span>() &amp;&amp; _pattern[pos+<span class="number">1</span>] == <span class="string">&#x27;%&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//规定%%格式化为原生的&#x27;%&#x27;字符</span></span><br><span class="line">                    string_row.<span class="built_in">push_back</span>(<span class="string">&#x27;%&#x27;</span>);</span><br><span class="line">                    pos+=<span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;<span class="comment">//跳过循环的后半部分,创建尽可能长的原始字符串</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(string_row.<span class="built_in">empty</span>() == <span class="literal">false</span>)<span class="comment">//原生字符串不为空</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//准备好了一段素材</span></span><br><span class="line">                    arry.<span class="built_in">push_back</span>(std::<span class="built_in">make_tuple</span>(string_row,<span class="string">&quot;&quot;</span>,<span class="number">0</span>));</span><br><span class="line">                    <span class="comment">//清空容器</span></span><br><span class="line">                    string_row.<span class="built_in">clear</span>();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//当前位置指向%字符</span></span><br><span class="line">                pos++;<span class="comment">//pos指向格式化字符位置</span></span><br><span class="line">                <span class="keyword">if</span>(pos&lt;_pattern.<span class="built_in">size</span>() &amp;&amp; <span class="built_in">isalpha</span>(_pattern[pos]))<span class="comment">//判断是不是字符</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//储存fc字符</span></span><br><span class="line">                    format_key = _pattern[pos];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    std::cout&lt;&lt; &amp;_pattern[pos<span class="number">-1</span>]&lt;&lt;<span class="string">&quot;位置附近格式错误！\n&quot;</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//下一步使pos指向格式化字符的下个位置，判断是否包含有子格式,例如在%d&#123;%Y-%m-%d&#125;中</span></span><br><span class="line">                pos++;</span><br><span class="line">                <span class="keyword">if</span>(pos+<span class="number">1</span> &lt; _pattern.<span class="built_in">size</span>() &amp;&amp; _pattern[pos] == <span class="string">&#x27;&#123;&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    sub_format_error = <span class="literal">true</span>;</span><br><span class="line">                    pos++;<span class="comment">//pos指向花括号下一个字符</span></span><br><span class="line">                    <span class="keyword">while</span> (pos&lt;_pattern.<span class="built_in">size</span>())</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span>(_pattern[pos] == <span class="string">&#x27;&#125;&#x27;</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="comment">//循环出口</span></span><br><span class="line">                            sub_format_error = <span class="literal">false</span>;</span><br><span class="line">                            pos++;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//在循环中时,存储子格式</span></span><br><span class="line">                        format_val.<span class="built_in">push_back</span>(_pattern[pos++]);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(sub_format_error)</span><br><span class="line">                    &#123;</span><br><span class="line">                        std::cout&lt;&lt;<span class="string">&quot;&#123;&#125;对应出错\n&quot;</span>;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//储存格式字符创建的原素材</span></span><br><span class="line">                arry.<span class="built_in">push_back</span>(std::<span class="built_in">make_tuple</span>(format_key,format_val,<span class="number">1</span>));</span><br><span class="line">                format_key.<span class="built_in">clear</span>();</span><br><span class="line">                format_val.<span class="built_in">clear</span>();</span><br><span class="line">            &#125;<span class="comment">//结束循环</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//继续处理未清空的容器/缓存</span></span><br><span class="line">            <span class="keyword">if</span>(string_row.<span class="built_in">empty</span>() == <span class="literal">false</span>)<span class="comment">//原生字符串不为空</span></span><br><span class="line">                arry.<span class="built_in">push_back</span>(std::<span class="built_in">make_tuple</span>(string_row,<span class="string">&quot;&quot;</span>,<span class="number">0</span>));</span><br><span class="line">            <span class="keyword">if</span>(format_key.<span class="built_in">empty</span>() == <span class="literal">false</span>)<span class="comment">//格式化字符不为空，注，上下顺序不能换,要和循环内一致</span></span><br><span class="line">                arry.<span class="built_in">push_back</span>(std::<span class="built_in">make_tuple</span>(format_key,format_val,<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">            <span class="comment">//开始产生item列表</span></span><br><span class="line">            <span class="keyword">if</span>(_items.<span class="built_in">empty</span>() == <span class="literal">false</span>)_items.<span class="built_in">clear</span>();<span class="comment">//清理_items</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; it:arry)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(std::<span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(it) == <span class="number">0</span>)<span class="comment">//获取第三个元素</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//生成非格式原始字符串</span></span><br><span class="line">                    <span class="function">FormatItem::ptr <span class="title">fi</span><span class="params">(<span class="keyword">new</span> OtherFormatItem(std::get&lt;<span class="number">0</span>&gt;(it)))</span></span>;</span><br><span class="line">                    _items.<span class="built_in">push_back</span>(fi);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    FormatItem::ptr fi = <span class="built_in">createItem</span>(std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(it),</span><br><span class="line">                                                    std::<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(it));</span><br><span class="line">                    <span class="keyword">if</span>(fi.<span class="built_in">get</span>() == <span class="literal">nullptr</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        std::cout&lt;&lt;<span class="string">&quot;没有对应的格式化字符串： %&quot;</span></span><br><span class="line">                                 &lt;&lt;std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(it)</span><br><span class="line">                                 &lt;&lt;std::endl;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    _items.<span class="built_in">push_back</span>(fi);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="comment">//完成拼接</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        std::string _pattern;<span class="comment">//储存格式串</span></span><br><span class="line">        std::vector&lt;FormatItem::ptr&gt; _items;<span class="comment">//产生格式化字符串的生成器列表</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="日志落地类"><a href="#日志落地类" class="headerlink" title="日志落地类"></a>日志落地类</h1><ul><li>增加注释</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;util.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;message.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;formatter.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> suplog&#123;</span><br><span class="line">    <span class="comment">//声明抽象父类LogSink</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">LogSink</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">using</span> ptr = std::shared_ptr&lt;LogSink&gt;;</span><br><span class="line">        <span class="built_in">LogSink</span>()&#123;&#125;</span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="built_in">LogSink</span>() =<span class="keyword">default</span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*data,<span class="type">size_t</span> len)</span> </span>= <span class="number">0</span>;<span class="comment">//声明统一的log接口</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//标准输出落地</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">StdoutSink</span>:<span class="keyword">public</span> LogSink</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">using</span> ptr = std::shared_ptr&lt;StdoutSink&gt;;</span><br><span class="line">        <span class="built_in">StdoutSink</span>()=<span class="keyword">default</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*data,<span class="type">size_t</span> len)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            std::cout.<span class="built_in">write</span>(data,len);</span><br><span class="line">            <span class="keyword">return</span>;<span class="comment">//标记函数结尾</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//文件落地类</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">FileSink</span>:<span class="keyword">public</span> LogSink</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">using</span> ptr = std::shared_ptr&lt;FileSink&gt;;</span><br><span class="line">        <span class="built_in">FileSink</span>(<span class="type">const</span> std::string&amp; filename):_filename(filename)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//创建目录</span></span><br><span class="line">            util::file::<span class="built_in">create_directory</span>(util::file::<span class="built_in">path</span>(filename));</span><br><span class="line">            _ofs.<span class="built_in">open</span>(_filename,std::ios::binary|std::ios::app);<span class="comment">//二进制方式写入</span></span><br><span class="line">            <span class="comment">//打开文件失败就assert,待改成抛异常</span></span><br><span class="line">            <span class="built_in">assert</span>(_ofs.<span class="built_in">is_open</span>());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//提供给外界获取文件名</span></span><br><span class="line">        <span class="function"><span class="type">const</span> std::string &amp;<span class="title">file</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> _filename; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*data,<span class="type">size_t</span> len)</span> <span class="keyword">override</span> </span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="comment">//写入数据</span></span><br><span class="line">            _ofs.<span class="built_in">write</span>((<span class="type">const</span> <span class="type">char</span>*)data,len);</span><br><span class="line">            <span class="keyword">if</span>(_ofs.<span class="built_in">good</span>() == <span class="literal">false</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//文件流状态异常</span></span><br><span class="line">                std::cout&lt;&lt;<span class="string">&quot;日志输出文件失败!\n&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        std::string _filename;<span class="comment">//文件路径</span></span><br><span class="line">        std::ofstream _ofs;<span class="comment">//文件输出流</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//滚动文件落地类</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">RollSink</span>:<span class="keyword">public</span> LogSink</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">using</span> ptr = std::shared_ptr&lt;RollSink&gt;;</span><br><span class="line">        <span class="comment">//实际文件名 = bsename + 可变部分</span></span><br><span class="line">        <span class="built_in">RollSink</span>(<span class="type">const</span> std::string&amp; basename,<span class="type">size_t</span> max_size)</span><br><span class="line">        :_basename(basename),_max_fsize(max_size),_cur_fsize(<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//创建目录</span></span><br><span class="line">            util::file::<span class="built_in">create_directory</span>(util::file::<span class="built_in">path</span>(_basename));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*data,<span class="type">size_t</span> len)</span> <span class="keyword">override</span> </span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="built_in">initLogFile</span>();<span class="comment">//初始化输出文件和文件输出流</span></span><br><span class="line">            _ofs.<span class="built_in">write</span>(data,len);<span class="comment">//写入数据</span></span><br><span class="line">            <span class="keyword">if</span>(_ofs.<span class="built_in">good</span>() == <span class="literal">false</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                std::cout&lt;&lt;<span class="string">&quot;日志输出文件失败!\n&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            _cur_fsize += len;<span class="comment">//更新文件大小</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">initLogFile</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="comment">//如果满足条件，触发创建新文件的条件</span></span><br><span class="line">            <span class="keyword">if</span>(_ofs.<span class="built_in">is_open</span>() == <span class="literal">false</span> || _cur_fsize &gt;=_max_fsize)</span><br><span class="line">            &#123;</span><br><span class="line">                _ofs.<span class="built_in">close</span>();<span class="comment">//先关闭原有文件流</span></span><br><span class="line">                <span class="keyword">if</span>(_cur_fsize &gt;=_max_fsize) <span class="built_in">sleep</span>(<span class="number">1</span>);<span class="comment">//防止同一秒有过多日志消息要打印，导致打开同一个日志文件</span></span><br><span class="line">                std::string name = <span class="built_in">createFilename</span>();</span><br><span class="line">                _ofs.<span class="built_in">open</span>(name,std::ios::binary | std::ios::app);</span><br><span class="line">                <span class="built_in">assert</span>(_ofs.<span class="built_in">is_open</span>());</span><br><span class="line">                _cur_fsize = <span class="number">0</span>;<span class="comment">//创建新文件后，重置文件大小</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//封装产生文件名的函数</span></span><br><span class="line">        <span class="function">std::string <span class="title">createFilename</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="comment">//这里采用的格式为</span></span><br><span class="line">            <span class="comment">// basename + 年月日 + .log</span></span><br><span class="line">            <span class="type">time_t</span> t = <span class="built_in">time</span>(<span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">struct</span> <span class="title class_">tm</span> lt;</span><br><span class="line">            <span class="built_in">localtime_r</span>(&amp;t,&amp;lt);</span><br><span class="line">            std::stringstream ss;</span><br><span class="line">            <span class="comment">//获取详细时间信息</span></span><br><span class="line">            ss &lt;&lt; _basename;</span><br><span class="line">            ss&lt;&lt; lt.tm_year + <span class="number">1900</span>;</span><br><span class="line">            ss &lt;&lt;lt.tm_mon + <span class="number">1</span>;</span><br><span class="line">            ss &lt;&lt; lt.tm_mday;</span><br><span class="line">            ss &lt;&lt; lt.tm_hour;</span><br><span class="line">            ss &lt;&lt; lt.tm_min;</span><br><span class="line">            ss &lt;&lt; lt.tm_sec;</span><br><span class="line">            ss &lt;&lt; <span class="string">&quot;.log&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> ss.<span class="built_in">str</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        std::string _basename;<span class="comment">//基础文件名</span></span><br><span class="line">        std::ofstream _ofs;<span class="comment">//输出用的文件输出流</span></span><br><span class="line">        <span class="type">size_t</span> _max_fsize;<span class="comment">//文件最大容量</span></span><br><span class="line">        <span class="type">size_t</span> _cur_fsize;<span class="comment">//当前输出文件的使用量</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建简单工厂</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">SinkFactory</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">//可变参数列表里储存了构造函数所需的所有参数</span></span><br><span class="line">        <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> SinkType,<span class="keyword">typename</span> ...Args&gt;</span></span><br><span class="line"><span class="function">        <span class="type">static</span> LogSink::ptr <span class="title">create</span><span class="params">(Args&amp;&amp;...args)</span></span>&#123;</span><br><span class="line">            <span class="comment">//返回shared_ptr,传的是构造函数参数列表</span></span><br><span class="line">            <span class="keyword">return</span> std::<span class="built_in">make_shared</span>&lt;SinkType&gt;(std::forward&lt;Args&gt;(args)...);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="日志类"><a href="#日志类" class="headerlink" title="日志类"></a>日志类</h1><ul><li>为更多接口添加功能描述</li><li>使用注释为代码分块</li><li>调整接口函数的括号位置，使格式统一</li><li>为<code>void</code>函数添加<code>return</code>，标记函数结尾</li></ul><h2 id="补丁"><a href="#补丁" class="headerlink" title="补丁"></a>补丁</h2><p>内部的<code>Build</code>类未提供清空<code>_sinks</code>的接口,遂添加<code>clearSink</code>接口</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">//清空落地类列表</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clearSink</span><span class="params">()</span></span>&#123;</span><br><span class="line">        _sinks.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="修改后的代码"><a href="#修改后的代码" class="headerlink" title="修改后的代码"></a>修改后的代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;util.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;level.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;message.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;formatter.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sink.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;looper.hpp&quot;</span><span class="comment">//不认识？没关系</span></span></span><br><span class="line">                    <span class="comment">//这个头文件后面才实现,给异步日志器的实现用的</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdarg&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> suplog&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Logger</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">//类内枚举日志器的类型</span></span><br><span class="line">        <span class="keyword">enum class</span> <span class="title class_">Type</span>&#123;</span><br><span class="line">            LOGGER_SYNC = <span class="number">0</span>,</span><br><span class="line">            LOGGER_ASYNC</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">using</span> ptr = std::shared_ptr&lt;Logger&gt;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">Logger</span>(<span class="type">const</span> std::string&amp; name,</span><br><span class="line">            Formatter::ptr formatter,</span><br><span class="line">            std::vector&lt;LogSink::ptr&gt; &amp;sinks,</span><br><span class="line">            LogLevel::Level level = LogLevel::Level::DEBUG</span><br><span class="line">        ):_name(name),_level(level),_formatter(formatter),</span><br><span class="line">        _sinks(sinks.<span class="built_in">begin</span>(),sinks.<span class="built_in">end</span>())</span><br><span class="line">        &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">std::string <span class="title">loggerName</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> _name; &#125;<span class="comment">//获取日志器名称</span></span><br><span class="line">        <span class="function">LogLevel::Level <span class="title">loggerLevel</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> _level; &#125;<span class="comment">//获取日志器等级</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用C语言风格的不定参数输出日志</span></span><br><span class="line">        <span class="comment">//接口log位于protected访问限定符下</span></span><br><span class="line">        <span class="comment">//=========start========</span></span><br><span class="line">        <span class="comment">//各个接口的主要差别在于日志等级不同</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">debug</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*file,<span class="type">size_t</span> line,<span class="type">const</span> <span class="type">char</span>*fmt,...)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">shouldLog</span>(LogLevel::Level::DEBUG) == <span class="literal">false</span>)<span class="comment">//如果等级不满足日志器最低要求</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            va_list al;</span><br><span class="line">            <span class="built_in">va_start</span>(al,fmt);<span class="comment">//依据fmt从内存中提取可变参数列表</span></span><br><span class="line">            <span class="built_in">log</span>(LogLevel::Level::DEBUG,file,line,fmt,al);<span class="comment">//日志输出,al向函数传递可变参数列表</span></span><br><span class="line">            <span class="built_in">va_end</span>(al);<span class="comment">//结束可变参数列表</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">info</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*file,<span class="type">size_t</span> line,<span class="type">const</span> <span class="type">char</span>*fmt,...)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">shouldLog</span>(LogLevel::Level::INFO) == <span class="literal">false</span>)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            va_list al;</span><br><span class="line">            <span class="built_in">va_start</span>(al,fmt);<span class="comment">//依据fmt从内存中提取可变参数列表</span></span><br><span class="line">            <span class="built_in">log</span>(LogLevel::Level::INFO,file,line,fmt,al);<span class="comment">//日志输出</span></span><br><span class="line">            <span class="built_in">va_end</span>(al);<span class="comment">//结束可变参数列表</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">warn</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*file,<span class="type">size_t</span> line,<span class="type">const</span> <span class="type">char</span>*fmt,...)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">shouldLog</span>(LogLevel::Level::WARN) == <span class="literal">false</span>)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            va_list al;</span><br><span class="line">            <span class="built_in">va_start</span>(al,fmt);<span class="comment">//依据fmt从内存中提取可变参数列表</span></span><br><span class="line">            <span class="built_in">log</span>(LogLevel::Level::WARN,file,line,fmt,al);<span class="comment">//日志输出</span></span><br><span class="line">            <span class="built_in">va_end</span>(al);<span class="comment">//结束可变参数列表</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">error</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*file,<span class="type">size_t</span> line,<span class="type">const</span> <span class="type">char</span>*fmt,...)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">shouldLog</span>(LogLevel::Level::ERROR) == <span class="literal">false</span>)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            va_list al;</span><br><span class="line">            <span class="built_in">va_start</span>(al,fmt);<span class="comment">//依据fmt从内存中提取可变参数列表</span></span><br><span class="line">            <span class="built_in">log</span>(LogLevel::Level::WARN,file,line,fmt,al);<span class="comment">//日志输出</span></span><br><span class="line">            <span class="built_in">va_end</span>(al);<span class="comment">//结束可变参数列表</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">fatal</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*file,<span class="type">size_t</span> line,<span class="type">const</span> <span class="type">char</span>*fmt,...)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">shouldLog</span>(LogLevel::Level::FATAL) == <span class="literal">false</span>)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            va_list al;</span><br><span class="line">            <span class="built_in">va_start</span>(al,fmt);<span class="comment">//依据fmt从内存中提取可变参数列表</span></span><br><span class="line">            <span class="built_in">log</span>(LogLevel::Level::FATAL,file,line,fmt,al);<span class="comment">//日志输出</span></span><br><span class="line">            <span class="built_in">va_end</span>(al);<span class="comment">//结束可变参数列表</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//===============end===============</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">//在内部声明一个建造者抽象类</span></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Builder</span></span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="keyword">using</span> ptr = std::shared_ptr&lt;Builder&gt;;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">Builder</span>():_level(LogLevel::Level::DEBUG),</span><br><span class="line">                _logger_type(Logger::Type::LOGGER_SYNC)</span><br><span class="line">            &#123;&#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//默认支持以下接口</span></span><br><span class="line">            <span class="comment">//======start======//</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//设置日志器名称</span></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">buildLoggerName</span><span class="params">(<span class="type">const</span> std::string&amp; name)</span></span>&#123; </span><br><span class="line">                _logger_name = name;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//设置日志器等级</span></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">buildLoggerLevel</span><span class="params">(LogLevel::Level level)</span></span>&#123; </span><br><span class="line">                _level = level;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//设置日志器类型</span></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">buildLoggerType</span><span class="params">(Logger::Type type)</span></span>&#123;</span><br><span class="line">                _logger_type = type;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//设置日志器格式串</span></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">buidFormatter</span><span class="params">(<span class="type">const</span> Formatter::ptr&amp; formatter)</span></span>&#123;</span><br><span class="line">                _formatter = formatter;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//设置日志器格式串-函数重载</span></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">buidFormatter</span><span class="params">(<span class="type">const</span> std::string&amp; formatStr)</span></span>&#123;</span><br><span class="line">                <span class="keyword">auto</span> formatter = std::<span class="built_in">make_shared</span>&lt;suplog::Formatter&gt;(formatStr);</span><br><span class="line">                _formatter = formatter;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//C++风格不定参数</span></span><br><span class="line">            <span class="comment">//增加落地类</span></span><br><span class="line">            <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> SinkType,<span class="keyword">typename</span> ...Args&gt;</span></span><br><span class="line"><span class="function">            <span class="type">void</span> <span class="title">buildSink</span><span class="params">(Args &amp;&amp;...args)</span></span>&#123;</span><br><span class="line">                <span class="keyword">auto</span> sink = SinkFactory::<span class="built_in">create</span>&lt;SinkType&gt;(std::forward&lt;Args&gt;(args)...);</span><br><span class="line">                _sinks.<span class="built_in">push_back</span>(sink);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//清空落地类列表</span></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">clearSink</span><span class="params">()</span></span>&#123;</span><br><span class="line">                _sinks.<span class="built_in">clear</span>();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//======end======//</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//声明抽象接口build，具体实现交给派生类</span></span><br><span class="line">            <span class="function"><span class="keyword">virtual</span> Logger::ptr <span class="title">build</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">protected</span>:</span><br><span class="line">            Logger::Type _logger_type;</span><br><span class="line">            std::string _logger_name;</span><br><span class="line">            LogLevel::Level _level;</span><br><span class="line">            Formatter::ptr _formatter;</span><br><span class="line">            std::vector&lt;LogSink::ptr&gt; _sinks;</span><br><span class="line">        &#125;;<span class="comment">//=====Build类声明定义结束=======</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//回到Logger类</span></span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">//根据日志等级，判断是否应该日志输出</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">shouldLog</span><span class="params">(LogLevel::Level level)</span></span>&#123; <span class="keyword">return</span> level &gt;= _level; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(LogLevel::Level level,<span class="type">const</span> <span class="type">char</span>*file,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">size_t</span> line,<span class="type">const</span> <span class="type">char</span>*fmt,va_list al)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">char</span> *buf;<span class="comment">//可以不初始化</span></span><br><span class="line">        std::string msg;</span><br><span class="line">        <span class="comment">//将格式化串和可变参数列表生成字符串，并存入buf指向的内存</span></span><br><span class="line">        <span class="type">int</span> len = <span class="built_in">vasprintf</span>(&amp;buf,fmt,al);<span class="comment">//自动在堆区申请内存</span></span><br><span class="line">        <span class="keyword">if</span>(len &lt; <span class="number">0</span>)</span><br><span class="line">            msg = <span class="string">&quot;格式化日志消息失败!!&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            msg.<span class="built_in">assign</span>(buf,len);<span class="comment">//转存到msg对象中</span></span><br><span class="line">            <span class="built_in">free</span>(buf);<span class="comment">//释放空间</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//LogMsg(name, file, line, payload, level)</span></span><br><span class="line">        <span class="function">LogMsg <span class="title">logmsg</span><span class="params">(_name,file,line,std::move(msg),level)</span></span>;<span class="comment">//使用了拷贝构造</span></span><br><span class="line">        std::string str;</span><br><span class="line">        <span class="comment">//使用logmsg获取输出字符串/输出任务</span></span><br><span class="line">        str = _formatter-&gt;format(logmsg);</span><br><span class="line">        <span class="built_in">logIt</span>(std::<span class="built_in">move</span>(str));<span class="comment">//真正开始执行输出任务。如何调用落地类由派生类具体实现</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//交给派生类实现</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">logIt</span><span class="params">(<span class="type">const</span> std::string &amp;msg)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        std::mutex _mutex;<span class="comment">//为多线程环境提前准互斥量</span></span><br><span class="line">        std::string _name;</span><br><span class="line">        Formatter::ptr _formatter;</span><br><span class="line">        std::atomic&lt;LogLevel::Level&gt; _level;<span class="comment">//使用atomic使_level的修改操作原子化</span></span><br><span class="line">        std::vector&lt;LogSink::ptr&gt; _sinks; </span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><h2 id="同步日志器类"><a href="#同步日志器类" class="headerlink" title="同步日志器类"></a>同步日志器类</h2><ul><li>增加注释和调整函数结构</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//同步日志器</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">SyncLogger</span>:<span class="keyword">public</span> Logger</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">using</span> ptr = std::shared_ptr&lt;SyncLogger&gt;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">SyncLogger</span>(<span class="type">const</span> std::string&amp; name,</span><br><span class="line">            Formatter::ptr formatter,</span><br><span class="line">            std::vector&lt;LogSink::ptr&gt;&amp;sinks,</span><br><span class="line">            LogLevel::Level level = LogLevel::Level::DEBUG)</span><br><span class="line">            :<span class="built_in">Logger</span>(name,formatter,sinks,level)</span><br><span class="line">            &#123;</span><br><span class="line">                std::cout &lt;&lt; LogLevel::<span class="built_in">toString</span>(level)&lt;&lt;<span class="string">&quot;同步日志器创建成功...\n&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">logIt</span><span class="params">(<span class="type">const</span> std::string&amp; msg_str)</span><span class="keyword">override</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                 <span class="comment">// lock 的析构函数在离开作用域时自动释放互斥锁</span></span><br><span class="line">                <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(_mutex)</span></span>;</span><br><span class="line">                <span class="keyword">if</span>(_sinks.<span class="built_in">empty</span>()) &#123; <span class="keyword">return</span>; &#125;<span class="comment">//没有落地方向</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//每个落地方向都输出一次</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;it:_sinks)</span><br><span class="line">                    it-&gt;<span class="built_in">log</span>(msg_str.<span class="built_in">c_str</span>(),msg_str.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><h2 id="本地日志器建造者类"><a href="#本地日志器建造者类" class="headerlink" title="本地日志器建造者类"></a>本地日志器建造者类</h2><ul><li>增加注释</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//本地日志器建造者</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">LocalLoggerBuilder</span>:<span class="keyword">public</span> Logger::Builder</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> Logger::ptr <span class="title">build</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="comment">//检测名称是否存在</span></span><br><span class="line">            <span class="keyword">if</span>(_logger_name.<span class="built_in">empty</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                std::cout&lt;&lt;<span class="string">&quot;日志器名称不能为空！！&quot;</span>;</span><br><span class="line">                <span class="built_in">abort</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//检测格式串</span></span><br><span class="line">            <span class="keyword">if</span>(_formatter.<span class="built_in">get</span>() == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                std::cout&lt;&lt;<span class="string">&quot;当前日志器： &quot;</span>&lt;&lt;_logger_name;</span><br><span class="line">                std::cout&lt;&lt;<span class="string">&quot; 未检测到⽇志格式,默认设置为: &quot;</span>;</span><br><span class="line">                std::cout&lt;&lt;<span class="string">&quot; %d&#123;%H:%M:%S&#125;%T%t%T[%p]%T[%c]%T%f:%l%T%m%n\n&quot;</span>;</span><br><span class="line">                _formatter = std::<span class="built_in">make_shared</span>&lt;Formatter&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//检测是否存在落地方向</span></span><br><span class="line">            <span class="keyword">if</span>(_sinks.<span class="built_in">empty</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                std::cout&lt;&lt;<span class="string">&quot;当前日志器: &quot;</span>&lt;&lt;_logger_name&lt;&lt;<span class="string">&quot;问检测到落地方向，默认为标准输出!\n&quot;</span>;</span><br><span class="line">                _sinks.<span class="built_in">push_back</span>(std::<span class="built_in">make_shared</span>&lt;StdoutSink&gt;());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Logger::ptr lp;<span class="comment">//使用多态</span></span><br><span class="line">            <span class="keyword">if</span>(_logger_type == Logger::Type::LOGGER_ASYNC)</span><br><span class="line">            &#123;</span><br><span class="line">                lp = std::<span class="built_in">make_shared</span>&lt;AsyncLogger&gt;(_logger_name,_formatter,_sinks,_level);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                lp = std::<span class="built_in">make_shared</span>&lt;SyncLogger&gt;(_logger_name,_formatter,_sinks,_level);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> lp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><h1 id="双缓冲区异步任务处理器"><a href="#双缓冲区异步任务处理器" class="headerlink" title="双缓冲区异步任务处理器"></a>双缓冲区异步任务处理器</h1><h2 id="Buffer类"><a href="#Buffer类" class="headerlink" title="Buffer类"></a>Buffer类</h2><ul><li>增加注释</li><li>调整函数结构</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> suplog</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置Buffer的一些基本参数</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_DEFUALT_SIZE (1*1024*1024)      <span class="comment">//缓冲区默认大小</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_INCREMENT_SIZE (1*1024*1024)    <span class="comment">//缓冲区默认扩展大小</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_THRESHOLD_SIZE (10*1024*1024)   <span class="comment">//缓冲区最大值</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Buffer</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Buffer</span>():_reader_idx(<span class="number">0</span>),_writer_idx(<span class="number">0</span>),_v(BUFFER_DEFUALT_SIZE)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> _reader_idx == _writer_idx; &#125;        <span class="comment">//判空</span></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">readAbleSize</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> _writer_idx - _reader_idx; &#125;<span class="comment">//是否可读</span></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">writeAbleSize</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> _v.<span class="built_in">size</span>() - _writer_idx; &#125; <span class="comment">//是否可写</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">()</span></span>&#123; _reader_idx = _writer_idx = <span class="number">0</span>; &#125;  <span class="comment">//重置读写指针</span></span><br><span class="line">    <span class="comment">//交换缓冲区</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(Buffer&amp; buf)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _v.<span class="built_in">swap</span>(buf._v);</span><br><span class="line">        std::<span class="built_in">swap</span>(_reader_idx,buf._reader_idx);</span><br><span class="line">        std::<span class="built_in">swap</span>(_writer_idx,buf._writer_idx);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//向缓冲区推送数据</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*data,<span class="type">size_t</span> len)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">ensureEnoughSpace</span>(len);</span><br><span class="line">        <span class="built_in">assert</span>(len&lt;=<span class="built_in">writeAbleSize</span>());</span><br><span class="line">        std::<span class="built_in">copy</span>(data,data+len,&amp;_v[_writer_idx]);</span><br><span class="line">        _writer_idx+=len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//缓冲区删除定长数据</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">(<span class="type">size_t</span> len)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _reader_idx +=len;</span><br><span class="line">        <span class="built_in">assert</span>(_reader_idx &lt;=_writer_idx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">begin</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//获取起始地址 </span></span><br><span class="line">        <span class="keyword">return</span> &amp;_v[_reader_idx]; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ensureEnoughSpace</span><span class="params">(<span class="type">size_t</span> len)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//如果写的下,则退出</span></span><br><span class="line">        <span class="keyword">if</span>(len &lt;=<span class="built_in">writeAbleSize</span>())<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">size_t</span> new_capacity;</span><br><span class="line">        <span class="comment">//每次增加1M的大小</span></span><br><span class="line">        <span class="keyword">if</span>(_v.<span class="built_in">size</span>() &lt; BUFFER_THRESHOLD_SIZE)</span><br><span class="line">            new_capacity = _v.<span class="built_in">size</span>()*<span class="number">2</span>+len;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            new_capacity = _v.<span class="built_in">size</span>() + BUFFER_INCREMENT_SIZE + len;</span><br><span class="line"></span><br><span class="line">        _v.<span class="built_in">resize</span>(new_capacity);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">size_t</span> _reader_idx;</span><br><span class="line">    <span class="type">size_t</span> _writer_idx;</span><br><span class="line">    std::vector&lt;<span class="type">char</span>&gt; _v;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AsyncLooper-类"><a href="#AsyncLooper-类" class="headerlink" title="AsyncLooper 类"></a>AsyncLooper 类</h2><ul><li>增加注释</li><li>修改变量名<code>al</code>为<code>alooper</code>，防止与之前出现过的变量发生含义混淆，影响代码理解</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;util.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;buffer.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> suplog</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">AsyncLooper</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">using</span> ptr = std::shared_ptr&lt;AsyncLooper&gt;;</span><br><span class="line">        <span class="keyword">using</span> Functor = std::function&lt;<span class="built_in">void</span>(Buffer &amp;buffer)&gt;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">AsyncLooper</span>(<span class="type">const</span> Functor&amp;cb)</span><br><span class="line">        : _running(<span class="literal">true</span>),</span><br><span class="line">        _looper_callback(cb),</span><br><span class="line">        _thread(std::<span class="built_in">thread</span>(&amp;AsyncLooper::worker_loop,<span class="keyword">this</span>))<span class="comment">//在构造函数中启动线程</span></span><br><span class="line">        &#123;&#125;</span><br><span class="line"></span><br><span class="line">        ~<span class="built_in">AsyncLooper</span>()&#123; <span class="built_in">stop</span>(); &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">stop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            _running =<span class="literal">false</span>;</span><br><span class="line">            _pop_cond.<span class="built_in">notify_all</span>();<span class="comment">//将所有线程的条件变量等待唤醒</span></span><br><span class="line">            _thread.<span class="built_in">join</span>();<span class="comment">//接收子进程</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//推送任务</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> std::string&amp;msg)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(_running == <span class="literal">false</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(_mutex)</span></span>;<span class="comment">//加锁</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//等待条件</span></span><br><span class="line">            _push_cond.<span class="built_in">wait</span>(lock,[&amp;]&#123;</span><br><span class="line">                <span class="keyword">return</span> _tasks_push.<span class="built_in">writeAbleSize</span>() &gt;= msg.<span class="built_in">size</span>();</span><br><span class="line">            &#125;);<span class="comment">//防止消息过大</span></span><br><span class="line"></span><br><span class="line">            _tasks_push.<span class="built_in">push</span>(msg.<span class="built_in">c_str</span>(),msg.<span class="built_in">size</span>());<span class="comment">//完成消息任务推送</span></span><br><span class="line"></span><br><span class="line">            _pop_cond.<span class="built_in">notify_all</span>();<span class="comment">//唤醒所有消费者</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="comment">//子线程的入口函数</span></span><br><span class="line">        <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">worker_loop</span><span class="params">(<span class="type">void</span>* arg)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="comment">//多线程执行函数得靠arg传递this指针</span></span><br><span class="line">            AsyncLooper* alooper = (AsyncLooper* )arg;</span><br><span class="line">            <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                 <span class="comment">// lock 的析构函数在离开作用域时(完成一趟循环)自动释放互斥锁</span></span><br><span class="line">                <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(alooper-&gt;_mutex)</span></span>;</span><br><span class="line">                <span class="comment">//线程出口,为空或关闭时退出循环</span></span><br><span class="line">                <span class="keyword">if</span>(alooper-&gt;_running == <span class="literal">false</span> &amp;&amp; alooper-&gt;_tasks_push.<span class="built_in">empty</span>())</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//生产者缓冲不为空或者停止运行时才会被唤醒</span></span><br><span class="line">                alooper-&gt;_pop_cond.<span class="built_in">wait</span>(lock,[&amp;]&#123;</span><br><span class="line">                    <span class="keyword">return</span> !alooper-&gt;_tasks_push.<span class="built_in">empty</span>() || !alooper-&gt;_running;</span><br><span class="line">                &#125;);</span><br><span class="line">                alooper-&gt;_tasks_push.<span class="built_in">swap</span>(alooper-&gt;_tasks_pop);<span class="comment">//交换缓冲区</span></span><br><span class="line"></span><br><span class="line">                alooper-&gt;_push_cond.<span class="built_in">notify_all</span>();<span class="comment">//唤醒所有生产者缓冲区</span></span><br><span class="line">                alooper-&gt;_looper_callback(alooper-&gt;_tasks_pop);<span class="comment">//调用回调函数，输出消费者缓冲区</span></span><br><span class="line">                <span class="comment">//输出完成，清空缓冲区</span></span><br><span class="line">                alooper-&gt;_tasks_pop.<span class="built_in">reset</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        Functor _looper_callback;<span class="comment">//输出缓冲区内容的回调函数</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        std::mutex _mutex;<span class="comment">//互斥锁</span></span><br><span class="line">        std::atomic&lt;<span class="type">bool</span>&gt; _running;<span class="comment">//能够原子地赋值状态指示</span></span><br><span class="line">        std::condition_variable _push_cond;<span class="comment">//生产者条件变量</span></span><br><span class="line">        std::condition_variable _pop_cond;<span class="comment">//消费者条件变量</span></span><br><span class="line">        Buffer _tasks_push;<span class="comment">//双缓冲区</span></span><br><span class="line">        Buffer _tasks_pop;</span><br><span class="line">        std::thread _thread;<span class="comment">//主线程管理子线程类用的</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="异步日志器"><a href="#异步日志器" class="headerlink" title="异步日志器"></a>异步日志器</h2><ul><li>增加注释</li><li>增加<code>return</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//异步日志器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AsyncLogger</span>:<span class="keyword">public</span> Logger</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> ptr = std::shared_ptr&lt;AsyncLogger&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">AsyncLogger</span>(<span class="type">const</span> std::string&amp; name,</span><br><span class="line">        Formatter::ptr formatter,</span><br><span class="line">        std::vector&lt;LogSink::ptr&gt;&amp;sinks,</span><br><span class="line">        LogLevel::Level level = LogLevel::Level::DEBUG)</span><br><span class="line">        :<span class="built_in">Logger</span>(name,formatter,sinks,level)</span><br><span class="line">        ,_looper(std::<span class="built_in">make_shared</span>&lt;AsyncLooper&gt;(</span><br><span class="line">            std::<span class="built_in">bind</span>(&amp;AsyncLogger::readLog,<span class="keyword">this</span>,std::placeholders::_1)))</span><br><span class="line">            <span class="comment">//传一个this,使包装器里的函数能够是成员函数,this后面的才是包装器指定的参数</span></span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; LogLevel::<span class="built_in">toString</span>(level)&lt;&lt;<span class="string">&quot;异步日志器创建成功...\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">logIt</span><span class="params">(<span class="type">const</span> std::string &amp;msg)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _looper-&gt;<span class="built_in">push</span>(msg);<span class="comment">//推送消息</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//_looper所用的回调函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">readLog</span><span class="params">(Buffer&amp; msg)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(_sinks.<span class="built_in">empty</span>())&#123; <span class="keyword">return</span>; &#125;<span class="comment">//判空</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;it:_sinks)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//调用落地功能</span></span><br><span class="line">            it-&gt;<span class="built_in">log</span>(msg.<span class="built_in">begin</span>(),msg.<span class="built_in">readAbleSize</span>());<span class="comment">//直接一次性输出所有缓存的日志</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    AsyncLooper::ptr _looper;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="单例日志器管理类"><a href="#单例日志器管理类" class="headerlink" title="单例日志器管理类"></a>单例日志器管理类</h1><ul><li>基本没有改动</li></ul><h1 id="全局日志建造者"><a href="#全局日志建造者" class="headerlink" title="全局日志建造者"></a>全局日志建造者</h1><ul><li>基本没有改动</li></ul><h1 id="suplog-hpp"><a href="#suplog-hpp" class="headerlink" title="suplog.hpp"></a>suplog.hpp</h1><ul><li>无变化</li></ul><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>这次整理代码，一方面是增加了其可读性，使其看起来更优雅，更整齐，另一方面也是再一次加深对项目的理解，顺便还能勘误 👆🤓</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>初识Linux套接字(socket)和TCP/UDP协议</title>
      <link href="/2024/10/08/LinuxSocket/"/>
      <url>/2024/10/08/LinuxSocket/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这是系列博客中的第二篇,导航如下</p><ul><li><a href="https://www.supdriver.top/2024/09/23/network/">初识计算机网络🔗</a></li><li><a href="https://www.supdriver.top/2024/10/08/LinuxSocket/">初识Linux套接字(socket)和TCP&#x2F;UDP协议🔗</a> 👈<em>您在这里</em></li></ul></blockquote><p>在Linux环境中，套接字（Socket）是一种用于<code>进程间通信</code>（IPC）的机制，但这里的进程，包括了同一网络下<strong>其它主机的进程</strong>，所以它被广泛应用于网络编程。它允许不同计算机上的进程或同一计算机上的不同进程之间进行数据交换。</p><p>由于此时我们的网络编程基础较少，所以本文的内容更<strong>偏向于实践</strong>,而不是原理。希望能在动手实践中加深对网络编程的熟悉程度，减少陌生感</p><p>在本文中，我们将：</p><ul><li><code>知识铺垫</code>:认识IP地址, 端口号, 网络字节序等网络编程中的基本概念（简略）</li><li><code>socket API学习</code></li><li>实现一个简单的UPD<code>客户端</code>&#x2F;<code>服务器</code></li><li>实现一个简单的TCP<code>客户端</code>&#x2F;<code>服务器</code>（服务器包括单连接版本，多进程版本，多线程版本）</li></ul><h1 id="知识铺垫"><a href="#知识铺垫" class="headerlink" title="知识铺垫"></a>知识铺垫</h1><h2 id="理解源IP地址和目的IP地址"><a href="#理解源IP地址和目的IP地址" class="headerlink" title="理解源IP地址和目的IP地址"></a>理解源IP地址和目的IP地址</h2><p>在数据包的头部中，包含两个IP地址，分别叫做<code>源IP地址</code>和<code>目的IP地址</code></p><p>为什么要有两个IP地址？因为一般<code>通过网络</code>建立的通信都是<strong>双向的</strong>,而且一方接收请求后，一般还要把响应<strong>发送回去</strong>，所以含有两个IP地址才能方便地建立双向链接和通信。而且数据包每经过一个中间主机，都会被询问一次源和目的，就像唐僧常说的口头禅：“贫僧自<code>东土大唐(源IP)</code>而来，要到<code>西天(目的IP)</code>取经去”。</p><p><audio src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/TangSen.mp3">Audio</audio></p><p>总结：通过<code>IP协议</code>，我们能找到<strong>唯一的主机</strong>建立网络通信。</p><h2 id="认识端口号"><a href="#认识端口号" class="headerlink" title="认识端口号"></a>认识端口号</h2><p>套接字（Socket）是一种用于<code>进程间通信</code>（IPC）的机制,然而<code>IP协议</code>只能指定唯一主机，想要进程间通信明显还不够。那在一台主机上，怎么标识唯一的进程呢？<code>端口号(port)</code>应运而生。</p><ul><li>端口号是一个2字节<strong>16位的整数</strong></li><li>正如上文所说，端口号用来标识本机的唯一进程</li><li><code>互斥性</code>:为保证唯一性，一个端口号只能被一个进程占用</li></ul><p>综上，通过<code>IP地址</code>+<code>端口号</code>便能够唯一地表示网络上的某一台主机的某一个进程。</p><h3 id="端口号-与-进程ID-辨析"><a href="#端口号-与-进程ID-辨析" class="headerlink" title="端口号 与 进程ID 辨析"></a>端口号 与 进程ID 辨析</h3><p>既然<code>端口号port</code>和<code>进程ID</code>都可以唯一地标识一个进程，那么这两者有何相似与差异呢?</p><ul><li><code>进程ID</code>:一个线程对应一个<code>pid</code>,一个<code>pid</code>对应一个线程，且操作系统就是用<code>pid</code>来调度线程的</li><li><code>端口(port)</code>:端口号更像是一种被所有线程共享的互斥资源，每个都只有一份，但是同一个线程可以申请占用多个端口号，而一个端口号因为只有一份，只能被一个线程占用</li></ul><h2 id="源端口号和目的端口号"><a href="#源端口号和目的端口号" class="headerlink" title="源端口号和目的端口号"></a>源端口号和目的端口号</h2><p>和源IP地址和目的IP地址配套使用，用于建立两台主机上特定的两个线程间的通信。</p><h2 id="认识TCP协议和UDP协议"><a href="#认识TCP协议和UDP协议" class="headerlink" title="认识TCP协议和UDP协议"></a>认识TCP协议和UDP协议</h2><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202410090913657.png"></p><p>这里仅仅是有一个大概的了解，对协议原理更详细的较少将在后面的博客中提出</p><h3 id="TPC协议"><a href="#TPC协议" class="headerlink" title="TPC协议"></a>TPC协议</h3><p>TCP(Transmission Control Protocol)是一种可靠的传输协议，特性如下</p><ul><li>传输层协议</li><li>有连接</li><li>可靠传输</li><li>面向字节流</li></ul><h3 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h3><p>UDP(User Datagram Protocol)是一种不可靠的传输协议，特性如下</p><ul><li>传输层协议</li><li>无连接</li><li>不可靠传输</li><li>面向数据报</li></ul><h2 id="网络字节序"><a href="#网络字节序" class="headerlink" title="网络字节序"></a>网络字节序</h2><p>我们已经知道,内存中的多字节数据相对于内存地址有大端和小端之分, 磁盘文件中的多字节数据相对于文件中的偏移地址也有大端小端之分,<br><strong>网络数据流同样有大端小端之分</strong>,这给网络中不同主机的通信带来了困难， 那么如何定义网络数据流的地址，以保证不同机器能通过网络通信呢？</p><blockquote><ul><li>发送主机通常将发送缓冲区中的数据按内存地址从低到高的顺序发出</li><li>收主机把从网络上接到的字节依次保存在接收缓冲区中,也是按内存地址从低到高的顺序保存</li><li>因此,网络数据流的地址应这样规定:先发出的数据是低地址,后发出的数据是高地址</li><li>TCP&#x2F;IP协议规定,<strong>网络数据流应采用大端字节序</strong>,即低地址高字节</li><li><strong>不管这台主机是大端机还是小端机</strong>, 都会按照这个TCP&#x2F;IP规定的网络字节序来发送&#x2F;接收数据</li><li>如果当前发送主机是小端, 就需要先将数据转成大端; 否则就忽略, 直接发送即可</li></ul></blockquote><p>关于网络字节序的规则如上，显然这些都由程序员来做，效率还是太低了。</p><p>为了提高编程效率，同时也为了提高代码移植性，使同样的C代码在大端计算机和小端计算机上都能正常运行，可以调用以下头文件的库函数做网络字节序和主机字节序的转换</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">htonl</span><span class="params">(<span class="type">uint32_t</span> hostlong)</span>; <span class="comment">//32位主机host字节序转网络net字节序</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">htons</span><span class="params">(<span class="type">uint16_t</span> hostshort)</span>;<span class="comment">//16位主机host字节序转网络net字节序</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">ntohl</span><span class="params">(<span class="type">uint32_t</span> netlong)</span>;  <span class="comment">//32位网络net字节序转主机host字节序</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">ntohs</span><span class="params">(<span class="type">uint16_t</span> netshort)</span>; <span class="comment">//16位网络net字节序转主机host字节序</span></span><br></pre></td></tr></table></figure><ul><li>这些函数名很好记,<code>h</code>表示<code>host</code>,<code>n</code>表示<code>network</code>,<code>l</code>表示<code>32位长整数</code>,<code>s</code>表示<code>16位短整数</code>。</li><li>例如<code>htons</code>表示将16位的短整数从主机字节序转换为网络字节序,例如将port端口号转换后准备发送</li><li><em>如果主机是小端字节序,这些函数将参数做相应的大小端转换然后返回</em></li><li><em>如果主机是大端字节序,这些 函数不做转换,将参数原封不动地返回。</em></li></ul><h2 id="Socket编程"><a href="#Socket编程" class="headerlink" title="Socket编程"></a>Socket编程</h2><p><code>&lt;sys/socket.h&gt;</code>提供了一系列套接字相关的接口，用于进行网络通信服务</p><p>基于Linux中<code>一切皆文件</code>的祖训，在套接字编程所创建的<code>socket文件</code>，也是作为文件管理的，<code>socket文件</code>也会申请自己的<code>文件描述符</code>,和其它打开的文件一起被管理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span>      </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 socket 文件描述符 (TCP/UDP, 客户端 + 服务器)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span>;</span><br><span class="line"><span class="comment">// 绑定端口号 (TCP/UDP, 服务器) </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">bind</span><span class="params">(<span class="type">int</span> socket, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *address,</span></span><br><span class="line"><span class="params"> <span class="type">socklen_t</span> address_len)</span>;</span><br><span class="line"><span class="comment">// 开始监听socket (TCP, 服务器)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">listen</span><span class="params">(<span class="type">int</span> socket, <span class="type">int</span> backlog)</span>;</span><br><span class="line"><span class="comment">// 接收请求 (TCP, 服务器)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">accept</span><span class="params">(<span class="type">int</span> socket, <span class="keyword">struct</span> sockaddr* address,</span></span><br><span class="line"><span class="params"> <span class="type">socklen_t</span>* address_len)</span>;</span><br><span class="line"><span class="comment">// 建立连接 (TCP, 客户端)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">connect</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr,</span></span><br><span class="line"><span class="params"> <span class="type">socklen_t</span> addrlen)</span>;</span><br></pre></td></tr></table></figure><p>常用接口如上，具体使用方法稍后在代码中展示</p><h2 id="struct-sockaddr-介绍"><a href="#struct-sockaddr-介绍" class="headerlink" title="struct sockaddr*介绍"></a>struct sockaddr*介绍</h2><h3 id="为什么不直接介绍struct-sockaddr"><a href="#为什么不直接介绍struct-sockaddr" class="headerlink" title="为什么不直接介绍struct sockaddr"></a>为什么不直接介绍struct sockaddr</h3><p><strong>struct sockaddr</strong>是个很简单的结构体，具有类似如下的结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">sa_family_t</span> sa_family;</span><br><span class="line">    <span class="type">char</span> sa_data[<span class="number">14</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而实际上在函数里用的也不是<code>struct sockaddr</code>,而是其它成员变量更丰富的结构体</p><p>它<strong>唯一的用处</strong>就是在函数传参时<strong>防止类型不匹配</strong>导致的报错，函数内部如何处理指针指向的内存，取决于<code>sa_family</code>的值。<code>struct sockaddr*</code>指针的作用有点类似于面向对象中<strong>父类指针</strong>在函数传参中的作用</p><p>各种<code>sockaddr_</code>家族</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用ipv4地址</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line">    <span class="type">sa_family_t</span>    sin_family; <span class="comment">// 地址族</span></span><br><span class="line">    <span class="type">in_port_t</span>      sin_port;   <span class="comment">// 端口号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span>   <span class="comment">// IPv4地址</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用ipv6地址</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in6</span> &#123;</span></span><br><span class="line">    <span class="type">sa_family_t</span>     sin6_family; <span class="comment">// 地址族</span></span><br><span class="line">    <span class="type">in_port_t</span>       sin6_port;   <span class="comment">// 端口号</span></span><br><span class="line">    <span class="type">uint32_t</span>        sin6_flowinfo; <span class="comment">// 流信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> <span class="title">sin6_addr</span>;</span>     <span class="comment">// IPv6地址</span></span><br><span class="line">    <span class="type">uint32_t</span>        sin6_scope_id; <span class="comment">// 作用域ID</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于Unix域套接字（IPC通信）</span></span><br><span class="line"><span class="comment">//包含本地文件系统路径</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> &#123;</span></span><br><span class="line">    <span class="type">sa_family_t</span> sun_family; <span class="comment">// 地址族</span></span><br><span class="line">    <span class="type">char</span>        sun_path[<span class="number">108</span>]; <span class="comment">// Unix域套接字路径</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于链路层（如以太网）</span></span><br><span class="line"><span class="comment">//包含物理设备信息和地址。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_ll</span> &#123;</span></span><br><span class="line">    <span class="type">uint16_t</span>   sll_family;   <span class="comment">// 地址族</span></span><br><span class="line">    <span class="type">uint16_t</span>   sll_protocol; <span class="comment">// 协议</span></span><br><span class="line">    <span class="type">int</span>        sll_ifindex;  <span class="comment">// 接口索引</span></span><br><span class="line">    <span class="type">uint16_t</span>   sll_hatype;   <span class="comment">// 硬件类型</span></span><br><span class="line">    <span class="type">uint8_t</span>    sll_pkttype;   <span class="comment">// 数据包类型</span></span><br><span class="line">    <span class="type">uint8_t</span>    sll_halen;     <span class="comment">// 硬件地址长度</span></span><br><span class="line">    <span class="type">uint8_t</span>    sll_addr[<span class="number">8</span>];   <span class="comment">// 源MAC地址</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202410171015633.png"></p><h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><p>接下来的介绍以<code>struct sockaddr_in</code>为例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line">    <span class="type">sa_family_t</span>    sin_family; <span class="comment">// 地址族</span></span><br><span class="line">    <span class="type">in_port_t</span>      sin_port;   <span class="comment">// 端口号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span>   <span class="comment">// IPv4地址</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>struct sockaddr*</code><strong>指向的结构体</strong>的用处对于服务器&#x2F;客户端有所不同</p><ul><li>对服务器提供服务<ul><li>规定提供网络服务的ip格式（ipv4&#x2F;ipv6）</li><li>规定提供网络服务的ip（因为一个电脑可以有多个ip，后文解释）</li><li>规定提供网络服务的端口号值</li></ul></li><li>对服务器连接客户端<ul><li>储存客户端的ip地址</li><li>储存客户端的port端口</li></ul></li><li>对客户端<ul><li>存储网络消息源的信息</li></ul></li></ul><p><strong><code>in_addr</code>的底层结构</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">uint32_t</span> <span class="type">in_addr_t</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="type">in_addr_t</span> s_addr;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p><code>in_addr</code>用来表示一个IPv4的IP地址. 其实就是一个32位的无符号整数;</p><h1 id="UDP通信编程"><a href="#UDP通信编程" class="headerlink" title="UDP通信编程"></a>UDP通信编程</h1><p>使用接口</p><ul><li><code>int socket(int domain, int type, int protocol);</code><ul><li>用于创建套接字文件，获取套接字文件描述符<code>fd</code></li><li><code>domain</code>规定域名通信协议，比如<code>IPV4</code>、<code>IPV6</code>、<code>本地通信协议</code>等</li><li><code>type</code>通信类型，<code>SOCK_DGRAM</code>表示面向<code>数据报</code>,<code>SOCK_STREAM</code>表示面向字节流，以及更多的类型,<strong>UDP通信使用<code>SOCK_DGRAM</code></strong></li><li><code>protocol</code>协议代码，可选内容取决于<code>domain</code>参数，可为<code>0</code></li><li><code>返回值</code>为套接字文件的文件描述符</li></ul></li><li><code>int bind(int sockfd, const struct sockaddr *addr,socklen_t addrlen);</code><ul><li>用于给指定<code>sockfd</code>绑定网络通信协议</li><li><code>sockfd</code>文件描述符</li><li><code>addr</code>就是上面介绍的<code>struct sockaddr</code>的子类</li><li><code>addrlen</code>为<code>addr</code>指向结构体的大小</li><li><code>返回值</code>成功则返回<code>0</code>，失败则返回<code>1</code></li></ul></li><li><code> ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags,struct sockaddr *src_addr, socklen_t *addrlen);</code><ul><li><code>sockfd</code>文件描述符</li><li><code>buf</code>字节串缓冲区，用于存放接收到的字节流</li><li><code>len</code>缓冲区大小，防止越界访问</li><li><code>flags</code>为位图，可以传多个参数。本次介绍不传参，所以传入一个<code>0</code></li><li><code>src_addr</code>指向储存消息源信息的结构体地址</li><li><code>addrlen</code>传入结构体的大小</li></ul></li><li><code>ssize_t sendto(int sockfd, const void *buf, size_t len, int flags,const struct sockaddr *dest_addr, socklen_t addrlen);</code><ul><li><code>sockfd</code>文件描述符</li><li><code>buf</code>字节流缓冲区，用于存放待发送的字节串</li><li><code>len</code>待发送字节串的长度</li><li><code>flags</code>为位图，可以传多个参数。本次介绍不传参，所以传入一个<code>0</code></li><li><code>src_addr</code>指向储存目标信息的结构体地址</li><li><code>addrlen</code>传入结构体的大小</li></ul></li></ul><p>看着接口很多，但其实在UDP协议下这几个接口的关系可以概括为下图：</p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202410181638626.png"></p><p>接下来我们分别编写一下简单的<code>UDP回显服务器</code></p><h2 id="封装UdpServer"><a href="#封装UdpServer" class="headerlink" title="封装UdpServer"></a>封装UdpServer</h2><p>对于服务器，为了方便地进行代码复用等，把UdpServer的相关代码封装在UdpServer类内，并将类的声明和实现储存在<code>udpServer.hpp</code>中</p><h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><blockquote><p>udpServer.hpp</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;strings.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::string defualt_ip = <span class="string">&quot;0.0.0.0&quot;</span>;<span class="comment">//接收任意地址的可用udp数据包-对外提供服务的ip地址</span></span><br><span class="line"><span class="type">uint16_t</span> defualt_port = <span class="number">25565</span>; <span class="comment">//硬编码一个使用端口号</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> size = <span class="number">1024</span>; <span class="comment">//规定缓冲区大小</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UdpServer</span></span><br><span class="line">&#123;    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">UdpServer</span>(<span class="type">uint16_t</span> port = defualt_port,<span class="type">const</span> std::string&amp; ip = defualt_ip )</span><br><span class="line">        :_port(port),_ip(ip),_isRunning(<span class="literal">false</span>)</span><br><span class="line">    &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">()</span></span>;<span class="comment">//初始化服务器</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询该用户是否已存在</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">CheckUser</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> sockaddr_in&amp; client,<span class="type">const</span> std::string &amp;clientip,<span class="type">uint16_t</span> clientport)</span></span>;</span><br><span class="line">    <span class="comment">//向所有用户广播新的连接用户</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Broadcast</span><span class="params">(<span class="type">const</span> std::string&amp; info,<span class="type">const</span> std::string &amp;clientip,<span class="type">uint16_t</span> clientport)</span></span>;</span><br><span class="line">    <span class="comment">//在主循环中执行主要逻辑</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Run</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">UdpServer</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(_sockfd&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">close</span>(_sockfd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _sockfd;<span class="comment">//储存套接字的文件描述符</span></span><br><span class="line">    <span class="type">bool</span> _isRunning;<span class="comment">//储存运行状态</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint16_t</span> _port; <span class="comment">//储存服务器端口号</span></span><br><span class="line">    std::string _ip;<span class="comment">//储存服务器ip</span></span><br><span class="line">    <span class="comment">//储存所有历史连接过的udp服务器的信息</span></span><br><span class="line">    std::unordered_map&lt;std::string,<span class="keyword">struct</span> sockaddr_in&gt; _ol_usr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一般<code>ip</code>和<code>port</code>都不是硬编码的，但这里只是示例程序，就不做的那么尽善尽美了。</p><p>特别的，当<code>ip == &#39;0.0.0.0&#39;</code>时，服务器会接收发往该服务器上所有可用<code>IP</code>地址的<code>UDP</code>数据包。这里再简单介绍下ip地址的选择(ipv4为例)</p><ul><li>私网ip<ul><li>常见的有192.xxx.xxx.xxx类型的ip地址</li><li>仅能进行私网（局域网）内的网络通信</li></ul></li><li>公网ip<ul><li>在<strong>互联网</strong>中唯一的地址，任何接入互联网的机器都能访问到。</li></ul></li><li>回环地址<ul><li>最常用的是<code>127.0.0.1</code>,回环地址用于网络测试和调试，<strong>代表本地计算机</strong></li></ul></li><li>特殊ip地址,广播地址<code>255.255.255.255</code>，网络地址,如<code>192.168.1.0</code>,不在本次的讨论范围内</li></ul><p><strong>网卡数量与ip的关系:</strong></p><ul><li>单网卡: 如果服务器只有一块网卡，UDP 服务器通常会绑定到该网卡的 IP 地址。这意味着可用的 IP 地址数量为这块网卡的 IP 地址数量。</li><li>多网卡: 如果服务器有多块网卡，每块网卡都可以有一个或多个 IP 地址，UDP 服务器可以选择绑定到任一网卡的 IP 地址。因此，可用的 IP 地址数量将取决于所有网卡上配置的 IP 地址总数。</li></ul><p>可以看到ip地址的关系挺复杂的，所以当出现<strong>服务器公网ip不能用于服务器绑定地址提供服务时，可以选择简化处理，选择0.0.0.0即可</strong></p><h3 id="Init"><a href="#Init" class="headerlink" title="Init()"></a>Init()</h3><p>用于初始化服务器:</p><ul><li>创建套接字文件</li><li>准备<code>sockaddr_in</code>的内容</li><li>绑定<code>sockaddr_in</code></li></ul><p>代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _sockfd  = <span class="built_in">socket</span>(AF_INET,SOCK_DGRAM,<span class="number">0</span>);<span class="comment">//创建套接字</span></span><br><span class="line">    <span class="keyword">if</span>(_sockfd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[Fatal],socket creation failed,sockfd: %d\n&quot;</span>,_sockfd);</span><br><span class="line">        <span class="built_in">exit</span>(SOCKET_ERR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[Info],socket create succeeded , sockfd: %d\n&quot;</span>,_sockfd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//bind socket</span></span><br><span class="line">    <span class="comment">//准备sockaddr_in的内容</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> local;</span><br><span class="line">    <span class="built_in">bzero</span>(&amp;local,<span class="built_in">sizeof</span>(local));<span class="comment">//先置0</span></span><br><span class="line">    local.sin_family = AF_INET; <span class="comment">//指定IP协议为IPV4</span></span><br><span class="line">    local.sin_port = <span class="built_in">htons</span>(_port);;<span class="comment">//指定端口号，要使用hton系类函数转换成网络字节序</span></span><br><span class="line">    <span class="comment">// local.sin_addr.s_addr = inet_addr(_ip.c_str());</span></span><br><span class="line">    local.sin_addr.s_addr = INADDR_ANY;<span class="comment">//和ip == &#x27;0.0.0.0&#x27;的效果是一样的</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//绑定并判断是否成功</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">bind</span>(_sockfd,(<span class="type">const</span> <span class="keyword">struct</span> sockaddr *)&amp; local,<span class="built_in">sizeof</span>(local)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Fatal,bind error,errno:%d ,err string: %s\n&quot;</span>,errno,<span class="built_in">strerror</span>(errno));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//打印成功的日志</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Info,%s:%u bind succeeded\n&quot;</span>,_ip.<span class="built_in">c_str</span>(),_port);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果预先定好了传入的ip为<code>0.0.0.0</code>，则还有更简便的方法，直接使用宏<code>INADDR_ANY</code>给<code>struct sockaddr_in.sin_addr.s_addr</code>赋值，这样连地址转换函数都省略了</p><p>在<code>Init()</code>函数中，我们仅仅实现了对套接字的绑定，关于收发udp数据报，我们将在<code>Run()</code>函数内实现。但为了提高代码封装性，在写其它接口前，我们先写两个工具函数</p><h3 id="CheckUser"><a href="#CheckUser" class="headerlink" title="CheckUser()"></a>CheckUser()</h3><p>检查是否是新用户接入</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CheckUser</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> sockaddr_in&amp; client,<span class="type">const</span> std::string &amp;clientip,<span class="type">uint16_t</span> clientport)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> iter = _ol_usr.<span class="built_in">find</span>(clientip);<span class="comment">//查找客户端ip是否存在</span></span><br><span class="line">    <span class="keyword">if</span>(iter == _ol_usr.<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Info,[%s] added to oline user\n&quot;</span>,clientip.<span class="built_in">c_str</span>());</span><br><span class="line">        _ol_usr.<span class="built_in">insert</span>(&#123;clientip,client&#125;);<span class="comment">//插入新用户</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Broadcast"><a href="#Broadcast" class="headerlink" title="Broadcast()"></a>Broadcast()</h3><p>回显服务器执行功能，像所有客户端广播信息</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Broadcast</span><span class="params">(<span class="type">const</span> std::string&amp; info,<span class="type">const</span> std::string &amp;clientip,<span class="type">uint16_t</span> clientport)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//拼接消息字符串</span></span><br><span class="line">    std::string msg = <span class="string">&quot;[&quot;</span>;</span><br><span class="line">    msg+=clientip;</span><br><span class="line">    msg+=<span class="string">&quot;:&quot;</span>;</span><br><span class="line">    msg+=std::<span class="built_in">to_string</span>(clientport);</span><br><span class="line">    msg+=<span class="string">&quot;]# &quot;</span>;</span><br><span class="line">    msg+= info;<span class="comment">//拼接上消息内容</span></span><br><span class="line">    <span class="comment">//遍历用户</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span>&amp;user:_ol_usr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Info,Broadcast\n&quot;</span>);</span><br><span class="line">        <span class="type">socklen_t</span> len = <span class="built_in">sizeof</span>(user.second);</span><br><span class="line">        <span class="built_in">sendto</span>(_sockfd,msg.<span class="built_in">c_str</span>(),msg.<span class="built_in">size</span>(),<span class="number">0</span>,(<span class="type">const</span> sockaddr*)&amp;(user.second),len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Run"><a href="#Run" class="headerlink" title="Run()"></a>Run()</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Info,Server started running...\n&quot;</span>);</span><br><span class="line">    _isRunning = <span class="literal">true</span>;</span><br><span class="line">    <span class="type">char</span> inbuffer[size] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(_isRunning)<span class="comment">//开启循环</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> client;<span class="comment">//储存客户端信息的结构体</span></span><br><span class="line">        <span class="type">socklen_t</span> len = <span class="built_in">sizeof</span>(client);</span><br><span class="line">        <span class="comment">//接收客户端消息报</span></span><br><span class="line">        <span class="type">ssize_t</span> n = <span class="built_in">recvfrom</span>(_sockfd,inbuffer,<span class="built_in">sizeof</span>(inbuffer)<span class="number">-1</span>,<span class="number">0</span>,(<span class="keyword">struct</span> sockaddr *) &amp;client , &amp;len);</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">0</span>)<span class="comment">//接收失败</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Warning,recvfrom error,errno:%d ,err string: %s\n&quot;</span>,errno,<span class="built_in">strerror</span>(errno));</span><br><span class="line">        &#125;</span><br><span class="line">        inbuffer[n] = <span class="number">0</span>;<span class="comment">//给字符串结尾添加&#x27;\0&#x27;</span></span><br><span class="line"></span><br><span class="line">        <span class="type">uint16_t</span> clientport = <span class="built_in">ntohs</span>(client.sin_port);<span class="comment">//网络字节序转主机字节序</span></span><br><span class="line">        std::string clientip = <span class="built_in">inet_ntoa</span>(client.sin_addr);<span class="comment">//该接口能自动转换出C字符串</span></span><br><span class="line"></span><br><span class="line">        std::string info = inbuffer;<span class="comment">//储存消息</span></span><br><span class="line">        <span class="built_in">CheckUser</span>(client,clientip,clientport);</span><br><span class="line">        <span class="built_in">Broadcast</span>(info,clientip,clientport);<span class="comment">//向客户端广播回显消息</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Info, Server get a msg! [%s:%u]: %s\n&quot;</span>,clientip.<span class="built_in">c_str</span>(),clientport,inbuffer);<span class="comment">//服务端显示消息</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编写Main-cpp"><a href="#编写Main-cpp" class="headerlink" title="编写Main.cpp"></a>编写Main.cpp</h3><p>因为启动服务器还需要一个源文件形成可执行文件，所以这边编写一个<code>Main.cpp</code></p><p>就是实例化了一个UdoServer对象并启动服务而已</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;udpServer.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* args[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;UdpServer&gt; <span class="title">svr</span><span class="params">(<span class="keyword">new</span> UdpServer())</span></span>;<span class="comment">//使用默认端口号和ip</span></span><br><span class="line">    svr-&gt;<span class="built_in">Init</span>();<span class="comment">//初始化</span></span><br><span class="line">    svr-&gt;<span class="built_in">Run</span>();<span class="comment">//启动运行</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="编写Client-cpp"><a href="#编写Client-cpp" class="headerlink" title="编写Client.cpp"></a>编写Client.cpp</h2><p>我们来写一个简单的udp客户端</p><p>下面要用到<a href="https://www.supdriver.top/2024/08/14/thread/">多线程🔗</a>防止进程在阻塞等待用户输入时，无法立即输出接收到的udp数据报</p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202410191543176.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;strings.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ThreadData</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> server;</span><br><span class="line">    <span class="type">int</span> sockfd;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接收信息的线程的入口函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">recv_msg</span><span class="params">(<span class="type">void</span>* args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ThreadData</span>* td = (<span class="keyword">struct</span> ThreadData*)args;<span class="comment">//获取参数包</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> temp;</span><br><span class="line">        <span class="type">socklen_t</span> len = <span class="built_in">sizeof</span>(temp);</span><br><span class="line">        <span class="comment">//阻塞等待接收udp数据报，这里的temp为服务器信息，接收后可以不使用</span></span><br><span class="line">        <span class="type">ssize_t</span> s = <span class="built_in">recvfrom</span>(td-&gt;sockfd,buffer,<span class="number">1023</span>,<span class="number">0</span>,(<span class="keyword">struct</span> sockaddr*)&amp;temp,&amp;len);</span><br><span class="line">        <span class="keyword">if</span>(s&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            buffer[s] = <span class="number">0</span>;<span class="comment">//输出内容</span></span><br><span class="line">            std::cout&lt;&lt;buffer&lt;&lt;std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送消息的线程的入口函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">send_msg</span><span class="params">(<span class="type">void</span>* args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//获取数据包，里面含有服务器信息</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ThreadData</span>* td = (<span class="keyword">struct</span> ThreadData*)args;</span><br><span class="line">    std::string msg;</span><br><span class="line">    <span class="type">socklen_t</span> len = <span class="built_in">sizeof</span>(td-&gt;server);</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;Please Enter@&quot;</span>;</span><br><span class="line">        std::<span class="built_in">getline</span>(std::cin,msg);<span class="comment">//获取一行消息</span></span><br><span class="line">        <span class="comment">//发送消息</span></span><br><span class="line">        <span class="built_in">sendto</span>(td-&gt;sockfd,msg.<span class="built_in">c_str</span>(),msg.<span class="built_in">size</span>(),<span class="number">0</span>,(<span class="keyword">struct</span> sockaddr*)&amp;td-&gt;server,len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//硬编码服务器信息</span></span><br><span class="line">    <span class="function">std::string <span class="title">serverip</span><span class="params">(<span class="string">&quot;127.0.0.1&quot;</span>)</span></span>;<span class="comment">//环回地址</span></span><br><span class="line">    <span class="type">uint16_t</span> serverport = <span class="number">25565</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ThreadData</span> td;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//准备td数据包</span></span><br><span class="line">    <span class="built_in">bzero</span>(&amp;td.server,<span class="built_in">sizeof</span>(td.server));</span><br><span class="line">    td.server.sin_family = AF_INET;<span class="comment">//使用IPV4协议</span></span><br><span class="line">    td.server.sin_port = <span class="built_in">htons</span>(serverport);<span class="comment">//端口</span></span><br><span class="line">    td.server.sin_addr.s_addr = <span class="built_in">inet_addr</span>(serverip.<span class="built_in">c_str</span>());<span class="comment">//地址</span></span><br><span class="line">    td.sockfd = <span class="built_in">socket</span>(AF_INET,SOCK_DGRAM,<span class="number">0</span>);<span class="comment">//创建套接字</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(td.sockfd&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;socket err\n&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//套接字创建失败</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">pthread_t</span> recvr,sender;</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;recvr,<span class="literal">nullptr</span>,recv_msg,&amp;td);<span class="comment">//创建收消息线程</span></span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;sender,<span class="literal">nullptr</span>,send_msg,&amp;td);<span class="comment">//创建发消息线程</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_join</span>(recvr,<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">pthread_join</span>(sender,<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(td.sockfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="地址转换函数"><a href="#地址转换函数" class="headerlink" title="地址转换函数"></a>地址转换函数</h3><p>在写客户端时指定客户端就不能用<code>INADDR_ANY</code>了，因为要指定具体的ip地址。</p><p>我们知道(IPv4地址)ip其实是一个32位无符号整数，而我们平时使用<code>点分十进制</code>表示，结构体的<code>struct sockaddr_in.sin_addr.s_addr</code>确正是32位无符号整数，为可以自己把字符串转成整数，当然也可以调用地址转换函数来执行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//字符串转in_addr的函数（address to network）</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">inet_aton</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *const_str_ptr, <span class="keyword">struct</span> in_addr *inaddr_ptr)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">in_addr_t</span> <span class="title function_">inet_addr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *const_str_ptr)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">inet_pton</span><span class="params">(<span class="type">int</span> addr_family, <span class="type">const</span> <span class="type">char</span> *src_str, <span class="type">void</span> *dst_addr)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//in_addr转字符串</span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">inet_ntoa</span><span class="params">(<span class="keyword">struct</span> in_addr in)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *<span class="title function_">inet_ntop</span><span class="params">(<span class="type">int</span> addr_family, <span class="type">const</span> <span class="type">void</span> *src_addr,</span></span><br><span class="line"><span class="params">                        <span class="type">char</span> *dst_str, <span class="type">socklen_t</span> size)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其中<code>inet_pton</code>和<code>inet_ntop</code>不仅可以转换<code>IPV4</code>的<code>in_addr</code>，还可以转换<code>IPV6</code>的<code>in6_addr</code>，因此函数接口使用了<code>void* addrptr</code>参数</p><h4 id="关于inet-ntoa"><a href="#关于inet-ntoa" class="headerlink" title="关于inet_ntoa"></a>关于inet_ntoa</h4><p>这个函数返回了一个<code>char*</code>，那么我们需不需要手动释放它呢？我们来查看一下man手册</p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202410280830637.png"></p><p>可以看到，返回的字符串并不在堆区上，而是在静态区。<strong>这将会导致一个问题</strong>，如果直接使用返回的地址，而不是另外拷贝一份字符串，原地址指向的字符串将会有随时被修改的风险。同时，这也严重影响了线程安全性。我们来写一小段代码验证man手册的说法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr1</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr2</span>;</span></span><br><span class="line">    addr1.sin_addr.s_addr = <span class="number">0</span>;</span><br><span class="line">    addr2.sin_addr.s_addr = <span class="number">0xffffffff</span>;<span class="comment">//准备第二个不同的地址</span></span><br><span class="line">    <span class="comment">//分别获取两个字符串</span></span><br><span class="line">    <span class="type">char</span> *ptr1 = inet_ntoa(addr1.sin_addr);</span><br><span class="line">    <span class="type">char</span> *ptr2 = inet_ntoa(addr2.sin_addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ptr1: %s address: %p\nptr2: %s address: %p\n&quot;</span>, ptr1, ptr1,ptr2,ptr2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下</p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202410280834709.png"></p><p>可以看到，<code>ptr1</code>和<code>ptr2</code>的值是一样的，所以指向的字符串也是一样的。而<code>ptr1</code>本应该储存了<code>&quot;0.0.0.0&quot;</code>，输出结果严重不符合预期</p><p>所以为了<strong>安全性问题</strong>,<strong>更建议使用</strong><code>inet_ntop</code>,因为它使用了用户提供的缓冲区来存储字符串，而各个线程的栈区是独立的，可以独立地存储字符串。</p><h2 id="编写makefile"><a href="#编写makefile" class="headerlink" title="编写makefile"></a>编写makefile</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><span class="keyword">.PHONY</span>:all</span></span><br><span class="line"><span class="section">all:udpServer udpclient</span></span><br><span class="line"></span><br><span class="line"><span class="section">udpServer:Main.cpp</span></span><br><span class="line">g++ -o <span class="variable">$@</span> <span class="variable">$^</span> -std=c++11</span><br><span class="line"><span class="section">udpclient:UdpClient.cpp</span></span><br><span class="line">g++ -o <span class="variable">$@</span> <span class="variable">$^</span> -std=c++11 -lpthread</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>:clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm -f udpServer udpclient</span><br></pre></td></tr></table></figure><h2 id="测试通信效果"><a href="#测试通信效果" class="headerlink" title="测试通信效果"></a>测试通信效果</h2><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202410191607980.png"></p><p>如上图所示，~~~除了输入输出有些顺序混乱~~~，客户端和服务端的回显通信服务工作得很好。</p><h2 id="UDP通信小结"><a href="#UDP通信小结" class="headerlink" title="UDP通信小结"></a>UDP通信小结</h2><p>UDP通信协议是一种<code>面向数据报</code>的不可靠的通信协议，一个数据报如果只读了一部分，剩下的只会被直接丢弃。但是它使用简单，建立连接的速率也比接下来要介绍的TCP通信协议要快</p><h1 id="TCP通信编程"><a href="#TCP通信编程" class="headerlink" title="TCP通信编程"></a>TCP通信编程</h1><p>使用接口：</p><p>首先还是<code>创建套接字文件</code>和<code>绑定struct sockaddr</code></p><ul><li><code>int socket(int domain, int type, int protocol);</code><ul><li>用于创建套接字文件，获取套接字文件描述符<code>fd</code></li><li><code>domain</code>规定域名通信协议，比如<code>IPV4</code>、<code>IPV6</code>、<code>本地通信协议</code>等</li><li><code>type</code>通信类型，<code>SOCK_DGRAM</code>表示面向<code>数据报</code>,<code>SOCK_STREAM</code>表示面向字节流，<strong>TCP通信使用<code>SOCK_STREAM</code></strong></li><li><code>protocol</code>协议代码，可选内容取决于<code>domain</code>参数，可为<code>0</code></li><li><code>返回值</code>为套接字文件的文件描述符</li></ul></li><li><code>int bind(int sockfd, const struct sockaddr *addr,socklen_t addrlen);</code><ul><li>用于给指定<code>sockfd</code>绑定网络通信协议</li><li><code>sockfd</code>文件描述符</li><li><code>addr</code>就是上面介绍的<code>struct sockaddr</code>的子类</li><li><code>addrlen</code>为<code>addr</code>指向结构体的大小</li><li><code>返回值</code>成功则返回<code>0</code>，失败则返回<code>1</code></li></ul></li><li><code>int listen(int sockfd, int backlog);</code><ul><li>声明指定<code>socket文件</code>处于<code>监听状态</code>，最多允许有<code>backlog</code>个客户端处于<code>连接等待状态</code></li><li><code>sockfd</code>文件描述符</li><li><code>backlog</code> 最多允许有<code>backlog</code>个客户端处于<code>连接等待状态</code></li><li><code>返回值</code>成功则返回<code>0</code>,失败则返回<code>1</code></li></ul></li><li><code>int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);</code><ul><li>服务端(默认阻塞)等待与客户端进行三次握手后的连接</li><li>连接成功后会创建<strong>新的</strong>专门用于通信的套接字文件描述符并返回</li><li><code>sockfd</code>用于监听的<code>sockfd</code>文件描述符</li><li><code>addr</code>输出型参数，一个缓冲区，指向储存消息源信息的结构体地址</li><li><code>addelen</code>传入结构体的大小</li><li><code>返回值</code>用于与特定客户端网络通信的文件描述符</li></ul></li><li><code>int connect(int sockfd, const struct sockaddr *addr,socklen_t addrlen);</code><ul><li>客户端(默认阻塞)等待与指定服务端建立TCP连接</li><li>连接成功后会创建<strong>新的</strong>用于通信的套接字文件描述符并返回</li><li><code>sockfd</code>用于建立通信创建的套接字文件</li><li><code>addr</code>储存了待连接的服务端的信息</li><li><code>addrlen</code>传入结构的大小</li></ul></li></ul><p>对接口的使用概览图如下</p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202410280951707.png"></p><h1 id="编写TCP回显服务器"><a href="#编写TCP回显服务器" class="headerlink" title="编写TCP回显服务器"></a>编写TCP回显服务器</h1><p>我们还是来写个简单的程序来实践一下这些接口。</p><h2 id="封装TCPSocket类"><a href="#封装TCPSocket类" class="headerlink" title="封装TCPSocket类"></a>封装TCPSocket类</h2><p>因为<code>监听</code>和<code>连接</code>用的<code>TCPSocket</code>与具体的IO通信使用的<code>sockfd</code>是可以分离的（不共用文件描述符），所以更适合使用C++封装成类</p><p>类声明如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TCPSocket</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TCPSocket</span>(<span class="type">int</span> fd = <span class="number">-1</span>)</span><br><span class="line">    :_sock_fd(fd)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建套接字</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Socket</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//绑定监听使用的ip和端口号</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Bind</span><span class="params">(<span class="type">const</span> std::string&amp; ip,<span class="type">uint16_t</span> port)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="comment">//开始监听</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Listen</span><span class="params">(<span class="type">int</span> backlog = <span class="number">5</span>)</span><span class="type">const</span></span>;</span><br><span class="line">    <span class="comment">//Accept新的TCP连接</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Accept</span><span class="params">(std::string* client_ip=<span class="literal">nullptr</span>,<span class="type">uint16_t</span>* client_port = <span class="literal">nullptr</span>)</span><span class="type">const</span></span>;</span><br><span class="line">    <span class="comment">//尝试对目标服务器发起新的连接</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Connect</span><span class="params">(<span class="type">const</span> std::string&amp;server_ip,<span class="type">const</span> <span class="type">uint16_t</span> server_port)</span><span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Close</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">close</span>(_sock_fd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">TCPSocket</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">Close</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _sock_fd;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中<code>Socket()</code>,<code>Bind()</code>,<code>Listen()</code>较为简单，直接实现即可。唯一要注意的是<code>Listen</code>要提供<code>backlog</code>参数将其传递给内部的<code>listen</code>函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TCPSocket</span>(<span class="type">const</span> std::string&amp; ip,<span class="type">uint32_t</span> port)</span><br><span class="line">    :_sock_fd(<span class="number">-1</span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Socket</span><span class="params">()</span><span class="comment">//创建套接字</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _sock_fd = <span class="built_in">socket</span>(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(_sock_fd &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;info: open socket fd :%d\n&quot;</span>,_sock_fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Bind</span><span class="params">(<span class="type">const</span> std::string&amp; ip,<span class="type">uint16_t</span> port)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> addr_in;</span><br><span class="line">        addr_in.sin_family = AF_INET;</span><br><span class="line">        addr_in.sin_addr.s_addr = <span class="built_in">inet_addr</span>(ip.<span class="built_in">c_str</span>());</span><br><span class="line">        addr_in.sin_port = <span class="built_in">htons</span>(port);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ret = <span class="built_in">bind</span>(_sock_fd,(<span class="type">const</span> <span class="keyword">struct</span> sockaddr*)&amp;addr_in,<span class="built_in">sizeof</span>(addr_in));</span><br><span class="line">        <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//开始监听</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Listen</span><span class="params">(<span class="type">int</span> backlog = <span class="number">5</span>)</span><span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="built_in">listen</span>(_sock_fd,backlog);</span><br><span class="line">        <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>接下来是封装<code>accept()</code>,我们准备让它接收连接请求，预处理，然后返回所需的信息。对于<code>Accept()</code>我们主要需要从里面获取<code>客户端ip</code>，<code>客户端port</code>,<code>对应的文件描述符</code>。我们设计让函数返回文件描述符，即在最后返回<code>accept</code>的返回值，与被封装的接口保持一致。至于剩下的两个参数，我们使用<code>输出型参数</code>来输出<code>ip</code>和<code>port</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Accept</span><span class="params">(std::string* client_ip=<span class="literal">nullptr</span>,<span class="type">uint16_t</span>* client_port = <span class="literal">nullptr</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> client_addr;</span><br><span class="line">        <span class="type">socklen_t</span> len = <span class="built_in">sizeof</span>(client_addr);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> new_fd = <span class="built_in">accept</span>(_sock_fd,(<span class="keyword">struct</span> sockaddr*)&amp;client_addr,&amp;len);</span><br><span class="line">        <span class="keyword">if</span>(new_fd &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> new_fd;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;info, accept fd: %d\n&quot;</span>,new_fd);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(client_ip !=<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">char</span> buffer[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="built_in">inet_ntop</span>(AF_INET,&amp;client_addr,buffer,<span class="built_in">sizeof</span>(client_addr));</span><br><span class="line">            *client_ip = buffer;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(client_port != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            *client_port = <span class="built_in">ntohs</span>(client_addr.sin_port);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> new_fd;<span class="comment">//返回新建的文件</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>Connect()</code>成员函数则是对<code>connect</code>函数进行封装，使其更加易用，只需传入服务器<code>ip</code>和<code>端口号</code>，然后接收其返回值即可获得用于通信的<code>文件描述符</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Connect</span><span class="params">(<span class="type">const</span> std::string&amp;server_ip,<span class="type">const</span> <span class="type">uint16_t</span> server_port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(server_ip.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ip不可为空\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> server_addr;</span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    server_addr.sin_port = <span class="built_in">htons</span>(server_port);</span><br><span class="line">    server_addr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(server_ip.<span class="built_in">c_str</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">connect</span>(_sock_fd,(<span class="type">const</span> <span class="keyword">struct</span> sockaddr*)&amp;server_addr,<span class="built_in">sizeof</span>(server_addr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="封装TCPEchoServer类"><a href="#封装TCPEchoServer类" class="headerlink" title="封装TCPEchoServer类"></a>封装TCPEchoServer类</h2><p>封装好套接字类后，我们就要来实践具体的通信部分了。在概念设计上，即使是最简单的回显服务器，明显单线程已经不能满足需求了，因为监听，连接，收发信息常常会把线程阻塞住，所以我们选择使用<code>多线程</code>或者<code>多进程</code>技术来优化程序。关于更高效的网络通信IO有很多内容可以展开讲，但不是本文的主题，所以放到以后的文章中</p><p><em>本文选择较为简单的<code>多进程</code>技术</em></p><p>基本结构如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;TCPSocket.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TCPEchoServer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TCPEchoServer</span>(<span class="type">const</span> std::string&amp; ip,<span class="type">const</span> <span class="type">uint16_t</span> port)</span><br><span class="line">    :_ip(ip),_port(port)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span></span>;<span class="comment">//主进程的运行逻辑</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">broadcast</span><span class="params">(<span class="type">const</span> std::string&amp; ip,<span class="type">const</span> <span class="type">uint16_t</span> port)</span></span>;<span class="comment">//进行广播</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">child_loop</span><span class="params">(<span class="type">int</span> fd)</span></span>;<span class="comment">//子进程提供回显服务的函数入口</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">TCPEchoServer</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        _socket.<span class="built_in">Close</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> fd:_clients)<span class="comment">//关闭所有通信用文件描述符</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">close</span>(fd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string _ip;<span class="comment">//存储服务端开放的ip</span></span><br><span class="line">    <span class="type">uint16_t</span> _port;<span class="comment">//存储服务端开放的port</span></span><br><span class="line">    TCPSocket _socket;<span class="comment">//存储监听用套接字</span></span><br><span class="line">    std::unordered_set&lt;<span class="type">int</span>&gt; _clients;<span class="comment">//存储通信用文件描述符</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到，<code>TCPEchoServer</code>类内管理了许多文件描述符，为了防止<code>文件描述符泄漏</code>,析构函数一定要记得把不需要的文件描述符都关闭了。</p><p>接下来我们先实现<code>broadcast</code>和<code>child_loop</code>,最后再实现<code>run</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">broadcast</span><span class="params">(<span class="type">const</span> std::string&amp; ip,<span class="type">const</span> <span class="type">uint16_t</span> port)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::string who;</span><br><span class="line">        who+=<span class="string">&quot;[&quot;</span>;</span><br><span class="line">        who+=ip;</span><br><span class="line">        who+=<span class="string">&quot;:&quot;</span>;</span><br><span class="line">        who+=std::<span class="built_in">to_string</span>(port);</span><br><span class="line">        who+=<span class="string">&quot;]&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function">std::string <span class="title">msg</span><span class="params">(who)</span></span>;</span><br><span class="line">        msg+=<span class="string">&quot;Entered Server\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">        std::vector&lt;<span class="type">int</span>&gt; del_list;<span class="comment">//后置删除断开连接的文件描述符</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> fd:_clients)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> ret = <span class="built_in">write</span>(fd,msg.<span class="built_in">c_str</span>(),msg.<span class="built_in">size</span>());</span><br><span class="line">            <span class="keyword">if</span>(ret == <span class="number">0</span>)<span class="comment">//文件描述符的写端关闭</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%s disconnected\n&quot;</span>,who.<span class="built_in">c_str</span>());</span><br><span class="line">                del_list.<span class="built_in">push_back</span>(fd);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> fd:del_list)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">close</span>(fd);<span class="comment">//关闭文件描述符</span></span><br><span class="line">            _clients.<span class="built_in">erase</span>(fd);<span class="comment">//去除列表</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里要清除写端关闭的文件描述符，但是在使用迭代器遍历(<em>for…auto…</em>)时，修改容器是很危险的，所以我们用到了缓冲区的思想，把待删除的文件描述符存在<code>vector</code>中，最后再集中关闭和移除出<code>_clients</code>;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">child_loop</span><span class="params">(<span class="type">int</span> fd)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">char</span> buffer[<span class="number">128</span>];</span><br><span class="line">            <span class="type">int</span> n =<span class="built_in">read</span>(fd,buffer,<span class="built_in">sizeof</span>(buffer)<span class="number">-1</span>);<span class="comment">//读取信息</span></span><br><span class="line">            <span class="keyword">if</span>(n&lt;=<span class="number">0</span>)<span class="keyword">return</span>;<span class="comment">//读取异常或连接关闭，退出工作函数</span></span><br><span class="line">            buffer[n] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="comment">//阻塞读成功后，再写回客户端   </span></span><br><span class="line">            n = <span class="built_in">write</span>(fd,buffer,<span class="built_in">sizeof</span>(buffer)<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">if</span>(n&lt;=<span class="number">0</span>)<span class="keyword">return</span>;<span class="comment">//输出异常或连接关闭，退出工作函数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>子进程（其实是孙子）的工作是一个死循环，持续提供服务。当连接关闭时，它就会自动退出循环。</p><p>最后来实现<code>run</code>函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//创建和绑定套接字，然后开始监听</span></span><br><span class="line">        <span class="keyword">if</span>(_socket.<span class="built_in">Socket</span>() == <span class="literal">false</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(_socket.<span class="built_in">Bind</span>(_ip,_port) == <span class="literal">false</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(_socket.<span class="built_in">Listen</span>() == <span class="literal">false</span>)<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            std::string client_ip;</span><br><span class="line">            <span class="type">uint16_t</span> client_port;</span><br><span class="line">            <span class="type">int</span> client_fd = _socket.<span class="built_in">Accept</span>(&amp;client_ip,&amp;client_port);<span class="comment">//获取连接</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(client_fd &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//本次accept失败，等待1s后再次尝试</span></span><br><span class="line">                <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//accept成功</span></span><br><span class="line">            <span class="built_in">broadcast</span>(client_ip,client_port);<span class="comment">//广播连接</span></span><br><span class="line">            _clients.<span class="built_in">insert</span>(client_fd);<span class="comment">//储存连接</span></span><br><span class="line"></span><br><span class="line">            <span class="type">pid_t</span> pid = fork();</span><br><span class="line">            <span class="keyword">if</span>(pid == <span class="number">0</span>)<span class="comment">//创建多进程</span></span><br><span class="line">            &#123;</span><br><span class="line">                _socket.<span class="built_in">Close</span>();<span class="comment">//关闭文件描述符</span></span><br><span class="line">                <span class="keyword">if</span>(fork() != <span class="number">0</span>) <span class="built_in">exit</span>(<span class="number">0</span>);<span class="comment">//子进程退出</span></span><br><span class="line">                <span class="comment">//孙子进程成为孤儿进程</span></span><br><span class="line">                <span class="built_in">child_loop</span>(client_fd);<span class="comment">//执行工作循环</span></span><br><span class="line">                <span class="built_in">close</span>(client_fd);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);<span class="comment">//孙子进程退出</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">pid_t</span> rid = <span class="built_in">waitpid</span>(pid,<span class="literal">nullptr</span>,<span class="number">0</span>);</span><br><span class="line">                (<span class="type">void</span>) rid;<span class="comment">//调用一下rid，防止报警告</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>一般创建了子进程之后，父进程还要等待子进程退出并回收子进程的资源。而默认情况下的等待是阻塞的，当然我们可以设置成为非阻塞轮询，<strong>但我们也可以讨巧地创建孙子进程</strong>,让子进程立即退出并被主进程回收，这时孙子进程变成孤儿进程，由<code>PID==1</code>的进程进行回收资源</p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202410290843206.png"></p><p>我们再简单地写一下<code>Main.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;TCPEchoServer.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;TCPEchoServer&gt; <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> TCPEchoServer(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">8888</span>))</span></span>;</span><br><span class="line">    ptr-&gt;<span class="built_in">run</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="编写TCPClient客户端"><a href="#编写TCPClient客户端" class="headerlink" title="编写TCPClient客户端"></a>编写TCPClient客户端</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;TCPSocket.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Recv</span><span class="params">(<span class="type">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> fd = *(<span class="type">int</span>*)arg;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> buffer[<span class="number">128</span>];</span><br><span class="line">        <span class="type">int</span> n = <span class="built_in">read</span>(fd,buffer,<span class="built_in">sizeof</span>(buffer)<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;<span class="built_in">printf</span>(<span class="string">&quot;disconnected\n&quot;</span>);<span class="keyword">break</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">0</span>)&#123;<span class="built_in">printf</span>(<span class="string">&quot;read error\n&quot;</span>);<span class="keyword">break</span>;&#125;</span><br><span class="line"></span><br><span class="line">        buffer[n] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        cout&lt;&lt;buffer&lt;&lt;endl&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Send</span><span class="params">(<span class="type">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> fd = *(<span class="type">int</span>*)arg;</span><br><span class="line">    string line;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">getline</span>(cin,line);</span><br><span class="line">        <span class="type">int</span> n = <span class="built_in">write</span>(fd,line.<span class="built_in">c_str</span>(),line.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;disconnected\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;write error\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TCPSocket conSocket;</span><br><span class="line">    conSocket.<span class="built_in">Socket</span>();</span><br><span class="line">    <span class="type">int</span> fd = conSocket.<span class="built_in">Connect</span>(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">8888</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用C++线程库</span></span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(Recv,&amp;fd)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(Send,&amp;fd)</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用了C++线程库，比C语言的更加简单易用。</p><h2 id="编写makefile-1"><a href="#编写makefile-1" class="headerlink" title="编写makefile"></a>编写makefile</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><span class="keyword">.PHONY</span>:all</span></span><br><span class="line"><span class="section">all:server client</span></span><br><span class="line"></span><br><span class="line"><span class="section">server:Main.cpp</span></span><br><span class="line">g++ -o <span class="variable">$@</span> <span class="variable">$^</span> -std=c++11 </span><br><span class="line"><span class="section">client:TCPClient.cpp</span></span><br><span class="line">g++ -o <span class="variable">$@</span> <span class="variable">$^</span> -std=c++11 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>:clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm -f server client</span><br></pre></td></tr></table></figure><p>这里依然使用了点小技巧（指<code>.PHONY:all</code>）</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>初识Linux编程&amp;初识makefile</title>
      <link href="/2024/09/30/touchLinux/"/>
      <url>/2024/09/30/touchLinux/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文将以实用的视角，以快速上手Linux平台的C++编程为目的，介绍:</p><ul><li>Linux的基本操作 </li><li>gcc&#x2F;g++的常用指令</li><li>makefile的常用编写方式</li></ul><h1 id="软件准备"><a href="#软件准备" class="headerlink" title="软件准备"></a>软件准备</h1><p><em>如果选择用虚拟机，那请自己解决</em></p><p>这里介绍使用<code>Linux服务器</code>配合<code>本地ssh链接软件</code>的方式在服务器上编写代码</p><p>首先是服务器，可以在主流服务器平台(阿里云，腾讯云，华为云)等购买服务器，一般有学生认证会更便宜,服务器配置不限，若要使用Linux,可以选择Ubuntu内核，(CentOs也行，就是太老了，且停止维护了)，然后自行查阅相关教程，设置默认管理员账户和密码，以及配置服务器，<strong>开启ssh远程链接权限</strong></p><p>关于本地的ssh链接软件，这里我只推荐两个我使用过的</p><ul><li>xshell7</li><li>vscode+ssh插件</li></ul><p>其中<code>xshell</code>比较简单，安装好就能用 <a href="https://www.xshell.com/en/free-for-home-school/#:~:text=We%20believe%20users%20from%20all%20backgrounds%20and%20circumstances">戳我去下载免费版xshell🔗</a>，怎么登录服务器？自行百度~。但缺点是仅支持控制台，所以写代码只能用<code>vim</code>等支持控制台的文本编辑器</p><p><code>vscode</code>+<code>ssh</code>插件会比<code>xshell</code>麻烦点，还要修改配置文件，具体教程可参考<a href="https://www.bilibili.com/video/BV13Z421T7oz/">b战视频🔗</a></p><p>但优点是<code>vscode</code>在支持终端(控制台)的同时还支持原本的<code>文本编辑器界面</code>,相当于可以用windows的<code>GUI可视化窗口</code>写代码了</p><p><em>下图为xshell(左)和vscode(右)的界面对比</em></p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202409302132012.png"></p><h1 id="Linux快速入门"><a href="#Linux快速入门" class="headerlink" title="Linux快速入门"></a>Linux快速入门</h1><p>不同于Windows平台的<code>GUI可视化</code>界面，在服务器编写代码，由于为了节省服务器资源，是不会安装GUI可视化界面的，所以还需要适应和学习终端的操作</p><h2 id="Linux-常用指令"><a href="#Linux-常用指令" class="headerlink" title="Linux 常用指令"></a>Linux 常用指令</h2><h3 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h3><p><code>ls</code>指令用于查看当前<code>目录</code>所含有的文件</p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202409302202715.png"></p><p>但是单纯的ls显示的内容太简略了，所幸它是能加参数的,格式是<code>-参数字符(串)</code>,多个参数时直接连在一起，不用间隔</p><p>常用参数如下</p><ul><li><code>-l</code>显示更多的详细信息</li><li><code>-a</code>显示全部文件，包括隐藏文件(以<code>.</code>开头的目录&#x2F;文件)</li><li><code>-i</code>显示唯一文件标示符s</li></ul><p>但是每次都打参数太麻烦了怎么办？没关系~！还有快捷命令<code>ll</code>，相当于<code>ls -al</code></p><p>平时最常用的就是<code>ll</code></p><h3 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h3><p>那么怎么切换路径呢？使用<code>cd 路径名称</code>即可</p><p><strong>关于路径</strong>，又分为<code>绝对路径</code>和<code>相对路径</code></p><p>在<code>Linux</code>中，所有目录的最终根目录都是<code>/</code>,没错，单一个<code>/</code></p><p>而用户登录后所在的文件夹是用户文件夹，以用户<code>supdriver</code>为例,一般路径为<code>/home/supdriver</code>,其中这个目录也可以用<code>~</code>指代</p><p>至于<code>相对目录</code>,对于除了根目录的普通目录，都会存在一个<code>.</code>目录和<code>..</code>目录，其中<code>.</code>目录就是指这个目录自己，而<code>..</code>则是上级目录</p><p>在了解完路径的基本概念后，使用<code>cd</code>命令就很简单了</p><p>下面举几个简单例子</p><ul><li><code>cd /home</code>打开家目录，所有的用户文件夹都在这</li><li><code>cd ~</code>打开当前登录用户的用户文件夹</li><li><code>cd -</code>打开上次<code>cd</code>打开的文件夹</li><li><code>cd /</code>打开根目录</li><li><code>cd ./tmp</code>打开当前目录下的<code>tmp</code>目录</li><li><code>cd ../</code>打开上级目录</li></ul><h3 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a>pwd</h3><p>既然已经知道了路径的概念，有时候我们想获取当前所在路径怎么办呢？使用<code>pwd</code>指令吧,不需要参数</p><h3 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h3><p><code>mkdir</code>是专门用于创建普通目录的指令，用法有:</p><ul><li><code>mkdir 目录名</code>在当前目录创建目录</li><li><code>mkdir 路径/目录名</code>在指定路径创建目录（如果有权限的话）</li></ul><h2 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h2><p><code>touch</code>指令可以用于生成文件,<code>linux</code>下的文件都是同样的种类，而且在linux中文件的后缀对操作系统识别文件类型并不重要</p><p><code>touch file</code>在当前目录创建一个名为<code>file</code>的普通文件,默认权限为<code>不可执行，可读，可写</code>，当然touch支持生成不同权限的文件，这里不作讨论，对与Linux权限系统有兴趣的可以自行学习</p><h2 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h2><p><code>rm</code>可用于删除文件,同时也有可选参数，不带参数删除文件时，会询问确认</p><ul><li><code>rm &lt;文件名&gt;</code>删除文件，但会先询问确认</li><li><code>rm -f &lt;文件名&gt;</code>强制删除文件，不会确认</li><li><code>rm -rf &lt;文件名/目录名&gt;</code>强制递归删除文件&#x2F;目录，可用于删除含有多层结构的目录</li></ul><p>千万不要执行<code>rm -rf /</code>，否则会把系统文件也删了，这个操作系统就废掉了</p><h2 id="Linux编程"><a href="#Linux编程" class="headerlink" title="Linux编程"></a>Linux编程</h2><p>不同于Windows上常用的<code>集成开发环境</code>，如<code>Visual Studio</code>,<code>devC++</code>,Linux的开发环境为<code>文本编辑器</code>+<code>gcc/g++</code>编译器，二者是独立的。</p><h3 id="文本编辑器"><a href="#文本编辑器" class="headerlink" title="文本编辑器"></a>文本编辑器</h3><h4 id="Vim"><a href="#Vim" class="headerlink" title="Vim"></a>Vim</h4><p>最常用的Linux文本编辑器当属<code>vim</code>了，因为基本每台Linux服务器都是自带<code>vim</code>的，支持插件扩展和配置文件，这里不多作介绍</p><p><code>Vim</code>是一款文本编辑器,下面介绍在vim界面中的常用指令</p><p><strong>三种模式</strong>:<code>命令模式(Command Mode)</code> <code>插入模式（Insert Mode</code> <code>命令行模式（Command-Line Mode）</code>（这里称命令行模式为<code>底行模式</code>）</p><p>三者关系如下图</p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2023-12-11_10-39-04.png"></p><ul><li><p>命令模式<br><code>vim</code>界面中多摁几次<code>ESC</code>就能退出其它模式回到<code>命令模式</code>，在这个模式下可以使用一系列vim<a href="https://linux.cn/article-8144-1.html">快捷键</a></p></li><li><p>底行模式<br><code>tips</code>:不管目前是什么模式,先狂按<code>ESC</code>,回到<code>命令模式</code>,然后输入<code>:</code>进入<code>底行模式</code>,准备开始输命令</p></li></ul><p><code>命令组成</code><br><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2023-12-11_12-48-54.png"></p><ul><li><p>保存<code>:w</code>-&gt;强制保存<code>!w</code></p></li><li><p>退出<code>:q</code>-&gt;强制退出<code>:!q</code></p></li><li><p>保存并退出<code>:wq</code>-.强制保存并退出<code>:!wq</code></p></li><li><p>对比<code>:vs </code>+<code>(源文件路径)</code></p></li><li><p>插入模式<br>在<code>命令模式</code>下按键盘<code>i</code>进入<code>插入模式</code>，执行正常的文本编辑功能</p></li></ul><h4 id="vscode"><a href="#vscode" class="headerlink" title="vscode"></a>vscode</h4><p><code>vscode</code>本身就是<strong>文本编辑器</strong>,这是各种插件让它的功能多了起来,这里推荐安装<code>C/C++</code>相关的插件（其实它自己识别到C++文件就会推荐你安装的）。至于<code>vscode</code>怎么用，就跟平时在Windows上用一样，不过同时也可以用终端命令行来辅助操作。</p><h3 id="gcc-g-编译器"><a href="#gcc-g-编译器" class="headerlink" title="gcc&#x2F;g++编译器"></a>gcc&#x2F;g++编译器</h3><p><strong>gcc是专门编译C语言文件的，拿去编译C++文件会报错！！</strong></p><p>这里介绍g++的使用</p><p><code>g++</code>默认编译终端当前文件夹下的源文件，接下来介绍常见用法</p><ol><li>直接编译<br><code>g++ &lt;源文件&gt;</code>将直接编译目标源文件，并产生<code>a.out</code>可执行文件</li></ol><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202410010914401.png"></p><ol start="2"><li>自定义产生的目标可执行文件<br><code>g++ -o &lt;可执行文件名&gt; &lt;源文件&gt;</code>&#x2F;<code>g++ &lt;源文件&gt; -o &lt;可执行文件名&gt;</code>,二者皆可</li></ol><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202410010932958.png"></p><ol start="3"><li>编译产生目标文件(<code>*.o</code>)并链接产生可执行文件</li></ol><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202410011007675.png"></p><p>如图，使用<code>-c</code>参数可以编译产生<code>*.o</code>目标文件，最后再链接到同一个文件中。下面举一个实际例子</p><p>我们有如下源文件<code>main.cpp</code> <code>add.cpp</code> <code>sub.cpp</code> <code>add.hpp</code> <code>sub.hpp</code>(其中main.cpp已经#include了头文件)</p><p>我们将依次输入如下指令产生<code>mycmd</code>可执行文件</p><ul><li><code>g++ -c main.cpp -o main.o</code></li><li><code>g++ -c add.cpp -o add.o</code></li><li><code>g++ -c sub.cpp -o sub.o</code></li><li><code>g++ -o mycmd *.o</code>  <code>*.o</code>表示选中所有以<code>.o</code>结尾的文件</li></ul><p>通过如上四个指令，就完成了可执行文件的编译，结果如下图</p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202410011018172.png"></p><h2 id="Makefile入门"><a href="#Makefile入门" class="headerlink" title="Makefile入门"></a>Makefile入门</h2><p>讲真手动维护这些编译文件太麻烦了，有没有更高效，更自动化一点的方式呢？正好Linux服务器都提供了<code>makefile</code>工具用于构建项目</p><p>我们接下来学习如何用<code>makefile</code>自动编译代码和清理可执行文件</p><h3 id="创建makefile文件"><a href="#创建makefile文件" class="headerlink" title="创建makefile文件"></a>创建makefile文件</h3><p>实际上创建<code>makefile</code>和创建<code>Makefile</code>文件效果是一样的</p><h3 id="单源文件的makefile编写"><a href="#单源文件的makefile编写" class="headerlink" title="单源文件的makefile编写"></a>单源文件的makefile编写</h3><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202410140900036.png"></p><p>如上图为示例代码，接下来我们逐步讲解</p><p>在一段makefile语句中，通常遵循以下格式</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">&lt;目标文件&gt;:&lt;依赖文件&gt; (&lt;依赖文件2&gt; &lt;依赖文件3&gt; ...)</span></span><br><span class="line">    &lt;命令行命令&gt;</span><br><span class="line">    (&lt;命令行命令2&gt;)</span><br><span class="line">    (&lt;命令行命令3&gt;)</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>其中的<code>&lt;目标文件&gt;</code>就是我们这句<code>makefile</code>指令执行完毕后要产生的目标文件,依赖文件则是在执行这句<code>makefile</code>指令前，这些依赖文件必须存在，若不存在，则执行失败&#x2F;向后寻找可产生依赖文件的<code>makefile</code>命令并自动执行</p><p>至于命令行命令，就是我们在终端中输入的指令</p><p>图中还有个特殊的用法，就是<code>.PHONEY</code>声明<code>伪目标对象</code>,一个<code>伪</code>字就说明了它不是真正的文件，而是一个抽象的目标文件，执行该段<code>makefile</code>时不会在磁盘上真正创建这样的文件。因此它也有个特性–<code>每次调用该段语句都会执行命令</code>。那如果是不使用<code>.PHONY</code>的普通<code>makefile</code>语句段呢？它只会在依赖文件发生更新后，才会在调用时真正执行命令</p><p><strong>makefile的部分简化写法</strong></p><p>makefile里也是可以声明和调用变量的，这里先不介绍声明变量，主要介绍调用变量，因为它还提供了默认变量用于简化代码</p><p>其中调用变量的方法为<code>$</code>+<code>变量名</code>,常用的默认变量为</p><ul><li><code>$@</code>调用储存了<code>依赖文件</code>的变量</li><li><code>$^</code>调用储存了<code>目标文件</code>的变量</li></ul><p>以上图的的makefile为例，我们可以将其改写为:</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">mycmd:main.cpp</span></span><br><span class="line">g++ -o <span class="variable">$@</span> <span class="variable">$^</span></span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>:clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm -f mycmd</span><br></pre></td></tr></table></figure><p><strong>makefile指令的使用</strong><br>如何在终端调用makefile里写好的命令呢？<code>Linux</code>提供了一个指令，叫做<code>make</code>可用于调用<code>makefile</code>内的指令</p><p>具体用法为<code>make &lt;目标文件名&gt;</code>,比如要生成<code>clean</code>伪目标对象，（其实就是执行清理操作，而不是创建操作）,就要在终端输入<code>make clean</code></p><p><strong>特别的</strong>，为了方便使用，往往<code>makefile</code>文件的第一个目标文件的构建，可以省略参数，直接输入<code>make</code>再回车即可执行命令</p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202410011920420.png"></p><h4 id="综合使用之多文件编译"><a href="#综合使用之多文件编译" class="headerlink" title="综合使用之多文件编译"></a>综合使用之多文件编译</h4><p>我们有如下源文件<code>main.cpp</code> <code>add.cpp</code> <code>sub.cpp</code> <code>add.hpp</code> <code>sub.hpp</code>(其中main.cpp已经#include了头文件)</p><p>我们该如何用makefile一键(make)编译出可执行文件呢？这里就要用到上文的知识，组织好文件之间的依赖关系和构建指令</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">mycmd:main.o add.o sub.o</span></span><br><span class="line">g++ -o mycmd *.o</span><br><span class="line"></span><br><span class="line"><span class="section">main.o:main.cpp</span></span><br><span class="line">g++ -c main.cpp -o main.o</span><br><span class="line"></span><br><span class="line"><span class="section">add.o:add.cpp</span></span><br><span class="line">g++ -c add.cpp -o add.o</span><br><span class="line"></span><br><span class="line"><span class="section">sub.o:sub.cpp</span></span><br><span class="line">g++ -c sub.cpp -o sub.o</span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>:clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm -f mycmd *.o</span><br></pre></td></tr></table></figure><p>代码如上，最终的<code>mycmd</code>文件依赖<code>main.o</code>,<code>add.o</code>,<code>sub.o</code>，所以后文又提供了这三者的构建方法，最后再提供一个clean方法用于清理文件</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>以上便是Linux平台CPP编程常用到的工具和方法</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>设计模式的C++实现(2)——代理模式</title>
      <link href="/2024/09/24/DP-proxy/"/>
      <url>/2024/09/24/DP-proxy/</url>
      
        <content type="html"><![CDATA[<h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><blockquote><p><strong>模式名称</strong>: 代理模式-Proxy<br><strong>类型</strong>: 结构型<br><strong>问题-使用场景</strong>: 在执行类和用户间再增加一个中间人，执行类的交互对于用户来说过于复杂，执行类的接口对参数检查较严格等<br><strong>解决方案</strong>： 可以封装一个类，为用户提供更简洁的接口，而与执行类的交互在其内部实现；或者封装一个头文件，在里面封装全局函数和宏函数等<br><strong>效果</strong>： 增加代码复杂性，封装层数更高，更加抽象。具体实现方式十分多样，增加了代码编写者的工作，但减少了用户的使用难度，也能一定程度上提高安全性</p></blockquote><p>代理模式指代理控制对其他对象的访问， 也就是<strong>代理对象控制对原对象的引⽤</strong>。在某些情况下，⼀<strong>个对象不适合或者不能直接被引⽤访问</strong>，⽽代理对象可以在客⼾端和⽬标对象之间起到<code>中介的作⽤</code>。代理模式的结构包括⼀个是真正的你要访问的对象(⽬标类)、⼀个是代理对象。⽬标对象与代理对象实现同⼀个接⼝，先访问代理类再通过代理类访问⽬标对象</p><p>按照编译时和运行时的行为，代理模式分为<code>静态代理</code>、<code>动态代理</code>：</p><ul><li><code>静态代理</code>指的是，在<strong>编译时就</strong>已经<strong>确定好</strong>了代理类和被代理类的关系。也就是说，在编译时就已经确定了代理类要代理的是哪个被代理类。</li><li><code>动态代理</code>指的是，在<strong>运⾏时才动态⽣成</strong>代理类，并将其与被代理类绑定。这意味着，在运⾏时才能确定代理类要代理的是哪个被代理类。</li></ul><p><em>以租房为例，房东将房⼦租出去，但是要租房⼦出去，需要发布招租启⽰， 带⼈看房，负责维修，这些⼯作中有些操作并⾮房东能完成，因此房东为了图省事，将房⼦委托给中介进⾏租赁。</em></p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202409260830884.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*房东要把⼀个房⼦通过中介租出去理解代理模式*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RentHouse</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">rentHouse</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*房东类：将房⼦租出去*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Landlord</span> : <span class="keyword">public</span> RentHouse &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rentHouse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;将房⼦租出去\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*中介代理类：对租房⼦进⾏功能加强，实现租房以外的其他功能*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Intermediary</span> : <span class="keyword">public</span> RentHouse &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rentHouse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;发布招租启⽰\n&quot;</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;带⼈看房\n&quot;</span>;</span><br><span class="line">_landlord.<span class="built_in">rentHouse</span>();</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;负责租后维修\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Landlord _landlord;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Intermediary intermediary;</span><br><span class="line">intermediary.<span class="built_in">rentHouse</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="具体应用"><a href="#具体应用" class="headerlink" title="具体应用"></a>具体应用</h1><ul><li><a href="https://www.supdriver.top/2024/09/24/muiltiDesignPatternsLogSystem/">C++基于多设计模式下的同步&amp;异步⽇志系统🔗</a>中对日志系统使用代理模式，用<code>suplog.hpp</code>作为代理人与用户交互</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式的C++实现(1)——单例模式</title>
      <link href="/2024/09/24/DP-singelton-pattern/"/>
      <url>/2024/09/24/DP-singelton-pattern/</url>
      
        <content type="html"><![CDATA[<h1 id="单例模式介绍"><a href="#单例模式介绍" class="headerlink" title="单例模式介绍"></a>单例模式介绍</h1><blockquote><p><strong>模式名称</strong>: 单例模式-Singleton<br><strong>类型</strong>: 创建型<br><strong>问题-使用场景</strong>: 希望一个类在全局只实例化出一个对象<br><strong>解决方案</strong>： 使用静态成员，将构造函数私有化，删除拷贝构造和<code>opetator=()</code>函数<br><strong>效果</strong>： 略微增加代码复杂性，使用了静态成员变量&#x2F;函数。但是能够保证该类只会有一个实例。</p></blockquote><p><strong>⼀个类只能创建⼀个对象，即单例模式</strong>，该设计模式可以保证系统中该类只有⼀个实例，并提供⼀个访问它的全局访问点，该实例被所有程序模块共享。⽐如在某个服务器程序中，该服务器的配置信息存放在⼀个⽂件中，这些配置数据由⼀个单例对象统⼀读取，然后服务进程中的其他对象再通过这个单例对象获取这些配置信息，这种⽅式<strong>简化了在复杂环境下的配置管理</strong>。</p><p>单例模式有两种实现模式：<code>饿汉模式</code>和<code>懒汉模式</code></p><h2 id="饿汉模式"><a href="#饿汉模式" class="headerlink" title="饿汉模式"></a>饿汉模式</h2><p>饿汉模式中，<strong>程序启动时</strong>就会创建⼀个唯⼀的实例对象。 因为单例对象已经确定， 所以⽐较适⽤于<strong>多线程环境中</strong>， 多线程获取单例对象不需要加锁， 可以有效的避免资源竞争,⾼性能。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">static</span> T _eton;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">Singleton</span>() &#123;&#125;<span class="comment">//私有化构造函数</span></span><br><span class="line">~<span class="built_in">Singleton</span>() &#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;<span class="comment">//删除拷贝构造</span></span><br><span class="line">Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;<span class="comment">//删除赋值运算重载</span></span><br><span class="line"><span class="function"><span class="type">static</span> T&amp; <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _eton;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T Singleton&lt;T&gt;::_eton = <span class="built_in">T</span>();</span><br></pre></td></tr></table></figure><h2 id="懒汉模式"><a href="#懒汉模式" class="headerlink" title="懒汉模式"></a>懒汉模式</h2><p>懒汉模式:第⼀次使⽤要使⽤单例对象的时候创建实例对象。如果单例对象构造特别<strong>耗时</strong>或者<strong>耗费济源</strong>(加载插件、加载⽹络资源等)， 可以选择懒汉模式， 在第⼀次使⽤的时候才创建对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//懒汉模式</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">Singleton</span>() &#123;&#125;</span><br><span class="line">~<span class="built_in">Singleton</span>() &#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="function"><span class="type">static</span> T&amp; <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">static</span> T _eton=<span class="built_in">T</span>();</span><br><span class="line"><span class="keyword">return</span> _eton;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="具体应用"><a href="#具体应用" class="headerlink" title="具体应用"></a>具体应用</h1><ul><li><a href="https://www.supdriver.top/2024/09/24/muiltiDesignPatternsLogSystem/">C++基于多设计模式下的同步&amp;异步⽇志系统🔗</a>中对全局建造者使用单例模式</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式的C++实现(3)——工厂模式与建造者模式</title>
      <link href="/2024/09/24/DP-factory-pattern/"/>
      <url>/2024/09/24/DP-factory-pattern/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>模式名称</strong>: 工厂模式-Factory<br><strong>类型</strong>: 创建型<br><strong>问题-使用场景</strong>: 当创建不同对象的过程过于复杂，或者需要隐藏&#x2F;封装创建对象的具体过程，或需要创建同一家族的产品（对象）时<br><strong>解决方案</strong>：将创建对象的过程封装到工厂类内，并提供设置创建不同对象的接口<br><strong>效果</strong>： 简化了用户操作，使创建对象，创建多个不同的对象更为简单易用，提高了代码的封装性。但是代码复杂性大大提高，类封装的层次更多了，可扩展性会有所欠缺。</p></blockquote><blockquote><p><strong>模式名称</strong>: 建造者模式-Builder<br><strong>类型</strong>: 创建型<br><strong>问题-使用场景</strong>: 当创建不同对象的过程过于复杂，或者需要隐藏&#x2F;封装创建对象的具体过程，或需要创建同一家族的产品（对象）时<br><strong>解决方案</strong>：将创建对象的过程封装到Builder内，并提供设置创建不同对象的接口，以及提供不同的Builder派生类,最后提供一个<code>指挥者类</code>统一指挥对象的创建<br><strong>效果</strong>： <strong>可扩展性强</strong>的同时，简化了用户操作，使创建对象，创建多个不同的对象更为简单易用，提高了代码的封装性。但是代码复杂性大大提高，类封装的层次更多了。</p></blockquote><p>⼯⼚模式是⼀种创建型设计模式， 它提供了⼀种创建对象的最佳⽅式。在⼯⼚模式中，我们创建对象时不会对上层暴露创建逻辑，⽽是通过使⽤⼀个共同结构来指向新创建的对象，以此实现创建-使⽤的分离。</p><p>工厂模式可分为以下三种：</p><ul><li>简单工厂模式</li><li>工厂方法模式</li><li>抽象工厂模式</li></ul><p>接下来我们具体介绍这三种工厂模式</p><h1 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h1><p>简单⼯⼚模式实现由⼀个<code>⼯⼚对象</code>通过<code>类型决定</code>创建出来指定产品类的实例。假设有个⼯⼚能⽣产出⽔果，当客⼾需要产品的时候明确告知⼯⼚⽣产哪类⽔果，⼯⼚需要接收⽤⼾提供的类别信息，当新增产品的时候，<code>⼯⼚内部去添加</code>新产品的⽣产⽅式</p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202409251006985.png"></p><ul><li><strong>优点</strong>:简单粗暴，直观易懂。使⽤⼀个⼯⼚⽣产同⼀等级结构下的任意产品</li><li><strong>缺点</strong>:<ul><li>所有东西⽣产在⼀起，产品太多会导致代码量庞⼤</li><li>开闭原则遵循(开放拓展，关闭修改)的不是太好，要新增产品就必须修改⼯⼚⽅法。</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Fruit</span> &#123;<span class="comment">//水果的抽象类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Fruit</span>() &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Apple</span> : <span class="keyword">public</span> Fruit &#123;<span class="comment">//苹果类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Apple</span>() &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;我是⼀个苹果&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Banana</span> : <span class="keyword">public</span> Fruit &#123;<span class="comment">//香蕉类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Banana</span>() &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;我是⼀个⾹蕉&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FruitFactory</span> &#123;<span class="comment">//水果工厂类,能生茶哪些水果由名字和内部代码决定</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//当前代码只能生产苹果或香蕉,扩展性差</span></span><br><span class="line"><span class="function"><span class="type">static</span> std::shared_ptr&lt;Fruit&gt; <span class="title">create</span><span class="params">(<span class="type">const</span> std::string&amp; name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (name == <span class="string">&quot;苹果&quot;</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> std::<span class="built_in">make_shared</span>&lt;Apple&gt;();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (name == <span class="string">&quot;⾹蕉&quot;</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> std::<span class="built_in">make_shared</span>&lt;Banana&gt;();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> std::<span class="built_in">shared_ptr</span>&lt;Fruit&gt;();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//fruit有使用多态</span></span><br><span class="line">std::shared_ptr&lt;Fruit&gt; fruit = FruitFactory::<span class="built_in">create</span>(<span class="string">&quot;苹果&quot;</span>);</span><br><span class="line">fruit-&gt;<span class="built_in">show</span>();</span><br><span class="line">fruit = FruitFactory::<span class="built_in">create</span>(<span class="string">&quot;⾹蕉&quot;</span>);</span><br><span class="line">fruit-&gt;<span class="built_in">show</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个模式的结构和管理产品对象的⽅式⼗分简单， 但是它的<strong>扩展性⾮常差</strong>，当我们需要新增产品的时候，就需要去修改⼯⼚类新增⼀个类型的产品创建逻辑，违背了开闭原则。</p><h1 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h1><p>在简单⼯⼚模式下新增多个⼯⼚，多个产品，<strong>每个产品对应⼀个⼯⼚</strong>。假设现在有A、B 两种产品，则开两个⼯⼚，⼯⼚ A 负责⽣产产品 A，⼯⼚ B 负责⽣产产品 B，⽤⼾只知道产品的⼯⼚名，⽽不知道具体的产品信息，⼯⼚不需要再接收客⼾的产品类别，⽽只负责⽣产产品。</p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202409251031391.png"></p><ul><li><strong>优点</strong>:<ul><li><strong>减轻了⼯⼚类的负担</strong>，将某类产品的⽣产交给指定的⼯⼚来进⾏</li><li><strong>开闭原则遵循较好</strong>，添加新产品只需要新增产品的⼯⼚即可，不需要修改原先的⼯⼚类</li></ul></li><li><strong>缺点</strong>： 缺点：对于某种可以形成⼀组产品族的情况处理较为复杂,需要<strong>创建⼤量的⼯⼚类</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Fruit</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Fruit</span>() &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Apple</span> : <span class="keyword">public</span> Fruit &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Apple</span>() &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;我是⼀个苹果&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">std::string _color;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Banana</span> : <span class="keyword">public</span> Fruit &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Banana</span>() &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;我是⼀个⾹蕉&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FruitFactory</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> std::shared_ptr&lt;Fruit&gt; <span class="title">create</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//手写一个苹果工厂类，继承父类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AppleFactory</span> : <span class="keyword">public</span> FruitFactory &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> std::shared_ptr&lt;Fruit&gt; <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> std::<span class="built_in">make_shared</span>&lt;Apple&gt;();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//手写一个香蕉工厂类，继承父类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BananaFactory</span> : <span class="keyword">public</span> FruitFactory &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> std::shared_ptr&lt;Fruit&gt; <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> std::<span class="built_in">make_shared</span>&lt;Banana&gt;();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//factory有使用多态</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;FruitFactory&gt; <span class="title">factory</span><span class="params">(<span class="keyword">new</span> AppleFactory())</span></span>;</span><br><span class="line"><span class="comment">//fruit有使用多态</span></span><br><span class="line">std::shared_ptr&lt;Fruit&gt; fruit;</span><br><span class="line">fruit = factory-&gt;<span class="built_in">create</span>();</span><br><span class="line">fruit-&gt;<span class="built_in">show</span>();</span><br><span class="line">factory.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">BananaFactory</span>());</span><br><span class="line">fruit = factory-&gt;<span class="built_in">create</span>();</span><br><span class="line">fruit-&gt;<span class="built_in">show</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h1><p>⼯⼚⽅法模式通过引⼊⼯⼚等级结构，解决了简单⼯⼚模式中⼯⼚类职责太重的问题，但由于⼯⼚⽅法模式中的<strong>每个⼯⼚只⽣产⼀类产品</strong>，可能会导致系统中存在 <strong>⼤量的⼯⼚类</strong>，势必会增加系统的开销。此时，我们可以考虑将⼀些<strong>相关的产品组成⼀个产品族</strong>（位于不同产品等级结构中功能相关联的产品组成的家族），由同⼀个⼯⼚来统⼀⽣产，这就是抽象⼯⼚模式的基本思想。</p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202409251106237.png"></p><ul><li><strong>优点</strong>:采用了分层结构</li><li><strong>缺点</strong>:违背了开闭原则，可扩展性差，扩展新产品线时需要对原代码有大量修改</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Fruit</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Fruit</span>() &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Apple</span> : <span class="keyword">public</span> Fruit &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Apple</span>() &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;我是⼀个苹果&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">std::string _color;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Banana</span> : <span class="keyword">public</span> Fruit &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Banana</span>() &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;我是⼀个⾹蕉&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">voice</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Lamp</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">voice</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;咩咩咩\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">voice</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;汪汪汪\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> std::shared_ptr&lt;Fruit&gt; <span class="title">getFruit</span><span class="params">(<span class="type">const</span> std::string&amp; name)</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> std::shared_ptr&lt;Animal&gt; <span class="title">getAnimal</span><span class="params">(<span class="type">const</span> std::string&amp; name)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FruitFactory</span> : <span class="keyword">public</span> Factory &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> std::shared_ptr&lt;Animal&gt; <span class="title">getAnimal</span><span class="params">(<span class="type">const</span> std::string&amp; name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> std::<span class="built_in">shared_ptr</span>&lt;Animal&gt;();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> std::shared_ptr&lt;Fruit&gt; <span class="title">getFruit</span><span class="params">(<span class="type">const</span> std::string&amp; name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (name == <span class="string">&quot;苹果&quot;</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> std::<span class="built_in">make_shared</span>&lt;Apple&gt;();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (name == <span class="string">&quot;⾹蕉&quot;</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> std::<span class="built_in">make_shared</span>&lt;Banana&gt;();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> std::<span class="built_in">shared_ptr</span>&lt;Fruit&gt;();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AnimalFactory</span> : <span class="keyword">public</span> Factory &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> std::shared_ptr&lt;Fruit&gt; <span class="title">getFruit</span><span class="params">(<span class="type">const</span> std::string&amp; name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> std::<span class="built_in">shared_ptr</span>&lt;Fruit&gt;();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> std::shared_ptr&lt;Animal&gt; <span class="title">getAnimal</span><span class="params">(<span class="type">const</span> std::string&amp; name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (name == <span class="string">&quot;⼩⽺&quot;</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> std::<span class="built_in">make_shared</span>&lt;Lamp&gt;();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (name == <span class="string">&quot;⼩狗&quot;</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> std::<span class="built_in">make_shared</span>&lt;Dog&gt;();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> std::<span class="built_in">shared_ptr</span>&lt;Animal&gt;();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FactoryProducer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">static</span> std::shared_ptr&lt;Factory&gt; <span class="title">getFactory</span><span class="params">(<span class="type">const</span> std::string&amp; name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (name == <span class="string">&quot;动物&quot;</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> std::<span class="built_in">make_shared</span>&lt;AnimalFactory&gt;();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> std::<span class="built_in">make_shared</span>&lt;FruitFactory&gt;();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::shared_ptr&lt;Factory&gt; fruit_factory = FactoryProducer::<span class="built_in">getFactory</span>(<span class="string">&quot;⽔果&quot;</span>);</span><br><span class="line">std::shared_ptr&lt;Fruit&gt; fruit = fruit_factory-&gt;<span class="built_in">getFruit</span>(<span class="string">&quot;苹果&quot;</span>);</span><br><span class="line">fruit-&gt;<span class="built_in">show</span>();</span><br><span class="line">fruit = fruit_factory-&gt;<span class="built_in">getFruit</span>(<span class="string">&quot;⾹蕉&quot;</span>);</span><br><span class="line">fruit-&gt;<span class="built_in">show</span>();</span><br><span class="line">std::shared_ptr&lt;Factory&gt; animal_factory = FactoryProducer::<span class="built_in">getFactory</span>(<span class="string">&quot;动物&quot;</span>);</span><br><span class="line">std::shared_ptr&lt;Animal&gt; animal = animal_factory-&gt;<span class="built_in">getAnimal</span>(<span class="string">&quot;⼩⽺&quot;</span>);</span><br><span class="line">animal-&gt;<span class="built_in">voice</span>();</span><br><span class="line">animal = animal_factory-&gt;<span class="built_in">getAnimal</span>(<span class="string">&quot;⼩狗&quot;</span>);</span><br><span class="line">animal-&gt;<span class="built_in">voice</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象⼯⼚模式适⽤于⽣产多个⼯⼚系列产品衍⽣的设计模式，增加新的产品等级结构复杂，需要对原有系统进⾏较⼤的修改，甚⾄需要修改抽象层代码，<strong>违背了“开闭原则”</strong>。</p><p>不过比较有意思的是具体的工厂（例如水果工厂）又可以采用不同的设计模式，不一定是简单工厂模式</p><h1 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h1><p>建造者模式是⼀种创建型设计模式， 使⽤多个简单的对象<strong>⼀步⼀步构建</strong>成⼀个复杂的对象，能够将⼀个复杂的对象的构建与它的表⽰分离，提供⼀种创建对象的最佳⽅式。主要⽤于解决对象的构建过于复杂的问题。</p><p>建造者模式基于四个核心实现:</p><ul><li>抽象产品类</li><li>具体产品类： 一个具体的产品对象类</li><li>抽象<code>Builder类</code>:实现抽象接口，构建各个部件</li><li>指挥者<code>Director类</code>:统一组件过程，提供给调用者使用，通过指挥者来构造产品</li></ul><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202409260755865.png"></p><ul><li><code>优点</code>:<ul><li>具体产品和具体的建造者都继承自抽象类</li><li>由统一的指挥者类指挥构建,不同的产品类有统一的实例化方式</li><li>可扩展性强,仅需实现不同的具体产品类和具体的建造者类</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="comment">/*抽象电脑类*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Computer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">using</span> ptr = std::shared_ptr&lt;Computer&gt;;</span><br><span class="line"><span class="built_in">Computer</span>() &#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setBoard</span><span class="params">(<span class="type">const</span> std::string&amp; board)</span> </span>&#123; _board = board; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setDisplay</span><span class="params">(<span class="type">const</span> std::string&amp; display)</span> </span>&#123; _display = display; &#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">setOs</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function">std::string <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::string computer = <span class="string">&quot;Computer:&#123;\n&quot;</span>;</span><br><span class="line">computer += <span class="string">&quot;\tboard=&quot;</span> + _board + <span class="string">&quot;,\n&quot;</span>;</span><br><span class="line">computer += <span class="string">&quot;\tdisplay=&quot;</span> + _display + <span class="string">&quot;,\n&quot;</span>;</span><br><span class="line">computer += <span class="string">&quot;\tOs=&quot;</span> + _os + <span class="string">&quot;,\n&quot;</span>;</span><br><span class="line">computer += <span class="string">&quot;&#125;\n&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> computer;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">std::string _board;</span><br><span class="line">std::string _display;</span><br><span class="line">std::string _os;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*具体产品类*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MacBook</span> : <span class="keyword">public</span> Computer &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">using</span> ptr = std::shared_ptr&lt;MacBook&gt;;</span><br><span class="line"><span class="built_in">MacBook</span>() &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">setOs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">_os = <span class="string">&quot;Max Os X12&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*抽象建造者类：包含创建⼀个产品对象的各个部件的抽象接⼝*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Builder</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">using</span> ptr = std::shared_ptr&lt;Builder&gt;;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">buildBoard</span><span class="params">(<span class="type">const</span> std::string&amp; board)</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">buildDisplay</span><span class="params">(<span class="type">const</span> std::string&amp; display)</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">buildOs</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> Computer::ptr <span class="title">build</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*具体产品的具体建造者类：实现抽象接⼝，构建和组装各个部件*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MacBookBuilder</span> : <span class="keyword">public</span> Builder &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">using</span> ptr = std::shared_ptr&lt;MacBookBuilder&gt;;</span><br><span class="line"><span class="built_in">MacBookBuilder</span>() : _computer(<span class="keyword">new</span> <span class="built_in">MacBook</span>()) &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">buildBoard</span><span class="params">(<span class="type">const</span> std::string&amp; board)</span> </span>&#123;</span><br><span class="line">_computer-&gt;<span class="built_in">setBoard</span>(board);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">buildDisplay</span><span class="params">(<span class="type">const</span> std::string&amp; display)</span> </span>&#123;</span><br><span class="line">_computer-&gt;<span class="built_in">setDisplay</span>(display);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">buildOs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">_computer-&gt;<span class="built_in">setOs</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> Computer::ptr <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> _computer;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Computer::ptr _computer;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*指挥者类，提供给调⽤者使⽤，通过指挥者来构造复杂产品*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Director</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Director</span>(Builder* builder) :_builder(builder) &#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">construct</span><span class="params">(<span class="type">const</span> std::string&amp; board, <span class="type">const</span> std::string&amp; display)</span> </span>&#123;</span><br><span class="line">_builder-&gt;<span class="built_in">buildBoard</span>(board);</span><br><span class="line">_builder-&gt;<span class="built_in">buildDisplay</span>(display);</span><br><span class="line">_builder-&gt;<span class="built_in">buildOs</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Builder::ptr _builder;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Builder* buidler = <span class="keyword">new</span> <span class="built_in">MacBookBuilder</span>();</span><br><span class="line"><span class="function">std::unique_ptr&lt;Director&gt; <span class="title">pd</span><span class="params">(<span class="keyword">new</span> Director(buidler))</span></span>;</span><br><span class="line">pd-&gt;<span class="built_in">construct</span>(<span class="string">&quot;英特尔主板&quot;</span>, <span class="string">&quot;VOC显⽰器&quot;</span>);</span><br><span class="line">Computer::ptr computer = buidler-&gt;<span class="built_in">build</span>();</span><br><span class="line">std::cout &lt;&lt; computer-&gt;<span class="built_in">toString</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>很明显，各个工厂模式和最后的建造者模式各有优劣：</p><ul><li>简单的场景用简单工厂就很好</li><li>需要形成产品族时，抽象工厂模式的结构就很清晰</li><li>需要很强的扩展性时，建造者模式就很符合要求</li></ul><p>所以各种设计模式都应当学习，理解其最适用的应用场景</p>]]></content>
      
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【版本v1.0】C++基于多设计模式下的同步&amp;异步⽇志系统</title>
      <link href="/2024/09/24/MDPLS-v1/"/>
      <url>/2024/09/24/MDPLS-v1/</url>
      
        <content type="html"><![CDATA[<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><ul><li><a href="https://www.supdriver.top/2024/08/13/logSystem/">Linux日志器（简易版）</a></li><li><a href="https://www.supdriver.top/2024/08/14/thread/">初识Linux线程</a></li><li><a href="https://www.supdriver.top/2024/09/24/DP-singelton-pattern/">初识设计模式&amp;单例模式&amp;代理模式–设计模式介绍(1)</a></li><li><a href="https://www.supdriver.top/2024/09/24/DP-factory-pattern/">工厂模式与建造者模式–设计模式介绍(2)</a></li></ul><h1 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h1><h2 id="背景引入"><a href="#背景引入" class="headerlink" title="背景引入"></a>背景引入</h2><blockquote><p>日志系统在软件开发和运维中扮演着至关重要的角色，主要体现在以下几个方面：</p><p><code>问题排查和调试</code>：日志记录了系统运行过程中的重要信息，包括错误信息、异常堆栈、接口调用信息等。开发人员可以通过分析日志快速定位问题，减少排查时间，提高开发效率。</p><p><code>性能监控</code>：通过记录应用程序的性能指标（如响应时间、请求吞吐量等），开发团队可以监控系统的健康状态，发现性能瓶颈并进行优化。</p><p><code>安全审计</code>：日志可以记录用户的操作和系统事件，为后期的安全审计提供依据。一旦发生安全事件，通过分析日志可以追踪到攻击来源和攻击方式。</p><p><code>用户行为分析</code>：通过对日志进行分析，开发团队可以了解用户的使用习惯和需求，这有助于改进产品功能和用户体验。</p><p><code>合规要求</code>：在许多行业中，日志记录是合规的要求之一。维护完整的日志记录可以帮助企业满足法律法规和行业标准。</p><p><code>系统健康监控</code>：通过实时监控日志，可以及时发现系统异常，进行预警和自动化处理，从而提高系统的可用性和稳定性。</p><p><code>故障恢复</code>：在系统出现故障时，日志记录可以帮助开发和运维人员还原问题发生前的状态，从而有助于快速恢复系统。</p></blockquote><p>总之，良好的日志系统能够帮助开发和运维团队提高效率、强化安全、提升用户体验，并确保系统的稳定性和可靠性。因此，在系统设计时，合理规划和实施日志记录机制是非常必要的。</p><h2 id="目标功能"><a href="#目标功能" class="headerlink" title="目标功能"></a>目标功能</h2><p>相比之前较为简单的<strong>日志类</strong>,我们这次将日志系统其升级为一个项目级的完整系统。</p><p>因此，我们要实现更多的功能:</p><ul><li>⽀持多级别⽇志消息</li><li>⽀持同步⽇志和异步⽇志</li><li>⽀持<strong>可靠写⼊</strong>⽇志到控制台、⽂件以及滚动⽂件中</li><li>⽀持<strong>多线程程序并发</strong>写⽇志</li><li>⽀持扩展不同的⽇志⽬标落地</li></ul><h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h2><ul><li>Linux环境（Ubuntu&#x2F;CentOS）</li><li>vscode&#x2F;vim 文本编辑器</li><li>g++&#x2F;gdb 编译器</li><li>Makefile</li></ul><h2 id="核心技术应用"><a href="#核心技术应用" class="headerlink" title="核心技术应用"></a>核心技术应用</h2><ul><li>类层次设计（抽象类，继承和多态的应用）</li><li>C++11 新语法的应用（多线程，右值引用等）</li><li>双缓冲区</li><li>生产者消费者模型</li><li>多线程与线程安全</li><li>多设计模式（单例，工厂，建造，代理者等）</li></ul><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>本项目不依赖其它任何第三方库，准备好Linux环境和文本编辑器即可</p><h2 id="日志系统再介绍"><a href="#日志系统再介绍" class="headerlink" title="日志系统再介绍"></a>日志系统再介绍</h2><h3 id="为什么需要日志系统"><a href="#为什么需要日志系统" class="headerlink" title="为什么需要日志系统"></a>为什么需要日志系统</h3><ul><li>⽣产环境的产品为了保证其稳定性及安全性是<strong>不允许开发⼈员附加调试器</strong>去排查问题， 可以借助⽇志系统来打印⼀些⽇志帮助开发⼈员解决问题</li><li>上线客⼾端的产品<strong>出现bug⽆法复现</strong>并解决， 可以借助⽇志系统打印⽇志并上传到服务端帮助开发⼈员进⾏分析</li><li>对于⼀些⾼频操作（如定时器、⼼跳包）在少量调试次数下可能⽆法触发我们想要的⾏为，通过断点的暂停**⽅式，我们不得不重复操作⼏⼗次、上百次甚⾄更多，导致排查问题效率是⾮常低下， 可以借助打印⽇志的⽅式查问题</li><li>在<strong>分布式、多线程&#x2F;多进程代码</strong>中， 出现bug⽐较<strong>难以定位</strong>， 可以借助⽇志系统打印log<strong>帮助定位</strong>bug</li><li>帮助 <strong>⾸次接触</strong>项⽬代码的新开发⼈员理解代码的运⾏流程</li></ul><h3 id="日志系统的技术实现"><a href="#日志系统的技术实现" class="headerlink" title="日志系统的技术实现"></a>日志系统的技术实现</h3><p>日志系统的技术实现主要报错三种类型：</p><ul><li><ol><li><code>控制台输出</code>:利用printf,std::cout等输出函数将日志信息打印到控制台</li></ol></li><li><code>文件输出</code>:对于⼤型商业化项⽬， 为了⽅便排查问题，我们⼀般会将⽇志输出到⽂件或者是数据库系统⽅便查询和分析⽇志， 主要分为同步⽇志和异步⽇志⽅式<ol start="2"><li>同步写日志</li><li>异步写日志</li></ol></li></ul><h4 id="同步写日志"><a href="#同步写日志" class="headerlink" title="同步写日志"></a>同步写日志</h4><p>同步⽇志是指当输出⽇志时，必须等待⽇志输出语句执⾏完毕后，才能执⾏后⾯的业务逻辑语句，⽇志输出语句与程序的业务逻辑语句将在同⼀个线程运⾏。每次调⽤⼀次打印⽇API就对应⼀次系统调⽤write写⽇志⽂件。</p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202409261006084.png"></p><p>在⾼并发场景下，随着⽇志数量不断增加，同步⽇志系统容易产⽣系统瓶颈：</p><ul><li>⼀⽅⾯，⼤量的⽇志打印陷⼊等量的write系统调⽤，有⼀定系统开销</li><li>另⼀⽅⾯，使得打印⽇志的进程附带了⼤量同步的磁盘IO，影响程序性能</li></ul><h4 id="异步写日志"><a href="#异步写日志" class="headerlink" title="异步写日志"></a>异步写日志</h4><p>异步⽇志是指在进⾏⽇志输出时，⽇志输出语句与业务逻辑语句并不是在同⼀个线程中运⾏，⽽是<strong>有专⻔的线程</strong>⽤于进⾏⽇志输出操作。业务线程只需要将⽇志放到⼀个<strong>内存缓冲区</strong>中不⽤等待即可继续执⾏后续业务逻辑（作为⽇志的⽣产者），⽽⽇志的落地操作交给单独的⽇志线程去完成（作为⽇志的消费者）,这是一个典型的<code>生产者-消费者模型</code></p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202409261023775.png"></p><p>这样做的好处是即使⽇志没有真的地完成输出也不会影响程序的主业务，可以提⾼程序的性能：</p><ul><li>主线程调⽤⽇志打印接⼝成为⾮阻塞操作</li><li>同步的磁盘IO从主线程中剥离出来交给单独的线程完成</li></ul><h1 id="日志系统框架设计"><a href="#日志系统框架设计" class="headerlink" title="日志系统框架设计"></a>日志系统框架设计</h1><p>本项⽬实现的是⼀个<strong>多⽇志器⽇志系统</strong>，主要实现的功能是让程序员能够轻松的将程序运⾏⽇志信息落地到指定的位置，且⽀持同步与异步<strong>两种⽅式</strong>的⽇志落地⽅式。</p><p>项⽬的框架设计将项⽬分为以下⼏个模块来实现。</p><h2 id="模块划分"><a href="#模块划分" class="headerlink" title="模块划分"></a>模块划分</h2><ul><li><code>⽇志等级模块</code>：对输出⽇志的等级进⾏划分，以便于控制⽇志的输出，并提供等级枚举转字符串功能。<ul><li><code>OFF</code>：关闭</li><li><code>DEBUG</code>：调试，调试时的关键信息输出。</li><li><code>INFO</code>：提⽰，普通的提⽰型⽇志信息。</li><li><code>WARN</code>：警告，不影响运⾏，但是需要注意⼀下的⽇志。</li><li><code>ERROR</code>：错误，程序运⾏出现错误的⽇志</li><li><code>FATAL</code>：致命，⼀般是代码异常导致程序⽆法继续推进运⾏的⽇志</li></ul></li><li><code>⽇志消息模块</code>：中间存储⽇志输出所需的各项要素信息<ul><li><code>时间</code>：描述本条⽇志的输出时间。</li><li><code>线程ID</code>：描述本条⽇志是哪个线程输出的。</li><li><code>⽇志等级</code>：描述本条⽇志的等级。</li><li><code>⽇志数据</code>：本条⽇志的有效载荷数据。</li><li><code>⽇志⽂件名</code>：描述本条⽇志在哪个源码⽂件中输出的。</li><li><code>⽇志⾏号</code>：描述本条⽇志在源码⽂件的哪⼀⾏输出的。</li></ul></li><li><code>⽇志消息格式化模块</code>：设置⽇志输出格式，并提供对⽇志消息进⾏格式化功能。<ul><li><code>系统的默认⽇志输出格式</code>： <code>%d｛%H:%M:%S｝%T[%t]%T[%p]%T[%c]%T%f:%l%T%m%n</code></li><li><code>%d｛%H:%M:%S｝</code>：表⽰⽇期时间，花括号中的内容表⽰⽇期时间的格式。（<strong>注：这里用本应用英文花括号，但是由于网站限制，暂时改成了中文花括号,上，下同，但多行代码框里是对的</strong>）</li><li><code>%T</code>：表⽰制表符缩进。</li><li><code>%t</code>：表⽰线程ID</li><li><code>%p</code>：表⽰⽇志级别</li><li><code>%c</code>：表⽰⽇志器名称，不同的开发组可以创建⾃⼰的⽇志器进⾏⽇志输出，⼩组之间互不影响。</li><li><code>%f</code>：表⽰⽇志输出时的源代码⽂件名。</li><li><code>%l</code>：表⽰⽇志输出时的源代码⾏号。</li><li><code>%m</code>：表⽰给与的⽇志有效载荷数据</li><li><code>%n</code>：表⽰换⾏</li><li>设计思想：设计不同的⼦类，不同的⼦类从⽇志消息中取出不同的数据进⾏处理。</li></ul></li><li><code>⽇志消息落地模块</code>：决定了⽇志的落地⽅向，可以是标准输出，也可以是⽇志⽂件，也可以滚动⽂件输出<ul><li><code>标准输出</code>：表⽰将⽇志进⾏标准输出的打印</li><li><code>⽇志⽂件输出</code>：表⽰将⽇志写⼊指定的⽂件末尾。</li><li><code>滚动⽂件输出</code>：当前以⽂件⼤⼩进⾏控制，当⼀个⽇志⽂件⼤⼩达到指定⼤⼩，则切换下⼀个⽂件进⾏输出</li><li>后期，也可以扩展远程⽇志输出，创建客⼾端，将⽇志消息发送给远程的⽇志分析服务器。</li><li><code>设计思想</code>：设计不同的⼦类，不同的⼦类控制不同的⽇志落地⽅向。</li></ul></li><li><code>⽇志器模块</code>:<ul><li>此模块是对以上⼏个模块的整合模块，⽤⼾通过⽇志器进⾏⽇志的输出，有效降低⽤⼾的使⽤难度</li><li>包含有：⽇志消息落地模块对象，⽇志消息格式化模块对象，⽇志输出等级</li></ul></li><li><code>⽇志器管理模块</code>:<ul><li><code>解耦合</code>：为了降低项⽬开发的⽇志耦合，不同的项⽬组可以有⾃⼰的⽇志器来控制输出格式以及落地⽅向，因此本项⽬是⼀个多⽇志器的⽇志系统。</li><li>管理模块就是对创建的所有⽇志器进⾏统⼀管理。并提供⼀个默认⽇志器提供标准输出的⽇志输出。</li></ul></li><li><code>异步线程模块</code>:<ul><li>实现对⽇志的异步输出功能，⽤⼾只需要将输出⽇志任务放⼊任务池，异步线程负责⽇志的落地输出功能，以此提供更加⾼效的⾮阻塞⽇志输出。</li></ul></li></ul><hr><h1 id="代码设计"><a href="#代码设计" class="headerlink" title="代码设计"></a>代码设计</h1><h2 id="作用域的设计"><a href="#作用域的设计" class="headerlink" title="作用域的设计"></a>作用域的设计</h2><p>为了防止命名冲突，以及提示整个项目的完整性和功能性等，将所有的相关代码封装在<code>suplog</code>命名空间中，其中<code>log</code>表示功能，<code>sup</code>为作者自定义的名称，以提高其唯一性</p><p>然后将内部的代码块按功能&#x2F;所属的业务组封装在子级命名空间中，具体示例见后面的代码封装</p><h2 id="实用类设计"><a href="#实用类设计" class="headerlink" title="实用类设计"></a>实用类设计</h2><p>提前完成一些零碎的功能接口，以便于项目会用到。而由于实现以下功能并不需要成员变量，所以将成员函数设置成<strong>静态的成员函数</strong>,即知识封装在类域中</p><ul><li><code>date</code>类域<ul><li>获取系统时间</li></ul></li><li><code>file</code>类域<ul><li>判断文件是否存在</li><li>获取文件的所在目录路径</li><li>创建目录</li></ul></li></ul><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202409271457541.png"></p><blockquote><p>util.hpp</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> suplog&#123;</span><br><span class="line">    <span class="keyword">namespace</span> util&#123;</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">date</span></span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="function"><span class="type">static</span> <span class="type">size_t</span> <span class="title">now</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> (<span class="type">size_t</span>)<span class="built_in">time</span>(<span class="literal">nullptr</span>);&#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">file</span>&#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">exists</span><span class="params">(<span class="type">const</span> std::string&amp;name)</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                <span class="comment">//struct stat配合stat函数作为输出型参数</span></span><br><span class="line">                <span class="keyword">struct</span> <span class="title class_">stat</span> st;</span><br><span class="line">                <span class="comment">//stat函数是系统调用接口</span></span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">stat</span>(name.<span class="built_in">c_str</span>(),&amp;st) == <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="type">static</span> std::string <span class="title">path</span><span class="params">(<span class="type">const</span> std::string &amp;name)</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                <span class="comment">//规定找不到就返回&quot;.&quot;&quot;</span></span><br><span class="line">                <span class="keyword">if</span>(name.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="string">&quot;.&quot;</span>;</span><br><span class="line"></span><br><span class="line">                <span class="type">size_t</span> pos = name.<span class="built_in">find_last_of</span>(<span class="string">&quot;/\\&quot;</span>);<span class="comment">//找到最后一个&quot;/&quot;或&quot;\\&quot;</span></span><br><span class="line">                <span class="keyword">return</span> name.<span class="built_in">substr</span>(<span class="number">0</span>,pos+<span class="number">1</span>);<span class="comment">//取得目录的路径</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">create_directory</span><span class="params">(<span class="type">const</span> std::string &amp;path)</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(path.<span class="built_in">empty</span>()) <span class="keyword">return</span>;<span class="comment">//路径为空</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">exists</span>(path)) <span class="keyword">return</span>;<span class="comment">//路径不存在-使用系统调用接口</span></span><br><span class="line">                <span class="type">size_t</span> pos,index = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span>(index&lt;path.<span class="built_in">size</span>())</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//找到index及以后的&quot;/&quot;</span></span><br><span class="line">                    pos = path.<span class="built_in">find_first_of</span>(<span class="string">&quot;/\\&quot;</span>,index);</span><br><span class="line">                    <span class="keyword">if</span>(pos == std::string::npos)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">//创建最后一层目录</span></span><br><span class="line">                        <span class="built_in">mkdir</span>(path.<span class="built_in">c_str</span>(),<span class="number">0755</span>);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//二者重叠时，跳到下一次循环</span></span><br><span class="line">                    <span class="keyword">if</span>(pos ==index) &#123;index = pos+<span class="number">1</span>;<span class="keyword">continue</span>;&#125;</span><br><span class="line">                    std::string subdir = path.<span class="built_in">substr</span>(<span class="number">0</span>,pos);</span><br><span class="line">                    <span class="comment">//文件夹已存在，不用创建，跳到下一段即可</span></span><br><span class="line">                    <span class="keyword">if</span>(subdir == <span class="string">&quot;.&quot;</span> || subdir == <span class="string">&quot;..&quot;</span>)</span><br><span class="line">                        &#123;index = pos + <span class="number">1</span>;<span class="keyword">continue</span>;&#125;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">exists</span>(subdir))<span class="comment">//理由同上</span></span><br><span class="line">                        &#123;index = pos + <span class="number">1</span>;<span class="keyword">continue</span>;&#125;</span><br><span class="line">                    <span class="comment">//逐级创建目录，权限为0755</span></span><br><span class="line">                    <span class="built_in">mkdir</span>(subdir.<span class="built_in">c_str</span>(),<span class="number">0755</span>);</span><br><span class="line">                    index = pos + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码测试"><a href="#代码测试" class="headerlink" title="代码测试"></a>代码测试</h3><p>写一部分测一部分才是开发的好习惯，以免以后面对满屏报错，找不到bug点</p><p>写一段测试代码</p><blockquote><p>main.cpp</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;util.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;测试时间: &quot;</span>&lt;&lt;suplog::util::date::<span class="built_in">now</span>()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;测试文件&quot;</span>&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;测试path()，获取到的path为： &quot;</span> &lt;&lt; suplog::util::file::<span class="built_in">path</span>(<span class="string">&quot;/home/supdriver/code/file.txt&quot;</span>);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;测试创建目录:... &quot;</span>;</span><br><span class="line">    suplog::util::file::<span class="built_in">create_directory</span>(<span class="string">&quot;./testdir/dir1/dir2&quot;</span>);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;创建成功&quot;</span>&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;测试exists(), 测试路径:\&quot;./testdir/dir1/dir2\&quot;,返回结果&quot;</span>&lt;&lt;suplog::util::file::<span class="built_in">exists</span>(<span class="string">&quot;./testdir/dir1/dir2&quot;</span>)&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">supdriver@ALi-cloud-Linux-2-2G:~/codes/Asynchrinous-Logging-System$ make clean</span><br><span class="line">rm -rf mycmd testdir</span><br><span class="line">supdriver@ALi-cloud-Linux-2-2G:~/codes/Asynchrinous-Logging-System$ make</span><br><span class="line">g++ -o mycmd main.cpp -std=c++11</span><br><span class="line">supdriver@ALi-cloud-Linux-2-2G:~/codes/Asynchrinous-Logging-System$ ./mycmd </span><br><span class="line">测试时间: 1727424996</span><br><span class="line">测试文件</span><br><span class="line">测试path()，获取到的path为： /home/supdriver/code/file.txt测试创建目录:... 创建成功</span><br><span class="line">测试exists(), 测试路径:&quot;./testdir/dir1/dir2&quot;,返回结果1</span><br></pre></td></tr></table></figure><p>可以看到，各个接口工作正常</p><h2 id="日志等级类设计"><a href="#日志等级类设计" class="headerlink" title="日志等级类设计"></a>日志等级类设计</h2><p>日志ID鞥机总共分为7个等级，分别为：</p><ul><li><code>OFF</code>：关闭所有日志输出</li><li><code>DEBUG</code>：调试，调试时的关键信息输出。</li><li><code>INFO</code>：提⽰，普通的提⽰型⽇志信息。</li><li><code>WARN</code>：警告，不影响运⾏，但是需要注意⼀下的⽇志。</li><li><code>ERROR</code>：错误，程序运⾏出现错误的⽇志</li><li><code>FATAL</code>：致命，⼀般是代码异常导致程序⽆法继续推进运⾏的⽇志</li></ul><p>其中用到了<code>TOSTRING</code>宏函数，利用宏的预编译特性 ，<strong>减少了函数调用</strong>，提高了程序性能</p><blockquote><p>level.hpp</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> suplog&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">LogLevel</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">enum class</span> <span class="title class_">Level</span>&#123;</span><br><span class="line">            DEBUG = <span class="number">1</span>,</span><br><span class="line">            INFO,</span><br><span class="line">            WARN,</span><br><span class="line">            ERROR,</span><br><span class="line">            FATAL,</span><br><span class="line">            OFF</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">toString</span><span class="params">(LogLevel::Level lv)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">switch</span>(lv)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//在内部定义一个宏函数,把变量名name变成字符串</span></span><br><span class="line">                <span class="meta">#<span class="keyword">define</span> TOSTRING(name) #name</span></span><br><span class="line">                <span class="keyword">case</span> LogLevel::Level::DEBUG: <span class="keyword">return</span> <span class="built_in">TOSTRING</span>(DEBUG);<span class="comment">//直接返回，不加用break</span></span><br><span class="line">                <span class="keyword">case</span> LogLevel::Level::INFO: <span class="keyword">return</span> <span class="built_in">TOSTRING</span>(INFO);</span><br><span class="line">                <span class="keyword">case</span> LogLevel::Level::WARN: <span class="keyword">return</span> <span class="built_in">TOSTRING</span>(WARN);</span><br><span class="line">                <span class="keyword">case</span> LogLevel::Level::ERROR: <span class="keyword">return</span> <span class="built_in">TOSTRING</span>(ERROR);</span><br><span class="line">                <span class="keyword">case</span> LogLevel::Level::FATAL: <span class="keyword">return</span> <span class="built_in">TOSTRING</span>(FATAL);</span><br><span class="line">                <span class="keyword">case</span> LogLevel::Level::OFF: <span class="keyword">return</span> <span class="built_in">TOSTRING</span>(OFF);</span><br><span class="line">                <span class="meta">#<span class="keyword">undef</span> TOSTRING <span class="comment">//取消宏函数</span></span></span><br><span class="line">                <span class="keyword">default</span>: <span class="keyword">return</span> <span class="string">&quot;UNKOWN&quot;</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;UNKNOWN&quot;</span>;<span class="comment">//防止编译报错</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码测试-1"><a href="#代码测试-1" class="headerlink" title="代码测试"></a>代码测试</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;util.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;level.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;测试字符串转换 FATAL:&quot;</span>;</span><br><span class="line">    cout&lt;&lt;suplog::LogLevel::<span class="built_in">toString</span>(suplog::LogLevel::Level::FATAL)&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">supdriver@ALi-cloud-Linux-2-2G:~/codes/Asynchrinous-Logging-System$ make clean</span><br><span class="line">rm -rf mycmd testdir</span><br><span class="line">supdriver@ALi-cloud-Linux-2-2G:~/codes/Asynchrinous-Logging-System$ make </span><br><span class="line">g++ -o mycmd main.cpp -std=c++11</span><br><span class="line">.supdriver@ALi-cloud-Linux-2-2G:~/codes/Asynchrinous-Logging-System$ ./mycmd </span><br><span class="line">测试字符串转换 FATAL:FATAL</span><br><span class="line">supdriver@ALi-cloud-Linux-2-2G:~/codes/Asynchrinous-Logging-System$ </span><br></pre></td></tr></table></figure><p>可以看到成功转换,该模块正常工作</p><h2 id="日志消息类设计"><a href="#日志消息类设计" class="headerlink" title="日志消息类设计"></a>日志消息类设计</h2><p>⽇志消息类主要是封装⼀条完整的⽇志消息所需的内容，其中包括⽇志等级、对应的<code>logger name</code>、打印⽇志源⽂件的位置信息（包括⽂件名和⾏号）、线程ID、时间戳信息、具体的⽇志信息等内容。</p><blockquote><p>message.hpp</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;util.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;level.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span><span class="comment">//c++多线程库</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> suplog&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">LogMsg</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//声明一个全局且唯一的指针</span></span><br><span class="line">        <span class="keyword">using</span> ptr = std::shared_ptr&lt;LogMsg&gt;;</span><br><span class="line">        std::string _name;  <span class="comment">//日志器名称</span></span><br><span class="line">        std::string _file;  <span class="comment">//文件名</span></span><br><span class="line">        <span class="type">size_t</span> _line;       <span class="comment">//行号</span></span><br><span class="line">        std::string _payload;<span class="comment">//日志消息</span></span><br><span class="line">        <span class="type">size_t</span> _ctime;      <span class="comment">//时间-时间戳</span></span><br><span class="line">        std::thread::id _tid;<span class="comment">//线程id</span></span><br><span class="line">        LogLevel::Level _level;<span class="comment">//日志等级</span></span><br><span class="line">        <span class="comment">//默认构造函数</span></span><br><span class="line">        <span class="built_in">LogMsg</span>()&#123;&#125;</span><br><span class="line">        <span class="comment">//构造函数</span></span><br><span class="line">        <span class="built_in">LogMsg</span>(</span><br><span class="line">            std::string name,</span><br><span class="line">            std::string file,</span><br><span class="line">            <span class="type">size_t</span> line,</span><br><span class="line">            std::string payload,</span><br><span class="line">            LogLevel::Level level</span><br><span class="line">        ):</span><br><span class="line">        _name(name),</span><br><span class="line">        _file(file),</span><br><span class="line">        _payload(payload),</span><br><span class="line">        _level(level),</span><br><span class="line">        _line(line),</span><br><span class="line">        _ctime(util::date::<span class="built_in">now</span>()),</span><br><span class="line">        _tid(std::this_thread::<span class="built_in">get_id</span>())&#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码就不作单独测试了</p><h2 id="日志输出格式化类设计"><a href="#日志输出格式化类设计" class="headerlink" title="日志输出格式化类设计"></a>日志输出格式化类设计</h2><p>⽇志格式化（Formatter）类主要负责格式化⽇志消息。其主要包含以下内容</p><ol><li><code>pattern</code>成员：保存⽇志输出的格式字符串。</li></ol><ul><li><code>%d</code> 日期</li><li><code>%T</code> 缩进</li><li><code>%t</code> 线程id</li><li><code>%p</code> 日志级别</li><li><code>%c</code> 日志器名称’</li><li><code>%f</code> 文件名</li><li><code>%l</code> 行号</li><li><code>%m</code> 日志消息</li><li><code>%n</code> 换行</li></ul><ol start="2"><li><code>std::vector&lt;FormatItem::ptr&gt; items</code>成员：⽤于按序保存格式化字符串对应的⼦格式化对象。</li></ol><p>其中<code>FormatItem</code>类主要负责⽇志消息⼦项的获取及格式化。其包含以下<code>⼦类</code></p><ul><li><code>MsgFormatItem</code> ：表⽰要从<code>LogMsg</code>中取出有效⽇志数据</li><li><code>LevelFormatItem</code> ：表⽰要从<code>LogMsg</code>中取出⽇志等级</li><li><code>NameFormatItem</code> ：表⽰要从<code>LogMsg</code>中取出⽇志器名称</li><li><code>ThreadFormatItem</code> ：表⽰要从<code>LogMsg</code>中取出线程ID</li><li><code>TimeFormatItem</code> ：表⽰要从<code>LogMsg</code>中取出时间戳并按照指定格式进⾏格式化</li><li><code>CFileFormatItem</code> ：表⽰要从<code>LogMsg</code>中取出源码所在⽂件名</li><li><code>CLineFormatItem</code> ：表⽰要从<code>LogMsg</code>中取出源码所在⾏号</li><li><code>TabFormatItem</code> ：表⽰⼀个制表符缩进</li><li><code>NLineFormatItem</code> ：表⽰⼀个换⾏</li><li><code>OtherFormatItem</code> ：表⽰⾮格式化的原始字符串</li></ul><p><strong>示例</strong>:将格式化字符串<code>&quot;[%d｛%H:%M:%S｝] %m%n&quot;</code>实例化为日志消息字符串</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">pattern = <span class="string">&quot;[%d&#123;%H:%M:%S&#125;] %m%n&quot;</span>;</span><br><span class="line">items = &#123;</span><br><span class="line">  &#123;<span class="built_in">OtherFormatItem</span>(), <span class="string">&quot;[&quot;</span>&#125;,</span><br><span class="line">  &#123;<span class="built_in">TimeFormatItem</span>(), <span class="string">&quot;%H:%M:%S&quot;</span>&#125;,</span><br><span class="line">  &#123;<span class="built_in">OtherFormatItem</span>(), <span class="string">&quot;]&quot;</span>&#125;,</span><br><span class="line">  &#123;<span class="built_in">MsgFormatItem</span>(), <span class="string">&quot;&quot;</span>&#125;,</span><br><span class="line">  &#123;<span class="built_in">NLineFormatItem</span>(), <span class="string">&quot;&quot;</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">LogMsg msg = &#123;</span><br><span class="line">  <span class="type">size_t</span> _line = <span class="number">22</span>;</span><br><span class="line">  <span class="type">size_t</span> _ctime = <span class="number">12345678</span>;</span><br><span class="line">  std::thread::id _tid = <span class="number">0x12345678</span>;</span><br><span class="line">  std::string _name = <span class="string">&quot;logger&quot;</span>;</span><br><span class="line">  std::string _file = <span class="string">&quot;main.cpp&quot;</span>;</span><br><span class="line">  std::string _payload = <span class="string">&quot;创建套接字失败&quot;</span>;</span><br><span class="line">  LogLevel::value _level = ERROR;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后组织出来的格式化消息为：<code>&quot;[22:32:54] 创建套接字失败\n&quot;</code></p><blockquote><p>formatter.hpp<br>实现FormatItem及其派生类</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> suplog&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*=========FormatItem及其派生类===========*/</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">FormatItem</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">using</span> ptr = std::shared_ptr&lt;FormatItem&gt;;</span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="built_in">FormatItem</span>()&#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">format</span><span class="params">(std::ostream&amp; os,<span class="type">const</span> LogMsg&amp; msg)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">MsgFormatItem</span>:<span class="keyword">public</span> FormatItem</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">MsgFormatItem</span>(<span class="type">const</span> std::string&amp; str = <span class="string">&quot;&quot;</span>)&#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">format</span><span class="params">(std::ostream&amp; os,<span class="type">const</span> LogMsg&amp; msg)</span></span>&#123;</span><br><span class="line">            os&lt;&lt;msg._payload;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">LevelFormatItem</span>:<span class="keyword">public</span> FormatItem&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">LevelFormatItem</span>(<span class="type">const</span> std::string&amp; str = <span class="string">&quot;&quot;</span>)&#123;&#125;;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">format</span><span class="params">(std::ostream&amp; os,<span class="type">const</span> LogMsg&amp; msg)</span></span>&#123;</span><br><span class="line">            os&lt;&lt;LogLevel::<span class="built_in">toString</span>(msg._level);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">NameFormatItem</span>:<span class="keyword">public</span> FormatItem&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">NameFormatItem</span>(<span class="type">const</span> std::string&amp; str=<span class="string">&quot;&quot;</span>)&#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">format</span><span class="params">(std::ostream&amp; os,<span class="type">const</span> LogMsg&amp; msg)</span></span>&#123;</span><br><span class="line">            os&lt;&lt;msg._name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">ThreadFormatItem</span>:<span class="keyword">public</span> FormatItem&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">ThreadFormatItem</span>(<span class="type">const</span> std::string&amp; str=<span class="string">&quot;&quot;</span>)&#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">format</span><span class="params">(std::ostream&amp; os,<span class="type">const</span> LogMsg&amp; msg)</span></span>&#123;</span><br><span class="line">            os&lt;&lt;msg._tid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">TimeFormatItem</span>:<span class="keyword">public</span> FormatItem&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        std::string _format;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">TimeFormatItem</span>(<span class="type">const</span> std::string&amp; format=<span class="string">&quot;%H:%M:%S&quot;</span>):_format(format)&#123;</span><br><span class="line">            <span class="keyword">if</span>(format.<span class="built_in">empty</span>()) _format = &#123;<span class="string">&quot;%H:%M:%S&quot;</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">format</span><span class="params">(std::ostream&amp; os,<span class="type">const</span> LogMsg&amp; msg)</span></span>&#123;</span><br><span class="line">            <span class="type">time_t</span> t = msg._ctime;</span><br><span class="line">            <span class="keyword">struct</span> <span class="title class_">tm</span> lt;</span><br><span class="line">            <span class="built_in">localtime_r</span>(&amp;t,&amp;lt);<span class="comment">//从时间戳t中提取时间信息到结构体lt中</span></span><br><span class="line">            <span class="type">char</span> tmp[<span class="number">128</span>];</span><br><span class="line">            <span class="built_in">strftime</span>(tmp,<span class="number">127</span>,_format.<span class="built_in">c_str</span>(),&amp;lt);<span class="comment">//格式化日期信息到字符串</span></span><br><span class="line">            os&lt;&lt;tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">CFileFormatItem</span>:<span class="keyword">public</span> FormatItem&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">CFileFormatItem</span>(<span class="type">const</span> std::string&amp; str=<span class="string">&quot;&quot;</span>)&#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">format</span><span class="params">(std::ostream&amp; os,<span class="type">const</span> LogMsg&amp; msg)</span></span>&#123;</span><br><span class="line">            os&lt;&lt;msg._file;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">CLineFormatItem</span>:<span class="keyword">public</span> FormatItem&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">CLineFormatItem</span>(<span class="type">const</span> std::string&amp; str=<span class="string">&quot;&quot;</span>)&#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">format</span><span class="params">(std::ostream&amp; os,<span class="type">const</span> LogMsg&amp; msg)</span></span>&#123;</span><br><span class="line">            os&lt;&lt;msg._line;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">TabFormatItem</span>:<span class="keyword">public</span> FormatItem&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">TabFormatItem</span>(<span class="type">const</span> std::string&amp; str=<span class="string">&quot;&quot;</span>)&#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">format</span><span class="params">(std::ostream&amp; os,<span class="type">const</span> LogMsg&amp; msg)</span></span>&#123;</span><br><span class="line">            os&lt;&lt;<span class="string">&#x27;\t&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;        </span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">NLineFormatItem</span>:<span class="keyword">public</span> FormatItem&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">NLineFormatItem</span>(<span class="type">const</span> std::string&amp; str=<span class="string">&quot;&quot;</span>)&#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">format</span><span class="params">(std::ostream&amp; os,<span class="type">const</span> LogMsg&amp; msg)</span></span>&#123;</span><br><span class="line">            os&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">OtherFormatItem</span>:<span class="keyword">public</span> FormatItem&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        std::string _str;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">OtherFormatItem</span>(<span class="type">const</span> std::string &amp;str=<span class="string">&quot;&quot;</span>):_str(str)&#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">format</span><span class="params">(std::ostream&amp; os,<span class="type">const</span> LogMsg&amp; msg)</span></span>&#123;</span><br><span class="line">            os&lt;&lt;_str;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*===============END==============*/</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到<code>FormatItem</code>的派生类非常多，我们用两行注释标注一下这一大块代码的作用和边界，这样有利于后期查阅和维护</p><p>同时很明显这里用到了<code>虚函数</code>和<code>继承抽象类</code>来实现<code>多态</code>，保证了后期能用统一的<code>shared_ptr&lt;FormatItem&gt;</code>父类指针统一管理所有派生类</p><blockquote><p>formatter.hpp<br>实现Formatter类<br>Formatter类主要用于实现解析 pattern字符串和将LogMsg转化为对应的日志消息<br>又由于有众多种类的<code>FormatItem</code>派生类要创建，所以我们还要将创建功能单独封装，因此确定有如下接口</p><ul><li><code>pattern</code>:返回<code>const string</code>,查看对象内储存的<code>pattern</code>字符串</li><li><code>create_item</code>:在堆上创建<code>Formatitem</code>派生类并返回子类指针</li><li><code>parsePattern</code>:<strong>解析格式串</strong>并生成<code>Formatitem</code>派生类列表</li></ul><p><em>对字符串解析的示意图</em><br><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202409291637114.png"></p></blockquote><p>关于解析格式串,这里使用<strong>缓存的思想尤为重要</strong></p><ul><li><code>string_row</code>是对原始字符进行缓存，一次性为多个字符创建一个<code>MsgFormatItem</code>,减少内存开支和性能消耗</li><li><code>format_key</code>,<code>format_val</code>是对格式字符和子格式串的缓存</li><li><code>arry</code>储存分析后的原素材,每一个元素对应一个<strong>待创建</strong>的<code>FormatItem</code>派生类</li></ul><p>正是有缓存的存在，我们可以将字符串分析，创建<code>FormatItem</code>派生类等复杂工作分开处理。当然相应地<strong>维护成本会增加</strong>：<strong>缓存最后都是要在合适的时机清空的</strong>,否则会丢失信息，让工作不完整。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> suplog&#123;</span><br><span class="line">    <span class="comment">//......上面的代码略...</span></span><br><span class="line">    <span class="comment">/*===============END==============*/</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">class</span> <span class="title class_">Formatter</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">using</span> ptr = std::shared_ptr&lt;Formatter&gt;;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            %d ⽇期</span></span><br><span class="line"><span class="comment">            %T 缩进</span></span><br><span class="line"><span class="comment">            %t 线程id</span></span><br><span class="line"><span class="comment">            %p ⽇志级别</span></span><br><span class="line"><span class="comment">            %c ⽇志器名称</span></span><br><span class="line"><span class="comment">            %f ⽂件名</span></span><br><span class="line"><span class="comment">            %l ⾏号</span></span><br><span class="line"><span class="comment">            %m ⽇志消息</span></span><br><span class="line"><span class="comment">            %n 换⾏</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">Formatter</span>(<span class="type">const</span> std::string&amp; pattern = <span class="string">&quot;[%d&#123;%H:%M:%S&#125;][%t][%p][%c][%f:%l] %m%n&quot;</span>)</span><br><span class="line">        :_pattern(pattern)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">assert</span>(<span class="built_in">parsePattern</span>());<span class="comment">//调用成员函数，后面声明</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//简单的查看pattern的接口</span></span><br><span class="line">        <span class="function"><span class="type">const</span> std::string <span class="title">pattern</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> _pattern;&#125;</span><br><span class="line">        <span class="comment">//最后实现，但是是最常用的接口，故写在前面</span></span><br><span class="line">        <span class="function">std::string <span class="title">format</span><span class="params">(<span class="type">const</span> LogMsg&amp; msg)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            std::stringstream ss;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; it: _items)</span><br><span class="line">            &#123;</span><br><span class="line">                it-&gt;format(ss,msg);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ss.<span class="built_in">str</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建FormatItem(给调用者使用多态)</span></span><br><span class="line">        <span class="function">FormatItem::ptr <span class="title">createItem</span><span class="params">(<span class="type">const</span> std::string&amp; fc,<span class="type">const</span> std::string&amp; subfmt)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(fc == <span class="string">&quot;m&quot;</span>) <span class="keyword">return</span> FormatItem::<span class="built_in">ptr</span>(<span class="keyword">new</span> <span class="built_in">MsgFormatItem</span>(subfmt));</span><br><span class="line">            <span class="keyword">if</span>(fc == <span class="string">&quot;p&quot;</span>) <span class="keyword">return</span> FormatItem::<span class="built_in">ptr</span>(<span class="keyword">new</span> <span class="built_in">LevelFormatItem</span>(subfmt));</span><br><span class="line">            <span class="keyword">if</span>(fc == <span class="string">&quot;c&quot;</span>) <span class="keyword">return</span> FormatItem::<span class="built_in">ptr</span>(<span class="keyword">new</span> <span class="built_in">NameFormatItem</span>(subfmt));</span><br><span class="line">            <span class="keyword">if</span>(fc == <span class="string">&quot;t&quot;</span>) <span class="keyword">return</span> FormatItem::<span class="built_in">ptr</span>(<span class="keyword">new</span> <span class="built_in">ThreadFormatItem</span>(subfmt));</span><br><span class="line">            <span class="keyword">if</span>(fc == <span class="string">&quot;n&quot;</span>) <span class="keyword">return</span> FormatItem::<span class="built_in">ptr</span>(<span class="keyword">new</span> <span class="built_in">NLineFormatItem</span>(subfmt));</span><br><span class="line">            <span class="keyword">if</span>(fc == <span class="string">&quot;d&quot;</span>) <span class="keyword">return</span> FormatItem::<span class="built_in">ptr</span>(<span class="keyword">new</span> <span class="built_in">TimeFormatItem</span>(subfmt));</span><br><span class="line">            <span class="keyword">if</span>(fc == <span class="string">&quot;f&quot;</span>) <span class="keyword">return</span> FormatItem::<span class="built_in">ptr</span>(<span class="keyword">new</span> <span class="built_in">CFileFormatItem</span>(subfmt));</span><br><span class="line">            <span class="keyword">if</span>(fc == <span class="string">&quot;l&quot;</span>) <span class="keyword">return</span> FormatItem::<span class="built_in">ptr</span>(<span class="keyword">new</span> <span class="built_in">CLineFormatItem</span>(subfmt));</span><br><span class="line">            <span class="keyword">if</span>(fc == <span class="string">&quot;T&quot;</span>) <span class="keyword">return</span> FormatItem::<span class="built_in">ptr</span>(<span class="keyword">new</span> <span class="built_in">TabFormatItem</span>(subfmt));</span><br><span class="line">            <span class="keyword">return</span> FormatItem::<span class="built_in">ptr</span>();<span class="comment">//未知fc</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//pattern解析</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//每个要素分为三部分：</span></span><br><span class="line">        <span class="comment">// 格式化字符 : %d %T %p...</span></span><br><span class="line">        <span class="comment">// 对应的输出⼦格式 ： &#123;%H:%M:%S&#125;</span></span><br><span class="line">        <span class="comment">// 对应数据的类型 ： 0-表⽰原始字符串，也就是⾮格式化字符，1-表⽰格式化数据类型</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//默认格式&quot;[%d&#123;%H:%M:%S&#125;][%t][%p][%c][%f:%l] %m%n&quot;</span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">parsePattern</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="comment">//储存分割好的字符串,是否为原始字符串由int指示</span></span><br><span class="line">            std::vector&lt;std::tuple&lt;std::string,std::string,<span class="type">int</span>&gt;&gt; arry;</span><br><span class="line">            std::string format_key;<span class="comment">//存放%之后的格式化字符</span></span><br><span class="line">            std::string format_val;<span class="comment">//存放格式化字符串后边&#123;&#125;中的子格式化字符串</span></span><br><span class="line">            std::string string_row;<span class="comment">//存放原始的非格式化字符串</span></span><br><span class="line">            <span class="type">bool</span> sub_format_error = <span class="literal">false</span>;</span><br><span class="line">            <span class="type">int</span> pos = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(pos &lt; _pattern.<span class="built_in">size</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(_pattern[pos] != <span class="string">&#x27;%&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    string_row.<span class="built_in">push_back</span>(_pattern[pos++]);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(pos+<span class="number">1</span>&lt;_pattern.<span class="built_in">size</span>() &amp;&amp; _pattern[pos+<span class="number">1</span>] == <span class="string">&#x27;%&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//规定%%格式化为原生的&#x27;%&#x27;字符</span></span><br><span class="line">                    string_row.<span class="built_in">push_back</span>(<span class="string">&#x27;%&#x27;</span>);</span><br><span class="line">                    pos+=<span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(string_row.<span class="built_in">empty</span>() == <span class="literal">false</span>)<span class="comment">//原生字符串不为空</span></span><br><span class="line">                &#123;</span><br><span class="line">                    arry.<span class="built_in">push_back</span>(std::<span class="built_in">make_tuple</span>(string_row,<span class="string">&quot;&quot;</span>,<span class="number">0</span>));</span><br><span class="line">                    string_row.<span class="built_in">clear</span>();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//当前位置指向%字符</span></span><br><span class="line">                pos++;<span class="comment">//pos指向格式化字符位置</span></span><br><span class="line">                <span class="keyword">if</span>(pos&lt;_pattern.<span class="built_in">size</span>() &amp;&amp; <span class="built_in">isalpha</span>(_pattern[pos]))<span class="comment">//判断是不是字符</span></span><br><span class="line">                &#123;</span><br><span class="line">                    format_key = _pattern[pos];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    std::cout&lt;&lt; &amp;_pattern[pos<span class="number">-1</span>]&lt;&lt;<span class="string">&quot;位置附近格式错误！\n&quot;</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//下一步使pos指向格式化字符的下个位置，判断是否包含有子格式,例如在%d&#123;%Y-%m-%d&#125;中</span></span><br><span class="line">                pos++;</span><br><span class="line">                <span class="keyword">if</span>(pos+<span class="number">1</span> &lt; _pattern.<span class="built_in">size</span>() &amp;&amp; _pattern[pos] == <span class="string">&#x27;&#123;&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    sub_format_error = <span class="literal">true</span>;</span><br><span class="line">                    pos++;<span class="comment">//pos指向花括号下一个字符</span></span><br><span class="line">                    <span class="keyword">while</span> (pos&lt;_pattern.<span class="built_in">size</span>())</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span>(_pattern[pos] == <span class="string">&#x27;&#125;&#x27;</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="comment">//循环出口</span></span><br><span class="line">                            sub_format_error = <span class="literal">false</span>;</span><br><span class="line">                            pos++;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//在循环中时</span></span><br><span class="line">                        format_val.<span class="built_in">push_back</span>(_pattern[pos++]);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(sub_format_error)</span><br><span class="line">                    &#123;</span><br><span class="line">                        std::cout&lt;&lt;<span class="string">&quot;&#123;&#125;对应出错\n&quot;</span>;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                arry.<span class="built_in">push_back</span>(std::<span class="built_in">make_tuple</span>(format_key,format_val,<span class="number">1</span>));</span><br><span class="line">                format_key.<span class="built_in">clear</span>();</span><br><span class="line">                format_val.<span class="built_in">clear</span>();</span><br><span class="line">            &#125;<span class="comment">//结束循环</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(string_row.<span class="built_in">empty</span>() == <span class="literal">false</span>)<span class="comment">//原生字符串不为空</span></span><br><span class="line">                arry.<span class="built_in">push_back</span>(std::<span class="built_in">make_tuple</span>(string_row,<span class="string">&quot;&quot;</span>,<span class="number">0</span>));</span><br><span class="line">            <span class="keyword">if</span>(format_key.<span class="built_in">empty</span>() == <span class="literal">false</span>)<span class="comment">//格式化字符不为空，注，上下顺序不能换,要和循环内一致</span></span><br><span class="line">                arry.<span class="built_in">push_back</span>(std::<span class="built_in">make_tuple</span>(format_key,format_val,<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">            <span class="comment">//开始拼接item列表</span></span><br><span class="line">            <span class="keyword">if</span>(_items.<span class="built_in">empty</span>() == <span class="literal">false</span>)_items.<span class="built_in">clear</span>();<span class="comment">//清理_items</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; it:arry)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(std::<span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(it) == <span class="number">0</span>)<span class="comment">//获取第三个元素</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="function">FormatItem::ptr <span class="title">fi</span><span class="params">(<span class="keyword">new</span> OtherFormatItem(std::get&lt;<span class="number">0</span>&gt;(it)))</span></span>;</span><br><span class="line">                    _items.<span class="built_in">push_back</span>(fi);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    FormatItem::ptr fi = <span class="built_in">createItem</span>(std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(it),</span><br><span class="line">                                                    std::<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(it));</span><br><span class="line">                    <span class="keyword">if</span>(fi.<span class="built_in">get</span>() == <span class="literal">nullptr</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        std::cout&lt;&lt;<span class="string">&quot;没有对应的格式化字符串： %&quot;</span></span><br><span class="line">                                 &lt;&lt;std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(it)</span><br><span class="line">                                 &lt;&lt;std::endl;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    _items.<span class="built_in">push_back</span>(fi);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="comment">//完成拼接</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        std::string _pattern;</span><br><span class="line">        std::vector&lt;FormatItem::ptr&gt; _items;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们写一下测试代码，把之前举的例子部分模拟出来</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;util.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;level.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;message.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;formatter.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    suplog::Formatter fmt;</span><br><span class="line">    std::string pattern = <span class="string">&quot;[%d&#123;%H:%M:%S&#125;] %m%n&quot;</span>;</span><br><span class="line">    suplog::LogMsg msg=&#123;</span><br><span class="line">        <span class="string">&quot;logger&quot;</span>,       <span class="comment">//名字</span></span><br><span class="line">        <span class="string">&quot;main.cpp&quot;</span>,     <span class="comment">//文件名</span></span><br><span class="line">        <span class="number">22</span>,             <span class="comment">//行数</span></span><br><span class="line">        <span class="string">&quot;创建套接字失败&quot;</span>,<span class="comment">//正文</span></span><br><span class="line">        suplog::LogLevel::Level::ERROR   <span class="comment">//等级</span></span><br><span class="line">    &#125;;</span><br><span class="line">    cout&lt;&lt;fmt.format(msg);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202409291610709.png"></p><p>输出结果如上，显然成功处理出了格式化字符串并输出了预期的日志信息</p><h2 id="日志落地类-LogSink-设计（简单工厂模式）"><a href="#日志落地类-LogSink-设计（简单工厂模式）" class="headerlink" title="日志落地类(LogSink)设计（简单工厂模式）"></a>日志落地类(LogSink)设计（简单工厂模式）</h2><p>日志落地类主要负责落地日志消息到目的地。<br>它主要包括以下内容：</p><ul><li><code>Formatter</code>日志格式化器：主要负责格式化日志消息</li><li><code>mutex互斥锁</code>:保证多线程日志落地过程中的线程安全，避免出现交叉输出的情况。这个类要设计成<strong>支持可扩展</strong>，所以其成员函数<code>log</code>设置为<strong>纯虚函数</strong>，当我们需要增加一个<code>log</code>输出目标,可以增加一个类继承自该类并重写<code>log</code>方法实现具体的落地日志逻辑。（简单工厂模式）</li></ul><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202409251006985.png"></p><ul><li>标准输出：<code>StdoutSink</code></li><li>固定文件: <code>FileSink</code></li><li>滚动文件: <code>RollSink</code><ul><li>滚动日志文件输出的<strong>必要性</strong>:<ol><li>由于<strong>机器磁盘空间有限</strong>， 我们不可能⼀直⽆限地向⼀个⽂件中增加数据</li><li>如果⼀个⽇志 <strong>⽂件体积太⼤</strong>，⼀⽅⾯是不好打开，另⼀⽅⾯是即时打开了由于包含数据巨⼤，也不利于查找我们需要的信息</li><li>所以<strong>实际开发中</strong>会对单个⽇志⽂件的⼤⼩也会做⼀些控制，即当⼤⼩超过某个⼤⼩时（如1GB），我们就重新创建⼀个新的⽇志⽂件来滚动写⽇志。 对于那些过期的⽇志， ⼤部分企业内部都有专⻔的运维⼈员去<strong>定时清理过期的⽇志</strong>，或者设置系统定时任务，定时清理过期⽇志。</li></ol></li><li>日志文件滚动的思想：⽇志⽂件滚动的条件有两个:⽂件⼤⼩ 和 时间。我们可以选择：<ul><li>日志文件在⼤于 1GB 的时候会更换新的⽂件</li><li>每天定点滚动⼀个⽇志⽂件</li></ul></li></ul></li></ul><p>本项目选择基于 文件大小 的潘墩滚动生成新的文件</p><blockquote><p>sink.hpp</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> suplog&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">LogSink</span><span class="comment">//抽象类</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">using</span> ptr = std::shared_ptr&lt;LogSink&gt;;</span><br><span class="line">        <span class="built_in">LogSink</span>()&#123;&#125;</span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="built_in">LogSink</span>() =<span class="keyword">default</span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*data,<span class="type">size_t</span> len)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">StdoutSink</span>:<span class="keyword">public</span> LogSink</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">using</span> ptr = std::shared_ptr&lt;StdoutSink&gt;;</span><br><span class="line">        <span class="built_in">StdoutSink</span>()=<span class="keyword">default</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*data,<span class="type">size_t</span> len)</span> <span class="keyword">override</span></span>&#123;<span class="comment">//加override关键字明示这是虚函数重载</span></span><br><span class="line">            std::cout.<span class="built_in">write</span>(data,len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">FileSink</span>:<span class="keyword">public</span> LogSink</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">using</span> ptr = std::shared_ptr&lt;FileSink&gt;;</span><br><span class="line">        <span class="built_in">FileSink</span>(<span class="type">const</span> std::string&amp; filename):_filename(filename)&#123;</span><br><span class="line">            <span class="comment">//创建目录</span></span><br><span class="line">            util::file::<span class="built_in">create_directory</span>(util::file::<span class="built_in">path</span>(filename));</span><br><span class="line">            _ofs.<span class="built_in">open</span>(_filename,std::ios::binary|std::ios::app);<span class="comment">//二进制方式写入</span></span><br><span class="line">            <span class="built_in">assert</span>(_ofs.<span class="built_in">is_open</span>());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//提供给外界获取文件名</span></span><br><span class="line">        <span class="function"><span class="type">const</span> std::string &amp;<span class="title">file</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> _filename;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*data,<span class="type">size_t</span> len)</span> <span class="keyword">override</span> </span>&#123;<span class="comment">//加override关键字明示这是虚函数重载</span></span><br><span class="line">            _ofs.<span class="built_in">write</span>((<span class="type">const</span> <span class="type">char</span>*)data,len);</span><br><span class="line">            <span class="keyword">if</span>(_ofs.<span class="built_in">good</span>() == <span class="literal">false</span>)&#123;</span><br><span class="line">                std::cout&lt;&lt;<span class="string">&quot;日志输出文件失败!\n&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        std::string _filename;</span><br><span class="line">        std::ofstream _ofs;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">RollSink</span>:<span class="keyword">public</span> LogSink</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">using</span> ptr = std::shared_ptr&lt;RollSink&gt;;</span><br><span class="line">        <span class="built_in">RollSink</span>(<span class="type">const</span> std::string&amp; basename,<span class="type">size_t</span> max_size)</span><br><span class="line">        :_basename(basename),_max_fsize(max_size),_cur_fsize(<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//创建目录</span></span><br><span class="line">            util::file::<span class="built_in">create_directory</span>(util::file::<span class="built_in">path</span>(_basename));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*data,<span class="type">size_t</span> len)</span> <span class="keyword">override</span> </span>&#123;<span class="comment">//加override关键字明示这是虚函数重载</span></span><br><span class="line">            <span class="built_in">initLogFile</span>();</span><br><span class="line">            _ofs.<span class="built_in">write</span>(data,len);</span><br><span class="line">            <span class="keyword">if</span>(_ofs.<span class="built_in">good</span>() == <span class="literal">false</span>)&#123;</span><br><span class="line">                std::cout&lt;&lt;<span class="string">&quot;日志输出文件失败!\n&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            _cur_fsize += len;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="comment">//在这里实现对日志文件的管理</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">initLogFile</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(_ofs.<span class="built_in">is_open</span>() == <span class="literal">false</span> || _cur_fsize &gt;=_max_fsize)</span><br><span class="line">            &#123;</span><br><span class="line">                _ofs.<span class="built_in">close</span>();</span><br><span class="line">                <span class="keyword">if</span>(_cur_fsize &gt;=_max_fsize) <span class="built_in">sleep</span>(<span class="number">1</span>);<span class="comment">//防止同一秒有过多日志消息要打印，导致打开同一个日志文件</span></span><br><span class="line">                std::string name = <span class="built_in">createFilename</span>();</span><br><span class="line">                _ofs.<span class="built_in">open</span>(name,std::ios::binary | std::ios::app);</span><br><span class="line">                <span class="built_in">assert</span>(_ofs.<span class="built_in">is_open</span>());</span><br><span class="line">                _cur_fsize = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//管理文件名的生成</span></span><br><span class="line">        <span class="function">std::string <span class="title">createFilename</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="type">time_t</span> t = <span class="built_in">time</span>(<span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">struct</span> <span class="title class_">tm</span> lt;</span><br><span class="line">            <span class="built_in">localtime_r</span>(&amp;t,&amp;lt);</span><br><span class="line">            std::stringstream ss;</span><br><span class="line">            <span class="comment">//获取详细时间信息</span></span><br><span class="line">            ss &lt;&lt; _basename;</span><br><span class="line">            ss&lt;&lt; lt.tm_year + <span class="number">1900</span>;</span><br><span class="line">            ss &lt;&lt;lt.tm_mon + <span class="number">1</span>;</span><br><span class="line">            ss &lt;&lt; lt.tm_mday;</span><br><span class="line">            ss &lt;&lt; lt.tm_hour;</span><br><span class="line">            ss &lt;&lt; lt.tm_min;</span><br><span class="line">            ss &lt;&lt; lt.tm_sec;</span><br><span class="line">            ss &lt;&lt; <span class="string">&quot;.log&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> ss.<span class="built_in">str</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        std::string _basename;</span><br><span class="line">        std::ofstream _ofs;</span><br><span class="line">        <span class="type">size_t</span> _max_fsize;</span><br><span class="line">        <span class="type">size_t</span> _cur_fsize;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建简单工厂</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">SinkFactory</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> SinkType,<span class="keyword">typename</span> ...Args&gt;</span></span><br><span class="line"><span class="function">        <span class="type">static</span> LogSink::ptr <span class="title">create</span><span class="params">(Args&amp;&amp;...args)</span></span>&#123;</span><br><span class="line">            <span class="comment">//返回shared_ptr,传的是构造函数参数列表</span></span><br><span class="line">            <span class="keyword">return</span> std::<span class="built_in">make_shared</span>&lt;SinkType&gt;(std::forward&lt;Args&gt;(args)...);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码测试-2"><a href="#代码测试-2" class="headerlink" title="代码测试"></a>代码测试</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;util.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;level.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;message.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;formatter.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sink.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    suplog::Formatter fmt;</span><br><span class="line">    std::string pattern = <span class="string">&quot;[%d&#123;%H:%M:%S&#125;] %m%n&quot;</span>;</span><br><span class="line">    suplog::LogMsg msg=&#123;</span><br><span class="line">        <span class="string">&quot;logger&quot;</span>,       <span class="comment">//名字</span></span><br><span class="line">        <span class="string">&quot;main.cpp&quot;</span>,     <span class="comment">//文件名</span></span><br><span class="line">        <span class="number">22</span>,             <span class="comment">//行数</span></span><br><span class="line">        <span class="string">&quot;创建套接字失败&quot;</span>,<span class="comment">//正文</span></span><br><span class="line">        suplog::LogLevel::Level::ERROR   <span class="comment">//等级</span></span><br><span class="line">    &#125;;</span><br><span class="line">    std::string str = fmt.format(msg);</span><br><span class="line"></span><br><span class="line">    std::shared_ptr&lt;suplog::LogSink&gt; lsptr;</span><br><span class="line"></span><br><span class="line">    lsptr.<span class="built_in">reset</span>(<span class="keyword">new</span> suplog::<span class="built_in">StdoutSink</span>());</span><br><span class="line">    lsptr-&gt;<span class="built_in">log</span>(str.<span class="built_in">c_str</span>(),str.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">    lsptr.<span class="built_in">reset</span>(<span class="keyword">new</span> suplog::<span class="built_in">FileSink</span>(<span class="string">&quot;./testdir/log.log&quot;</span>));</span><br><span class="line">    lsptr-&gt;<span class="built_in">log</span>(str.<span class="built_in">c_str</span>(),str.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">    lsptr.<span class="built_in">reset</span>(<span class="keyword">new</span> suplog::<span class="built_in">RollSink</span>(<span class="string">&quot;./testdir/rollsink/log&quot;</span>,<span class="number">10</span>));<span class="comment">//故意设置小，查看滚动效果</span></span><br><span class="line">    string msg1=<span class="built_in">string</span>(str).<span class="built_in">append</span>(<span class="string">&quot;msg1&quot;</span>);</span><br><span class="line">    string msg2=<span class="built_in">string</span>(str).<span class="built_in">append</span>(<span class="string">&quot;msg2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    lsptr-&gt;<span class="built_in">log</span>(msg1.<span class="built_in">c_str</span>(),msg1.<span class="built_in">size</span>());</span><br><span class="line">    lsptr-&gt;<span class="built_in">log</span>(msg2.<span class="built_in">c_str</span>(),msg2.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了测试日志落地的功能,我们设计了一段测试代码，测试其多态性的同时，测试了三种落地方式,<strong>特别的</strong>,在<code>RollSink</code>中故意把<code>max_size</code>设的很小，让它能够在测试中滚动输出日志。</p><p>输出结果如下</p><blockquote><p>标准输出落地<br><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202409301424289.png"></p></blockquote><blockquote><p>文件输出落地<br><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202409301426958.png"></p></blockquote><blockquote><p>滚动文件输出落地<br><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202409301426958.png"></p></blockquote><p>可以看到各类落地功能都执行得很好</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">其实之前在suplog::util::file::path函数中</span><br><span class="line">作者不小心写错了一个函数，把name.find_last_of(&quot;/\\&quot;);中的</span><br><span class="line">find_last_of写成了find_last_not_of,结果前面的测试代码</span><br><span class="line">没有测试出bug,导致目录是创建出来了，但是把文件夹路径最后的</span><br><span class="line">文件名也当成目录给创建出来了，可见每一步都做测试的重要性，因为在</span><br><span class="line">这次的测试中，我发现了文件输出失败，原因是打不开文件。（目录当然打不开了）</span><br><span class="line">经过一通排查发现问题出在了之前写的path函数里</span><br><span class="line"></span><br><span class="line">所以一定要多做测试！</span><br></pre></td></tr></table></figure><h2 id="日志类-Logger-主干部分设计（建造者模式）"><a href="#日志类-Logger-主干部分设计（建造者模式）" class="headerlink" title="日志类(Logger)主干部分设计（建造者模式）"></a>日志类(Logger)主干部分设计（建造者模式）</h2><p>⽇志器主要是⽤来和<strong>前端交互</strong>， 当我们需要使⽤⽇志系统打印log的时候， 只需要创建<code>Logger</code>对象，调⽤该对象<code>debug</code>、<code>info</code>、<code>warn</code>、<code>error</code>、<code>fatal</code>等 <strong>⽅法</strong>输出⾃⼰想打印的⽇志即可，⽀持<strong>解析可变参数列表和输出格式</strong>， 即可以做到像使⽤printf函数⼀样打印⽇志。</p><p>当前⽇志系统计划⽀持<code>同步⽇志</code> &amp; <code>异步⽇志</code>两种模式，两个不同的⽇志器唯⼀不同的地⽅在于他们在⽇志的落地⽅式上有所不同：</p><ul><li><code>同步⽇志器</code>：直接对⽇志消息进⾏输出。</li><li><code>异步⽇志器</code>：将⽇志消息放⼊缓冲区，由<strong>异步线程</strong>进⾏输出。</li></ul><p>因此⽇志器类在设计的时候先设计出⼀个<code>Logger基类</code>，在Logger基类的基础上，继承出<code>SyncLogger同步⽇志器</code>和<code>AsyncLogger异步⽇志器</code>。</p><p>且因为⽇志器模块是对前边多个模块的整合，想要创建⼀个⽇志器，需要设置⽇志器名称，设置⽇志输出等级，设置⽇志器类型，设置⽇志输出格式，设置落地⽅向，且落地⽅向有可能存在多个，整个⽇志器的<strong>创建过程较为复杂</strong>，为了保持良好的代码⻛格，编写出优雅的代码，因此⽇志器的创建这⾥采⽤了<code>建造者模式</code>来进⾏创建</p><p>因为同步日志器类比较简单，就直接在这里实现了。</p><p>而异步日志器虽然也在这里实现，但是由于比较复杂，在下一步实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;util.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;level.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;message.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;formatter.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sink.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;looper.hpp&quot;</span><span class="comment">//不认识？没关系，</span></span></span><br><span class="line">                    <span class="comment">//这个头文件后面才实现,给异步日志器的实现用的</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdarg&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> suplog&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Logger</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">enum class</span> <span class="title class_">Type</span>&#123;</span><br><span class="line">            LOGGER_SYNC = <span class="number">0</span>,</span><br><span class="line">            LOGGER_ASYNC</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">using</span> ptr = std::shared_ptr&lt;Logger&gt;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">Logger</span>(<span class="type">const</span> std::string&amp; name,</span><br><span class="line">            Formatter::ptr formatter,</span><br><span class="line">            std::vector&lt;LogSink::ptr&gt; &amp;sinks,</span><br><span class="line">            LogLevel::Level level = LogLevel::Level::DEBUG</span><br><span class="line">        ):_name(name),_level(level),_formatter(formatter),</span><br><span class="line">        _sinks(sinks.<span class="built_in">begin</span>(),sinks.<span class="built_in">end</span>())</span><br><span class="line">        &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">std::string <span class="title">loggerName</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> _name;&#125;</span><br><span class="line">        <span class="function">LogLevel::Level <span class="title">loggerLevel</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> _level;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用C语言风格的不定参数</span></span><br><span class="line">        <span class="comment">//=========start========</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">debug</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*file,<span class="type">size_t</span> line,<span class="type">const</span> <span class="type">char</span>*fmt,...)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">shouldLog</span>(LogLevel::Level::DEBUG) == <span class="literal">false</span>)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            va_list al;</span><br><span class="line">            <span class="built_in">va_start</span>(al,fmt);<span class="comment">//依据fmt从内存中提取可变参数列表</span></span><br><span class="line">            <span class="built_in">log</span>(LogLevel::Level::DEBUG,file,line,fmt,al);<span class="comment">//日志输出</span></span><br><span class="line">            <span class="built_in">va_end</span>(al);<span class="comment">//结束可变参数列表</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">info</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*file,<span class="type">size_t</span> line,<span class="type">const</span> <span class="type">char</span>*fmt,...)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">shouldLog</span>(LogLevel::Level::INFO) == <span class="literal">false</span>)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            va_list al;</span><br><span class="line">            <span class="built_in">va_start</span>(al,fmt);<span class="comment">//依据fmt从内存中提取可变参数列表</span></span><br><span class="line">            <span class="built_in">log</span>(LogLevel::Level::INFO,file,line,fmt,al);<span class="comment">//日志输出</span></span><br><span class="line">            <span class="built_in">va_end</span>(al);<span class="comment">//结束可变参数列表</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">warn</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*file,<span class="type">size_t</span> line,<span class="type">const</span> <span class="type">char</span>*fmt,...)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">shouldLog</span>(LogLevel::Level::WARN) == <span class="literal">false</span>)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            va_list al;</span><br><span class="line">            <span class="built_in">va_start</span>(al,fmt);<span class="comment">//依据fmt从内存中提取可变参数列表</span></span><br><span class="line">            <span class="built_in">log</span>(LogLevel::Level::WARN,file,line,fmt,al);<span class="comment">//日志输出</span></span><br><span class="line">            <span class="built_in">va_end</span>(al);<span class="comment">//结束可变参数列表</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">error</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*file,<span class="type">size_t</span> line,<span class="type">const</span> <span class="type">char</span>*fmt,...)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">shouldLog</span>(LogLevel::Level::ERROR) == <span class="literal">false</span>)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            va_list al;</span><br><span class="line">            <span class="built_in">va_start</span>(al,fmt);<span class="comment">//依据fmt从内存中提取可变参数列表</span></span><br><span class="line">            <span class="built_in">log</span>(LogLevel::Level::WARN,file,line,fmt,al);<span class="comment">//日志输出</span></span><br><span class="line">            <span class="built_in">va_end</span>(al);<span class="comment">//结束可变参数列表</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">fatal</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*file,<span class="type">size_t</span> line,<span class="type">const</span> <span class="type">char</span>*fmt,...)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">shouldLog</span>(LogLevel::Level::FATAL) == <span class="literal">false</span>)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            va_list al;</span><br><span class="line">            <span class="built_in">va_start</span>(al,fmt);<span class="comment">//依据fmt从内存中提取可变参数列表</span></span><br><span class="line">            <span class="built_in">log</span>(LogLevel::Level::FATAL,file,line,fmt,al);<span class="comment">//日志输出</span></span><br><span class="line">            <span class="built_in">va_end</span>(al);<span class="comment">//结束可变参数列表</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//===============end===============</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">//在内部声明一个建造者抽象类</span></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Builder</span></span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="keyword">using</span> ptr = std::shared_ptr&lt;Builder&gt;;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">Builder</span>():_level(LogLevel::Level::DEBUG),</span><br><span class="line">                _logger_type(Logger::Type::LOGGER_SYNC)</span><br><span class="line">            &#123;&#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">buildLoggerName</span><span class="params">(<span class="type">const</span> std::string&amp; name)</span></span>&#123;_logger_name = name;&#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">buildLoggerLevel</span><span class="params">(LogLevel::Level level)</span></span>&#123;_level = level;&#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">buildLoggerType</span><span class="params">(Logger::Type type)</span></span>&#123;_logger_type = type;&#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">buidFormatter</span><span class="params">(<span class="type">const</span> Formatter::ptr&amp; formatter)</span></span>&#123;</span><br><span class="line">                _formatter = formatter;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">buidFormatter</span><span class="params">(<span class="type">const</span> std::string&amp; formatStr)</span></span>&#123;</span><br><span class="line">                <span class="keyword">auto</span> formatter = std::<span class="built_in">make_shared</span>&lt;suplog::Formatter&gt;(formatStr);</span><br><span class="line">                _formatter = formatter;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//C++风格不定参数</span></span><br><span class="line">            <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> SinkType,<span class="keyword">typename</span> ...Args&gt;</span></span><br><span class="line"><span class="function">            <span class="type">void</span> <span class="title">buildSink</span><span class="params">(Args &amp;&amp;...arfs)</span></span>&#123;</span><br><span class="line">                <span class="keyword">auto</span> sink = SinkFactory::<span class="built_in">create</span>&lt;SinkType&gt;(std::forward&lt;Args&gt;(args)...);</span><br><span class="line">                _sinks.<span class="built_in">push_back</span>(sink);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">virtual</span> Logger::ptr <span class="title">build</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">protected</span>:</span><br><span class="line">            Logger::Type _logger_type;</span><br><span class="line">            std::string _logger_name;</span><br><span class="line">            LogLevel::Level _level;</span><br><span class="line">            Formatter::ptr _formatter;</span><br><span class="line">            std::vector&lt;LogSink::ptr&gt; _sinks;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">shouldLog</span><span class="params">(LogLevel::Level level)</span></span>&#123;<span class="keyword">return</span> level&gt;= _level;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(LogLevel::Level level,<span class="type">const</span> <span class="type">char</span>*file,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">size_t</span> line,<span class="type">const</span> <span class="type">char</span>*fmt,va_list al)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">char</span> *buf;<span class="comment">//可以不初始化</span></span><br><span class="line">        std::string msg;</span><br><span class="line">        <span class="type">int</span> len = <span class="built_in">vasprintf</span>(&amp;buf,fmt,al);<span class="comment">//自动在堆区申请内存</span></span><br><span class="line">        <span class="keyword">if</span>(len &lt; <span class="number">0</span>)</span><br><span class="line">            msg = <span class="string">&quot;格式化日志消息失败!!&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            msg.<span class="built_in">assign</span>(buf,len);</span><br><span class="line">            <span class="built_in">free</span>(buf);<span class="comment">//释放空间</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//LogMsg(name, file, line, payload, level)</span></span><br><span class="line">        <span class="function">LogMsg <span class="title">logmsg</span><span class="params">(_name,file,line,std::move(msg),level)</span></span>;</span><br><span class="line">        std::string str;</span><br><span class="line">        str = _formatter-&gt;format(logmsg);</span><br><span class="line">        <span class="built_in">logIt</span>(std::<span class="built_in">move</span>(str));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">logIt</span><span class="params">(<span class="type">const</span> std::string &amp;msg)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        std::mutex _mutex;</span><br><span class="line">        std::string _name;</span><br><span class="line">        Formatter::ptr _formatter;</span><br><span class="line">        std::atomic&lt;LogLevel::Level&gt; _level;</span><br><span class="line">        std::vector&lt;LogSink::ptr&gt; _sinks; </span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//同步日志器比较简单，所以直接实现了</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">SyncLogger</span>:<span class="keyword">public</span> Logger</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">using</span> ptr = std::shared_ptr&lt;SyncLogger&gt;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">SyncLogger</span>(<span class="type">const</span> std::string&amp; name,</span><br><span class="line">            Formatter::ptr formatter,</span><br><span class="line">            std::vector&lt;LogSink::ptr&gt;&amp;sinks,</span><br><span class="line">            LogLevel::Level level = LogLevel::Level::DEBUG)</span><br><span class="line">            :<span class="built_in">Logger</span>(name,formatter,sinks,level)&#123;</span><br><span class="line">                std::cout &lt;&lt; LogLevel::<span class="built_in">toString</span>(level)&lt;&lt;<span class="string">&quot;同步日志器创建成功...\n&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">logIt</span><span class="params">(<span class="type">const</span> std::string&amp; msg_str)</span></span>&#123;</span><br><span class="line">                <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(_mutex)</span></span>;<span class="comment">//函数结束后自动释放锁</span></span><br><span class="line">                <span class="keyword">if</span>(_sinks.<span class="built_in">empty</span>()) &#123;<span class="keyword">return</span>;&#125;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;it:_sinks)</span><br><span class="line">                    it-&gt;<span class="built_in">log</span>(msg_str.<span class="built_in">c_str</span>(),msg_str.<span class="built_in">size</span>());</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">LocalLoggerBuilder</span>:<span class="keyword">public</span> Logger::Builder</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> Logger::ptr <span class="title">build</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(_logger_name.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                std::cout&lt;&lt;<span class="string">&quot;日志器名称不能为空！！&quot;</span>;</span><br><span class="line">                <span class="built_in">abort</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(_formatter.<span class="built_in">get</span>() == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                std::cout&lt;&lt;<span class="string">&quot;当前日志器： &quot;</span>&lt;&lt;_logger_name;</span><br><span class="line">                std::cout&lt;&lt;<span class="string">&quot; 未检测到⽇志格式,默认设置为: &quot;</span>;</span><br><span class="line">                std::cout&lt;&lt;<span class="string">&quot; %d&#123;%H:%M:%S&#125;%T%t%T[%p]%T[%c]%T%f:%l%T%m%n\n&quot;</span>;</span><br><span class="line">                _formatter = std::<span class="built_in">make_shared</span>&lt;Formatter&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(_sinks.<span class="built_in">empty</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                std::cout&lt;&lt;<span class="string">&quot;当前日志器: &quot;</span>&lt;&lt;_logger_name&lt;&lt;<span class="string">&quot;问检测到落地方向，默认为标准输出!\n&quot;</span>;</span><br><span class="line">                _sinks.<span class="built_in">push_back</span>(std::<span class="built_in">make_shared</span>&lt;StdoutSink&gt;());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Logger::ptr lp;</span><br><span class="line">            <span class="keyword">if</span>(_logger_type == Logger::Type::LOGGER_ASYNC)</span><br><span class="line">            &#123;</span><br><span class="line">                lp = std::<span class="built_in">make_shared</span>&lt;AsyncLogger&gt;(_logger_name,_formatter,_sinks,_level);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                lp = std::<span class="built_in">make_shared</span>&lt;SyncLogger&gt;(_logger_name,_formatter,_sinks,_level);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="双缓冲区异步任务处理器（AsyncLooper）设计"><a href="#双缓冲区异步任务处理器（AsyncLooper）设计" class="headerlink" title="双缓冲区异步任务处理器（AsyncLooper）设计"></a>双缓冲区异步任务处理器（AsyncLooper）设计</h2><p>设计思想：异步处理线程 + 数据池</p><p>使⽤者将需要完成的任务添加到任务池中，由<strong>异步线程来完成任务的实际执⾏操作</strong>。</p><p>任务池的设计思想:<strong>双缓冲区阻塞数据池</strong></p><p>优势：缓冲区避免了空间的频繁申请释放，且尽可能的减少了生产者与消费者之间<strong>锁冲突</strong>的概率,提高了任务处理的效率</p><blockquote><p>在任务池的设计中，有很多备选⽅案，⽐如循环队列等等，但是不管是哪⼀种都会涉及到<strong>锁冲突</strong>的情况，因为在⽣产者与消费者模型中，任何两个⻆⾊之间都具有互斥关系，因此每⼀次的任务<strong>添加与取出都有可能涉及锁的冲突</strong>，⽽双缓冲区不同，双缓冲区是处理器将⼀个缓冲区中的任务全部处理完毕后，然后交换两个缓冲区，重新对新的缓冲区中的任务进⾏处理，虽然同时多线程写⼊也会冲突，但是冲突并不会像每次只处理⼀条的时候频繁（减少了⽣产者与消费者之间的锁冲突），且不涉及到空间的频繁申请释放所带来的消耗。</p></blockquote><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202410041822328.gif"></p><blockquote><p>buffer.hpp</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> suplog</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_DEFUALT_SIZE (1*1024*1024)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_INCREMENT_SIZE (1*1024*1024)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_THRESHOLD_SIZE (10*1024*1024)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Buffer</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Buffer</span>():_reader_idx(<span class="number">0</span>),_writer_idx(<span class="number">0</span>),_v(BUFFER_DEFUALT_SIZE)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> _reader_idx == _writer_idx;&#125;</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">readAbleSize</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> _writer_idx - _reader_idx;&#125;</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">writeAbleSize</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> _v.<span class="built_in">size</span>() - _writer_idx;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">()</span></span>&#123;_reader_idx = _writer_idx = <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(Buffer&amp; buf)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _v.<span class="built_in">swap</span>(buf._v);</span><br><span class="line">        std::<span class="built_in">swap</span>(_reader_idx,buf._reader_idx);</span><br><span class="line">        std::<span class="built_in">swap</span>(_writer_idx,buf._writer_idx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*data,<span class="type">size_t</span> len)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">ensureEnoughSpace</span>(len);</span><br><span class="line">        <span class="built_in">assert</span>(len&lt;=<span class="built_in">writeAbleSize</span>());</span><br><span class="line">        std::<span class="built_in">copy</span>(data,data+len,&amp;_v[_writer_idx]);</span><br><span class="line">        _writer_idx+=len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">(<span class="type">size_t</span> len)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _reader_idx +=len;</span><br><span class="line">        <span class="built_in">assert</span>(_reader_idx &lt;=_writer_idx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">begin</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> &amp;_v[_reader_idx];&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ensureEnoughSpace</span><span class="params">(<span class="type">size_t</span> len)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(len &lt;=<span class="built_in">writeAbleSize</span>())<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">size_t</span> new_capacity;</span><br><span class="line">        <span class="comment">//每次增加1M的大小</span></span><br><span class="line">        <span class="keyword">if</span>(_v.<span class="built_in">size</span>() &lt; BUFFER_THRESHOLD_SIZE)</span><br><span class="line">            new_capacity = _v.<span class="built_in">size</span>()*<span class="number">2</span>+len;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            new_capacity = _v.<span class="built_in">size</span>() + BUFFER_INCREMENT_SIZE + len;</span><br><span class="line"></span><br><span class="line">        _v.<span class="built_in">resize</span>(new_capacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">size_t</span> _reader_idx;</span><br><span class="line">    <span class="type">size_t</span> _writer_idx;</span><br><span class="line">    std::vector&lt;<span class="type">char</span>&gt; _v;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>looper.hpp</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;util.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;buffer.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> suplog</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">AsyncLooper</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">using</span> ptr = std::shared_ptr&lt;AsyncLooper&gt;;</span><br><span class="line">        <span class="keyword">using</span> Functor = std::function&lt;<span class="built_in">void</span>(Buffer &amp;buffer)&gt;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">AsyncLooper</span>(<span class="type">const</span> Functor&amp;cb)</span><br><span class="line">        : _running(<span class="literal">true</span>),</span><br><span class="line">        _looper_callback(cb),</span><br><span class="line">        _thread(std::<span class="built_in">thread</span>(&amp;AsyncLooper::worker_loop,<span class="keyword">this</span>))</span><br><span class="line">        &#123;&#125;</span><br><span class="line"></span><br><span class="line">        ~<span class="built_in">AsyncLooper</span>()&#123;<span class="built_in">stop</span>();&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">stop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            _running =<span class="literal">false</span>;</span><br><span class="line">            _pop_cond.<span class="built_in">notify_all</span>();<span class="comment">//取消所有线程的条件变量等待</span></span><br><span class="line">            _thread.<span class="built_in">join</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> std::string&amp;msg)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(_running == <span class="literal">false</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(_mutex)</span></span>;</span><br><span class="line">            _push_cond.<span class="built_in">wait</span>(lock,[&amp;]&#123;</span><br><span class="line">                <span class="keyword">return</span> _tasks_push.<span class="built_in">writeAbleSize</span>() &gt;= msg.<span class="built_in">size</span>();</span><br><span class="line">                &#125;);<span class="comment">//防止消息过大</span></span><br><span class="line"></span><br><span class="line">            _tasks_push.<span class="built_in">push</span>(msg.<span class="built_in">c_str</span>(),msg.<span class="built_in">size</span>());<span class="comment">//完成消息任务推送</span></span><br><span class="line"></span><br><span class="line">            _pop_cond.<span class="built_in">notify_all</span>();<span class="comment">//唤醒所有消费者</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">worker_loop</span><span class="params">(<span class="type">void</span>* arg)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="comment">//多线程执行函数得靠arg传递this指针</span></span><br><span class="line">            AsyncLooper* al = (AsyncLooper* )arg;</span><br><span class="line">            <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                 <span class="comment">// lock 的析构函数在离开作用域时自动释放互斥锁</span></span><br><span class="line">                <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(al-&gt;_mutex)</span></span>;</span><br><span class="line">                <span class="comment">//线程出口,为空且关闭时退出循环</span></span><br><span class="line">                <span class="keyword">if</span>(al-&gt;_running == <span class="literal">false</span> &amp;&amp; al-&gt;_tasks_push.<span class="built_in">empty</span>())</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//生产者缓冲不为空或者停止运行时才会被唤醒</span></span><br><span class="line">                al-&gt;_pop_cond.<span class="built_in">wait</span>(lock,[&amp;]&#123;<span class="keyword">return</span> !al-&gt;_tasks_push.<span class="built_in">empty</span>() || !al-&gt;_running;&#125;);</span><br><span class="line">                al-&gt;_tasks_push.<span class="built_in">swap</span>(al-&gt;_tasks_pop);<span class="comment">//交换缓冲区</span></span><br><span class="line"></span><br><span class="line">                al-&gt;_push_cond.<span class="built_in">notify_all</span>();<span class="comment">//唤醒所有生产者缓冲区</span></span><br><span class="line">                al-&gt;_looper_callback(al-&gt;_tasks_pop);<span class="comment">//输出消费者缓冲区</span></span><br><span class="line">                al-&gt;_tasks_pop.<span class="built_in">reset</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        Functor _looper_callback;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        std::mutex _mutex;</span><br><span class="line">        std::atomic&lt;<span class="type">bool</span>&gt; _running;</span><br><span class="line">        std::condition_variable _push_cond;</span><br><span class="line">        std::condition_variable _pop_cond;</span><br><span class="line">        Buffer _tasks_push;</span><br><span class="line">        Buffer _tasks_pop;</span><br><span class="line">        std::thread _thread;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="异步日志器-AsyncLogger-设计"><a href="#异步日志器-AsyncLogger-设计" class="headerlink" title="异步日志器(AsyncLogger)设计"></a>异步日志器(AsyncLogger)设计</h2><p>在实现了<code>AsyncLooper</code>后，异步日志器的实现就很简单了，具体的<code>生产者-消费者</code>交互工作都交给了<code>AsyncLooper</code>，异步日志器主要负责推送日志任务，以及获取日志任务，转发给落地类(<code>LogSink</code>)去完成</p><ul><li><code>LogIt</code>为重写父类函数，专门现将⽇志数据加⼊异步队列缓冲区中</li><li><code>readLog</code>函数在<strong>异步线程</strong>上执行调用,完成日志的实际落地工作</li></ul><blockquote><p>logger.hpp</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//class SyncLogger:public Logger</span></span><br><span class="line"><span class="comment">//上面已经实现过了，代码略......</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">AsyncLogger</span>:<span class="keyword">public</span> Logger</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">using</span> ptr = std::shared_ptr&lt;AsyncLogger&gt;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">AsyncLogger</span>(<span class="type">const</span> std::string&amp; name,</span><br><span class="line">            Formatter::ptr formatter,</span><br><span class="line">            std::vector&lt;LogSink::ptr&gt;&amp;sinks,</span><br><span class="line">            LogLevel::Level level = LogLevel::Level::DEBUG)</span><br><span class="line">            :<span class="built_in">Logger</span>(name,formatter,sinks,level)</span><br><span class="line">            ,_looper(std::<span class="built_in">make_shared</span>&lt;AsyncLooper&gt;(</span><br><span class="line">                std::<span class="built_in">bind</span>(&amp;AsyncLogger::readLog,<span class="keyword">this</span>,std::placeholders::_1)))</span><br><span class="line">                <span class="comment">//传一个this,使包装器里的函数能够是成员函数,this后面的才是包装器指定的参数</span></span><br><span class="line">            &#123;</span><br><span class="line">                std::cout &lt;&lt; LogLevel::<span class="built_in">toString</span>(level)&lt;&lt;<span class="string">&quot;异步日志器创建成功...\n&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">logIt</span><span class="params">(<span class="type">const</span> std::string &amp;msg)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            _looper-&gt;<span class="built_in">push</span>(msg);<span class="comment">//推送消息</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">readLog</span><span class="params">(Buffer&amp; msg)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(_sinks.<span class="built_in">empty</span>())&#123;<span class="keyword">return</span>;&#125;<span class="comment">//判空</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;it:_sinks)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//调用落地功能</span></span><br><span class="line">                it-&gt;<span class="built_in">log</span>(msg.<span class="built_in">begin</span>(),msg.<span class="built_in">readAbleSize</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        AsyncLooper::ptr _looper;</span><br><span class="line">    </span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  class LocalLoggerBuilder:public Logger::Builder</span></span><br><span class="line"><span class="comment">//  实现过了，代码略......</span></span><br></pre></td></tr></table></figure><h2 id="单例日志器管理类设计（单例模式）"><a href="#单例日志器管理类设计（单例模式）" class="headerlink" title="单例日志器管理类设计（单例模式）"></a>单例日志器管理类设计（单例模式）</h2><p>日志的输出，我们希望能够在<strong>任意位置都可以进行</strong>，但是当我们创建了一个日志器后，就会受到日志器所在<strong>作用域</strong>的访问属性限制。</p><p>因此，为了突破访问区域的限制，我们再封装一个日志器管理类，并采用<code>单例模式</code>，安全地在全局的任意位置调用指定的日志器</p><p><code>全局日志器建造者类</code>：既然日志器管理类是在全局上工作的，我们决定再封装一个配套的<strong>全局日志器建造者类</strong>,<strong>自动</strong>将新增的日志器添加到单例日志类管理器中。</p><p>对特定日志器的访问:这里采用通过名字索引的方式获取指定日志器</p><blockquote><p>logger.hpp</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//接在LocalLoggerBuilder后面</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">LoggerManager</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">static</span> LoggerManager&amp; <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="type">static</span> LoggerManager lm;<span class="comment">//饿汉模式创建全局对象</span></span><br><span class="line">            <span class="keyword">return</span> lm;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">hasLogger</span><span class="params">(<span class="type">const</span> std::string&amp; name)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(_mutex)</span></span>;</span><br><span class="line">            <span class="keyword">auto</span> it = _loggers.<span class="built_in">find</span>(name);</span><br><span class="line">            <span class="keyword">if</span>(it == _loggers.<span class="built_in">end</span>())</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">addLogger</span><span class="params">(<span class="type">const</span> std::string&amp; name,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="type">const</span> Logger::ptr logger)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(_mutex)</span></span>;</span><br><span class="line">            _loggers.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(name,logger));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">Logger::ptr <span class="title">getLogger</span><span class="params">(<span class="type">const</span> std::string &amp;name)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(_mutex)</span></span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">hasLogger</span>(name))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">auto</span> it = _loggers.<span class="built_in">find</span>(name);</span><br><span class="line">                <span class="keyword">if</span>(it!= _loggers.<span class="built_in">end</span>())</span><br><span class="line">                    <span class="keyword">return</span> it-&gt;second;<span class="comment">//找到了，返回指针</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//找不到</span></span><br><span class="line">            <span class="keyword">return</span> Logger::<span class="built_in">ptr</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">Logger::ptr <span class="title">rootLogger</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(_mutex)</span></span>;</span><br><span class="line">            <span class="keyword">return</span> _root_logger;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">LoggerManager</span>()<span class="comment">//私有化防止外部调用，破坏单例模式</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//调用本地建造者</span></span><br><span class="line">            <span class="function">std::unique_ptr&lt;LocalLoggerBuilder&gt; <span class="title">slb</span><span class="params">(<span class="keyword">new</span> LocalLoggerBuilder())</span></span>;</span><br><span class="line">            slb-&gt;<span class="built_in">buildLoggerName</span>(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">            slb-&gt;<span class="built_in">buildLoggerType</span>(Logger::Type::LOGGER_SYNC);</span><br><span class="line">            <span class="comment">//格式使用默认</span></span><br><span class="line">            <span class="comment">//采用默认落地方向</span></span><br><span class="line">            _root_logger = slb-&gt;<span class="built_in">build</span>();</span><br><span class="line">            _loggers.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(<span class="string">&quot;root&quot;</span>,_root_logger));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">LoggerManager</span>(<span class="type">const</span> LoggerManager&amp;) = <span class="keyword">delete</span>;<span class="comment">//删除拷贝构造</span></span><br><span class="line">        LoggerManager&amp; <span class="keyword">operator</span>=(<span class="type">const</span> LoggerManager&amp;) = <span class="keyword">delete</span>;<span class="comment">//删除重载</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        std::mutex _mutex;<span class="comment">//互斥量</span></span><br><span class="line">        Logger::ptr _root_logger;<span class="comment">//至少有一个日志器</span></span><br><span class="line">        std::unordered_map&lt;std::string,Logger::ptr&gt; _loggers;</span><br><span class="line">        <span class="comment">//使用父类指针统一管理，使用多态</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">GlobalLoggerBuilder</span>:<span class="keyword">public</span> Logger::Builder</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> Logger::ptr <span class="title">build</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(_logger_name.<span class="built_in">empty</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                std::cout&lt;&lt;<span class="string">&quot;日志器名称不能为空!!&quot;</span>;</span><br><span class="line">                <span class="built_in">abort</span>();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//不能有重名的日志器</span></span><br><span class="line">            <span class="built_in">assert</span>(LoggerManager::<span class="built_in">getInstance</span>().<span class="built_in">hasLogger</span>(_logger_name) == <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(_formatter.<span class="built_in">get</span>() == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                std::cout&lt;&lt;<span class="string">&quot;当前日志器： &quot;</span>&lt;&lt;_logger_name;</span><br><span class="line">                std::cout&lt;&lt;<span class="string">&quot; 未检测到⽇志格式,默认设置为: &quot;</span>;</span><br><span class="line">                std::cout&lt;&lt;<span class="string">&quot; %d&#123;%H:%M:%S&#125;%T%t%T[%p]%T[%c]%T%f:%l%T%m%n\n&quot;</span>;</span><br><span class="line">                _formatter = std::<span class="built_in">make_shared</span>&lt;Formatter&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(_sinks.<span class="built_in">empty</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                std::cout&lt;&lt;<span class="string">&quot;当前日志器: &quot;</span>&lt;&lt;_logger_name&lt;&lt;<span class="string">&quot;问检测到落地方向，默认为标准输出!\n&quot;</span>;</span><br><span class="line">                _sinks.<span class="built_in">push_back</span>(std::<span class="built_in">make_shared</span>&lt;StdoutSink&gt;());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Logger::ptr lp;</span><br><span class="line">            <span class="keyword">if</span>(_logger_type == Logger::Type::LOGGER_SYNC)</span><br><span class="line">            &#123;</span><br><span class="line">                lp = std::<span class="built_in">make_shared</span>&lt;SyncLogger&gt;(_logger_name,_formatter,_sinks,_level);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                lp = std::<span class="built_in">make_shared</span>&lt;AsyncLogger&gt;(_logger_name,_formatter,_sinks,_level);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//加入全局日志器管理类中</span></span><br><span class="line">            LoggerManager::<span class="built_in">getInstance</span>().<span class="built_in">addLogger</span>(_logger_name,lp);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> lp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><p>终于是完成了日志系统的大部分代码，由于前几个模块关联性过高，所以测试代码憋到现在来写，没关系，这就开测！</p><p>测试目标</p><ul><li>测试<code>GlobalLoggerBuilder</code>能否正常创建实例</li><li>测试两种日志器能否正常工作</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;logger.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string path = <span class="string">&quot;./test/rollsink&quot;</span>;</span><br><span class="line">    suplog::LoggerManager&amp; lm = suplog::LoggerManager::<span class="built_in">getInstance</span>();</span><br><span class="line"></span><br><span class="line">    suplog::GlobalLoggerBuilder glb;</span><br><span class="line">    glb.<span class="built_in">buildLoggerName</span>(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">    glb.<span class="built_in">buildSink</span>&lt;suplog::RollSink&gt;(<span class="string">&quot;./test/rollsink&quot;</span>,<span class="number">10</span>);</span><br><span class="line">    glb.<span class="built_in">buildLoggerType</span>(suplog::Logger::Type::LOGGER_ASYNC);</span><br><span class="line"></span><br><span class="line">    suplog::Logger::ptr alogger= glb.<span class="built_in">build</span>();</span><br><span class="line">    suplog::Logger::ptr slogger = lm.<span class="built_in">rootLogger</span>();</span><br><span class="line"></span><br><span class="line">    alogger-&gt;<span class="built_in">warn</span>(<span class="string">&quot;main.cpp&quot;</span>,<span class="number">19</span>,<span class="string">&quot;这是一条警告测试信息，测试码:%d&quot;</span>,<span class="number">0</span>);</span><br><span class="line">    alogger-&gt;<span class="built_in">warn</span>(<span class="string">&quot;main.cpp&quot;</span>,<span class="number">20</span>,<span class="string">&quot;这是一条警告测试信息，测试码:%d&quot;</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    slogger-&gt;<span class="built_in">debug</span>(<span class="string">&quot;main.cpp&quot;</span>,<span class="number">22</span>,<span class="string">&quot;这是一条标准输出测试信息&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下</p><p><em>标准输出</em></p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202410042158759.png"></p><p><em>滚动文件输出</em></p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202410042201373.png"></p><p>可以看到，正常工作</p><h2 id="日志宏-全局接口设计-代理模式"><a href="#日志宏-全局接口设计-代理模式" class="headerlink" title="日志宏&amp;全局接口设计(代理模式)"></a>日志宏&amp;全局接口设计(代理模式)</h2><p>目前<code>logger.h</code>暴露给用户的接口还是太多了，所以新增一个代理来简化和保护.提供全局的日志器获取接口</p><p>实现代理模式时，通过<code>全局函数</code>或<code>宏函数</code>来代理<code>Logger</code>类的<code>log</code>,<code>debug</code>,<code>info</code>,<code>warn</code>,<code>error</code>,<code>fatal</code>等接口,以便于控制源码文件名称和行号的输出控制，简化用户操作</p><p>设计上，<strong>标准输出日志的功能由主日志器承担</strong>。当仅需要标准输出日志的时候可以通过当日志器来打印日志。且操作时只需要通过宏函数直接进行输出即可</p><blockquote><p>suplog.hpp</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;logger.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> suplog</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Logger::ptr <span class="title">getLogger</span><span class="params">(<span class="type">const</span> std::string&amp; name)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LoggerManager::<span class="built_in">getInstance</span>().<span class="built_in">getLogger</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Logger::ptr <span class="title">rootLogger</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LoggerManager::<span class="built_in">getInstance</span>().<span class="built_in">rootLogger</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> WOW 6666</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//开始定义宏函数</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> debug(fmt,...)  debug(__FILE__,__LINE__,fmt,##__VA_ARGS__)<span class="comment">//利用宏，自动传入文件路径和行号</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> info(fmt,...)  info(__FILE__,__LINE__,fmt,##__VA_ARGS__)</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> warn(fmt,...)  warn(__FILE__,__LINE__,fmt,##__VA_ARGS__)</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> <span class="keyword">error</span>(fmt,...)  <span class="keyword">error</span>(__FILE__,__LINE__,fmt,##__VA_ARGS__)</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> fatal(fmt,...)  fatal(__FILE__,__LINE__,fmt,##__VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//封装真正能用的宏函数</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> LOG_DEBUG(logger,fmt,...) (logger)-&gt;debug(fmt,##__VA_ARGS__)<span class="comment">//这里就用了上面的宏函数</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> LOG_INFO(logger,fmt,...) (logger)-&gt;info(fmt,##__VA_ARGS__)</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> LOG_WARN(logger,fmt,...) (logger)-&gt;warn(fmt,##__VA_ARGS__)</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> LOG_ERROR(logger,fmt,...) (logger)-&gt;<span class="keyword">error</span>(fmt,##__VA_ARGS__)</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> LOG_FATAL(logger,fmt,...) (logger)-&gt;fatal(fmt,##__VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//封装主函数的调用</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> LOGD(fmt,...) LOG_DEBUG(suplog::rootLogger(),fmt,##__VA_ARGS__)</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> LOGI(fmt,...) LOG_INFO(suplog::rootLogger(),fmt,##__VA_ARGS__)</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> LOGW(fmt,...) LOG_WARN(suplog::rootLogger(),fmt,##__VA_ARGS__)</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> LOGE(fmt,...) LOG_ERROR(suplog::rootLogger(),fmt,##__VA_ARGS__)</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> LOGF(fmt,...) LOG_FATAL(suplog::rootLogger(),fmt,##__VA_ARGS__)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="项目测试"><a href="#项目测试" class="headerlink" title="项目测试"></a>项目测试</h1><p>至此项目代码的基本功能已经完成，剩下的便是对其进行一系列测试了</p><p><a href="https://github.com/sis-shen/Asynchrinous-Logging-System/releases/tag/%E6%AD%A3%E5%BC%8F%E7%89%88">戳我去代码发布页🔗</a></p><h2 id="功能测试"><a href="#功能测试" class="headerlink" title="功能测试"></a>功能测试</h2><p>测试⼀个⽇志器中包含有所有的落地⽅向，观察是否每个⽅向都正常落地，分别测试<code>同步⽅式</code>和<code>异步⽅式</code>落地后数据是否正常。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;suplog.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//功能测试</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loggerTest</span><span class="params">(<span class="type">const</span> std::string&amp; logger_name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    suplog::Logger::ptr lp = suplog::<span class="built_in">getLogger</span>(logger_name);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert</span>(lp.<span class="built_in">get</span>());<span class="comment">//防止拿到空指针</span></span><br><span class="line">    <span class="built_in">LOGD</span>(<span class="string">&quot;------------example---------------&quot;</span>);</span><br><span class="line">    <span class="comment">//测试原生日志器</span></span><br><span class="line">    lp-&gt;<span class="built_in">debug</span>(<span class="string">&quot;%s&quot;</span>, <span class="string">&quot;logger-&gt;debug&quot;</span>);</span><br><span class="line">    lp-&gt;<span class="built_in">info</span>(<span class="string">&quot;%s&quot;</span>, <span class="string">&quot;logger-&gt;info&quot;</span>);</span><br><span class="line">    lp-&gt;<span class="built_in">warn</span>(<span class="string">&quot;%s&quot;</span>, <span class="string">&quot;logger-&gt;warn&quot;</span>);</span><br><span class="line">    lp-&gt;<span class="built_in">error</span>(<span class="string">&quot;%s&quot;</span>, <span class="string">&quot;logger-&gt;error&quot;</span>);</span><br><span class="line">    lp-&gt;<span class="built_in">fatal</span>(<span class="string">&quot;%s&quot;</span>, <span class="string">&quot;logger-&gt;fatal&quot;</span>);</span><br><span class="line">    <span class="comment">//测试代理模式</span></span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(lp, <span class="string">&quot;%s&quot;</span>, <span class="string">&quot;LOG_DEBUG&quot;</span>);</span><br><span class="line">    <span class="built_in">LOG_INFO</span>(lp, <span class="string">&quot;%s&quot;</span>, <span class="string">&quot;LOG_INFO&quot;</span>);</span><br><span class="line">    <span class="built_in">LOG_WARN</span>(lp, <span class="string">&quot;%s&quot;</span>, <span class="string">&quot;LOG_WARN&quot;</span>);</span><br><span class="line">    <span class="built_in">LOG_ERROR</span>(lp, <span class="string">&quot;%s&quot;</span>, <span class="string">&quot;LOG_ERROR&quot;</span>);</span><br><span class="line">    <span class="built_in">LOG_FATAL</span>(lp, <span class="string">&quot;%s&quot;</span>, <span class="string">&quot;LOG_FATAL&quot;</span>);</span><br><span class="line">    <span class="built_in">LOGD</span>(<span class="string">&quot;-----------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">    std::string log_msg = <span class="string">&quot;hello supdriver test log msg -&quot;</span>;</span><br><span class="line">    <span class="type">size_t</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(count &lt; <span class="number">1000000</span>)<span class="comment">//输出一百万条日志</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::string msg = log_msg + std::<span class="built_in">to_string</span>(count++);</span><br><span class="line">        lp-&gt;<span class="built_in">error</span>(<span class="string">&quot;%s&quot;</span>,msg.<span class="built_in">c_str</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    suplog::<span class="function">GlobalLoggerBuilder::ptr <span class="title">glb</span><span class="params">(<span class="keyword">new</span> suplog::GlobalLoggerBuilder())</span></span>;</span><br><span class="line">    glb-&gt;<span class="built_in">buildLoggerName</span>(<span class="string">&quot;sync-logger&quot;</span>);<span class="comment">//设置日志器名称</span></span><br><span class="line">    <span class="comment">// glb-&gt;buidFormatter(&quot;[%d][%c][%f:%l][%p] %m%n&quot;);//设置日志输出格式</span></span><br><span class="line">    glb-&gt;<span class="built_in">buildLoggerLevel</span>(suplog::LogLevel::Level::DEBUG);</span><br><span class="line">    glb-&gt;<span class="built_in">buildSink</span>&lt;suplog::StdoutSink&gt;();<span class="comment">//创建标准输出落地方向</span></span><br><span class="line">    glb-&gt;<span class="built_in">buildSink</span>&lt;suplog::FileSink&gt;(<span class="string">&quot;./testdir/logs/sync.log&quot;</span>);<span class="comment">//创建文件落地方向</span></span><br><span class="line">    glb-&gt;<span class="built_in">buildSink</span>&lt;suplog::RollSink&gt;(<span class="string">&quot;./testdir/roll_logs/roll-&quot;</span>,<span class="number">10</span>*<span class="number">1024</span>*<span class="number">1024</span>);</span><br><span class="line">    glb-&gt;<span class="built_in">buildLoggerType</span>(suplog::Logger::Type::LOGGER_SYNC);</span><br><span class="line"></span><br><span class="line">    glb-&gt;<span class="built_in">build</span>();<span class="comment">//建造同步日志器</span></span><br><span class="line"></span><br><span class="line">    glb-&gt;<span class="built_in">buildLoggerName</span>(<span class="string">&quot;async-logger&quot;</span>);</span><br><span class="line">    glb-&gt;<span class="built_in">buildSink</span>&lt;suplog::FileSink&gt;(<span class="string">&quot;./testdir/logs/async.log&quot;</span>);<span class="comment">//创建文件落地方向</span></span><br><span class="line">    glb-&gt;<span class="built_in">buildSink</span>&lt;suplog::RollSink&gt;(<span class="string">&quot;./testdir/async-roll/roll-&quot;</span>,<span class="number">10</span>*<span class="number">1024</span>*<span class="number">1024</span>);</span><br><span class="line">    glb-&gt;<span class="built_in">buildLoggerType</span>(suplog::Logger::Type::LOGGER_ASYNC);</span><br><span class="line"></span><br><span class="line">    glb-&gt;<span class="built_in">build</span>();<span class="comment">//建造异步日志器</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">loggerTest</span>(<span class="string">&quot;sync-logger&quot;</span>);</span><br><span class="line">    <span class="built_in">loggerTest</span>(<span class="string">&quot;async-logger&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果：功能运行正常，但是由于<code>100万</code>条日志实在太多，就不把测试结果放出来了</p><h2 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h2><p>下⾯对⽇志系统做⼀个性能测试，测试⼀下平均每秒能打印多少条⽇志消息到⽂件。</p><p>主要的测试⽅法是：每秒能打印⽇志数 &#x3D; 打印⽇志条数 &#x2F; 总的打印⽇志消耗时间</p><p>主要测试要素：同步&#x2F;异步 &amp; 单线程&#x2F;多线程</p><ul><li>100w+条指定⻓度的⽇志输出所耗时间</li><li>每秒可以输出多少条⽇志</li><li>每秒可以输出多少MB⽇志</li></ul><p>测试环境</p><ul><li><code>CPU</code>:Intel(R) Xeon(R) Platinum 2.5GHZ*2</li><li><code>RAM</code>:2G</li><li><code>OS</code>:Ubuntu 22.04 64位</li></ul><blockquote><p>bench.hpp</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;suplog.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span><span class="comment">//处理时间</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> suplog</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bench</span><span class="params">(<span class="type">const</span> std::string&amp; logger_name,<span class="type">size_t</span> thread_num,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">size_t</span> msglen,<span class="type">size_t</span> msg_count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Logger::ptr lp = <span class="built_in">getLogger</span>(logger_name);</span><br><span class="line">    <span class="keyword">if</span>(lp.<span class="built_in">get</span>() ==<span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="function">std::string <span class="title">msg</span><span class="params">(msglen,<span class="string">&#x27;1&#x27;</span>)</span></span>;<span class="comment">//用字符1补全长度</span></span><br><span class="line">    <span class="type">size_t</span> msg_count_per_thread = msg_count/thread_num;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">double</span>&gt; <span class="title">cost_time</span><span class="params">(thread_num)</span></span>;</span><br><span class="line">    std::vector&lt;std::thread&gt;threads;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;输入线程数量&quot;</span>&lt;&lt;thread_num&lt;&lt;std::endl;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;输出日志数量&quot;</span>&lt;&lt;msg_count &lt;&lt;std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;输出⽇志⼤⼩: &quot;</span> &lt;&lt; msglen * msg_count / <span class="number">1024</span> &lt;&lt; <span class="string">&quot;KB&quot;</span> &lt;&lt;std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;thread_num;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//empalce_back直接构造对象，即新增新的任务线程</span></span><br><span class="line">        threads.<span class="built_in">emplace_back</span>([&amp;,i]()&#123;</span><br><span class="line">            <span class="keyword">auto</span> start = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">size_t</span> j = <span class="number">0</span>;j&lt;msg_count_per_thread;++j)</span><br><span class="line">            &#123;</span><br><span class="line">                lp-&gt;<span class="built_in">fatal</span>(<span class="string">&quot;%s&quot;</span>,msg.<span class="built_in">c_str</span>());<span class="comment">//输出日志</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">auto</span> end = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">            <span class="comment">//计算时间差</span></span><br><span class="line">            <span class="keyword">auto</span> cost = std::chrono::duration_cast&lt;std::chrono::duration&lt;<span class="type">double</span>&gt;&gt;(end-start);</span><br><span class="line">            cost_time[i] = cost.<span class="built_in">count</span>();</span><br><span class="line">            <span class="keyword">auto</span> avg = msg_count_per_thread/cost_time[i];<span class="comment">//每个线程中每秒打印多少日志</span></span><br><span class="line">            std::cout&lt;&lt;<span class="string">&quot;线程&quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;耗时：&quot;</span>&lt;&lt;cost_time[i]&lt;&lt;<span class="string">&quot;s &quot;</span>;</span><br><span class="line">            std::cout&lt;&lt;<span class="string">&quot;平均：： &quot;</span>&lt;&lt;(<span class="type">size_t</span>)avg&lt;&lt;<span class="string">&quot;/s\n&quot;</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; thr:threads)</span><br><span class="line">    &#123;</span><br><span class="line">        thr.<span class="built_in">join</span>();<span class="comment">//回收子线程</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> max_cost = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> cost:cost_time) max_cost = max_cost &lt;cost?cost:max_cost;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;总消耗时间： &quot;</span>&lt;&lt;max_cost&lt;&lt;std::endl;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;平均每秒输出: &quot;</span>&lt;&lt;(<span class="type">size_t</span>)(msg_count/max_cost)&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>main.cpp</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;suplog.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bench.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//性能测试</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sync_bench_thread_log</span><span class="params">(<span class="type">size_t</span> thread_count,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">size_t</span> msg_count,<span class="type">size_t</span> msg_len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> num = <span class="number">1</span>;<span class="comment">//记录函数被调用的次数</span></span><br><span class="line">    std::string logger_name = <span class="string">&quot;sync_bench_logger&quot;</span> + std::<span class="built_in">to_string</span>(num++);</span><br><span class="line">    <span class="built_in">LOGI</span>(<span class="string">&quot;*****************************************************&quot;</span>);</span><br><span class="line">    <span class="built_in">LOGI</span>(<span class="string">&quot;同步日志测试：%u threads,%u messages&quot;</span>,thread_count,msg_count);</span><br><span class="line"></span><br><span class="line">    suplog::<span class="function">GlobalLoggerBuilder::ptr <span class="title">glb</span><span class="params">(<span class="keyword">new</span> suplog::GlobalLoggerBuilder)</span></span>;</span><br><span class="line">    glb-&gt;<span class="built_in">buildLoggerName</span>(logger_name);</span><br><span class="line">    glb-&gt;<span class="built_in">buidFormatter</span>(<span class="string">&quot;%m%n&quot;</span>);</span><br><span class="line">    std::string path = std::<span class="built_in">string</span>(<span class="string">&quot;./testdir/sync&quot;</span>)+std::<span class="built_in">to_string</span>(num)+std::<span class="built_in">string</span>(<span class="string">&quot;.log&quot;</span>);</span><br><span class="line">    glb-&gt;<span class="built_in">buildSink</span>&lt;suplog::FileSink&gt;(path);</span><br><span class="line">    glb-&gt;<span class="built_in">buildLoggerType</span>(suplog::Logger::Type::LOGGER_SYNC);</span><br><span class="line">    glb-&gt;<span class="built_in">build</span>();</span><br><span class="line">    </span><br><span class="line">    suplog::<span class="built_in">bench</span>(logger_name,thread_count,msg_len,msg_count);</span><br><span class="line">    <span class="built_in">LOGI</span>(<span class="string">&quot;*****************************************************&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">async_bench_thread_log</span><span class="params">(<span class="type">size_t</span> thread_count,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">size_t</span> msg_count,<span class="type">size_t</span> msg_len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> num = <span class="number">1</span>;</span><br><span class="line">    std::string logger_name = <span class="string">&quot;async_bench_logger&quot;</span>+std::<span class="built_in">to_string</span>(num++);</span><br><span class="line">    <span class="built_in">LOGI</span>(<span class="string">&quot;*****************************************************&quot;</span>);</span><br><span class="line">    <span class="built_in">LOGI</span>(<span class="string">&quot;异步日志测试：%u threads,%u messages&quot;</span>,thread_count,msg_count);</span><br><span class="line"></span><br><span class="line">    suplog::<span class="function">GlobalLoggerBuilder::ptr <span class="title">glb</span><span class="params">(<span class="keyword">new</span> suplog::GlobalLoggerBuilder)</span></span>;</span><br><span class="line">    glb-&gt;<span class="built_in">buildLoggerName</span>(logger_name);</span><br><span class="line">    glb-&gt;<span class="built_in">buidFormatter</span>(<span class="string">&quot;%m%n&quot;</span>);</span><br><span class="line">    std::string path = std::<span class="built_in">string</span>(<span class="string">&quot;./testdir/async&quot;</span>)+std::<span class="built_in">to_string</span>(num)+std::<span class="built_in">string</span>(<span class="string">&quot;.log&quot;</span>);</span><br><span class="line">    glb-&gt;<span class="built_in">buildSink</span>&lt;suplog::FileSink&gt;(path);</span><br><span class="line">    glb-&gt;<span class="built_in">buildLoggerType</span>(suplog::Logger::Type::LOGGER_ASYNC);</span><br><span class="line">    glb-&gt;<span class="built_in">build</span>();</span><br><span class="line">    </span><br><span class="line">    suplog::<span class="built_in">bench</span>(logger_name,thread_count,msg_len,msg_count);</span><br><span class="line">    <span class="built_in">LOGI</span>(<span class="string">&quot;*****************************************************&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bench_test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//同步写日志</span></span><br><span class="line">    <span class="built_in">sync_bench_thread_log</span>(<span class="number">1</span>,<span class="number">1000000</span>,<span class="number">100</span>);</span><br><span class="line">    <span class="built_in">sync_bench_thread_log</span>(<span class="number">5</span>,<span class="number">1000000</span>,<span class="number">100</span>);</span><br><span class="line">    <span class="comment">//异步日志输出，为了避免因为等待落地影响时间，所以日志数量降低为小于双缓冲区大小进行测试</span></span><br><span class="line">    <span class="built_in">async_bench_thread_log</span>(<span class="number">1</span>,<span class="number">100000</span>,<span class="number">100</span>);</span><br><span class="line">    <span class="built_in">async_bench_thread_log</span>(<span class="number">5</span>,<span class="number">100000</span>,<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">bench_test</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">当前日志器： root 未检测到⽇志格式,默认设置为:  %d&#123;%H:%M:%S&#125;%T%t%T[%p]%T[%c]%T%f:%l%T%m%n</span><br><span class="line">当前日志器: root问检测到落地方向，默认为标准输出!</span><br><span class="line">DEBUG同步日志器创建成功...</span><br><span class="line">[10:51:28][140705783203648][INFO][root][main.cpp:13] *****************************************************</span><br><span class="line">[10:51:28][140705783203648][INFO][root][main.cpp:14] 同步日志测试：1 threads,1000000 messages</span><br><span class="line">DEBUG同步日志器创建成功...</span><br><span class="line">输入线程数量1</span><br><span class="line">输出日志数量1000000</span><br><span class="line">输出⽇志⼤⼩: 97656KB</span><br><span class="line">线程0耗时：1.23733s 平均：： 808188/s</span><br><span class="line">总消耗时间： 1.23733</span><br><span class="line">平均每秒输出: 808188</span><br><span class="line">[10:51:30][140705783203648][INFO][root][main.cpp:25] *****************************************************</span><br><span class="line">[10:51:30][140705783203648][INFO][root][main.cpp:13] *****************************************************</span><br><span class="line">[10:51:30][140705783203648][INFO][root][main.cpp:14] 同步日志测试：5 threads,1000000 messages</span><br><span class="line">DEBUG同步日志器创建成功...</span><br><span class="line">输入线程数量5</span><br><span class="line">输出日志数量1000000</span><br><span class="line">输出⽇志⼤⼩: 97656KB</span><br><span class="line">线程2耗时：1.01608s 平均：： 196834/s</span><br><span class="line">线程0耗时：1.04435s 平均：： 191506/s</span><br><span class="line">线程1耗时：1.06357s 平均：： 188045/s</span><br><span class="line">线程4耗时：1.09672s 平均：： 182361/s</span><br><span class="line">线程3耗时：1.11074s 平均：： 180060/s</span><br><span class="line">总消耗时间： 1.11074</span><br><span class="line">平均每秒输出: 900303</span><br><span class="line">[10:51:31][140705783203648][INFO][root][main.cpp:25] *****************************************************</span><br><span class="line">[10:51:31][140705783203648][INFO][root][main.cpp:34] *****************************************************</span><br><span class="line">[10:51:31][140705783203648][INFO][root][main.cpp:35] 异步日志测试：1 threads,100000 messages</span><br><span class="line">DEBUG异步日志器创建成功...</span><br><span class="line">输入线程数量1</span><br><span class="line">输出日志数量100000</span><br><span class="line">输出⽇志⼤⼩: 9765KB</span><br><span class="line">线程0耗时：0.322045s 平均：： 310515/s</span><br><span class="line">总消耗时间： 0.322045</span><br><span class="line">平均每秒输出: 310515</span><br><span class="line">[10:51:31][140705783203648][INFO][root][main.cpp:46] *****************************************************</span><br><span class="line">[10:51:31][140705783203648][INFO][root][main.cpp:34] *****************************************************</span><br><span class="line">[10:51:31][140705783203648][INFO][root][main.cpp:35] 异步日志测试：5 threads,100000 messages</span><br><span class="line">DEBUG异步日志器创建成功...</span><br><span class="line">输入线程数量5</span><br><span class="line">输出日志数量100000</span><br><span class="line">输出⽇志⼤⼩: 9765KB</span><br><span class="line">线程3耗时：0.0818183s 平均：： 244444/s</span><br><span class="line">线程0耗时：0.102184s 平均：： 195725/s</span><br><span class="line">线程1耗时：0.101945s 平均：： 196183/s</span><br><span class="line">线程4耗时：0.104484s 平均：： 191417/s</span><br><span class="line">线程2耗时：0.116347s 平均：： 171899/s</span><br><span class="line">总消耗时间： 0.116347</span><br><span class="line">平均每秒输出: 859496</span><br><span class="line">[10:51:31][140705783203648][INFO][root][main.cpp:46] *****************************************************</span><br></pre></td></tr></table></figure><p>从上面的测试可以看出:</p><p>在<strong>单线程情况下</strong>: 异步效率看起来还没有同步高，实际上是由于,对于<strong>同步操作</strong>,现在的IO操作在⽤⼾态都会有<strong>缓冲区</strong>进⾏缓冲区，<br>因此我们当前测试⽤例看起来的同步其实 <strong>⼤多时候也是在操作内存</strong>，只有在缓冲区满了才会涉及到阻塞写磁盘操作，即磁盘的<code>IO</code>操作占比很少。<br>而对于<strong>异步操作</strong>,⼀个很重要的原因就是单线程同步操作中不存在锁冲突，⽽单线程异<strong>步⽇志操作存在⼤量的锁冲突</strong>，因此性能也会有⼀定的降低。</p><p>但是，我们也要看到限制同步⽇志效率的最⼤原因是磁盘性能，打⽇志的线程多少并⽆明显区别，线程多了反⽽会降低，因为增加了磁盘的读写争抢</p><p>⽽对于异步⽇志的限制，并⾮磁盘的性能，⽽是cpu的处理性能，打⽇志并不会因为落地⽽阻塞，因此在多线程打⽇志的情况下性能有了显著的提⾼。</p><p>总结:</p><ul><li><code>同步日志器</code>适合<code>大内存</code> <code>单线程</code> <code>小规模</code>日志操作</li><li><code>异步日志器</code>适合<code>强CPU</code> <code>多线程</code> <code>大规模</code>日志操作</li></ul><h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><p>到这里，整个项目已经基本完善，但关于日志系统还有很多可以扩展的地方，甚至把日志系统扩展为有日志服务器的<code>CS</code>服务模式</p><p>如下更新将会在以后的博客中实现,敬请期待~</p><ul><li>实现<code>日志服务器</code>和<code>客户端</code>,服务端负责存储日志，并提供检索，分析，展示等功能</li><li>丰富Sink类<ul><li>支持按小时按天滚动文件</li><li>支持将log通过<strong>网络传输</strong>落地到日志服务器(tcp&#x2F;udp)</li><li>支持在控制台通过日志等级渲染<strong>不同颜色</strong>输出方便定位</li><li>支持落地日志到<strong>数据库</strong> </li><li>支持配置服务器地址，将日志落地到远程服务器</li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【保持最新】C++基于多设计模式下的同步&amp;异步⽇志系统</title>
      <link href="/2024/09/24/muiltiDesignPatternsLogSystem/"/>
      <url>/2024/09/24/muiltiDesignPatternsLogSystem/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>当前版本v1.0</strong></p></blockquote><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><ul><li><a href="https://www.supdriver.top/2024/08/13/logSystem/">Linux日志器（简易版）</a></li><li><a href="https://www.supdriver.top/2024/08/14/thread/">初识Linux线程</a></li><li><a href="https://www.supdriver.top/2024/09/24/DP-singelton-pattern/">初识设计模式&amp;单例模式&amp;代理模式–设计模式介绍(1)</a></li><li><a href="https://www.supdriver.top/2024/09/24/DP-factory-pattern/">工厂模式与建造者模式–设计模式介绍(2)</a></li></ul><h1 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h1><h2 id="背景引入"><a href="#背景引入" class="headerlink" title="背景引入"></a>背景引入</h2><blockquote><p>日志系统在软件开发和运维中扮演着至关重要的角色，主要体现在以下几个方面：</p><p><code>问题排查和调试</code>：日志记录了系统运行过程中的重要信息，包括错误信息、异常堆栈、接口调用信息等。开发人员可以通过分析日志快速定位问题，减少排查时间，提高开发效率。</p><p><code>性能监控</code>：通过记录应用程序的性能指标（如响应时间、请求吞吐量等），开发团队可以监控系统的健康状态，发现性能瓶颈并进行优化。</p><p><code>安全审计</code>：日志可以记录用户的操作和系统事件，为后期的安全审计提供依据。一旦发生安全事件，通过分析日志可以追踪到攻击来源和攻击方式。</p><p><code>用户行为分析</code>：通过对日志进行分析，开发团队可以了解用户的使用习惯和需求，这有助于改进产品功能和用户体验。</p><p><code>合规要求</code>：在许多行业中，日志记录是合规的要求之一。维护完整的日志记录可以帮助企业满足法律法规和行业标准。</p><p><code>系统健康监控</code>：通过实时监控日志，可以及时发现系统异常，进行预警和自动化处理，从而提高系统的可用性和稳定性。</p><p><code>故障恢复</code>：在系统出现故障时，日志记录可以帮助开发和运维人员还原问题发生前的状态，从而有助于快速恢复系统。</p></blockquote><p>总之，良好的日志系统能够帮助开发和运维团队提高效率、强化安全、提升用户体验，并确保系统的稳定性和可靠性。因此，在系统设计时，合理规划和实施日志记录机制是非常必要的。</p><h2 id="目标功能"><a href="#目标功能" class="headerlink" title="目标功能"></a>目标功能</h2><p>相比之前较为简单的<strong>日志类</strong>,我们这次将日志系统其升级为一个项目级的完整系统。</p><p>因此，我们要实现更多的功能:</p><ul><li>⽀持多级别⽇志消息</li><li>⽀持同步⽇志和异步⽇志</li><li>⽀持<strong>可靠写⼊</strong>⽇志到控制台、⽂件以及滚动⽂件中</li><li>⽀持<strong>多线程程序并发</strong>写⽇志</li><li>⽀持扩展不同的⽇志⽬标落地</li></ul><h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h2><ul><li>Linux环境（Ubuntu&#x2F;CentOS）</li><li>vscode&#x2F;vim 文本编辑器</li><li>g++&#x2F;gdb 编译器</li><li>Makefile</li></ul><h2 id="核心技术应用"><a href="#核心技术应用" class="headerlink" title="核心技术应用"></a>核心技术应用</h2><ul><li>类层次设计（抽象类，继承和多态的应用）</li><li>C++11 新语法的应用（多线程，右值引用等）</li><li>双缓冲区</li><li>生产者消费者模型</li><li>多线程与线程安全</li><li>多设计模式（单例，工厂，建造，代理者等）</li></ul><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>本项目不依赖其它任何第三方库，准备好Linux环境和文本编辑器即可</p><h2 id="日志系统再介绍"><a href="#日志系统再介绍" class="headerlink" title="日志系统再介绍"></a>日志系统再介绍</h2><h3 id="为什么需要日志系统"><a href="#为什么需要日志系统" class="headerlink" title="为什么需要日志系统"></a>为什么需要日志系统</h3><ul><li>⽣产环境的产品为了保证其稳定性及安全性是<strong>不允许开发⼈员附加调试器</strong>去排查问题， 可以借助⽇志系统来打印⼀些⽇志帮助开发⼈员解决问题</li><li>上线客⼾端的产品<strong>出现bug⽆法复现</strong>并解决， 可以借助⽇志系统打印⽇志并上传到服务端帮助开发⼈员进⾏分析</li><li>对于⼀些⾼频操作（如定时器、⼼跳包）在少量调试次数下可能⽆法触发我们想要的⾏为，通过断点的暂停**⽅式，我们不得不重复操作⼏⼗次、上百次甚⾄更多，导致排查问题效率是⾮常低下， 可以借助打印⽇志的⽅式查问题</li><li>在<strong>分布式、多线程&#x2F;多进程代码</strong>中， 出现bug⽐较<strong>难以定位</strong>， 可以借助⽇志系统打印log<strong>帮助定位</strong>bug</li><li>帮助 <strong>⾸次接触</strong>项⽬代码的新开发⼈员理解代码的运⾏流程</li></ul><h3 id="日志系统的技术实现"><a href="#日志系统的技术实现" class="headerlink" title="日志系统的技术实现"></a>日志系统的技术实现</h3><p>日志系统的技术实现主要报错三种类型：</p><ul><li><ol><li><code>控制台输出</code>:利用printf,std::cout等输出函数将日志信息打印到控制台</li></ol></li><li><code>文件输出</code>:对于⼤型商业化项⽬， 为了⽅便排查问题，我们⼀般会将⽇志输出到⽂件或者是数据库系统⽅便查询和分析⽇志， 主要分为同步⽇志和异步⽇志⽅式<ol start="2"><li>同步写日志</li><li>异步写日志</li></ol></li></ul><h4 id="同步写日志"><a href="#同步写日志" class="headerlink" title="同步写日志"></a>同步写日志</h4><p>同步⽇志是指当输出⽇志时，必须等待⽇志输出语句执⾏完毕后，才能执⾏后⾯的业务逻辑语句，⽇志输出语句与程序的业务逻辑语句将在同⼀个线程运⾏。每次调⽤⼀次打印⽇API就对应⼀次系统调⽤write写⽇志⽂件。</p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202409261006084.png"></p><p>在⾼并发场景下，随着⽇志数量不断增加，同步⽇志系统容易产⽣系统瓶颈：</p><ul><li>⼀⽅⾯，⼤量的⽇志打印陷⼊等量的write系统调⽤，有⼀定系统开销</li><li>另⼀⽅⾯，使得打印⽇志的进程附带了⼤量同步的磁盘IO，影响程序性能</li></ul><h4 id="异步写日志"><a href="#异步写日志" class="headerlink" title="异步写日志"></a>异步写日志</h4><p>异步⽇志是指在进⾏⽇志输出时，⽇志输出语句与业务逻辑语句并不是在同⼀个线程中运⾏，⽽是<strong>有专⻔的线程</strong>⽤于进⾏⽇志输出操作。业务线程只需要将⽇志放到⼀个<strong>内存缓冲区</strong>中不⽤等待即可继续执⾏后续业务逻辑（作为⽇志的⽣产者），⽽⽇志的落地操作交给单独的⽇志线程去完成（作为⽇志的消费者）,这是一个典型的<code>生产者-消费者模型</code></p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202409261023775.png"></p><p>这样做的好处是即使⽇志没有真的地完成输出也不会影响程序的主业务，可以提⾼程序的性能：</p><ul><li>主线程调⽤⽇志打印接⼝成为⾮阻塞操作</li><li>同步的磁盘IO从主线程中剥离出来交给单独的线程完成</li></ul><h1 id="日志系统框架设计"><a href="#日志系统框架设计" class="headerlink" title="日志系统框架设计"></a>日志系统框架设计</h1><p>本项⽬实现的是⼀个<strong>多⽇志器⽇志系统</strong>，主要实现的功能是让程序员能够轻松的将程序运⾏⽇志信息落地到指定的位置，且⽀持同步与异步<strong>两种⽅式</strong>的⽇志落地⽅式。</p><p>项⽬的框架设计将项⽬分为以下⼏个模块来实现。</p><h2 id="模块划分"><a href="#模块划分" class="headerlink" title="模块划分"></a>模块划分</h2><ul><li><code>⽇志等级模块</code>：对输出⽇志的等级进⾏划分，以便于控制⽇志的输出，并提供等级枚举转字符串功能。<ul><li><code>OFF</code>：关闭</li><li><code>DEBUG</code>：调试，调试时的关键信息输出。</li><li><code>INFO</code>：提⽰，普通的提⽰型⽇志信息。</li><li><code>WARN</code>：警告，不影响运⾏，但是需要注意⼀下的⽇志。</li><li><code>ERROR</code>：错误，程序运⾏出现错误的⽇志</li><li><code>FATAL</code>：致命，⼀般是代码异常导致程序⽆法继续推进运⾏的⽇志</li></ul></li><li><code>⽇志消息模块</code>：中间存储⽇志输出所需的各项要素信息<ul><li><code>时间</code>：描述本条⽇志的输出时间。</li><li><code>线程ID</code>：描述本条⽇志是哪个线程输出的。</li><li><code>⽇志等级</code>：描述本条⽇志的等级。</li><li><code>⽇志数据</code>：本条⽇志的有效载荷数据。</li><li><code>⽇志⽂件名</code>：描述本条⽇志在哪个源码⽂件中输出的。</li><li><code>⽇志⾏号</code>：描述本条⽇志在源码⽂件的哪⼀⾏输出的。</li></ul></li><li><code>⽇志消息格式化模块</code>：设置⽇志输出格式，并提供对⽇志消息进⾏格式化功能。<ul><li><code>系统的默认⽇志输出格式</code>： <code>%d｛%H:%M:%S｝%T[%t]%T[%p]%T[%c]%T%f:%l%T%m%n</code></li><li><code>%d｛%H:%M:%S｝</code>：表⽰⽇期时间，花括号中的内容表⽰⽇期时间的格式。（<strong>注：这里用本应用英文花括号，但是由于网站限制，暂时改成了中文花括号,上，下同，但多行代码框里是对的</strong>）</li><li><code>%T</code>：表⽰制表符缩进。</li><li><code>%t</code>：表⽰线程ID</li><li><code>%p</code>：表⽰⽇志级别</li><li><code>%c</code>：表⽰⽇志器名称，不同的开发组可以创建⾃⼰的⽇志器进⾏⽇志输出，⼩组之间互不影响。</li><li><code>%f</code>：表⽰⽇志输出时的源代码⽂件名。</li><li><code>%l</code>：表⽰⽇志输出时的源代码⾏号。</li><li><code>%m</code>：表⽰给与的⽇志有效载荷数据</li><li><code>%n</code>：表⽰换⾏</li><li>设计思想：设计不同的⼦类，不同的⼦类从⽇志消息中取出不同的数据进⾏处理。</li></ul></li><li><code>⽇志消息落地模块</code>：决定了⽇志的落地⽅向，可以是标准输出，也可以是⽇志⽂件，也可以滚动⽂件输出<ul><li><code>标准输出</code>：表⽰将⽇志进⾏标准输出的打印</li><li><code>⽇志⽂件输出</code>：表⽰将⽇志写⼊指定的⽂件末尾。</li><li><code>滚动⽂件输出</code>：当前以⽂件⼤⼩进⾏控制，当⼀个⽇志⽂件⼤⼩达到指定⼤⼩，则切换下⼀个⽂件进⾏输出</li><li>后期，也可以扩展远程⽇志输出，创建客⼾端，将⽇志消息发送给远程的⽇志分析服务器。</li><li><code>设计思想</code>：设计不同的⼦类，不同的⼦类控制不同的⽇志落地⽅向。</li></ul></li><li><code>⽇志器模块</code>:<ul><li>此模块是对以上⼏个模块的整合模块，⽤⼾通过⽇志器进⾏⽇志的输出，有效降低⽤⼾的使⽤难度</li><li>包含有：⽇志消息落地模块对象，⽇志消息格式化模块对象，⽇志输出等级</li></ul></li><li><code>⽇志器管理模块</code>:<ul><li><code>解耦合</code>：为了降低项⽬开发的⽇志耦合，不同的项⽬组可以有⾃⼰的⽇志器来控制输出格式以及落地⽅向，因此本项⽬是⼀个多⽇志器的⽇志系统。</li><li>管理模块就是对创建的所有⽇志器进⾏统⼀管理。并提供⼀个默认⽇志器提供标准输出的⽇志输出。</li></ul></li><li><code>异步线程模块</code>:<ul><li>实现对⽇志的异步输出功能，⽤⼾只需要将输出⽇志任务放⼊任务池，异步线程负责⽇志的落地输出功能，以此提供更加⾼效的⾮阻塞⽇志输出。</li></ul></li></ul><hr><h1 id="代码设计"><a href="#代码设计" class="headerlink" title="代码设计"></a>代码设计</h1><h2 id="作用域的设计"><a href="#作用域的设计" class="headerlink" title="作用域的设计"></a>作用域的设计</h2><p>为了防止命名冲突，以及提示整个项目的完整性和功能性等，将所有的相关代码封装在<code>suplog</code>命名空间中，其中<code>log</code>表示功能，<code>sup</code>为作者自定义的名称，以提高其唯一性</p><p>然后将内部的代码块按功能&#x2F;所属的业务组封装在子级命名空间中，具体示例见后面的代码封装</p><h2 id="实用类设计"><a href="#实用类设计" class="headerlink" title="实用类设计"></a>实用类设计</h2><p>提前完成一些零碎的功能接口，以便于项目会用到。而由于实现以下功能并不需要成员变量，所以将成员函数设置成<strong>静态的成员函数</strong>,即知识封装在类域中</p><ul><li><code>date</code>类域<ul><li>获取系统时间</li></ul></li><li><code>file</code>类域<ul><li>判断文件是否存在</li><li>获取文件的所在目录路径</li><li>创建目录</li></ul></li></ul><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202409271457541.png"></p><blockquote><p>util.hpp</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> suplog&#123;</span><br><span class="line">    <span class="keyword">namespace</span> util&#123;</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">date</span></span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="function"><span class="type">static</span> <span class="type">size_t</span> <span class="title">now</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> (<span class="type">size_t</span>)<span class="built_in">time</span>(<span class="literal">nullptr</span>);&#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">file</span>&#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">exists</span><span class="params">(<span class="type">const</span> std::string&amp;name)</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                <span class="comment">//struct stat配合stat函数作为输出型参数</span></span><br><span class="line">                <span class="keyword">struct</span> <span class="title class_">stat</span> st;</span><br><span class="line">                <span class="comment">//stat函数是系统调用接口</span></span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">stat</span>(name.<span class="built_in">c_str</span>(),&amp;st) == <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="type">static</span> std::string <span class="title">path</span><span class="params">(<span class="type">const</span> std::string &amp;name)</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                <span class="comment">//规定找不到就返回&quot;.&quot;&quot;</span></span><br><span class="line">                <span class="keyword">if</span>(name.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="string">&quot;.&quot;</span>;</span><br><span class="line"></span><br><span class="line">                <span class="type">size_t</span> pos = name.<span class="built_in">find_last_of</span>(<span class="string">&quot;/\\&quot;</span>);<span class="comment">//找到最后一个&quot;/&quot;或&quot;\\&quot;</span></span><br><span class="line">                <span class="keyword">return</span> name.<span class="built_in">substr</span>(<span class="number">0</span>,pos+<span class="number">1</span>);<span class="comment">//取得目录的路径</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">create_directory</span><span class="params">(<span class="type">const</span> std::string &amp;path)</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(path.<span class="built_in">empty</span>()) <span class="keyword">return</span>;<span class="comment">//路径为空</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">exists</span>(path)) <span class="keyword">return</span>;<span class="comment">//路径不存在-使用系统调用接口</span></span><br><span class="line">                <span class="type">size_t</span> pos,index = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span>(index&lt;path.<span class="built_in">size</span>())</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//找到index及以后的&quot;/&quot;</span></span><br><span class="line">                    pos = path.<span class="built_in">find_first_of</span>(<span class="string">&quot;/\\&quot;</span>,index);</span><br><span class="line">                    <span class="keyword">if</span>(pos == std::string::npos)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">//创建最后一层目录</span></span><br><span class="line">                        <span class="built_in">mkdir</span>(path.<span class="built_in">c_str</span>(),<span class="number">0755</span>);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//二者重叠时，跳到下一次循环</span></span><br><span class="line">                    <span class="keyword">if</span>(pos ==index) &#123;index = pos+<span class="number">1</span>;<span class="keyword">continue</span>;&#125;</span><br><span class="line">                    std::string subdir = path.<span class="built_in">substr</span>(<span class="number">0</span>,pos);</span><br><span class="line">                    <span class="comment">//文件夹已存在，不用创建，跳到下一段即可</span></span><br><span class="line">                    <span class="keyword">if</span>(subdir == <span class="string">&quot;.&quot;</span> || subdir == <span class="string">&quot;..&quot;</span>)</span><br><span class="line">                        &#123;index = pos + <span class="number">1</span>;<span class="keyword">continue</span>;&#125;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">exists</span>(subdir))<span class="comment">//理由同上</span></span><br><span class="line">                        &#123;index = pos + <span class="number">1</span>;<span class="keyword">continue</span>;&#125;</span><br><span class="line">                    <span class="comment">//逐级创建目录，权限为0755</span></span><br><span class="line">                    <span class="built_in">mkdir</span>(subdir.<span class="built_in">c_str</span>(),<span class="number">0755</span>);</span><br><span class="line">                    index = pos + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码测试"><a href="#代码测试" class="headerlink" title="代码测试"></a>代码测试</h3><p>写一部分测一部分才是开发的好习惯，以免以后面对满屏报错，找不到bug点</p><p>写一段测试代码</p><blockquote><p>main.cpp</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;util.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;测试时间: &quot;</span>&lt;&lt;suplog::util::date::<span class="built_in">now</span>()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;测试文件&quot;</span>&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;测试path()，获取到的path为： &quot;</span> &lt;&lt; suplog::util::file::<span class="built_in">path</span>(<span class="string">&quot;/home/supdriver/code/file.txt&quot;</span>);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;测试创建目录:... &quot;</span>;</span><br><span class="line">    suplog::util::file::<span class="built_in">create_directory</span>(<span class="string">&quot;./testdir/dir1/dir2&quot;</span>);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;创建成功&quot;</span>&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;测试exists(), 测试路径:\&quot;./testdir/dir1/dir2\&quot;,返回结果&quot;</span>&lt;&lt;suplog::util::file::<span class="built_in">exists</span>(<span class="string">&quot;./testdir/dir1/dir2&quot;</span>)&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">supdriver@ALi-cloud-Linux-2-2G:~/codes/Asynchrinous-Logging-System$ make clean</span><br><span class="line">rm -rf mycmd testdir</span><br><span class="line">supdriver@ALi-cloud-Linux-2-2G:~/codes/Asynchrinous-Logging-System$ make</span><br><span class="line">g++ -o mycmd main.cpp -std=c++11</span><br><span class="line">supdriver@ALi-cloud-Linux-2-2G:~/codes/Asynchrinous-Logging-System$ ./mycmd </span><br><span class="line">测试时间: 1727424996</span><br><span class="line">测试文件</span><br><span class="line">测试path()，获取到的path为： /home/supdriver/code/file.txt测试创建目录:... 创建成功</span><br><span class="line">测试exists(), 测试路径:&quot;./testdir/dir1/dir2&quot;,返回结果1</span><br></pre></td></tr></table></figure><p>可以看到，各个接口工作正常</p><h2 id="日志等级类设计"><a href="#日志等级类设计" class="headerlink" title="日志等级类设计"></a>日志等级类设计</h2><p>日志ID鞥机总共分为7个等级，分别为：</p><ul><li><code>OFF</code>：关闭所有日志输出</li><li><code>DEBUG</code>：调试，调试时的关键信息输出。</li><li><code>INFO</code>：提⽰，普通的提⽰型⽇志信息。</li><li><code>WARN</code>：警告，不影响运⾏，但是需要注意⼀下的⽇志。</li><li><code>ERROR</code>：错误，程序运⾏出现错误的⽇志</li><li><code>FATAL</code>：致命，⼀般是代码异常导致程序⽆法继续推进运⾏的⽇志</li></ul><p>其中用到了<code>TOSTRING</code>宏函数，利用宏的预编译特性 ，<strong>减少了函数调用</strong>，提高了程序性能</p><blockquote><p>level.hpp</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> suplog&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">LogLevel</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">enum class</span> <span class="title class_">Level</span>&#123;</span><br><span class="line">            DEBUG = <span class="number">1</span>,</span><br><span class="line">            INFO,</span><br><span class="line">            WARN,</span><br><span class="line">            ERROR,</span><br><span class="line">            FATAL,</span><br><span class="line">            OFF</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">toString</span><span class="params">(LogLevel::Level lv)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">switch</span>(lv)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//在内部定义一个宏函数,把变量名name变成字符串</span></span><br><span class="line">                <span class="meta">#<span class="keyword">define</span> TOSTRING(name) #name</span></span><br><span class="line">                <span class="keyword">case</span> LogLevel::Level::DEBUG: <span class="keyword">return</span> <span class="built_in">TOSTRING</span>(DEBUG);<span class="comment">//直接返回，不加用break</span></span><br><span class="line">                <span class="keyword">case</span> LogLevel::Level::INFO: <span class="keyword">return</span> <span class="built_in">TOSTRING</span>(INFO);</span><br><span class="line">                <span class="keyword">case</span> LogLevel::Level::WARN: <span class="keyword">return</span> <span class="built_in">TOSTRING</span>(WARN);</span><br><span class="line">                <span class="keyword">case</span> LogLevel::Level::ERROR: <span class="keyword">return</span> <span class="built_in">TOSTRING</span>(ERROR);</span><br><span class="line">                <span class="keyword">case</span> LogLevel::Level::FATAL: <span class="keyword">return</span> <span class="built_in">TOSTRING</span>(FATAL);</span><br><span class="line">                <span class="keyword">case</span> LogLevel::Level::OFF: <span class="keyword">return</span> <span class="built_in">TOSTRING</span>(OFF);</span><br><span class="line">                <span class="meta">#<span class="keyword">undef</span> TOSTRING <span class="comment">//取消宏函数</span></span></span><br><span class="line">                <span class="keyword">default</span>: <span class="keyword">return</span> <span class="string">&quot;UNKOWN&quot;</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;UNKNOWN&quot;</span>;<span class="comment">//防止编译报错</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码测试-1"><a href="#代码测试-1" class="headerlink" title="代码测试"></a>代码测试</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;util.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;level.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;测试字符串转换 FATAL:&quot;</span>;</span><br><span class="line">    cout&lt;&lt;suplog::LogLevel::<span class="built_in">toString</span>(suplog::LogLevel::Level::FATAL)&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">supdriver@ALi-cloud-Linux-2-2G:~/codes/Asynchrinous-Logging-System$ make clean</span><br><span class="line">rm -rf mycmd testdir</span><br><span class="line">supdriver@ALi-cloud-Linux-2-2G:~/codes/Asynchrinous-Logging-System$ make </span><br><span class="line">g++ -o mycmd main.cpp -std=c++11</span><br><span class="line">.supdriver@ALi-cloud-Linux-2-2G:~/codes/Asynchrinous-Logging-System$ ./mycmd </span><br><span class="line">测试字符串转换 FATAL:FATAL</span><br><span class="line">supdriver@ALi-cloud-Linux-2-2G:~/codes/Asynchrinous-Logging-System$ </span><br></pre></td></tr></table></figure><p>可以看到成功转换,该模块正常工作</p><h2 id="日志消息类设计"><a href="#日志消息类设计" class="headerlink" title="日志消息类设计"></a>日志消息类设计</h2><p>⽇志消息类主要是封装⼀条完整的⽇志消息所需的内容，其中包括⽇志等级、对应的<code>logger name</code>、打印⽇志源⽂件的位置信息（包括⽂件名和⾏号）、线程ID、时间戳信息、具体的⽇志信息等内容。</p><blockquote><p>message.hpp</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;util.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;level.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span><span class="comment">//c++多线程库</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> suplog&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">LogMsg</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//声明一个全局且唯一的指针</span></span><br><span class="line">        <span class="keyword">using</span> ptr = std::shared_ptr&lt;LogMsg&gt;;</span><br><span class="line">        std::string _name;  <span class="comment">//日志器名称</span></span><br><span class="line">        std::string _file;  <span class="comment">//文件名</span></span><br><span class="line">        <span class="type">size_t</span> _line;       <span class="comment">//行号</span></span><br><span class="line">        std::string _payload;<span class="comment">//日志消息</span></span><br><span class="line">        <span class="type">size_t</span> _ctime;      <span class="comment">//时间-时间戳</span></span><br><span class="line">        std::thread::id _tid;<span class="comment">//线程id</span></span><br><span class="line">        LogLevel::Level _level;<span class="comment">//日志等级</span></span><br><span class="line">        <span class="comment">//默认构造函数</span></span><br><span class="line">        <span class="built_in">LogMsg</span>()&#123;&#125;</span><br><span class="line">        <span class="comment">//构造函数</span></span><br><span class="line">        <span class="built_in">LogMsg</span>(</span><br><span class="line">            std::string name,</span><br><span class="line">            std::string file,</span><br><span class="line">            <span class="type">size_t</span> line,</span><br><span class="line">            std::string payload,</span><br><span class="line">            LogLevel::Level level</span><br><span class="line">        ):</span><br><span class="line">        _name(name),</span><br><span class="line">        _file(file),</span><br><span class="line">        _payload(payload),</span><br><span class="line">        _level(level),</span><br><span class="line">        _line(line),</span><br><span class="line">        _ctime(util::date::<span class="built_in">now</span>()),</span><br><span class="line">        _tid(std::this_thread::<span class="built_in">get_id</span>())&#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码就不作单独测试了</p><h2 id="日志输出格式化类设计"><a href="#日志输出格式化类设计" class="headerlink" title="日志输出格式化类设计"></a>日志输出格式化类设计</h2><p>⽇志格式化（Formatter）类主要负责格式化⽇志消息。其主要包含以下内容</p><ol><li><code>pattern</code>成员：保存⽇志输出的格式字符串。</li></ol><ul><li><code>%d</code> 日期</li><li><code>%T</code> 缩进</li><li><code>%t</code> 线程id</li><li><code>%p</code> 日志级别</li><li><code>%c</code> 日志器名称’</li><li><code>%f</code> 文件名</li><li><code>%l</code> 行号</li><li><code>%m</code> 日志消息</li><li><code>%n</code> 换行</li></ul><ol start="2"><li><code>std::vector&lt;FormatItem::ptr&gt; items</code>成员：⽤于按序保存格式化字符串对应的⼦格式化对象。</li></ol><p>其中<code>FormatItem</code>类主要负责⽇志消息⼦项的获取及格式化。其包含以下<code>⼦类</code></p><ul><li><code>MsgFormatItem</code> ：表⽰要从<code>LogMsg</code>中取出有效⽇志数据</li><li><code>LevelFormatItem</code> ：表⽰要从<code>LogMsg</code>中取出⽇志等级</li><li><code>NameFormatItem</code> ：表⽰要从<code>LogMsg</code>中取出⽇志器名称</li><li><code>ThreadFormatItem</code> ：表⽰要从<code>LogMsg</code>中取出线程ID</li><li><code>TimeFormatItem</code> ：表⽰要从<code>LogMsg</code>中取出时间戳并按照指定格式进⾏格式化</li><li><code>CFileFormatItem</code> ：表⽰要从<code>LogMsg</code>中取出源码所在⽂件名</li><li><code>CLineFormatItem</code> ：表⽰要从<code>LogMsg</code>中取出源码所在⾏号</li><li><code>TabFormatItem</code> ：表⽰⼀个制表符缩进</li><li><code>NLineFormatItem</code> ：表⽰⼀个换⾏</li><li><code>OtherFormatItem</code> ：表⽰⾮格式化的原始字符串</li></ul><p><strong>示例</strong>:将格式化字符串<code>&quot;[%d｛%H:%M:%S｝] %m%n&quot;</code>实例化为日志消息字符串</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">pattern = <span class="string">&quot;[%d&#123;%H:%M:%S&#125;] %m%n&quot;</span>;</span><br><span class="line">items = &#123;</span><br><span class="line">  &#123;<span class="built_in">OtherFormatItem</span>(), <span class="string">&quot;[&quot;</span>&#125;,</span><br><span class="line">  &#123;<span class="built_in">TimeFormatItem</span>(), <span class="string">&quot;%H:%M:%S&quot;</span>&#125;,</span><br><span class="line">  &#123;<span class="built_in">OtherFormatItem</span>(), <span class="string">&quot;]&quot;</span>&#125;,</span><br><span class="line">  &#123;<span class="built_in">MsgFormatItem</span>(), <span class="string">&quot;&quot;</span>&#125;,</span><br><span class="line">  &#123;<span class="built_in">NLineFormatItem</span>(), <span class="string">&quot;&quot;</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">LogMsg msg = &#123;</span><br><span class="line">  <span class="type">size_t</span> _line = <span class="number">22</span>;</span><br><span class="line">  <span class="type">size_t</span> _ctime = <span class="number">12345678</span>;</span><br><span class="line">  std::thread::id _tid = <span class="number">0x12345678</span>;</span><br><span class="line">  std::string _name = <span class="string">&quot;logger&quot;</span>;</span><br><span class="line">  std::string _file = <span class="string">&quot;main.cpp&quot;</span>;</span><br><span class="line">  std::string _payload = <span class="string">&quot;创建套接字失败&quot;</span>;</span><br><span class="line">  LogLevel::value _level = ERROR;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后组织出来的格式化消息为：<code>&quot;[22:32:54] 创建套接字失败\n&quot;</code></p><blockquote><p>formatter.hpp<br>实现FormatItem及其派生类</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> suplog&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*=========FormatItem及其派生类===========*/</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">FormatItem</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">using</span> ptr = std::shared_ptr&lt;FormatItem&gt;;</span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="built_in">FormatItem</span>()&#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">format</span><span class="params">(std::ostream&amp; os,<span class="type">const</span> LogMsg&amp; msg)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">MsgFormatItem</span>:<span class="keyword">public</span> FormatItem</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">MsgFormatItem</span>(<span class="type">const</span> std::string&amp; str = <span class="string">&quot;&quot;</span>)&#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">format</span><span class="params">(std::ostream&amp; os,<span class="type">const</span> LogMsg&amp; msg)</span></span>&#123;</span><br><span class="line">            os&lt;&lt;msg._payload;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">LevelFormatItem</span>:<span class="keyword">public</span> FormatItem&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">LevelFormatItem</span>(<span class="type">const</span> std::string&amp; str = <span class="string">&quot;&quot;</span>)&#123;&#125;;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">format</span><span class="params">(std::ostream&amp; os,<span class="type">const</span> LogMsg&amp; msg)</span></span>&#123;</span><br><span class="line">            os&lt;&lt;LogLevel::<span class="built_in">toString</span>(msg._level);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">NameFormatItem</span>:<span class="keyword">public</span> FormatItem&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">NameFormatItem</span>(<span class="type">const</span> std::string&amp; str=<span class="string">&quot;&quot;</span>)&#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">format</span><span class="params">(std::ostream&amp; os,<span class="type">const</span> LogMsg&amp; msg)</span></span>&#123;</span><br><span class="line">            os&lt;&lt;msg._name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">ThreadFormatItem</span>:<span class="keyword">public</span> FormatItem&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">ThreadFormatItem</span>(<span class="type">const</span> std::string&amp; str=<span class="string">&quot;&quot;</span>)&#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">format</span><span class="params">(std::ostream&amp; os,<span class="type">const</span> LogMsg&amp; msg)</span></span>&#123;</span><br><span class="line">            os&lt;&lt;msg._tid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">TimeFormatItem</span>:<span class="keyword">public</span> FormatItem&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        std::string _format;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">TimeFormatItem</span>(<span class="type">const</span> std::string&amp; format=<span class="string">&quot;%H:%M:%S&quot;</span>):_format(format)&#123;</span><br><span class="line">            <span class="keyword">if</span>(format.<span class="built_in">empty</span>()) _format = &#123;<span class="string">&quot;%H:%M:%S&quot;</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">format</span><span class="params">(std::ostream&amp; os,<span class="type">const</span> LogMsg&amp; msg)</span></span>&#123;</span><br><span class="line">            <span class="type">time_t</span> t = msg._ctime;</span><br><span class="line">            <span class="keyword">struct</span> <span class="title class_">tm</span> lt;</span><br><span class="line">            <span class="built_in">localtime_r</span>(&amp;t,&amp;lt);<span class="comment">//从时间戳t中提取时间信息到结构体lt中</span></span><br><span class="line">            <span class="type">char</span> tmp[<span class="number">128</span>];</span><br><span class="line">            <span class="built_in">strftime</span>(tmp,<span class="number">127</span>,_format.<span class="built_in">c_str</span>(),&amp;lt);<span class="comment">//格式化日期信息到字符串</span></span><br><span class="line">            os&lt;&lt;tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">CFileFormatItem</span>:<span class="keyword">public</span> FormatItem&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">CFileFormatItem</span>(<span class="type">const</span> std::string&amp; str=<span class="string">&quot;&quot;</span>)&#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">format</span><span class="params">(std::ostream&amp; os,<span class="type">const</span> LogMsg&amp; msg)</span></span>&#123;</span><br><span class="line">            os&lt;&lt;msg._file;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">CLineFormatItem</span>:<span class="keyword">public</span> FormatItem&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">CLineFormatItem</span>(<span class="type">const</span> std::string&amp; str=<span class="string">&quot;&quot;</span>)&#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">format</span><span class="params">(std::ostream&amp; os,<span class="type">const</span> LogMsg&amp; msg)</span></span>&#123;</span><br><span class="line">            os&lt;&lt;msg._line;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">TabFormatItem</span>:<span class="keyword">public</span> FormatItem&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">TabFormatItem</span>(<span class="type">const</span> std::string&amp; str=<span class="string">&quot;&quot;</span>)&#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">format</span><span class="params">(std::ostream&amp; os,<span class="type">const</span> LogMsg&amp; msg)</span></span>&#123;</span><br><span class="line">            os&lt;&lt;<span class="string">&#x27;\t&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;        </span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">NLineFormatItem</span>:<span class="keyword">public</span> FormatItem&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">NLineFormatItem</span>(<span class="type">const</span> std::string&amp; str=<span class="string">&quot;&quot;</span>)&#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">format</span><span class="params">(std::ostream&amp; os,<span class="type">const</span> LogMsg&amp; msg)</span></span>&#123;</span><br><span class="line">            os&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">OtherFormatItem</span>:<span class="keyword">public</span> FormatItem&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        std::string _str;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">OtherFormatItem</span>(<span class="type">const</span> std::string &amp;str=<span class="string">&quot;&quot;</span>):_str(str)&#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">format</span><span class="params">(std::ostream&amp; os,<span class="type">const</span> LogMsg&amp; msg)</span></span>&#123;</span><br><span class="line">            os&lt;&lt;_str;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*===============END==============*/</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到<code>FormatItem</code>的派生类非常多，我们用两行注释标注一下这一大块代码的作用和边界，这样有利于后期查阅和维护</p><p>同时很明显这里用到了<code>虚函数</code>和<code>继承抽象类</code>来实现<code>多态</code>，保证了后期能用统一的<code>shared_ptr&lt;FormatItem&gt;</code>父类指针统一管理所有派生类</p><blockquote><p>formatter.hpp<br>实现Formatter类<br>Formatter类主要用于实现解析 pattern字符串和将LogMsg转化为对应的日志消息<br>又由于有众多种类的<code>FormatItem</code>派生类要创建，所以我们还要将创建功能单独封装，因此确定有如下接口</p><ul><li><code>pattern</code>:返回<code>const string</code>,查看对象内储存的<code>pattern</code>字符串</li><li><code>create_item</code>:在堆上创建<code>Formatitem</code>派生类并返回子类指针</li><li><code>parsePattern</code>:<strong>解析格式串</strong>并生成<code>Formatitem</code>派生类列表</li></ul><p><em>对字符串解析的示意图</em><br><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202409291637114.png"></p></blockquote><p>关于解析格式串,这里使用<strong>缓存的思想尤为重要</strong></p><ul><li><code>string_row</code>是对原始字符进行缓存，一次性为多个字符创建一个<code>MsgFormatItem</code>,减少内存开支和性能消耗</li><li><code>format_key</code>,<code>format_val</code>是对格式字符和子格式串的缓存</li><li><code>arry</code>储存分析后的原素材,每一个元素对应一个<strong>待创建</strong>的<code>FormatItem</code>派生类</li></ul><p>正是有缓存的存在，我们可以将字符串分析，创建<code>FormatItem</code>派生类等复杂工作分开处理。当然相应地<strong>维护成本会增加</strong>：<strong>缓存最后都是要在合适的时机清空的</strong>,否则会丢失信息，让工作不完整。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> suplog&#123;</span><br><span class="line">    <span class="comment">//......上面的代码略...</span></span><br><span class="line">    <span class="comment">/*===============END==============*/</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">class</span> <span class="title class_">Formatter</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">using</span> ptr = std::shared_ptr&lt;Formatter&gt;;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            %d ⽇期</span></span><br><span class="line"><span class="comment">            %T 缩进</span></span><br><span class="line"><span class="comment">            %t 线程id</span></span><br><span class="line"><span class="comment">            %p ⽇志级别</span></span><br><span class="line"><span class="comment">            %c ⽇志器名称</span></span><br><span class="line"><span class="comment">            %f ⽂件名</span></span><br><span class="line"><span class="comment">            %l ⾏号</span></span><br><span class="line"><span class="comment">            %m ⽇志消息</span></span><br><span class="line"><span class="comment">            %n 换⾏</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">Formatter</span>(<span class="type">const</span> std::string&amp; pattern = <span class="string">&quot;[%d&#123;%H:%M:%S&#125;][%t][%p][%c][%f:%l] %m%n&quot;</span>)</span><br><span class="line">        :_pattern(pattern)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">assert</span>(<span class="built_in">parsePattern</span>());<span class="comment">//调用成员函数，后面声明</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//简单的查看pattern的接口</span></span><br><span class="line">        <span class="function"><span class="type">const</span> std::string <span class="title">pattern</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> _pattern;&#125;</span><br><span class="line">        <span class="comment">//最后实现，但是是最常用的接口，故写在前面</span></span><br><span class="line">        <span class="function">std::string <span class="title">format</span><span class="params">(<span class="type">const</span> LogMsg&amp; msg)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            std::stringstream ss;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; it: _items)</span><br><span class="line">            &#123;</span><br><span class="line">                it-&gt;format(ss,msg);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ss.<span class="built_in">str</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建FormatItem(给调用者使用多态)</span></span><br><span class="line">        <span class="function">FormatItem::ptr <span class="title">createItem</span><span class="params">(<span class="type">const</span> std::string&amp; fc,<span class="type">const</span> std::string&amp; subfmt)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(fc == <span class="string">&quot;m&quot;</span>) <span class="keyword">return</span> FormatItem::<span class="built_in">ptr</span>(<span class="keyword">new</span> <span class="built_in">MsgFormatItem</span>(subfmt));</span><br><span class="line">            <span class="keyword">if</span>(fc == <span class="string">&quot;p&quot;</span>) <span class="keyword">return</span> FormatItem::<span class="built_in">ptr</span>(<span class="keyword">new</span> <span class="built_in">LevelFormatItem</span>(subfmt));</span><br><span class="line">            <span class="keyword">if</span>(fc == <span class="string">&quot;c&quot;</span>) <span class="keyword">return</span> FormatItem::<span class="built_in">ptr</span>(<span class="keyword">new</span> <span class="built_in">NameFormatItem</span>(subfmt));</span><br><span class="line">            <span class="keyword">if</span>(fc == <span class="string">&quot;t&quot;</span>) <span class="keyword">return</span> FormatItem::<span class="built_in">ptr</span>(<span class="keyword">new</span> <span class="built_in">ThreadFormatItem</span>(subfmt));</span><br><span class="line">            <span class="keyword">if</span>(fc == <span class="string">&quot;n&quot;</span>) <span class="keyword">return</span> FormatItem::<span class="built_in">ptr</span>(<span class="keyword">new</span> <span class="built_in">NLineFormatItem</span>(subfmt));</span><br><span class="line">            <span class="keyword">if</span>(fc == <span class="string">&quot;d&quot;</span>) <span class="keyword">return</span> FormatItem::<span class="built_in">ptr</span>(<span class="keyword">new</span> <span class="built_in">TimeFormatItem</span>(subfmt));</span><br><span class="line">            <span class="keyword">if</span>(fc == <span class="string">&quot;f&quot;</span>) <span class="keyword">return</span> FormatItem::<span class="built_in">ptr</span>(<span class="keyword">new</span> <span class="built_in">CFileFormatItem</span>(subfmt));</span><br><span class="line">            <span class="keyword">if</span>(fc == <span class="string">&quot;l&quot;</span>) <span class="keyword">return</span> FormatItem::<span class="built_in">ptr</span>(<span class="keyword">new</span> <span class="built_in">CLineFormatItem</span>(subfmt));</span><br><span class="line">            <span class="keyword">if</span>(fc == <span class="string">&quot;T&quot;</span>) <span class="keyword">return</span> FormatItem::<span class="built_in">ptr</span>(<span class="keyword">new</span> <span class="built_in">TabFormatItem</span>(subfmt));</span><br><span class="line">            <span class="keyword">return</span> FormatItem::<span class="built_in">ptr</span>();<span class="comment">//未知fc</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//pattern解析</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//每个要素分为三部分：</span></span><br><span class="line">        <span class="comment">// 格式化字符 : %d %T %p...</span></span><br><span class="line">        <span class="comment">// 对应的输出⼦格式 ： &#123;%H:%M:%S&#125;</span></span><br><span class="line">        <span class="comment">// 对应数据的类型 ： 0-表⽰原始字符串，也就是⾮格式化字符，1-表⽰格式化数据类型</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//默认格式&quot;[%d&#123;%H:%M:%S&#125;][%t][%p][%c][%f:%l] %m%n&quot;</span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">parsePattern</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="comment">//储存分割好的字符串,是否为原始字符串由int指示</span></span><br><span class="line">            std::vector&lt;std::tuple&lt;std::string,std::string,<span class="type">int</span>&gt;&gt; arry;</span><br><span class="line">            std::string format_key;<span class="comment">//存放%之后的格式化字符</span></span><br><span class="line">            std::string format_val;<span class="comment">//存放格式化字符串后边&#123;&#125;中的子格式化字符串</span></span><br><span class="line">            std::string string_row;<span class="comment">//存放原始的非格式化字符串</span></span><br><span class="line">            <span class="type">bool</span> sub_format_error = <span class="literal">false</span>;</span><br><span class="line">            <span class="type">int</span> pos = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(pos &lt; _pattern.<span class="built_in">size</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(_pattern[pos] != <span class="string">&#x27;%&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    string_row.<span class="built_in">push_back</span>(_pattern[pos++]);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(pos+<span class="number">1</span>&lt;_pattern.<span class="built_in">size</span>() &amp;&amp; _pattern[pos+<span class="number">1</span>] == <span class="string">&#x27;%&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//规定%%格式化为原生的&#x27;%&#x27;字符</span></span><br><span class="line">                    string_row.<span class="built_in">push_back</span>(<span class="string">&#x27;%&#x27;</span>);</span><br><span class="line">                    pos+=<span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(string_row.<span class="built_in">empty</span>() == <span class="literal">false</span>)<span class="comment">//原生字符串不为空</span></span><br><span class="line">                &#123;</span><br><span class="line">                    arry.<span class="built_in">push_back</span>(std::<span class="built_in">make_tuple</span>(string_row,<span class="string">&quot;&quot;</span>,<span class="number">0</span>));</span><br><span class="line">                    string_row.<span class="built_in">clear</span>();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//当前位置指向%字符</span></span><br><span class="line">                pos++;<span class="comment">//pos指向格式化字符位置</span></span><br><span class="line">                <span class="keyword">if</span>(pos&lt;_pattern.<span class="built_in">size</span>() &amp;&amp; <span class="built_in">isalpha</span>(_pattern[pos]))<span class="comment">//判断是不是字符</span></span><br><span class="line">                &#123;</span><br><span class="line">                    format_key = _pattern[pos];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    std::cout&lt;&lt; &amp;_pattern[pos<span class="number">-1</span>]&lt;&lt;<span class="string">&quot;位置附近格式错误！\n&quot;</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//下一步使pos指向格式化字符的下个位置，判断是否包含有子格式,例如在%d&#123;%Y-%m-%d&#125;中</span></span><br><span class="line">                pos++;</span><br><span class="line">                <span class="keyword">if</span>(pos+<span class="number">1</span> &lt; _pattern.<span class="built_in">size</span>() &amp;&amp; _pattern[pos] == <span class="string">&#x27;&#123;&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    sub_format_error = <span class="literal">true</span>;</span><br><span class="line">                    pos++;<span class="comment">//pos指向花括号下一个字符</span></span><br><span class="line">                    <span class="keyword">while</span> (pos&lt;_pattern.<span class="built_in">size</span>())</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span>(_pattern[pos] == <span class="string">&#x27;&#125;&#x27;</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="comment">//循环出口</span></span><br><span class="line">                            sub_format_error = <span class="literal">false</span>;</span><br><span class="line">                            pos++;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//在循环中时</span></span><br><span class="line">                        format_val.<span class="built_in">push_back</span>(_pattern[pos++]);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(sub_format_error)</span><br><span class="line">                    &#123;</span><br><span class="line">                        std::cout&lt;&lt;<span class="string">&quot;&#123;&#125;对应出错\n&quot;</span>;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                arry.<span class="built_in">push_back</span>(std::<span class="built_in">make_tuple</span>(format_key,format_val,<span class="number">1</span>));</span><br><span class="line">                format_key.<span class="built_in">clear</span>();</span><br><span class="line">                format_val.<span class="built_in">clear</span>();</span><br><span class="line">            &#125;<span class="comment">//结束循环</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(string_row.<span class="built_in">empty</span>() == <span class="literal">false</span>)<span class="comment">//原生字符串不为空</span></span><br><span class="line">                arry.<span class="built_in">push_back</span>(std::<span class="built_in">make_tuple</span>(string_row,<span class="string">&quot;&quot;</span>,<span class="number">0</span>));</span><br><span class="line">            <span class="keyword">if</span>(format_key.<span class="built_in">empty</span>() == <span class="literal">false</span>)<span class="comment">//格式化字符不为空，注，上下顺序不能换,要和循环内一致</span></span><br><span class="line">                arry.<span class="built_in">push_back</span>(std::<span class="built_in">make_tuple</span>(format_key,format_val,<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">            <span class="comment">//开始拼接item列表</span></span><br><span class="line">            <span class="keyword">if</span>(_items.<span class="built_in">empty</span>() == <span class="literal">false</span>)_items.<span class="built_in">clear</span>();<span class="comment">//清理_items</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; it:arry)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(std::<span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(it) == <span class="number">0</span>)<span class="comment">//获取第三个元素</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="function">FormatItem::ptr <span class="title">fi</span><span class="params">(<span class="keyword">new</span> OtherFormatItem(std::get&lt;<span class="number">0</span>&gt;(it)))</span></span>;</span><br><span class="line">                    _items.<span class="built_in">push_back</span>(fi);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    FormatItem::ptr fi = <span class="built_in">createItem</span>(std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(it),</span><br><span class="line">                                                    std::<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(it));</span><br><span class="line">                    <span class="keyword">if</span>(fi.<span class="built_in">get</span>() == <span class="literal">nullptr</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        std::cout&lt;&lt;<span class="string">&quot;没有对应的格式化字符串： %&quot;</span></span><br><span class="line">                                 &lt;&lt;std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(it)</span><br><span class="line">                                 &lt;&lt;std::endl;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    _items.<span class="built_in">push_back</span>(fi);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="comment">//完成拼接</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        std::string _pattern;</span><br><span class="line">        std::vector&lt;FormatItem::ptr&gt; _items;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们写一下测试代码，把之前举的例子部分模拟出来</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;util.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;level.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;message.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;formatter.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    suplog::Formatter fmt;</span><br><span class="line">    std::string pattern = <span class="string">&quot;[%d&#123;%H:%M:%S&#125;] %m%n&quot;</span>;</span><br><span class="line">    suplog::LogMsg msg=&#123;</span><br><span class="line">        <span class="string">&quot;logger&quot;</span>,       <span class="comment">//名字</span></span><br><span class="line">        <span class="string">&quot;main.cpp&quot;</span>,     <span class="comment">//文件名</span></span><br><span class="line">        <span class="number">22</span>,             <span class="comment">//行数</span></span><br><span class="line">        <span class="string">&quot;创建套接字失败&quot;</span>,<span class="comment">//正文</span></span><br><span class="line">        suplog::LogLevel::Level::ERROR   <span class="comment">//等级</span></span><br><span class="line">    &#125;;</span><br><span class="line">    cout&lt;&lt;fmt.format(msg);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202409291610709.png"></p><p>输出结果如上，显然成功处理出了格式化字符串并输出了预期的日志信息</p><h2 id="日志落地类-LogSink-设计（简单工厂模式）"><a href="#日志落地类-LogSink-设计（简单工厂模式）" class="headerlink" title="日志落地类(LogSink)设计（简单工厂模式）"></a>日志落地类(LogSink)设计（简单工厂模式）</h2><p>日志落地类主要负责落地日志消息到目的地。<br>它主要包括以下内容：</p><ul><li><code>Formatter</code>日志格式化器：主要负责格式化日志消息</li><li><code>mutex互斥锁</code>:保证多线程日志落地过程中的线程安全，避免出现交叉输出的情况。这个类要设计成<strong>支持可扩展</strong>，所以其成员函数<code>log</code>设置为<strong>纯虚函数</strong>，当我们需要增加一个<code>log</code>输出目标,可以增加一个类继承自该类并重写<code>log</code>方法实现具体的落地日志逻辑。（简单工厂模式）</li></ul><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202409251006985.png"></p><ul><li>标准输出：<code>StdoutSink</code></li><li>固定文件: <code>FileSink</code></li><li>滚动文件: <code>RollSink</code><ul><li>滚动日志文件输出的<strong>必要性</strong>:<ol><li>由于<strong>机器磁盘空间有限</strong>， 我们不可能⼀直⽆限地向⼀个⽂件中增加数据</li><li>如果⼀个⽇志 <strong>⽂件体积太⼤</strong>，⼀⽅⾯是不好打开，另⼀⽅⾯是即时打开了由于包含数据巨⼤，也不利于查找我们需要的信息</li><li>所以<strong>实际开发中</strong>会对单个⽇志⽂件的⼤⼩也会做⼀些控制，即当⼤⼩超过某个⼤⼩时（如1GB），我们就重新创建⼀个新的⽇志⽂件来滚动写⽇志。 对于那些过期的⽇志， ⼤部分企业内部都有专⻔的运维⼈员去<strong>定时清理过期的⽇志</strong>，或者设置系统定时任务，定时清理过期⽇志。</li></ol></li><li>日志文件滚动的思想：⽇志⽂件滚动的条件有两个:⽂件⼤⼩ 和 时间。我们可以选择：<ul><li>日志文件在⼤于 1GB 的时候会更换新的⽂件</li><li>每天定点滚动⼀个⽇志⽂件</li></ul></li></ul></li></ul><p>本项目选择基于 文件大小 的潘墩滚动生成新的文件</p><blockquote><p>sink.hpp</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> suplog&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">LogSink</span><span class="comment">//抽象类</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">using</span> ptr = std::shared_ptr&lt;LogSink&gt;;</span><br><span class="line">        <span class="built_in">LogSink</span>()&#123;&#125;</span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="built_in">LogSink</span>() =<span class="keyword">default</span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*data,<span class="type">size_t</span> len)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">StdoutSink</span>:<span class="keyword">public</span> LogSink</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">using</span> ptr = std::shared_ptr&lt;StdoutSink&gt;;</span><br><span class="line">        <span class="built_in">StdoutSink</span>()=<span class="keyword">default</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*data,<span class="type">size_t</span> len)</span> <span class="keyword">override</span></span>&#123;<span class="comment">//加override关键字明示这是虚函数重载</span></span><br><span class="line">            std::cout.<span class="built_in">write</span>(data,len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">FileSink</span>:<span class="keyword">public</span> LogSink</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">using</span> ptr = std::shared_ptr&lt;FileSink&gt;;</span><br><span class="line">        <span class="built_in">FileSink</span>(<span class="type">const</span> std::string&amp; filename):_filename(filename)&#123;</span><br><span class="line">            <span class="comment">//创建目录</span></span><br><span class="line">            util::file::<span class="built_in">create_directory</span>(util::file::<span class="built_in">path</span>(filename));</span><br><span class="line">            _ofs.<span class="built_in">open</span>(_filename,std::ios::binary|std::ios::app);<span class="comment">//二进制方式写入</span></span><br><span class="line">            <span class="built_in">assert</span>(_ofs.<span class="built_in">is_open</span>());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//提供给外界获取文件名</span></span><br><span class="line">        <span class="function"><span class="type">const</span> std::string &amp;<span class="title">file</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> _filename;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*data,<span class="type">size_t</span> len)</span> <span class="keyword">override</span> </span>&#123;<span class="comment">//加override关键字明示这是虚函数重载</span></span><br><span class="line">            _ofs.<span class="built_in">write</span>((<span class="type">const</span> <span class="type">char</span>*)data,len);</span><br><span class="line">            <span class="keyword">if</span>(_ofs.<span class="built_in">good</span>() == <span class="literal">false</span>)&#123;</span><br><span class="line">                std::cout&lt;&lt;<span class="string">&quot;日志输出文件失败!\n&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        std::string _filename;</span><br><span class="line">        std::ofstream _ofs;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">RollSink</span>:<span class="keyword">public</span> LogSink</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">using</span> ptr = std::shared_ptr&lt;RollSink&gt;;</span><br><span class="line">        <span class="built_in">RollSink</span>(<span class="type">const</span> std::string&amp; basename,<span class="type">size_t</span> max_size)</span><br><span class="line">        :_basename(basename),_max_fsize(max_size),_cur_fsize(<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//创建目录</span></span><br><span class="line">            util::file::<span class="built_in">create_directory</span>(util::file::<span class="built_in">path</span>(_basename));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*data,<span class="type">size_t</span> len)</span> <span class="keyword">override</span> </span>&#123;<span class="comment">//加override关键字明示这是虚函数重载</span></span><br><span class="line">            <span class="built_in">initLogFile</span>();</span><br><span class="line">            _ofs.<span class="built_in">write</span>(data,len);</span><br><span class="line">            <span class="keyword">if</span>(_ofs.<span class="built_in">good</span>() == <span class="literal">false</span>)&#123;</span><br><span class="line">                std::cout&lt;&lt;<span class="string">&quot;日志输出文件失败!\n&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            _cur_fsize += len;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="comment">//在这里实现对日志文件的管理</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">initLogFile</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(_ofs.<span class="built_in">is_open</span>() == <span class="literal">false</span> || _cur_fsize &gt;=_max_fsize)</span><br><span class="line">            &#123;</span><br><span class="line">                _ofs.<span class="built_in">close</span>();</span><br><span class="line">                <span class="keyword">if</span>(_cur_fsize &gt;=_max_fsize) <span class="built_in">sleep</span>(<span class="number">1</span>);<span class="comment">//防止同一秒有过多日志消息要打印，导致打开同一个日志文件</span></span><br><span class="line">                std::string name = <span class="built_in">createFilename</span>();</span><br><span class="line">                _ofs.<span class="built_in">open</span>(name,std::ios::binary | std::ios::app);</span><br><span class="line">                <span class="built_in">assert</span>(_ofs.<span class="built_in">is_open</span>());</span><br><span class="line">                _cur_fsize = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//管理文件名的生成</span></span><br><span class="line">        <span class="function">std::string <span class="title">createFilename</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="type">time_t</span> t = <span class="built_in">time</span>(<span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">struct</span> <span class="title class_">tm</span> lt;</span><br><span class="line">            <span class="built_in">localtime_r</span>(&amp;t,&amp;lt);</span><br><span class="line">            std::stringstream ss;</span><br><span class="line">            <span class="comment">//获取详细时间信息</span></span><br><span class="line">            ss &lt;&lt; _basename;</span><br><span class="line">            ss&lt;&lt; lt.tm_year + <span class="number">1900</span>;</span><br><span class="line">            ss &lt;&lt;lt.tm_mon + <span class="number">1</span>;</span><br><span class="line">            ss &lt;&lt; lt.tm_mday;</span><br><span class="line">            ss &lt;&lt; lt.tm_hour;</span><br><span class="line">            ss &lt;&lt; lt.tm_min;</span><br><span class="line">            ss &lt;&lt; lt.tm_sec;</span><br><span class="line">            ss &lt;&lt; <span class="string">&quot;.log&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> ss.<span class="built_in">str</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        std::string _basename;</span><br><span class="line">        std::ofstream _ofs;</span><br><span class="line">        <span class="type">size_t</span> _max_fsize;</span><br><span class="line">        <span class="type">size_t</span> _cur_fsize;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建简单工厂</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">SinkFactory</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> SinkType,<span class="keyword">typename</span> ...Args&gt;</span></span><br><span class="line"><span class="function">        <span class="type">static</span> LogSink::ptr <span class="title">create</span><span class="params">(Args&amp;&amp;...args)</span></span>&#123;</span><br><span class="line">            <span class="comment">//返回shared_ptr,传的是构造函数参数列表</span></span><br><span class="line">            <span class="keyword">return</span> std::<span class="built_in">make_shared</span>&lt;SinkType&gt;(std::forward&lt;Args&gt;(args)...);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码测试-2"><a href="#代码测试-2" class="headerlink" title="代码测试"></a>代码测试</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;util.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;level.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;message.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;formatter.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sink.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    suplog::Formatter fmt;</span><br><span class="line">    std::string pattern = <span class="string">&quot;[%d&#123;%H:%M:%S&#125;] %m%n&quot;</span>;</span><br><span class="line">    suplog::LogMsg msg=&#123;</span><br><span class="line">        <span class="string">&quot;logger&quot;</span>,       <span class="comment">//名字</span></span><br><span class="line">        <span class="string">&quot;main.cpp&quot;</span>,     <span class="comment">//文件名</span></span><br><span class="line">        <span class="number">22</span>,             <span class="comment">//行数</span></span><br><span class="line">        <span class="string">&quot;创建套接字失败&quot;</span>,<span class="comment">//正文</span></span><br><span class="line">        suplog::LogLevel::Level::ERROR   <span class="comment">//等级</span></span><br><span class="line">    &#125;;</span><br><span class="line">    std::string str = fmt.format(msg);</span><br><span class="line"></span><br><span class="line">    std::shared_ptr&lt;suplog::LogSink&gt; lsptr;</span><br><span class="line"></span><br><span class="line">    lsptr.<span class="built_in">reset</span>(<span class="keyword">new</span> suplog::<span class="built_in">StdoutSink</span>());</span><br><span class="line">    lsptr-&gt;<span class="built_in">log</span>(str.<span class="built_in">c_str</span>(),str.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">    lsptr.<span class="built_in">reset</span>(<span class="keyword">new</span> suplog::<span class="built_in">FileSink</span>(<span class="string">&quot;./testdir/log.log&quot;</span>));</span><br><span class="line">    lsptr-&gt;<span class="built_in">log</span>(str.<span class="built_in">c_str</span>(),str.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">    lsptr.<span class="built_in">reset</span>(<span class="keyword">new</span> suplog::<span class="built_in">RollSink</span>(<span class="string">&quot;./testdir/rollsink/log&quot;</span>,<span class="number">10</span>));<span class="comment">//故意设置小，查看滚动效果</span></span><br><span class="line">    string msg1=<span class="built_in">string</span>(str).<span class="built_in">append</span>(<span class="string">&quot;msg1&quot;</span>);</span><br><span class="line">    string msg2=<span class="built_in">string</span>(str).<span class="built_in">append</span>(<span class="string">&quot;msg2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    lsptr-&gt;<span class="built_in">log</span>(msg1.<span class="built_in">c_str</span>(),msg1.<span class="built_in">size</span>());</span><br><span class="line">    lsptr-&gt;<span class="built_in">log</span>(msg2.<span class="built_in">c_str</span>(),msg2.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了测试日志落地的功能,我们设计了一段测试代码，测试其多态性的同时，测试了三种落地方式,<strong>特别的</strong>,在<code>RollSink</code>中故意把<code>max_size</code>设的很小，让它能够在测试中滚动输出日志。</p><p>输出结果如下</p><blockquote><p>标准输出落地<br><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202409301424289.png"></p></blockquote><blockquote><p>文件输出落地<br><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202409301426958.png"></p></blockquote><blockquote><p>滚动文件输出落地<br><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202409301426958.png"></p></blockquote><p>可以看到各类落地功能都执行得很好</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">其实之前在suplog::util::file::path函数中</span><br><span class="line">作者不小心写错了一个函数，把name.find_last_of(&quot;/\\&quot;);中的</span><br><span class="line">find_last_of写成了find_last_not_of,结果前面的测试代码</span><br><span class="line">没有测试出bug,导致目录是创建出来了，但是把文件夹路径最后的</span><br><span class="line">文件名也当成目录给创建出来了，可见每一步都做测试的重要性，因为在</span><br><span class="line">这次的测试中，我发现了文件输出失败，原因是打不开文件。（目录当然打不开了）</span><br><span class="line">经过一通排查发现问题出在了之前写的path函数里</span><br><span class="line"></span><br><span class="line">所以一定要多做测试！</span><br></pre></td></tr></table></figure><h2 id="日志类-Logger-主干部分设计（建造者模式）"><a href="#日志类-Logger-主干部分设计（建造者模式）" class="headerlink" title="日志类(Logger)主干部分设计（建造者模式）"></a>日志类(Logger)主干部分设计（建造者模式）</h2><p>⽇志器主要是⽤来和<strong>前端交互</strong>， 当我们需要使⽤⽇志系统打印log的时候， 只需要创建<code>Logger</code>对象，调⽤该对象<code>debug</code>、<code>info</code>、<code>warn</code>、<code>error</code>、<code>fatal</code>等 <strong>⽅法</strong>输出⾃⼰想打印的⽇志即可，⽀持<strong>解析可变参数列表和输出格式</strong>， 即可以做到像使⽤printf函数⼀样打印⽇志。</p><p>当前⽇志系统计划⽀持<code>同步⽇志</code> &amp; <code>异步⽇志</code>两种模式，两个不同的⽇志器唯⼀不同的地⽅在于他们在⽇志的落地⽅式上有所不同：</p><ul><li><code>同步⽇志器</code>：直接对⽇志消息进⾏输出。</li><li><code>异步⽇志器</code>：将⽇志消息放⼊缓冲区，由<strong>异步线程</strong>进⾏输出。</li></ul><p>因此⽇志器类在设计的时候先设计出⼀个<code>Logger基类</code>，在Logger基类的基础上，继承出<code>SyncLogger同步⽇志器</code>和<code>AsyncLogger异步⽇志器</code>。</p><p>且因为⽇志器模块是对前边多个模块的整合，想要创建⼀个⽇志器，需要设置⽇志器名称，设置⽇志输出等级，设置⽇志器类型，设置⽇志输出格式，设置落地⽅向，且落地⽅向有可能存在多个，整个⽇志器的<strong>创建过程较为复杂</strong>，为了保持良好的代码⻛格，编写出优雅的代码，因此⽇志器的创建这⾥采⽤了<code>建造者模式</code>来进⾏创建</p><p>因为同步日志器类比较简单，就直接在这里实现了。</p><p>而异步日志器虽然也在这里实现，但是由于比较复杂，在下一步实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;util.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;level.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;message.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;formatter.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sink.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;looper.hpp&quot;</span><span class="comment">//不认识？没关系，</span></span></span><br><span class="line">                    <span class="comment">//这个头文件后面才实现,给异步日志器的实现用的</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdarg&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> suplog&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Logger</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">enum class</span> <span class="title class_">Type</span>&#123;</span><br><span class="line">            LOGGER_SYNC = <span class="number">0</span>,</span><br><span class="line">            LOGGER_ASYNC</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">using</span> ptr = std::shared_ptr&lt;Logger&gt;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">Logger</span>(<span class="type">const</span> std::string&amp; name,</span><br><span class="line">            Formatter::ptr formatter,</span><br><span class="line">            std::vector&lt;LogSink::ptr&gt; &amp;sinks,</span><br><span class="line">            LogLevel::Level level = LogLevel::Level::DEBUG</span><br><span class="line">        ):_name(name),_level(level),_formatter(formatter),</span><br><span class="line">        _sinks(sinks.<span class="built_in">begin</span>(),sinks.<span class="built_in">end</span>())</span><br><span class="line">        &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">std::string <span class="title">loggerName</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> _name;&#125;</span><br><span class="line">        <span class="function">LogLevel::Level <span class="title">loggerLevel</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> _level;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用C语言风格的不定参数</span></span><br><span class="line">        <span class="comment">//=========start========</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">debug</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*file,<span class="type">size_t</span> line,<span class="type">const</span> <span class="type">char</span>*fmt,...)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">shouldLog</span>(LogLevel::Level::DEBUG) == <span class="literal">false</span>)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            va_list al;</span><br><span class="line">            <span class="built_in">va_start</span>(al,fmt);<span class="comment">//依据fmt从内存中提取可变参数列表</span></span><br><span class="line">            <span class="built_in">log</span>(LogLevel::Level::DEBUG,file,line,fmt,al);<span class="comment">//日志输出</span></span><br><span class="line">            <span class="built_in">va_end</span>(al);<span class="comment">//结束可变参数列表</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">info</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*file,<span class="type">size_t</span> line,<span class="type">const</span> <span class="type">char</span>*fmt,...)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">shouldLog</span>(LogLevel::Level::INFO) == <span class="literal">false</span>)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            va_list al;</span><br><span class="line">            <span class="built_in">va_start</span>(al,fmt);<span class="comment">//依据fmt从内存中提取可变参数列表</span></span><br><span class="line">            <span class="built_in">log</span>(LogLevel::Level::INFO,file,line,fmt,al);<span class="comment">//日志输出</span></span><br><span class="line">            <span class="built_in">va_end</span>(al);<span class="comment">//结束可变参数列表</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">warn</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*file,<span class="type">size_t</span> line,<span class="type">const</span> <span class="type">char</span>*fmt,...)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">shouldLog</span>(LogLevel::Level::WARN) == <span class="literal">false</span>)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            va_list al;</span><br><span class="line">            <span class="built_in">va_start</span>(al,fmt);<span class="comment">//依据fmt从内存中提取可变参数列表</span></span><br><span class="line">            <span class="built_in">log</span>(LogLevel::Level::WARN,file,line,fmt,al);<span class="comment">//日志输出</span></span><br><span class="line">            <span class="built_in">va_end</span>(al);<span class="comment">//结束可变参数列表</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">error</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*file,<span class="type">size_t</span> line,<span class="type">const</span> <span class="type">char</span>*fmt,...)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">shouldLog</span>(LogLevel::Level::ERROR) == <span class="literal">false</span>)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            va_list al;</span><br><span class="line">            <span class="built_in">va_start</span>(al,fmt);<span class="comment">//依据fmt从内存中提取可变参数列表</span></span><br><span class="line">            <span class="built_in">log</span>(LogLevel::Level::WARN,file,line,fmt,al);<span class="comment">//日志输出</span></span><br><span class="line">            <span class="built_in">va_end</span>(al);<span class="comment">//结束可变参数列表</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">fatal</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*file,<span class="type">size_t</span> line,<span class="type">const</span> <span class="type">char</span>*fmt,...)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">shouldLog</span>(LogLevel::Level::FATAL) == <span class="literal">false</span>)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            va_list al;</span><br><span class="line">            <span class="built_in">va_start</span>(al,fmt);<span class="comment">//依据fmt从内存中提取可变参数列表</span></span><br><span class="line">            <span class="built_in">log</span>(LogLevel::Level::FATAL,file,line,fmt,al);<span class="comment">//日志输出</span></span><br><span class="line">            <span class="built_in">va_end</span>(al);<span class="comment">//结束可变参数列表</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//===============end===============</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">//在内部声明一个建造者抽象类</span></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Builder</span></span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="keyword">using</span> ptr = std::shared_ptr&lt;Builder&gt;;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">Builder</span>():_level(LogLevel::Level::DEBUG),</span><br><span class="line">                _logger_type(Logger::Type::LOGGER_SYNC)</span><br><span class="line">            &#123;&#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">buildLoggerName</span><span class="params">(<span class="type">const</span> std::string&amp; name)</span></span>&#123;_logger_name = name;&#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">buildLoggerLevel</span><span class="params">(LogLevel::Level level)</span></span>&#123;_level = level;&#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">buildLoggerType</span><span class="params">(Logger::Type type)</span></span>&#123;_logger_type = type;&#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">buidFormatter</span><span class="params">(<span class="type">const</span> Formatter::ptr&amp; formatter)</span></span>&#123;</span><br><span class="line">                _formatter = formatter;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">buidFormatter</span><span class="params">(<span class="type">const</span> std::string&amp; formatStr)</span></span>&#123;</span><br><span class="line">                <span class="keyword">auto</span> formatter = std::<span class="built_in">make_shared</span>&lt;suplog::Formatter&gt;(formatStr);</span><br><span class="line">                _formatter = formatter;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//C++风格不定参数</span></span><br><span class="line">            <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> SinkType,<span class="keyword">typename</span> ...Args&gt;</span></span><br><span class="line"><span class="function">            <span class="type">void</span> <span class="title">buildSink</span><span class="params">(Args &amp;&amp;...arfs)</span></span>&#123;</span><br><span class="line">                <span class="keyword">auto</span> sink = SinkFactory::<span class="built_in">create</span>&lt;SinkType&gt;(std::forward&lt;Args&gt;(args)...);</span><br><span class="line">                _sinks.<span class="built_in">push_back</span>(sink);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">virtual</span> Logger::ptr <span class="title">build</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">protected</span>:</span><br><span class="line">            Logger::Type _logger_type;</span><br><span class="line">            std::string _logger_name;</span><br><span class="line">            LogLevel::Level _level;</span><br><span class="line">            Formatter::ptr _formatter;</span><br><span class="line">            std::vector&lt;LogSink::ptr&gt; _sinks;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">shouldLog</span><span class="params">(LogLevel::Level level)</span></span>&#123;<span class="keyword">return</span> level&gt;= _level;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(LogLevel::Level level,<span class="type">const</span> <span class="type">char</span>*file,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">size_t</span> line,<span class="type">const</span> <span class="type">char</span>*fmt,va_list al)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">char</span> *buf;<span class="comment">//可以不初始化</span></span><br><span class="line">        std::string msg;</span><br><span class="line">        <span class="type">int</span> len = <span class="built_in">vasprintf</span>(&amp;buf,fmt,al);<span class="comment">//自动在堆区申请内存</span></span><br><span class="line">        <span class="keyword">if</span>(len &lt; <span class="number">0</span>)</span><br><span class="line">            msg = <span class="string">&quot;格式化日志消息失败!!&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            msg.<span class="built_in">assign</span>(buf,len);</span><br><span class="line">            <span class="built_in">free</span>(buf);<span class="comment">//释放空间</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//LogMsg(name, file, line, payload, level)</span></span><br><span class="line">        <span class="function">LogMsg <span class="title">logmsg</span><span class="params">(_name,file,line,std::move(msg),level)</span></span>;</span><br><span class="line">        std::string str;</span><br><span class="line">        str = _formatter-&gt;format(logmsg);</span><br><span class="line">        <span class="built_in">logIt</span>(std::<span class="built_in">move</span>(str));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">logIt</span><span class="params">(<span class="type">const</span> std::string &amp;msg)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        std::mutex _mutex;</span><br><span class="line">        std::string _name;</span><br><span class="line">        Formatter::ptr _formatter;</span><br><span class="line">        std::atomic&lt;LogLevel::Level&gt; _level;</span><br><span class="line">        std::vector&lt;LogSink::ptr&gt; _sinks; </span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//同步日志器比较简单，所以直接实现了</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">SyncLogger</span>:<span class="keyword">public</span> Logger</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">using</span> ptr = std::shared_ptr&lt;SyncLogger&gt;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">SyncLogger</span>(<span class="type">const</span> std::string&amp; name,</span><br><span class="line">            Formatter::ptr formatter,</span><br><span class="line">            std::vector&lt;LogSink::ptr&gt;&amp;sinks,</span><br><span class="line">            LogLevel::Level level = LogLevel::Level::DEBUG)</span><br><span class="line">            :<span class="built_in">Logger</span>(name,formatter,sinks,level)&#123;</span><br><span class="line">                std::cout &lt;&lt; LogLevel::<span class="built_in">toString</span>(level)&lt;&lt;<span class="string">&quot;同步日志器创建成功...\n&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">logIt</span><span class="params">(<span class="type">const</span> std::string&amp; msg_str)</span></span>&#123;</span><br><span class="line">                <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(_mutex)</span></span>;<span class="comment">//函数结束后自动释放锁</span></span><br><span class="line">                <span class="keyword">if</span>(_sinks.<span class="built_in">empty</span>()) &#123;<span class="keyword">return</span>;&#125;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;it:_sinks)</span><br><span class="line">                    it-&gt;<span class="built_in">log</span>(msg_str.<span class="built_in">c_str</span>(),msg_str.<span class="built_in">size</span>());</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">LocalLoggerBuilder</span>:<span class="keyword">public</span> Logger::Builder</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> Logger::ptr <span class="title">build</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(_logger_name.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                std::cout&lt;&lt;<span class="string">&quot;日志器名称不能为空！！&quot;</span>;</span><br><span class="line">                <span class="built_in">abort</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(_formatter.<span class="built_in">get</span>() == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                std::cout&lt;&lt;<span class="string">&quot;当前日志器： &quot;</span>&lt;&lt;_logger_name;</span><br><span class="line">                std::cout&lt;&lt;<span class="string">&quot; 未检测到⽇志格式,默认设置为: &quot;</span>;</span><br><span class="line">                std::cout&lt;&lt;<span class="string">&quot; %d&#123;%H:%M:%S&#125;%T%t%T[%p]%T[%c]%T%f:%l%T%m%n\n&quot;</span>;</span><br><span class="line">                _formatter = std::<span class="built_in">make_shared</span>&lt;Formatter&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(_sinks.<span class="built_in">empty</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                std::cout&lt;&lt;<span class="string">&quot;当前日志器: &quot;</span>&lt;&lt;_logger_name&lt;&lt;<span class="string">&quot;问检测到落地方向，默认为标准输出!\n&quot;</span>;</span><br><span class="line">                _sinks.<span class="built_in">push_back</span>(std::<span class="built_in">make_shared</span>&lt;StdoutSink&gt;());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Logger::ptr lp;</span><br><span class="line">            <span class="keyword">if</span>(_logger_type == Logger::Type::LOGGER_ASYNC)</span><br><span class="line">            &#123;</span><br><span class="line">                lp = std::<span class="built_in">make_shared</span>&lt;AsyncLogger&gt;(_logger_name,_formatter,_sinks,_level);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                lp = std::<span class="built_in">make_shared</span>&lt;SyncLogger&gt;(_logger_name,_formatter,_sinks,_level);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="双缓冲区异步任务处理器（AsyncLooper）设计"><a href="#双缓冲区异步任务处理器（AsyncLooper）设计" class="headerlink" title="双缓冲区异步任务处理器（AsyncLooper）设计"></a>双缓冲区异步任务处理器（AsyncLooper）设计</h2><p>设计思想：异步处理线程 + 数据池</p><p>使⽤者将需要完成的任务添加到任务池中，由<strong>异步线程来完成任务的实际执⾏操作</strong>。</p><p>任务池的设计思想:<strong>双缓冲区阻塞数据池</strong></p><p>优势：缓冲区避免了空间的频繁申请释放，且尽可能的减少了生产者与消费者之间<strong>锁冲突</strong>的概率,提高了任务处理的效率</p><blockquote><p>在任务池的设计中，有很多备选⽅案，⽐如循环队列等等，但是不管是哪⼀种都会涉及到<strong>锁冲突</strong>的情况，因为在⽣产者与消费者模型中，任何两个⻆⾊之间都具有互斥关系，因此每⼀次的任务<strong>添加与取出都有可能涉及锁的冲突</strong>，⽽双缓冲区不同，双缓冲区是处理器将⼀个缓冲区中的任务全部处理完毕后，然后交换两个缓冲区，重新对新的缓冲区中的任务进⾏处理，虽然同时多线程写⼊也会冲突，但是冲突并不会像每次只处理⼀条的时候频繁（减少了⽣产者与消费者之间的锁冲突），且不涉及到空间的频繁申请释放所带来的消耗。</p></blockquote><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202410041822328.gif"></p><blockquote><p>buffer.hpp</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> suplog</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_DEFUALT_SIZE (1*1024*1024)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_INCREMENT_SIZE (1*1024*1024)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_THRESHOLD_SIZE (10*1024*1024)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Buffer</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Buffer</span>():_reader_idx(<span class="number">0</span>),_writer_idx(<span class="number">0</span>),_v(BUFFER_DEFUALT_SIZE)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> _reader_idx == _writer_idx;&#125;</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">readAbleSize</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> _writer_idx - _reader_idx;&#125;</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">writeAbleSize</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> _v.<span class="built_in">size</span>() - _writer_idx;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">()</span></span>&#123;_reader_idx = _writer_idx = <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(Buffer&amp; buf)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _v.<span class="built_in">swap</span>(buf._v);</span><br><span class="line">        std::<span class="built_in">swap</span>(_reader_idx,buf._reader_idx);</span><br><span class="line">        std::<span class="built_in">swap</span>(_writer_idx,buf._writer_idx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*data,<span class="type">size_t</span> len)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">ensureEnoughSpace</span>(len);</span><br><span class="line">        <span class="built_in">assert</span>(len&lt;=<span class="built_in">writeAbleSize</span>());</span><br><span class="line">        std::<span class="built_in">copy</span>(data,data+len,&amp;_v[_writer_idx]);</span><br><span class="line">        _writer_idx+=len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">(<span class="type">size_t</span> len)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _reader_idx +=len;</span><br><span class="line">        <span class="built_in">assert</span>(_reader_idx &lt;=_writer_idx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">begin</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> &amp;_v[_reader_idx];&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ensureEnoughSpace</span><span class="params">(<span class="type">size_t</span> len)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(len &lt;=<span class="built_in">writeAbleSize</span>())<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">size_t</span> new_capacity;</span><br><span class="line">        <span class="comment">//每次增加1M的大小</span></span><br><span class="line">        <span class="keyword">if</span>(_v.<span class="built_in">size</span>() &lt; BUFFER_THRESHOLD_SIZE)</span><br><span class="line">            new_capacity = _v.<span class="built_in">size</span>()*<span class="number">2</span>+len;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            new_capacity = _v.<span class="built_in">size</span>() + BUFFER_INCREMENT_SIZE + len;</span><br><span class="line"></span><br><span class="line">        _v.<span class="built_in">resize</span>(new_capacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">size_t</span> _reader_idx;</span><br><span class="line">    <span class="type">size_t</span> _writer_idx;</span><br><span class="line">    std::vector&lt;<span class="type">char</span>&gt; _v;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>looper.hpp</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;util.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;buffer.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> suplog</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">AsyncLooper</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">using</span> ptr = std::shared_ptr&lt;AsyncLooper&gt;;</span><br><span class="line">        <span class="keyword">using</span> Functor = std::function&lt;<span class="built_in">void</span>(Buffer &amp;buffer)&gt;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">AsyncLooper</span>(<span class="type">const</span> Functor&amp;cb)</span><br><span class="line">        : _running(<span class="literal">true</span>),</span><br><span class="line">        _looper_callback(cb),</span><br><span class="line">        _thread(std::<span class="built_in">thread</span>(&amp;AsyncLooper::worker_loop,<span class="keyword">this</span>))</span><br><span class="line">        &#123;&#125;</span><br><span class="line"></span><br><span class="line">        ~<span class="built_in">AsyncLooper</span>()&#123;<span class="built_in">stop</span>();&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">stop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            _running =<span class="literal">false</span>;</span><br><span class="line">            _pop_cond.<span class="built_in">notify_all</span>();<span class="comment">//取消所有线程的条件变量等待</span></span><br><span class="line">            _thread.<span class="built_in">join</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> std::string&amp;msg)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(_running == <span class="literal">false</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(_mutex)</span></span>;</span><br><span class="line">            _push_cond.<span class="built_in">wait</span>(lock,[&amp;]&#123;</span><br><span class="line">                <span class="keyword">return</span> _tasks_push.<span class="built_in">writeAbleSize</span>() &gt;= msg.<span class="built_in">size</span>();</span><br><span class="line">                &#125;);<span class="comment">//防止消息过大</span></span><br><span class="line"></span><br><span class="line">            _tasks_push.<span class="built_in">push</span>(msg.<span class="built_in">c_str</span>(),msg.<span class="built_in">size</span>());<span class="comment">//完成消息任务推送</span></span><br><span class="line"></span><br><span class="line">            _pop_cond.<span class="built_in">notify_all</span>();<span class="comment">//唤醒所有消费者</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">worker_loop</span><span class="params">(<span class="type">void</span>* arg)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="comment">//多线程执行函数得靠arg传递this指针</span></span><br><span class="line">            AsyncLooper* al = (AsyncLooper* )arg;</span><br><span class="line">            <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                 <span class="comment">// lock 的析构函数在离开作用域时自动释放互斥锁</span></span><br><span class="line">                <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(al-&gt;_mutex)</span></span>;</span><br><span class="line">                <span class="comment">//线程出口,为空且关闭时退出循环</span></span><br><span class="line">                <span class="keyword">if</span>(al-&gt;_running == <span class="literal">false</span> &amp;&amp; al-&gt;_tasks_push.<span class="built_in">empty</span>())</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//生产者缓冲不为空或者停止运行时才会被唤醒</span></span><br><span class="line">                al-&gt;_pop_cond.<span class="built_in">wait</span>(lock,[&amp;]&#123;<span class="keyword">return</span> !al-&gt;_tasks_push.<span class="built_in">empty</span>() || !al-&gt;_running;&#125;);</span><br><span class="line">                al-&gt;_tasks_push.<span class="built_in">swap</span>(al-&gt;_tasks_pop);<span class="comment">//交换缓冲区</span></span><br><span class="line"></span><br><span class="line">                al-&gt;_push_cond.<span class="built_in">notify_all</span>();<span class="comment">//唤醒所有生产者缓冲区</span></span><br><span class="line">                al-&gt;_looper_callback(al-&gt;_tasks_pop);<span class="comment">//输出消费者缓冲区</span></span><br><span class="line">                al-&gt;_tasks_pop.<span class="built_in">reset</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        Functor _looper_callback;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        std::mutex _mutex;</span><br><span class="line">        std::atomic&lt;<span class="type">bool</span>&gt; _running;</span><br><span class="line">        std::condition_variable _push_cond;</span><br><span class="line">        std::condition_variable _pop_cond;</span><br><span class="line">        Buffer _tasks_push;</span><br><span class="line">        Buffer _tasks_pop;</span><br><span class="line">        std::thread _thread;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="异步日志器-AsyncLogger-设计"><a href="#异步日志器-AsyncLogger-设计" class="headerlink" title="异步日志器(AsyncLogger)设计"></a>异步日志器(AsyncLogger)设计</h2><p>在实现了<code>AsyncLooper</code>后，异步日志器的实现就很简单了，具体的<code>生产者-消费者</code>交互工作都交给了<code>AsyncLooper</code>，异步日志器主要负责推送日志任务，以及获取日志任务，转发给落地类(<code>LogSink</code>)去完成</p><ul><li><code>LogIt</code>为重写父类函数，专门现将⽇志数据加⼊异步队列缓冲区中</li><li><code>readLog</code>函数在<strong>异步线程</strong>上执行调用,完成日志的实际落地工作</li></ul><blockquote><p>logger.hpp</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//class SyncLogger:public Logger</span></span><br><span class="line"><span class="comment">//上面已经实现过了，代码略......</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">AsyncLogger</span>:<span class="keyword">public</span> Logger</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">using</span> ptr = std::shared_ptr&lt;AsyncLogger&gt;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">AsyncLogger</span>(<span class="type">const</span> std::string&amp; name,</span><br><span class="line">            Formatter::ptr formatter,</span><br><span class="line">            std::vector&lt;LogSink::ptr&gt;&amp;sinks,</span><br><span class="line">            LogLevel::Level level = LogLevel::Level::DEBUG)</span><br><span class="line">            :<span class="built_in">Logger</span>(name,formatter,sinks,level)</span><br><span class="line">            ,_looper(std::<span class="built_in">make_shared</span>&lt;AsyncLooper&gt;(</span><br><span class="line">                std::<span class="built_in">bind</span>(&amp;AsyncLogger::readLog,<span class="keyword">this</span>,std::placeholders::_1)))</span><br><span class="line">                <span class="comment">//传一个this,使包装器里的函数能够是成员函数,this后面的才是包装器指定的参数</span></span><br><span class="line">            &#123;</span><br><span class="line">                std::cout &lt;&lt; LogLevel::<span class="built_in">toString</span>(level)&lt;&lt;<span class="string">&quot;异步日志器创建成功...\n&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">logIt</span><span class="params">(<span class="type">const</span> std::string &amp;msg)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            _looper-&gt;<span class="built_in">push</span>(msg);<span class="comment">//推送消息</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">readLog</span><span class="params">(Buffer&amp; msg)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(_sinks.<span class="built_in">empty</span>())&#123;<span class="keyword">return</span>;&#125;<span class="comment">//判空</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;it:_sinks)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//调用落地功能</span></span><br><span class="line">                it-&gt;<span class="built_in">log</span>(msg.<span class="built_in">begin</span>(),msg.<span class="built_in">readAbleSize</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        AsyncLooper::ptr _looper;</span><br><span class="line">    </span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  class LocalLoggerBuilder:public Logger::Builder</span></span><br><span class="line"><span class="comment">//  实现过了，代码略......</span></span><br></pre></td></tr></table></figure><h2 id="单例日志器管理类设计（单例模式）"><a href="#单例日志器管理类设计（单例模式）" class="headerlink" title="单例日志器管理类设计（单例模式）"></a>单例日志器管理类设计（单例模式）</h2><p>日志的输出，我们希望能够在<strong>任意位置都可以进行</strong>，但是当我们创建了一个日志器后，就会受到日志器所在<strong>作用域</strong>的访问属性限制。</p><p>因此，为了突破访问区域的限制，我们再封装一个日志器管理类，并采用<code>单例模式</code>，安全地在全局的任意位置调用指定的日志器</p><p><code>全局日志器建造者类</code>：既然日志器管理类是在全局上工作的，我们决定再封装一个配套的<strong>全局日志器建造者类</strong>,<strong>自动</strong>将新增的日志器添加到单例日志类管理器中。</p><p>对特定日志器的访问:这里采用通过名字索引的方式获取指定日志器</p><blockquote><p>logger.hpp</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//接在LocalLoggerBuilder后面</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">LoggerManager</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">static</span> LoggerManager&amp; <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="type">static</span> LoggerManager lm;<span class="comment">//饿汉模式创建全局对象</span></span><br><span class="line">            <span class="keyword">return</span> lm;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">hasLogger</span><span class="params">(<span class="type">const</span> std::string&amp; name)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(_mutex)</span></span>;</span><br><span class="line">            <span class="keyword">auto</span> it = _loggers.<span class="built_in">find</span>(name);</span><br><span class="line">            <span class="keyword">if</span>(it == _loggers.<span class="built_in">end</span>())</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">addLogger</span><span class="params">(<span class="type">const</span> std::string&amp; name,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="type">const</span> Logger::ptr logger)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(_mutex)</span></span>;</span><br><span class="line">            _loggers.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(name,logger));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">Logger::ptr <span class="title">getLogger</span><span class="params">(<span class="type">const</span> std::string &amp;name)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(_mutex)</span></span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">hasLogger</span>(name))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">auto</span> it = _loggers.<span class="built_in">find</span>(name);</span><br><span class="line">                <span class="keyword">if</span>(it!= _loggers.<span class="built_in">end</span>())</span><br><span class="line">                    <span class="keyword">return</span> it-&gt;second;<span class="comment">//找到了，返回指针</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//找不到</span></span><br><span class="line">            <span class="keyword">return</span> Logger::<span class="built_in">ptr</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">Logger::ptr <span class="title">rootLogger</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(_mutex)</span></span>;</span><br><span class="line">            <span class="keyword">return</span> _root_logger;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">LoggerManager</span>()<span class="comment">//私有化防止外部调用，破坏单例模式</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//调用本地建造者</span></span><br><span class="line">            <span class="function">std::unique_ptr&lt;LocalLoggerBuilder&gt; <span class="title">slb</span><span class="params">(<span class="keyword">new</span> LocalLoggerBuilder())</span></span>;</span><br><span class="line">            slb-&gt;<span class="built_in">buildLoggerName</span>(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">            slb-&gt;<span class="built_in">buildLoggerType</span>(Logger::Type::LOGGER_SYNC);</span><br><span class="line">            <span class="comment">//格式使用默认</span></span><br><span class="line">            <span class="comment">//采用默认落地方向</span></span><br><span class="line">            _root_logger = slb-&gt;<span class="built_in">build</span>();</span><br><span class="line">            _loggers.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(<span class="string">&quot;root&quot;</span>,_root_logger));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">LoggerManager</span>(<span class="type">const</span> LoggerManager&amp;) = <span class="keyword">delete</span>;<span class="comment">//删除拷贝构造</span></span><br><span class="line">        LoggerManager&amp; <span class="keyword">operator</span>=(<span class="type">const</span> LoggerManager&amp;) = <span class="keyword">delete</span>;<span class="comment">//删除重载</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        std::mutex _mutex;<span class="comment">//互斥量</span></span><br><span class="line">        Logger::ptr _root_logger;<span class="comment">//至少有一个日志器</span></span><br><span class="line">        std::unordered_map&lt;std::string,Logger::ptr&gt; _loggers;</span><br><span class="line">        <span class="comment">//使用父类指针统一管理，使用多态</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">GlobalLoggerBuilder</span>:<span class="keyword">public</span> Logger::Builder</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> Logger::ptr <span class="title">build</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(_logger_name.<span class="built_in">empty</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                std::cout&lt;&lt;<span class="string">&quot;日志器名称不能为空!!&quot;</span>;</span><br><span class="line">                <span class="built_in">abort</span>();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//不能有重名的日志器</span></span><br><span class="line">            <span class="built_in">assert</span>(LoggerManager::<span class="built_in">getInstance</span>().<span class="built_in">hasLogger</span>(_logger_name) == <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(_formatter.<span class="built_in">get</span>() == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                std::cout&lt;&lt;<span class="string">&quot;当前日志器： &quot;</span>&lt;&lt;_logger_name;</span><br><span class="line">                std::cout&lt;&lt;<span class="string">&quot; 未检测到⽇志格式,默认设置为: &quot;</span>;</span><br><span class="line">                std::cout&lt;&lt;<span class="string">&quot; %d&#123;%H:%M:%S&#125;%T%t%T[%p]%T[%c]%T%f:%l%T%m%n\n&quot;</span>;</span><br><span class="line">                _formatter = std::<span class="built_in">make_shared</span>&lt;Formatter&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(_sinks.<span class="built_in">empty</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                std::cout&lt;&lt;<span class="string">&quot;当前日志器: &quot;</span>&lt;&lt;_logger_name&lt;&lt;<span class="string">&quot;问检测到落地方向，默认为标准输出!\n&quot;</span>;</span><br><span class="line">                _sinks.<span class="built_in">push_back</span>(std::<span class="built_in">make_shared</span>&lt;StdoutSink&gt;());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Logger::ptr lp;</span><br><span class="line">            <span class="keyword">if</span>(_logger_type == Logger::Type::LOGGER_SYNC)</span><br><span class="line">            &#123;</span><br><span class="line">                lp = std::<span class="built_in">make_shared</span>&lt;SyncLogger&gt;(_logger_name,_formatter,_sinks,_level);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                lp = std::<span class="built_in">make_shared</span>&lt;AsyncLogger&gt;(_logger_name,_formatter,_sinks,_level);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//加入全局日志器管理类中</span></span><br><span class="line">            LoggerManager::<span class="built_in">getInstance</span>().<span class="built_in">addLogger</span>(_logger_name,lp);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> lp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><p>终于是完成了日志系统的大部分代码，由于前几个模块关联性过高，所以测试代码憋到现在来写，没关系，这就开测！</p><p>测试目标</p><ul><li>测试<code>GlobalLoggerBuilder</code>能否正常创建实例</li><li>测试两种日志器能否正常工作</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;logger.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string path = <span class="string">&quot;./test/rollsink&quot;</span>;</span><br><span class="line">    suplog::LoggerManager&amp; lm = suplog::LoggerManager::<span class="built_in">getInstance</span>();</span><br><span class="line"></span><br><span class="line">    suplog::GlobalLoggerBuilder glb;</span><br><span class="line">    glb.<span class="built_in">buildLoggerName</span>(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">    glb.<span class="built_in">buildSink</span>&lt;suplog::RollSink&gt;(<span class="string">&quot;./test/rollsink&quot;</span>,<span class="number">10</span>);</span><br><span class="line">    glb.<span class="built_in">buildLoggerType</span>(suplog::Logger::Type::LOGGER_ASYNC);</span><br><span class="line"></span><br><span class="line">    suplog::Logger::ptr alogger= glb.<span class="built_in">build</span>();</span><br><span class="line">    suplog::Logger::ptr slogger = lm.<span class="built_in">rootLogger</span>();</span><br><span class="line"></span><br><span class="line">    alogger-&gt;<span class="built_in">warn</span>(<span class="string">&quot;main.cpp&quot;</span>,<span class="number">19</span>,<span class="string">&quot;这是一条警告测试信息，测试码:%d&quot;</span>,<span class="number">0</span>);</span><br><span class="line">    alogger-&gt;<span class="built_in">warn</span>(<span class="string">&quot;main.cpp&quot;</span>,<span class="number">20</span>,<span class="string">&quot;这是一条警告测试信息，测试码:%d&quot;</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    slogger-&gt;<span class="built_in">debug</span>(<span class="string">&quot;main.cpp&quot;</span>,<span class="number">22</span>,<span class="string">&quot;这是一条标准输出测试信息&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下</p><p><em>标准输出</em></p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202410042158759.png"></p><p><em>滚动文件输出</em></p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202410042201373.png"></p><p>可以看到，正常工作</p><h2 id="日志宏-全局接口设计-代理模式"><a href="#日志宏-全局接口设计-代理模式" class="headerlink" title="日志宏&amp;全局接口设计(代理模式)"></a>日志宏&amp;全局接口设计(代理模式)</h2><p>目前<code>logger.h</code>暴露给用户的接口还是太多了，所以新增一个代理来简化和保护.提供全局的日志器获取接口</p><p>实现代理模式时，通过<code>全局函数</code>或<code>宏函数</code>来代理<code>Logger</code>类的<code>log</code>,<code>debug</code>,<code>info</code>,<code>warn</code>,<code>error</code>,<code>fatal</code>等接口,以便于控制源码文件名称和行号的输出控制，简化用户操作</p><p>设计上，<strong>标准输出日志的功能由主日志器承担</strong>。当仅需要标准输出日志的时候可以通过当日志器来打印日志。且操作时只需要通过宏函数直接进行输出即可</p><blockquote><p>suplog.hpp</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;logger.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> suplog</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Logger::ptr <span class="title">getLogger</span><span class="params">(<span class="type">const</span> std::string&amp; name)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LoggerManager::<span class="built_in">getInstance</span>().<span class="built_in">getLogger</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Logger::ptr <span class="title">rootLogger</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LoggerManager::<span class="built_in">getInstance</span>().<span class="built_in">rootLogger</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> WOW 6666</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//开始定义宏函数</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> debug(fmt,...)  debug(__FILE__,__LINE__,fmt,##__VA_ARGS__)<span class="comment">//利用宏，自动传入文件路径和行号</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> info(fmt,...)  info(__FILE__,__LINE__,fmt,##__VA_ARGS__)</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> warn(fmt,...)  warn(__FILE__,__LINE__,fmt,##__VA_ARGS__)</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> <span class="keyword">error</span>(fmt,...)  <span class="keyword">error</span>(__FILE__,__LINE__,fmt,##__VA_ARGS__)</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> fatal(fmt,...)  fatal(__FILE__,__LINE__,fmt,##__VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//封装真正能用的宏函数</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> LOG_DEBUG(logger,fmt,...) (logger)-&gt;debug(fmt,##__VA_ARGS__)<span class="comment">//这里就用了上面的宏函数</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> LOG_INFO(logger,fmt,...) (logger)-&gt;info(fmt,##__VA_ARGS__)</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> LOG_WARN(logger,fmt,...) (logger)-&gt;warn(fmt,##__VA_ARGS__)</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> LOG_ERROR(logger,fmt,...) (logger)-&gt;<span class="keyword">error</span>(fmt,##__VA_ARGS__)</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> LOG_FATAL(logger,fmt,...) (logger)-&gt;fatal(fmt,##__VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//封装主函数的调用</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> LOGD(fmt,...) LOG_DEBUG(suplog::rootLogger(),fmt,##__VA_ARGS__)</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> LOGI(fmt,...) LOG_INFO(suplog::rootLogger(),fmt,##__VA_ARGS__)</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> LOGW(fmt,...) LOG_WARN(suplog::rootLogger(),fmt,##__VA_ARGS__)</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> LOGE(fmt,...) LOG_ERROR(suplog::rootLogger(),fmt,##__VA_ARGS__)</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> LOGF(fmt,...) LOG_FATAL(suplog::rootLogger(),fmt,##__VA_ARGS__)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="项目测试"><a href="#项目测试" class="headerlink" title="项目测试"></a>项目测试</h1><p>至此项目代码的基本功能已经完成，剩下的便是对其进行一系列测试了</p><p><a href="https://github.com/sis-shen/Asynchrinous-Logging-System/releases/tag/%E6%AD%A3%E5%BC%8F%E7%89%88">戳我去代码发布页🔗</a></p><h2 id="功能测试"><a href="#功能测试" class="headerlink" title="功能测试"></a>功能测试</h2><p>测试⼀个⽇志器中包含有所有的落地⽅向，观察是否每个⽅向都正常落地，分别测试<code>同步⽅式</code>和<code>异步⽅式</code>落地后数据是否正常。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;suplog.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//功能测试</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loggerTest</span><span class="params">(<span class="type">const</span> std::string&amp; logger_name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    suplog::Logger::ptr lp = suplog::<span class="built_in">getLogger</span>(logger_name);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert</span>(lp.<span class="built_in">get</span>());<span class="comment">//防止拿到空指针</span></span><br><span class="line">    <span class="built_in">LOGD</span>(<span class="string">&quot;------------example---------------&quot;</span>);</span><br><span class="line">    <span class="comment">//测试原生日志器</span></span><br><span class="line">    lp-&gt;<span class="built_in">debug</span>(<span class="string">&quot;%s&quot;</span>, <span class="string">&quot;logger-&gt;debug&quot;</span>);</span><br><span class="line">    lp-&gt;<span class="built_in">info</span>(<span class="string">&quot;%s&quot;</span>, <span class="string">&quot;logger-&gt;info&quot;</span>);</span><br><span class="line">    lp-&gt;<span class="built_in">warn</span>(<span class="string">&quot;%s&quot;</span>, <span class="string">&quot;logger-&gt;warn&quot;</span>);</span><br><span class="line">    lp-&gt;<span class="built_in">error</span>(<span class="string">&quot;%s&quot;</span>, <span class="string">&quot;logger-&gt;error&quot;</span>);</span><br><span class="line">    lp-&gt;<span class="built_in">fatal</span>(<span class="string">&quot;%s&quot;</span>, <span class="string">&quot;logger-&gt;fatal&quot;</span>);</span><br><span class="line">    <span class="comment">//测试代理模式</span></span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(lp, <span class="string">&quot;%s&quot;</span>, <span class="string">&quot;LOG_DEBUG&quot;</span>);</span><br><span class="line">    <span class="built_in">LOG_INFO</span>(lp, <span class="string">&quot;%s&quot;</span>, <span class="string">&quot;LOG_INFO&quot;</span>);</span><br><span class="line">    <span class="built_in">LOG_WARN</span>(lp, <span class="string">&quot;%s&quot;</span>, <span class="string">&quot;LOG_WARN&quot;</span>);</span><br><span class="line">    <span class="built_in">LOG_ERROR</span>(lp, <span class="string">&quot;%s&quot;</span>, <span class="string">&quot;LOG_ERROR&quot;</span>);</span><br><span class="line">    <span class="built_in">LOG_FATAL</span>(lp, <span class="string">&quot;%s&quot;</span>, <span class="string">&quot;LOG_FATAL&quot;</span>);</span><br><span class="line">    <span class="built_in">LOGD</span>(<span class="string">&quot;-----------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">    std::string log_msg = <span class="string">&quot;hello supdriver test log msg -&quot;</span>;</span><br><span class="line">    <span class="type">size_t</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(count &lt; <span class="number">1000000</span>)<span class="comment">//输出一百万条日志</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::string msg = log_msg + std::<span class="built_in">to_string</span>(count++);</span><br><span class="line">        lp-&gt;<span class="built_in">error</span>(<span class="string">&quot;%s&quot;</span>,msg.<span class="built_in">c_str</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    suplog::<span class="function">GlobalLoggerBuilder::ptr <span class="title">glb</span><span class="params">(<span class="keyword">new</span> suplog::GlobalLoggerBuilder())</span></span>;</span><br><span class="line">    glb-&gt;<span class="built_in">buildLoggerName</span>(<span class="string">&quot;sync-logger&quot;</span>);<span class="comment">//设置日志器名称</span></span><br><span class="line">    <span class="comment">// glb-&gt;buidFormatter(&quot;[%d][%c][%f:%l][%p] %m%n&quot;);//设置日志输出格式</span></span><br><span class="line">    glb-&gt;<span class="built_in">buildLoggerLevel</span>(suplog::LogLevel::Level::DEBUG);</span><br><span class="line">    glb-&gt;<span class="built_in">buildSink</span>&lt;suplog::StdoutSink&gt;();<span class="comment">//创建标准输出落地方向</span></span><br><span class="line">    glb-&gt;<span class="built_in">buildSink</span>&lt;suplog::FileSink&gt;(<span class="string">&quot;./testdir/logs/sync.log&quot;</span>);<span class="comment">//创建文件落地方向</span></span><br><span class="line">    glb-&gt;<span class="built_in">buildSink</span>&lt;suplog::RollSink&gt;(<span class="string">&quot;./testdir/roll_logs/roll-&quot;</span>,<span class="number">10</span>*<span class="number">1024</span>*<span class="number">1024</span>);</span><br><span class="line">    glb-&gt;<span class="built_in">buildLoggerType</span>(suplog::Logger::Type::LOGGER_SYNC);</span><br><span class="line"></span><br><span class="line">    glb-&gt;<span class="built_in">build</span>();<span class="comment">//建造同步日志器</span></span><br><span class="line"></span><br><span class="line">    glb-&gt;<span class="built_in">buildLoggerName</span>(<span class="string">&quot;async-logger&quot;</span>);</span><br><span class="line">    glb-&gt;<span class="built_in">buildSink</span>&lt;suplog::FileSink&gt;(<span class="string">&quot;./testdir/logs/async.log&quot;</span>);<span class="comment">//创建文件落地方向</span></span><br><span class="line">    glb-&gt;<span class="built_in">buildSink</span>&lt;suplog::RollSink&gt;(<span class="string">&quot;./testdir/async-roll/roll-&quot;</span>,<span class="number">10</span>*<span class="number">1024</span>*<span class="number">1024</span>);</span><br><span class="line">    glb-&gt;<span class="built_in">buildLoggerType</span>(suplog::Logger::Type::LOGGER_ASYNC);</span><br><span class="line"></span><br><span class="line">    glb-&gt;<span class="built_in">build</span>();<span class="comment">//建造异步日志器</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">loggerTest</span>(<span class="string">&quot;sync-logger&quot;</span>);</span><br><span class="line">    <span class="built_in">loggerTest</span>(<span class="string">&quot;async-logger&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果：功能运行正常，但是由于<code>100万</code>条日志实在太多，就不把测试结果放出来了</p><h2 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h2><p>下⾯对⽇志系统做⼀个性能测试，测试⼀下平均每秒能打印多少条⽇志消息到⽂件。</p><p>主要的测试⽅法是：每秒能打印⽇志数 &#x3D; 打印⽇志条数 &#x2F; 总的打印⽇志消耗时间</p><p>主要测试要素：同步&#x2F;异步 &amp; 单线程&#x2F;多线程</p><ul><li>100w+条指定⻓度的⽇志输出所耗时间</li><li>每秒可以输出多少条⽇志</li><li>每秒可以输出多少MB⽇志</li></ul><p>测试环境</p><ul><li><code>CPU</code>:Intel(R) Xeon(R) Platinum 2.5GHZ*2</li><li><code>RAM</code>:2G</li><li><code>OS</code>:Ubuntu 22.04 64位</li></ul><blockquote><p>bench.hpp</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;suplog.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span><span class="comment">//处理时间</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> suplog</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bench</span><span class="params">(<span class="type">const</span> std::string&amp; logger_name,<span class="type">size_t</span> thread_num,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">size_t</span> msglen,<span class="type">size_t</span> msg_count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Logger::ptr lp = <span class="built_in">getLogger</span>(logger_name);</span><br><span class="line">    <span class="keyword">if</span>(lp.<span class="built_in">get</span>() ==<span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="function">std::string <span class="title">msg</span><span class="params">(msglen,<span class="string">&#x27;1&#x27;</span>)</span></span>;<span class="comment">//用字符1补全长度</span></span><br><span class="line">    <span class="type">size_t</span> msg_count_per_thread = msg_count/thread_num;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">double</span>&gt; <span class="title">cost_time</span><span class="params">(thread_num)</span></span>;</span><br><span class="line">    std::vector&lt;std::thread&gt;threads;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;输入线程数量&quot;</span>&lt;&lt;thread_num&lt;&lt;std::endl;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;输出日志数量&quot;</span>&lt;&lt;msg_count &lt;&lt;std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;输出⽇志⼤⼩: &quot;</span> &lt;&lt; msglen * msg_count / <span class="number">1024</span> &lt;&lt; <span class="string">&quot;KB&quot;</span> &lt;&lt;std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;thread_num;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//empalce_back直接构造对象，即新增新的任务线程</span></span><br><span class="line">        threads.<span class="built_in">emplace_back</span>([&amp;,i]()&#123;</span><br><span class="line">            <span class="keyword">auto</span> start = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">size_t</span> j = <span class="number">0</span>;j&lt;msg_count_per_thread;++j)</span><br><span class="line">            &#123;</span><br><span class="line">                lp-&gt;<span class="built_in">fatal</span>(<span class="string">&quot;%s&quot;</span>,msg.<span class="built_in">c_str</span>());<span class="comment">//输出日志</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">auto</span> end = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">            <span class="comment">//计算时间差</span></span><br><span class="line">            <span class="keyword">auto</span> cost = std::chrono::duration_cast&lt;std::chrono::duration&lt;<span class="type">double</span>&gt;&gt;(end-start);</span><br><span class="line">            cost_time[i] = cost.<span class="built_in">count</span>();</span><br><span class="line">            <span class="keyword">auto</span> avg = msg_count_per_thread/cost_time[i];<span class="comment">//每个线程中每秒打印多少日志</span></span><br><span class="line">            std::cout&lt;&lt;<span class="string">&quot;线程&quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;耗时：&quot;</span>&lt;&lt;cost_time[i]&lt;&lt;<span class="string">&quot;s &quot;</span>;</span><br><span class="line">            std::cout&lt;&lt;<span class="string">&quot;平均：： &quot;</span>&lt;&lt;(<span class="type">size_t</span>)avg&lt;&lt;<span class="string">&quot;/s\n&quot;</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; thr:threads)</span><br><span class="line">    &#123;</span><br><span class="line">        thr.<span class="built_in">join</span>();<span class="comment">//回收子线程</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> max_cost = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> cost:cost_time) max_cost = max_cost &lt;cost?cost:max_cost;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;总消耗时间： &quot;</span>&lt;&lt;max_cost&lt;&lt;std::endl;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;平均每秒输出: &quot;</span>&lt;&lt;(<span class="type">size_t</span>)(msg_count/max_cost)&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>main.cpp</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;suplog.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bench.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//性能测试</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sync_bench_thread_log</span><span class="params">(<span class="type">size_t</span> thread_count,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">size_t</span> msg_count,<span class="type">size_t</span> msg_len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> num = <span class="number">1</span>;<span class="comment">//记录函数被调用的次数</span></span><br><span class="line">    std::string logger_name = <span class="string">&quot;sync_bench_logger&quot;</span> + std::<span class="built_in">to_string</span>(num++);</span><br><span class="line">    <span class="built_in">LOGI</span>(<span class="string">&quot;*****************************************************&quot;</span>);</span><br><span class="line">    <span class="built_in">LOGI</span>(<span class="string">&quot;同步日志测试：%u threads,%u messages&quot;</span>,thread_count,msg_count);</span><br><span class="line"></span><br><span class="line">    suplog::<span class="function">GlobalLoggerBuilder::ptr <span class="title">glb</span><span class="params">(<span class="keyword">new</span> suplog::GlobalLoggerBuilder)</span></span>;</span><br><span class="line">    glb-&gt;<span class="built_in">buildLoggerName</span>(logger_name);</span><br><span class="line">    glb-&gt;<span class="built_in">buidFormatter</span>(<span class="string">&quot;%m%n&quot;</span>);</span><br><span class="line">    std::string path = std::<span class="built_in">string</span>(<span class="string">&quot;./testdir/sync&quot;</span>)+std::<span class="built_in">to_string</span>(num)+std::<span class="built_in">string</span>(<span class="string">&quot;.log&quot;</span>);</span><br><span class="line">    glb-&gt;<span class="built_in">buildSink</span>&lt;suplog::FileSink&gt;(path);</span><br><span class="line">    glb-&gt;<span class="built_in">buildLoggerType</span>(suplog::Logger::Type::LOGGER_SYNC);</span><br><span class="line">    glb-&gt;<span class="built_in">build</span>();</span><br><span class="line">    </span><br><span class="line">    suplog::<span class="built_in">bench</span>(logger_name,thread_count,msg_len,msg_count);</span><br><span class="line">    <span class="built_in">LOGI</span>(<span class="string">&quot;*****************************************************&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">async_bench_thread_log</span><span class="params">(<span class="type">size_t</span> thread_count,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">size_t</span> msg_count,<span class="type">size_t</span> msg_len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> num = <span class="number">1</span>;</span><br><span class="line">    std::string logger_name = <span class="string">&quot;async_bench_logger&quot;</span>+std::<span class="built_in">to_string</span>(num++);</span><br><span class="line">    <span class="built_in">LOGI</span>(<span class="string">&quot;*****************************************************&quot;</span>);</span><br><span class="line">    <span class="built_in">LOGI</span>(<span class="string">&quot;异步日志测试：%u threads,%u messages&quot;</span>,thread_count,msg_count);</span><br><span class="line"></span><br><span class="line">    suplog::<span class="function">GlobalLoggerBuilder::ptr <span class="title">glb</span><span class="params">(<span class="keyword">new</span> suplog::GlobalLoggerBuilder)</span></span>;</span><br><span class="line">    glb-&gt;<span class="built_in">buildLoggerName</span>(logger_name);</span><br><span class="line">    glb-&gt;<span class="built_in">buidFormatter</span>(<span class="string">&quot;%m%n&quot;</span>);</span><br><span class="line">    std::string path = std::<span class="built_in">string</span>(<span class="string">&quot;./testdir/async&quot;</span>)+std::<span class="built_in">to_string</span>(num)+std::<span class="built_in">string</span>(<span class="string">&quot;.log&quot;</span>);</span><br><span class="line">    glb-&gt;<span class="built_in">buildSink</span>&lt;suplog::FileSink&gt;(path);</span><br><span class="line">    glb-&gt;<span class="built_in">buildLoggerType</span>(suplog::Logger::Type::LOGGER_ASYNC);</span><br><span class="line">    glb-&gt;<span class="built_in">build</span>();</span><br><span class="line">    </span><br><span class="line">    suplog::<span class="built_in">bench</span>(logger_name,thread_count,msg_len,msg_count);</span><br><span class="line">    <span class="built_in">LOGI</span>(<span class="string">&quot;*****************************************************&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bench_test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//同步写日志</span></span><br><span class="line">    <span class="built_in">sync_bench_thread_log</span>(<span class="number">1</span>,<span class="number">1000000</span>,<span class="number">100</span>);</span><br><span class="line">    <span class="built_in">sync_bench_thread_log</span>(<span class="number">5</span>,<span class="number">1000000</span>,<span class="number">100</span>);</span><br><span class="line">    <span class="comment">//异步日志输出，为了避免因为等待落地影响时间，所以日志数量降低为小于双缓冲区大小进行测试</span></span><br><span class="line">    <span class="built_in">async_bench_thread_log</span>(<span class="number">1</span>,<span class="number">100000</span>,<span class="number">100</span>);</span><br><span class="line">    <span class="built_in">async_bench_thread_log</span>(<span class="number">5</span>,<span class="number">100000</span>,<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">bench_test</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">当前日志器： root 未检测到⽇志格式,默认设置为:  %d&#123;%H:%M:%S&#125;%T%t%T[%p]%T[%c]%T%f:%l%T%m%n</span><br><span class="line">当前日志器: root问检测到落地方向，默认为标准输出!</span><br><span class="line">DEBUG同步日志器创建成功...</span><br><span class="line">[10:51:28][140705783203648][INFO][root][main.cpp:13] *****************************************************</span><br><span class="line">[10:51:28][140705783203648][INFO][root][main.cpp:14] 同步日志测试：1 threads,1000000 messages</span><br><span class="line">DEBUG同步日志器创建成功...</span><br><span class="line">输入线程数量1</span><br><span class="line">输出日志数量1000000</span><br><span class="line">输出⽇志⼤⼩: 97656KB</span><br><span class="line">线程0耗时：1.23733s 平均：： 808188/s</span><br><span class="line">总消耗时间： 1.23733</span><br><span class="line">平均每秒输出: 808188</span><br><span class="line">[10:51:30][140705783203648][INFO][root][main.cpp:25] *****************************************************</span><br><span class="line">[10:51:30][140705783203648][INFO][root][main.cpp:13] *****************************************************</span><br><span class="line">[10:51:30][140705783203648][INFO][root][main.cpp:14] 同步日志测试：5 threads,1000000 messages</span><br><span class="line">DEBUG同步日志器创建成功...</span><br><span class="line">输入线程数量5</span><br><span class="line">输出日志数量1000000</span><br><span class="line">输出⽇志⼤⼩: 97656KB</span><br><span class="line">线程2耗时：1.01608s 平均：： 196834/s</span><br><span class="line">线程0耗时：1.04435s 平均：： 191506/s</span><br><span class="line">线程1耗时：1.06357s 平均：： 188045/s</span><br><span class="line">线程4耗时：1.09672s 平均：： 182361/s</span><br><span class="line">线程3耗时：1.11074s 平均：： 180060/s</span><br><span class="line">总消耗时间： 1.11074</span><br><span class="line">平均每秒输出: 900303</span><br><span class="line">[10:51:31][140705783203648][INFO][root][main.cpp:25] *****************************************************</span><br><span class="line">[10:51:31][140705783203648][INFO][root][main.cpp:34] *****************************************************</span><br><span class="line">[10:51:31][140705783203648][INFO][root][main.cpp:35] 异步日志测试：1 threads,100000 messages</span><br><span class="line">DEBUG异步日志器创建成功...</span><br><span class="line">输入线程数量1</span><br><span class="line">输出日志数量100000</span><br><span class="line">输出⽇志⼤⼩: 9765KB</span><br><span class="line">线程0耗时：0.322045s 平均：： 310515/s</span><br><span class="line">总消耗时间： 0.322045</span><br><span class="line">平均每秒输出: 310515</span><br><span class="line">[10:51:31][140705783203648][INFO][root][main.cpp:46] *****************************************************</span><br><span class="line">[10:51:31][140705783203648][INFO][root][main.cpp:34] *****************************************************</span><br><span class="line">[10:51:31][140705783203648][INFO][root][main.cpp:35] 异步日志测试：5 threads,100000 messages</span><br><span class="line">DEBUG异步日志器创建成功...</span><br><span class="line">输入线程数量5</span><br><span class="line">输出日志数量100000</span><br><span class="line">输出⽇志⼤⼩: 9765KB</span><br><span class="line">线程3耗时：0.0818183s 平均：： 244444/s</span><br><span class="line">线程0耗时：0.102184s 平均：： 195725/s</span><br><span class="line">线程1耗时：0.101945s 平均：： 196183/s</span><br><span class="line">线程4耗时：0.104484s 平均：： 191417/s</span><br><span class="line">线程2耗时：0.116347s 平均：： 171899/s</span><br><span class="line">总消耗时间： 0.116347</span><br><span class="line">平均每秒输出: 859496</span><br><span class="line">[10:51:31][140705783203648][INFO][root][main.cpp:46] *****************************************************</span><br></pre></td></tr></table></figure><p>从上面的测试可以看出:</p><p>在<strong>单线程情况下</strong>: 异步效率看起来还没有同步高，实际上是由于,对于<strong>同步操作</strong>,现在的IO操作在⽤⼾态都会有<strong>缓冲区</strong>进⾏缓冲区，<br>因此我们当前测试⽤例看起来的同步其实 <strong>⼤多时候也是在操作内存</strong>，只有在缓冲区满了才会涉及到阻塞写磁盘操作，即磁盘的<code>IO</code>操作占比很少。<br>而对于<strong>异步操作</strong>,⼀个很重要的原因就是单线程同步操作中不存在锁冲突，⽽单线程异<strong>步⽇志操作存在⼤量的锁冲突</strong>，因此性能也会有⼀定的降低。</p><p>但是，我们也要看到限制同步⽇志效率的最⼤原因是磁盘性能，打⽇志的线程多少并⽆明显区别，线程多了反⽽会降低，因为增加了磁盘的读写争抢</p><p>⽽对于异步⽇志的限制，并⾮磁盘的性能，⽽是cpu的处理性能，打⽇志并不会因为落地⽽阻塞，因此在多线程打⽇志的情况下性能有了显著的提⾼。</p><p>总结:</p><ul><li><code>同步日志器</code>适合<code>大内存</code> <code>单线程</code> <code>小规模</code>日志操作</li><li><code>异步日志器</code>适合<code>强CPU</code> <code>多线程</code> <code>大规模</code>日志操作</li></ul><h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><p>到这里，整个项目已经基本完善，但关于日志系统还有很多可以扩展的地方，甚至把日志系统扩展为有日志服务器的<code>CS</code>服务模式</p><p>如下更新将会在以后的博客中实现,敬请期待~</p><ul><li>实现<code>日志服务器</code>和<code>客户端</code>,服务端负责存储日志，并提供检索，分析，展示等功能</li><li>丰富Sink类<ul><li>支持按小时按天滚动文件</li><li>支持将log通过<strong>网络传输</strong>落地到日志服务器(tcp&#x2F;udp)</li><li>支持在控制台通过日志等级渲染<strong>不同颜色</strong>输出方便定位</li><li>支持落地日志到<strong>数据库</strong> </li><li>支持配置服务器地址，将日志落地到远程服务器</li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Cpp售货机类模拟实现</title>
      <link href="/2024/09/24/VendingMachine/"/>
      <url>/2024/09/24/VendingMachine/</url>
      
        <content type="html"><![CDATA[<p>这是一篇复习类的博客,主要综合运用以下知识：</p><ul><li>格式化输入输出及打印菜单</li><li>类的封装</li><li>类的组合</li><li>子函数概念</li><li>共享指针</li><li>lambda表达式</li></ul><h1 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h1><p>为了简便，就把类的声明和实现写在同一个<code>VendingMachine.h</code>文件里了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; <span class="comment">//展开std命名空间</span></span><br></pre></td></tr></table></figure><p>这里一次性给出所用的头文件，后文便不再添加了</p><h1 id="封装商品类"><a href="#封装商品类" class="headerlink" title="封装商品类"></a>封装商品类</h1><p>售货机当然要管理商品啦，那怎么管理呢？依然是<strong>先描述，再组织</strong></p><p>怎么描述？把它封装成商品类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Item</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Item</span>(<span class="type">const</span> string&amp; name,<span class="type">double</span> price,<span class="type">int</span> cnt)</span><br><span class="line">:_name(name),_price(price),_cnt(cnt)</span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">string _name;</span><br><span class="line"><span class="type">double</span> _price;</span><br><span class="line"><span class="type">int</span> _cnt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>怎么组织？用<code>vecotr</code>储存，用<code>unordered_map</code>建立以<code>name</code>为键，<code>下标</code>为值的索引，统一管理所有商品</p><h1 id="封装VendingMachine类"><a href="#封装VendingMachine类" class="headerlink" title="封装VendingMachine类"></a>封装VendingMachine类</h1><h2 id="基本框架"><a href="#基本框架" class="headerlink" title="基本框架"></a>基本框架</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VendingMachine</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">VendingMachine</span>(<span class="type">int</span> capacity = <span class="number">100</span>) :_amount(<span class="number">0</span>), _sale(<span class="number">0</span>),_capacity(capacity) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">vector&lt;Item&gt; _GoodsList; <span class="comment">//储存商品列表</span></span><br><span class="line">unordered_map&lt;string, <span class="type">int</span>&gt; _index; <span class="comment">//储存名字指向索引的哈希表</span></span><br><span class="line"></span><br><span class="line"><span class="type">double</span> _amount;<span class="comment">//货物总价值</span></span><br><span class="line"><span class="type">double</span> _sale;<span class="comment">//总销售额</span></span><br><span class="line"><span class="type">int</span> _capacity;<span class="comment">//容量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="实现增加货物和销售货物"><a href="#实现增加货物和销售货物" class="headerlink" title="实现增加货物和销售货物"></a>实现增加货物和销售货物</h2><p>这里就要使用子函数的概念了。将实际增加货物的功能和IO功能进行解耦合，封装在两个函数中。<code>_AddItem</code>负责实现增加货物，<code>AddItem</code>负责<code>IO处理</code>和回调<code>_AddItem</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">AddItem</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">Info</span>();</span><br><span class="line">string name;</span><br><span class="line"><span class="type">double</span> price;</span><br><span class="line"><span class="type">int</span> num;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;请先后输入 [商品名称] [单价] [数量]&quot;</span> &lt;&lt; endl;</span><br><span class="line">cin &gt;&gt; name &gt;&gt; price &gt;&gt; num;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> _AddItem(name, price, num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">bool</span> _AddItem(<span class="type">const</span> string&amp; name, <span class="type">double</span> price,<span class="type">int</span> num)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (_index.<span class="built_in">count</span>(name))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//更新商品数量</span></span><br><span class="line">Item&amp; item = _GoodsList[_index[name]];</span><br><span class="line"><span class="keyword">if</span> (item._price != price)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;商品添加失败，价格与记录不符: &quot;</span> &lt;&lt; price &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">item._cnt += num;</span><br><span class="line">_amount += price * num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (price &lt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;非法单价: &quot;</span> &lt;&lt; price &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (num &lt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;非法数量: &quot;</span> &lt;&lt; num &lt;&lt;  endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (_capacity &lt; num)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;容量不足， 容量: %d ，添加的数量: %d\n&quot;</span>, _capacity, num);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> sz = _GoodsList.<span class="built_in">size</span>();</span><br><span class="line">_index[name] = sz;</span><br><span class="line">_GoodsList.<span class="built_in">push_back</span>(<span class="built_in">Item</span>(name, price, num));</span><br><span class="line">_amount += price * num;</span><br><span class="line">_capacity -= num;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;商品添加成功，商品名: %s,单价: %.2lf,本次添加的数量: %d\n&quot;</span>, name.<span class="built_in">c_str</span>(), price, num);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>销售货物也是同理</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SellItem</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">string name;</span><br><span class="line"><span class="type">int</span> num;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;请输入 [商品名] [数量]&quot;</span> &lt;&lt; endl;</span><br><span class="line">cin &gt;&gt; name &gt;&gt; num;</span><br><span class="line"><span class="keyword">return</span> _SellItem(name, num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">bool</span> _SellItem(<span class="type">const</span> string&amp; name,<span class="type">int</span> num)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (num &lt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;非法的售卖数量: &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!_index.<span class="built_in">count</span>(name))</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;不存在的商品: &quot;</span> &lt;&lt; name &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Item&amp; item = _GoodsList[_index[name]];</span><br><span class="line"><span class="keyword">if</span> (item._cnt &lt; num)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;交易失败，剩余库存不足！剩余: &quot;</span> &lt;&lt; item._cnt &lt;&lt; <span class="string">&quot; 预期售卖: &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">item._cnt -= num;</span><br><span class="line"><span class="type">double</span> sum = num * item._price;</span><br><span class="line">_amount -= sum;</span><br><span class="line">_capacity += num;</span><br><span class="line">_sale += sum;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;交易成功！商品名: %s,单价: %.2lf,交易数量: %d,本次交易额: %.2lf\n&quot;</span>, name.<span class="built_in">c_str</span>(), item._price, num, sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现多种查询功能"><a href="#实现多种查询功能" class="headerlink" title="实现多种查询功能"></a>实现多种查询功能</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InfoItem</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">string name;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;请输入待查询的商品名称&quot;</span> &lt;&lt; endl;</span><br><span class="line">_InfoItem(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">void</span> _InfoItem(<span class="type">const</span> string&amp; name)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!_index.<span class="built_in">count</span>(name))</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;商品不存在&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">Item&amp; item = _GoodsList[_index[name]];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;商品名: %s,单价: %.2lf,剩余量: %d&quot;</span>, name.<span class="built_in">c_str</span>(), item._price, item._cnt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>下面要根据不同需求排序数组，这里我们就要用<code>sort</code>函数配合<code>lambda表达式</code>方便地使用不同的排序规则进行排序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShowItems</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;默认顺序&quot;</span> &lt;&lt; endl;</span><br><span class="line">_ShowItems(_GoodsList);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShowItemsByName</span><span class="params">(<span class="type">bool</span> reverse_arr=<span class="literal">false</span>)</span><span class="comment">//默认升序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (reverse_arr)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;按名字降序&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;按名字升序&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">auto</span> copy = _GoodsList;</span><br><span class="line"><span class="built_in">sort</span>(copy.<span class="built_in">begin</span>(), copy.<span class="built_in">end</span>(), [&amp;](<span class="type">const</span> Item&amp; item1, <span class="type">const</span> Item&amp; item2) &#123;</span><br><span class="line"><span class="keyword">if</span> (item1._name &lt;= item2._name)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">if</span> (reverse_arr)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">reverse</span>(copy.<span class="built_in">begin</span>(), copy.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br><span class="line">_ShowItems(copy);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShowItemsByPrice</span><span class="params">(<span class="type">bool</span> reverse_arr = <span class="literal">false</span>)</span><span class="comment">//默认升序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (reverse_arr)cout &lt;&lt; <span class="string">&quot;按单价降序&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;按价格升序&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">auto</span> copy = _GoodsList;</span><br><span class="line"><span class="built_in">sort</span>(copy.<span class="built_in">begin</span>(), copy.<span class="built_in">end</span>(), [&amp;](<span class="type">const</span> Item&amp; item1, <span class="type">const</span> Item&amp; item2) &#123;</span><br><span class="line"><span class="keyword">if</span> (item1._price &lt;= item2._price)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">if</span> (reverse_arr)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">reverse</span>(copy.<span class="built_in">begin</span>(), copy.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br><span class="line">_ShowItems(copy);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShowItemsByCNT</span><span class="params">(<span class="type">bool</span> reverse_arr = <span class="literal">false</span>)</span><span class="comment">//默认升序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (reverse_arr) cout &lt;&lt; <span class="string">&quot;按剩余量降序&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;按剩余量升序&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">auto</span> copy = _GoodsList;</span><br><span class="line"><span class="built_in">sort</span>(copy.<span class="built_in">begin</span>(), copy.<span class="built_in">end</span>(), [&amp;](<span class="type">const</span> Item&amp; item1, <span class="type">const</span> Item&amp; item2) &#123;</span><br><span class="line"><span class="keyword">if</span> (item1._cnt &lt;= item2._cnt)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">if</span> (reverse_arr)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">reverse</span>(copy.<span class="built_in">begin</span>(), copy.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br><span class="line">_ShowItems(copy);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">void</span> _ShowItems(<span class="type">const</span> vector&lt;Item&gt;&amp; goodslist)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%-10s %-10s %-4s\n&quot;</span>, <span class="string">&quot;商品名&quot;</span>, <span class="string">&quot;单价&quot;</span>, <span class="string">&quot;剩余数量&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> item : goodslist)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%-10s %-10.2lf %-4d\n&quot;</span>, item._name.<span class="built_in">c_str</span>(), item._price, item._cnt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Info</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;商品数量: %u ,机器内商品总价值 %.2lf,总销售额: %.2lf,剩余容量: %d\n&quot;</span>,</span><br><span class="line">_GoodsList.<span class="built_in">size</span>(), _amount, _sale, _capacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现自动初始化"><a href="#实现自动初始化" class="headerlink" title="实现自动初始化"></a>实现自动初始化</h2><p>写一个函数自动初始化参数，方便调试</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AutoInit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (_GoodsList.<span class="built_in">size</span>() != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;不能重复初始化!!!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">_AddItem(<span class="string">&quot;小苹果&quot;</span>, <span class="number">5</span>, <span class="number">10</span>);</span><br><span class="line">_AddItem(<span class="string">&quot;大香蕉&quot;</span>, <span class="number">2.5</span>, <span class="number">2</span>);</span><br><span class="line">_AddItem(<span class="string">&quot;香蕉君&quot;</span>, <span class="number">30</span>, <span class="number">5</span>);</span><br><span class="line">_AddItem(<span class="string">&quot;野兽先辈&quot;</span>, <span class="number">1145.14</span>, <span class="number">15</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现菜单和运行功能"><a href="#实现菜单和运行功能" class="headerlink" title="实现菜单和运行功能"></a>实现菜单和运行功能</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> cmd = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">PrintMenu</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;请输入操作码&quot;</span> &lt;&lt; endl;</span><br><span class="line">cin &gt;&gt; cmd;</span><br><span class="line"><span class="keyword">switch</span> (cmd)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line"><span class="built_in">AutoInit</span>(); <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line"><span class="built_in">AddItem</span>(); <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line"><span class="built_in">ShowItems</span>(); <span class="built_in">SellItem</span>(); <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line"><span class="built_in">Info</span>(); <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line"><span class="built_in">ShowItems</span>(); <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line"><span class="built_in">ShowItemsByName</span>(); <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line"><span class="built_in">ShowItemsByName</span>(<span class="literal">true</span>); <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line"><span class="built_in">ShowItemsByPrice</span>(); <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line"><span class="built_in">ShowItemsByPrice</span>(<span class="literal">true</span>); <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line"><span class="built_in">ShowItemsByCNT</span>(); <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">11</span>:</span><br><span class="line"><span class="built_in">ShowItemsByCNT</span>(<span class="literal">true</span>); <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;未知操作码&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;输入任意按键继续...&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">getchar</span>();</span><br><span class="line"><span class="built_in">getchar</span>();</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">while</span> (cmd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintMenu</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">ClearScreen</span>();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;===========菜单=============\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;0.退出 \n1.自动初始化 \n2.添加商品 \n3.购买商品 \n4.显示售货机信息  \n&quot;</span>);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;5.默认顺序显示商品列表\n&quot;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;6.按名称升序显示商品列表\n&quot;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;7.按名称降序显示商品列表\n&quot;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;8.按单价升序显示商品列表\n&quot;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;9.按单价降序显示商品列表\n&quot;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;10.按剩余量升序显示商品列表\n&quot;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;11.按剩余量降序显示商品列表\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;=============================\n\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ClearScreen</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="编写main函数"><a href="#编写main函数" class="headerlink" title="编写main函数"></a>编写main函数</h1><p>把<code>main</code>函数放在<code>main.cpp</code>里</p><p>其中我们要用到<code>shared_ptr</code>实现共享指针，内部的原理是对同一个指针提供引用计数，当引用计数要归零时才释放资源，达到自动内存管理的目的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;VendingMachine.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">shared_ptr&lt;VendingMachine&gt; <span class="title">pvm</span><span class="params">(<span class="keyword">new</span> VendingMachine())</span></span>;</span><br><span class="line"></span><br><span class="line">pvm-&gt;<span class="built_in">Run</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>啪的一下很快啊，一个模拟售货机就做出来了。项目很简单，拿来复习，写起来还是很心情愉悦的</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>初识计算机网络</title>
      <link href="/2024/09/23/network/"/>
      <url>/2024/09/23/network/</url>
      
        <content type="html"><![CDATA[<blockquote><p>—-这是第一条ARPANET信息，发送于1969年10月29日，从加州大学洛杉矶分校（UCLA）发往斯坦福大学。这条消息本来想说的是“登录”（LOGIN），但是系统崩溃了。</p></blockquote><blockquote><p>因特网初创于20世纪60年代，其初衷在于建造一个网络来<strong>连接分散在不同地理位置的计算机</strong></p></blockquote><blockquote><p>如今的因特网由几百万个松散连接的<strong>独立网络构成</strong>，其中的每个网络都连接到另外一个或多个网络。邻近的计算机通过本地的<code>局域网</code>相互连接，这些局域网通常为<code>无线以太网</code>。网络之间通过<code>网关</code>或<code>路由器</code>相互连接。网关和路由器是专用的计算机，用来把组成信息的数据包从一个网络指引到下一个网络。（维基百科上说网关是通用设备，而路由器是其中的特例，其用途并不通用。）网关之间互相交换着路由信息，这样它们就至少知道哪些网络与本地网络相连并可以被访问到。</p></blockquote><h1 id="计算机网络背景"><a href="#计算机网络背景" class="headerlink" title="计算机网络背景"></a>计算机网络背景</h1><h2 id="网络发展"><a href="#网络发展" class="headerlink" title="网络发展"></a>网络发展</h2><ol><li>独立模式：计算机之间相互独立</li></ol><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202409231505905.png"></p><ol start="2"><li>网络互连：多态计算机连接在一起，完成数据共享</li></ol><p><em>例如网吧的无盘系统，同一个房间的所有电脑连在一起，共享硬盘</em></p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202409231507877.png"></p><ol start="3"><li>局域网<code>LAN</code>: 网络中计算机的数量更多了，通过<code>交换机</code>和<code>路由器</code>连在一起</li></ol><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202409231520992.png"></p><ol start="4"><li>广域网<code>WAN</code>：通过局域网的层层相连，将相隔千里的计算机连在一起</li></ol><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202409231530121.png"></p><p>其中的<code>局域网</code>和<code>广域网</code>只是相对的概念。例如我们有“天朝特色”的广域网，也可以看作是一个局域网</p><h2 id="认识协议"><a href="#认识协议" class="headerlink" title="认识协议"></a>认识协议</h2><p>信息在网络之间游代的时候，被分作称为数据包的小块。一个数据包就是按特定格式组织起来的一串字节。不同设备使用不同的数据包格式。</p><p>那么如何实现网络间数据包的正确发送与接收呢？我们要先实现如下目标</p><ol><li>明确接收方的地址</li><li>明确数据包本身的长度</li><li>统一的字节流编码方式</li><li>校验数据包的正确性(<em>没有在传输中发生错误修改</em>)</li><li>…</li></ol><p>为此，<code>通信协议</code>应运而生</p><p>通信协议（Communication Protocol）是指在电子设备或计算机网络之间进行数据交换时，所遵守的一套规则和约定。这些规约决定了通信过程中各种细节如何处理，包括数据的格式、传输方式、错误检查、数据压缩、如何开始和终止通信等。<strong>在计算机网络中，我们所用的通信协议叫做网络（通信）协议</strong></p><p>实际上，网络协议考虑地更为复杂:</p><ul><li>计算机生产厂商有很多;</li><li>计算机操作系统,也有很多;</li><li>算机网络硬件设备,还是有很多;</li><li>如何让这些不同厂商之间生产的计算机能够相互顺畅的通信？就需要有人站出来,约定一个共同的标准,大家都来遵守,这就是 网络协议;</li></ul><h3 id="协议分层"><a href="#协议分层" class="headerlink" title="协议分层"></a>协议分层</h3><p>从上面对网络协议的思考，显然已经<strong>天然地出现了对协议分层的要求</strong>，我们接下来认识一下什么是协议分层，有什么好处</p><p><strong>打电话的例子</strong>:</p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202409240813667.png"></p><p>在这个例子中, 我们的协议只有两层; 但是实际的网络通信会更加复杂, 需要分更多的层次。</p><p>封层最大的好处就是<code>封装</code>。每一层只考虑两件事</p><ul><li>自己层内的协议如何实现</li><li>如何与相邻层沟通<br>而不用考虑其它层的实现原理</li></ul><h3 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h3><p>OSI（Open System Interconnection，开放系统互连）七层网络模型称为开放式系统互联参考模型，是一个<strong>逻辑上的定义和规范</strong></p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202409240829303.png"></p><p><code>OSI七层模型</code>是一种<strong>框架性的设计方法</strong>，其最主要的功能使就是帮助不同类型的主机实现数据传输。它的最大优点是将服务、接口和协议这三个概念明确地区分开来，概念清楚，理论也比较完整. 通过七个层次化的结构模型使不同的系统不同的网络之间实现可靠的通讯。</p><p>但是, 它既复杂又不实用，所以我们接下来介绍<code>TCP/IP五层模型</code></p><h3 id="TCP-IP五层-或四层-协议"><a href="#TCP-IP五层-或四层-协议" class="headerlink" title="TCP&#x2F;IP五层(或四层)协议"></a>TCP&#x2F;IP五层(或四层)协议</h3><p>TCP&#x2F;IP是<strong>一组协议</strong>的代名词，它还包括许多协议，组成了TCP&#x2F;IP协议簇.TCP&#x2F;IP通讯协议采用了5层的层级结构，每一层都呼叫它的下一层所提供的网络来完成自己的需求.</p><blockquote><p><code>物理层</code>:<strong>负责光&#x2F;电信号的传递方式</strong>.比如现在以太网通用的网线(双绞线)、早期以太网采用的的同轴电缆(现在主要用于有线电视)、光纤,现在的wifi无线网使用电磁波等都属于物理层的概念。物理层的能力决定了最大传输速率、传输距离、抗干扰性等.集线器(Hub)工作在物理层.<br><code>数据链路层</code>:<strong>负责设备之间</strong>的数据帧的传送和识别.例如网卡设备的驱动、帧同步(就是说从网线上检测到什么信号算作新帧的开始)、冲突检测(如果检测到冲突就自动重发)、数据差错校验等工作.有以太网、令牌环网,无线LAN等标准.<strong>交换机(Switch)工作在数据链路层</strong>.<br><code>网络层</code>:<strong>负责地址管理和路由选择</strong>.例如在<strong>IP协议</strong>中,通过IP地址来标识一台主机,并通过路由表的方式规划出两台主机之间的数据传输的线路(路由).<strong>路由器(Router)工作在网路层</strong>.<br><code>传输层</code>:<strong>负责两台主机之间的数据传输</strong>.如传输控制协议 (TCP),能够确保数据可靠的从源主机发送到目标主机.<br><code>应用层</code>:<strong>负责应用程序间沟通</strong>，如简单电子邮件传输（SMTP））、文件传输协议（FTP）、网络远程访问协议（Telnet）等.我们的网络编程主要就是针对应用层.</p></blockquote><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202409240918431.png"></p><h2 id="网络传输基本流程"><a href="#网络传输基本流程" class="headerlink" title="网络传输基本流程"></a>网络传输基本流程</h2><p>同一个网段内的两台主机进行文件传输</p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202409240926465.png"></p><p>两台计算机通过TCP&#x2F;IP协议通讯的过程如下所示</p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202409241021268.png"></p><p>当文件<strong>跨网段</strong>传输时，数据的传输过程中要经过一个或多个路由器，其中包含了令牌环系统，如下图</p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202409241023842.png"></p><h2 id="数据包的封装与分用"><a href="#数据包的封装与分用" class="headerlink" title="数据包的封装与分用"></a>数据包的封装与分用</h2><p><strong>不同的协议层</strong>通信需要用到不同的报头，所以需要用到数据包的层层封装和分用</p><ul><li><code>数据包的称谓</code>:不同的协议层对数据包有不同的称谓,在传输层叫做段(<code>segment</code>),在网络层叫做数据报 (<code>datagram</code>),在链路层叫做帧(<code>frame</code>)。但没关系，它们本质上都是数据包</li><li><code>封装(Encapsulation)</code>:应用层数据通过协议栈发到网络上时,<strong>每层协议</strong>都要加上一个数据首部(<code>header</code>),称为<code>封装</code></li><li><code>首部信息</code>：首部信息中包含了一些类似于首部有多长, 载荷(<code>payload</code>)有多长, <strong>上层协议</strong>是什么等信息</li><li><code>数据包的向上传递</code>：数据封装成帧后发到传输介质上,到达目的主机后<strong>每层协议再剥掉相应的首部</strong>, 根据首部中的 “上层协议字段” 将数据交给对应的上层协议处理.</li></ul><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202410080819908.png"></p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202410080827934.png"></p><h2 id="网络中的地址管理"><a href="#网络中的地址管理" class="headerlink" title="网络中的地址管理"></a>网络中的地址管理</h2><h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><p>在IP协议中，地址就像电话号码一样，每台主句都必须有一个辨识身份的地址，才能根因特网上的替他主机区分开来。<br>这个标识号码叫做<code>IP地址</code>。<code>IP地址</code>的本质是<strong>一串定长的01码</strong>,按长度可分两种:<code>IPV4</code>(32位,4字节),<code>IPV6</code>(128位,16字节),但平时见到的ip地址似乎不长这样，而是类似于<code>140.180.223.42</code>(普林斯顿带血网站)这样的地址。<br>这样的记法叫<code>点分十进制表示法</code>。本质上还是01码，只不过拆开来了而已，这么做的原因单纯是因为比<code>01</code>码或者十六进制码更好记</p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202410080859886.png"></p><p>而IPv6地址通常写作16个用十六进制值表示的字节，字节之间用冒号分割，比如2620:0:1003:100c:9227:e4ff:fee9:05ec。IPv6地址的表现形式相较于点分十进制形式<strong>更不直观</strong>，但本质和功能和<code>IPV4</code>差不多，所以我们着重介绍<code>IPV4</code>相关的IP协议</p><p>显然一个定长的<code>01码</code>总会有用完的一天，那么这个问题又该怎么解决&#x2F;缓解呢？在接下来的博客中我们也将逐一介绍各种方法。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>网络股票信息爬虫与可视化</title>
      <link href="/2024/09/15/OLSIC/"/>
      <url>/2024/09/15/OLSIC/</url>
      
        <content type="html"><![CDATA[<h1 id="背景分析"><a href="#背景分析" class="headerlink" title="背景分析"></a>背景分析</h1><h2 id="背景概述"><a href="#背景概述" class="headerlink" title="背景概述"></a>背景概述</h2><p>在当今快速发展的金融市场中，股票市场的动态变化对投资者和金融分析师至关重要。随着信息技术的进步，特别是互联网和大数据技术的发展，投资者可以实时获得大量的股票市场信息。然而，这些信息通常以原始数据形式存在，需要进一步处理和分析才能提取有价值的洞见。在这种背景下，网络股票信息爬虫与可视化技术应运而生，成为股票市场分析的重要工具。</p><h2 id="网络股票信息爬虫"><a href="#网络股票信息爬虫" class="headerlink" title="网络股票信息爬虫"></a>网络股票信息爬虫</h2><p>网络股票信息爬虫（Web Scraping）是一种自动化的数据收集技术，旨在从互联网上提取股票市场相关的信息。它利用程序化方法访问和抓取各种金融网站和新闻平台上的数据，例如股票价格、交易量、公司财报、新闻动态等。爬虫技术可以高效地从大规模数据源中获取最新的信息，支持实时数据更新和历史数据回溯分析。</p><p><strong>关键技术</strong>:</p><ul><li>爬虫框架：如<code>Scrapy</code>、<code>BeautifulSoup</code>等，用于解析HTML页面和提取数据。<ul><li><em>由于本文的目标网站的股票数据并不在页面中，也就是说不需要做网页分析和提取</em></li></ul></li><li>API接口：一些金融网站提供API接口，允许程序直接获取结构化的数据。<ul><li>(例如本文使用<code>Get</code>方法的https请求，获取了<code>json</code>文件)</li></ul></li><li>数据存储：抓取的数据通常需要存储在数据库中，如<code>MySQL</code>、<code>MongoDB</code>等，以便后续分析和处理。<ul><li>(本文使用作者个人服务器上MYSQL作为存储数据库)</li></ul></li></ul><h2 id="数据可视化"><a href="#数据可视化" class="headerlink" title="数据可视化"></a>数据可视化</h2><p>数据可视化是将复杂的股票市场数据以图形化的方式呈现出来，使得数据更易于理解和分析。通过可视化技术，投资者可以直观地观察股票价格趋势、交易量变化、市场波动等重要信息，从而做出更加明智的投资决策。</p><p><strong>常用可视化方法</strong>:</p><ul><li>时间序列图：示股票价格或交易量随时间变化的趋势。</li><li>蜡烛图（CandlestickChart）:用于股票价格在一定时间内的开盘、收盘、最高和最低价格。<ul><li>又称<code>K图</code>，文本就是使用K图作为可视化方式</li></ul></li><li>热力图（Heatmap）:用颜色强度表示不同股票的表现或市场的热点区域。</li><li>散点图和折线图：用于展示多维数据之间的关系和趋势。</li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>网络股票信息爬虫与可视化技术在金融市场分析中具有广泛的应用。它们不仅可以帮助投资者实时监控市场动态，还能够通过历史数据分析预测未来趋势。此外，这些技术还被用于量化分析、算法交易、风险管理等领域，以提高投资决策的科学性和准确性。  </p><p>网络股票信息爬虫与可视化技术为现代金融市场提供了强大的数据支持和分析工具。通过自动化数据抓取和图形化呈现，投资者可以更高效地获取市场信息和洞察，有助于做出更准确的投资决策。随着技术的不断发展，这些工具将在金融分析中发挥越来越重要的作用。</p><h2 id="业务流程图"><a href="#业务流程图" class="headerlink" title="业务流程图"></a>业务流程图</h2><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/OLSIC_flowchart.png"></p><h1 id="代码实现业务功能"><a href="#代码实现业务功能" class="headerlink" title="代码实现业务功能"></a>代码实现业务功能</h1><h2 id="代码框架"><a href="#代码框架" class="headerlink" title="代码框架"></a>代码框架</h2><ul><li>网络爬虫<ul><li>使用<code>requests</code>模块向网站发送定制的<code>https</code>请求</li><li>使用<code>json</code>处理网站返回的<code>json</code>数据</li><li>爬虫部分的代码封装在<code>SnowBallCrawler.py中</code></li></ul></li><li>数据库持久化<ul><li>在<code>mysql</code>中创建项目所需的数据库和表</li><li>使用<code>pymysql</code>模块连接数据库并执行插入和查询操作</li></ul></li><li>GUI可视化<ul><li>使用<code>dearpygui</code>模块实现GUI可视化并管理组件</li><li>使用<code>dearpygui</code>的统计图绘制功能绘制<code>K图</code></li><li>项目的主要逻辑集成在可视化代码的主要部分</li><li>将自定义的复杂组件封装在类里</li></ul></li></ul><h2 id="网络爬虫"><a href="#网络爬虫" class="headerlink" title="网络爬虫"></a>网络爬虫</h2><p>我们首先来实现网络爬虫部分，这里的目标网站是<a href="https://xueqiu.com/S/SH600519">雪球网站的茅台股票</a></p><h3 id="网页分析"><a href="#网页分析" class="headerlink" title="网页分析"></a>网页分析</h3><p>一般股票网站的数据不会直接放在原始的<code>https</code>请求的响应中，所以要打开<code>F12</code>分析网站的二次请求的内容，方法有两种:</p><p><strong>方法一如图</strong>:</p><ol><li>按下<code>f12</code>打开网页分析器</li><li>点击选项卡中的<code>网络(Network)</code>切换到对应的页面,并选中下方的<code>Fetch/XHR</code>分类卡</li><li>刷新网页，并点击网站中的<code>日K</code>选项，鼠标悬停在某一天的线上</li><li>从悬停提示的数字中选一个比较有唯一性的（比如收盘价）,在搜索中填入选中的数字</li><li>一般这样就能选出唯一的响应了，里面就存着我们所需要的数据（我们这个例子就有280多条数据）</li></ol><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/OLSIC_page1.png"></p><p><strong>方法二</strong></p><p>如果方法一搜索不出来，还可以使用限定抓包时间的方法，减小搜索范围</p><ol><li>按下<code>f12</code>打开网页分析器</li><li>点击选项卡中的<code>网络(Network)</code>切换到对应的页面,并选中下方的<code>Fetch/XHR</code>分类卡</li><li>刷新网页，等待网页完全加载后，再来回切换<code>日K</code>和<code>周K（或其它类似选项卡）</code>,观察时间轴窗口的变化</li><li>最后点击<code>日K</code>选项卡，在时间轴窗口单击发生变化的地方，然后调整观察区间</li><li>搜索筛选出来的响应</li></ol><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202410091905283.gif"></p><hr><p>如图，我们找到了想要的响应，接下来我们分析标头<code>header</code>,接下来点击标头选项卡</p><ul><li>请求<code>URL</code></li></ul><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/OLSIC_header.png"></p><p>如图，目标网站使用了<code>GET</code>方法请求数据，所以我们要着重分析<code>GET</code>方法的<code>参数</code>和<code>无参URL</code>(用于拼接请求URL)，而参数就在<code>URL</code>中</p><p>拆分参数并转换成python字典后如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">param_data = &#123;</span><br><span class="line">            <span class="string">&#x27;symbol&#x27;</span>:<span class="string">&#x27;SH600519&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;begin&#x27;</span>:<span class="number">1726713214191</span>,</span><br><span class="line">            <span class="string">&#x27;period&#x27;</span>:<span class="string">&#x27;day&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;type&#x27;</span>:<span class="string">&#x27;before&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;count&#x27;</span>:<span class="string">&#x27;-284&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;indicator&#x27;</span>:<span class="string">&#x27;kline,pe,pb,ps,pcf,market_capital,agt,ggt,balance&#x27;</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>很明显，<code>begin</code>是时间戳，用于请求最新的数据,但是比较特别的，网站用的是<code>整数的毫秒级时间戳</code>,在python中使用time模块传当前的<code>begin</code>值时得注意</p><p>因为本项目只爬取一支股票的信息，剩下的参数不作解析</p><ul><li>标头(<code>header</code>)</li></ul><p>为了防止被网站的反爬取给拦截下来，标头需要和自己在网站里查到的保持一致</p><p>转成python字典的代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">self.headers = &#123;</span><br><span class="line">            <span class="string">&#x27;Accept&#x27;</span>:<span class="string">&#x27;application/json, text/plain, */*&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Accept-Encoding&#x27;</span>:<span class="string">&#x27;gzip, deflate, br, zstd&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Accept-Language&#x27;</span>:<span class="string">&#x27;zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Cookie&#x27;</span>:<span class="string">&#x27;请使用自己的Cookie,本文作者已隐去&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Origin&#x27;</span>:<span class="string">&#x27;https://xueqiu.com&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Priority&#x27;</span>:<span class="string">&#x27;u=1, i&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Referer&#x27;</span>:<span class="string">&#x27;https://xueqiu.com/S/SH600519&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Sec-Ch-Ua&#x27;</span>:<span class="string">&#x27;&quot;Not/A)Brand&quot;;v=&quot;8&quot;, &quot;Chromium&quot;;v=&quot;126&quot;, &quot;Microsoft Edge&quot;;v=&quot;126&quot;&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;sec-ch-ua-mobile&#x27;</span>:<span class="string">&#x27;?0&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;sec-ch-ua-platform&#x27;</span>:<span class="string">&#x27;&quot;Windows&quot;&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Sec-Fetch-Dest&#x27;</span>:<span class="string">&#x27;empty&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Sec-Fetch-Mode&#x27;</span>:<span class="string">&#x27;cors&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Sec-Fetch-Site&#x27;</span>:<span class="string">&#x27;same-site&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;User-Agent&#x27;</span>:<span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/126.0.0.0 Safari/537.36 Edg/126.0.0.0&#x27;</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="封装类"><a href="#封装类" class="headerlink" title="封装类"></a>封装类</h3><p>因为只爬取一支股票，就不封装通用性强的类了，而是只针对这一支股票，所以封装一个<code>GZMaoTai</code>类,并提供<code>get_response</code>接口，向外界传送每次爬取的数据。其中对返回的joson格式的字符串，使用<code>Josn</code>模块将其反序列化，并储存在Python列表中返回</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GZMaoTai</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line"></span><br><span class="line">        self.url = <span class="string">&#x27;https://stock.xueqiu.com/v5/stock/chart/kline.json&#x27;</span></span><br><span class="line">        self.headers = &#123;</span><br><span class="line">            <span class="string">&#x27;Accept&#x27;</span>:<span class="string">&#x27;application/json, text/plain, */*&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Accept-Encoding&#x27;</span>:<span class="string">&#x27;gzip, deflate, br, zstd&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Accept-Language&#x27;</span>:<span class="string">&#x27;zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Cookie&#x27;</span>:<span class="string">&#x27;请使用自己的Cookie,本文作者已隐去&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Origin&#x27;</span>:<span class="string">&#x27;https://xueqiu.com&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Priority&#x27;</span>:<span class="string">&#x27;u=1, i&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Referer&#x27;</span>:<span class="string">&#x27;https://xueqiu.com/S/SH600519&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Sec-Ch-Ua&#x27;</span>:<span class="string">&#x27;&quot;Not/A)Brand&quot;;v=&quot;8&quot;, &quot;Chromium&quot;;v=&quot;126&quot;, &quot;Microsoft Edge&quot;;v=&quot;126&quot;&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;sec-ch-ua-mobile&#x27;</span>:<span class="string">&#x27;?0&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;sec-ch-ua-platform&#x27;</span>:<span class="string">&#x27;&quot;Windows&quot;&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Sec-Fetch-Dest&#x27;</span>:<span class="string">&#x27;empty&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Sec-Fetch-Mode&#x27;</span>:<span class="string">&#x27;cors&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Sec-Fetch-Site&#x27;</span>:<span class="string">&#x27;same-site&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;User-Agent&#x27;</span>:<span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/126.0.0.0 Safari/537.36 Edg/126.0.0.0&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_response</span>(<span class="params">self,date</span>):</span><br><span class="line">        nowtime = <span class="built_in">int</span>(time.time() * <span class="number">1000.0</span>)</span><br><span class="line">        param_data = &#123;</span><br><span class="line">            <span class="string">&#x27;symbol&#x27;</span>:<span class="string">&#x27;SH600519&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;begin&#x27;</span>:<span class="built_in">str</span>(nowtime),</span><br><span class="line">            <span class="string">&#x27;period&#x27;</span>:<span class="string">&#x27;day&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;type&#x27;</span>:<span class="string">&#x27;before&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;count&#x27;</span>:<span class="string">&#x27;-284&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;indicator&#x27;</span>:<span class="string">&#x27;kline,pe,pb,ps,pcf,market_capital,agt,ggt,balance&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;开始爬取数据&quot;</span>)</span><br><span class="line">        response = requests.get(self.url,headers=self.headers,params=param_data,timeout=<span class="number">5</span>)</span><br><span class="line">        <span class="built_in">print</span>(response.text)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;爬取成功，数据包如上&quot;</span>)</span><br><span class="line"></span><br><span class="line">        data_json = json.loads(response.text)  <span class="comment"># Json反序列化</span></span><br><span class="line">        items = data_json[<span class="string">&#x27;data&#x27;</span>][<span class="string">&#x27;item&#x27;</span>]</span><br><span class="line">        <span class="comment"># for i in range(len(items)):</span></span><br><span class="line">        <span class="comment"># print(items[i])</span></span><br><span class="line">        <span class="comment"># json数据对应</span></span><br><span class="line">        <span class="comment"># [0] timestamp</span></span><br><span class="line">        <span class="comment"># [1] 成交量</span></span><br><span class="line">        <span class="comment"># [2] 开盘价</span></span><br><span class="line">        <span class="comment"># [3] 最高价</span></span><br><span class="line">        <span class="comment"># [4] 最低价</span></span><br><span class="line">        <span class="comment"># [5] 收盘价</span></span><br><span class="line">        <span class="comment"># [6] 涨跌额</span></span><br><span class="line">        <span class="comment"># [7] 涨跌幅</span></span><br><span class="line">        <span class="comment"># [8] 换手率</span></span><br><span class="line">        <span class="comment"># [9] 成交额(亿)</span></span><br><span class="line">        <span class="comment"># [10] null</span></span><br><span class="line">        <span class="comment"># [11] null</span></span><br><span class="line">        <span class="comment"># [12]</span></span><br><span class="line">        <span class="keyword">return</span> items</span><br></pre></td></tr></table></figure><h2 id="数据库持久化"><a href="#数据库持久化" class="headerlink" title="数据库持久化"></a>数据库持久化</h2><h3 id="数据库准备"><a href="#数据库准备" class="headerlink" title="数据库准备"></a>数据库准备</h3><p>这里使用远端的<code>MYSQL</code>管理数据库,作者使用了自己的服务器,具体的配置和安装不作介绍。</p><ol><li>我们创建一个用于存储股票表的数据库<code>stock</code></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create database if not exists stock</span><br></pre></td></tr></table></figure><ol start="2"><li><p>我们针对本次实验，再创建一个<code>MaoTai</code>表。（若要自动建表，则这部分在代码实现）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">create table MaoTai(</span><br><span class="line">    timesamp bigint not null,</span><br><span class="line">    volume int not null,</span><br><span class="line">    open decimal(8,4) not null,</span><br><span class="line">    high decimal(8,4) not null,</span><br><span class="line">    low decimal(8,4) not null,</span><br><span class="line">    close decimal(8,4) not null,</span><br><span class="line">    chg decimal(8,4) not null,</span><br><span class="line">    percent decimal(8,4) not null,</span><br><span class="line">    turnoverrate decimal(8,4) not null,</span><br><span class="line">    amount decimal(12,1) not null</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>特别说明地，这边的<code>timesamp</code>是拼写错误😅,这个表结构不是特别好看，也没有设置主键，~~~亲身实践，时间戳太大了，不能作为主键，否则这个表的增删查改会超时~~~</p></li><li><p>我们创建一个专门管理股票数据库的远程登录账户<code>supdiver</code>,并把用户权限限定在<code>stock.MaoTai</code>表上</p></li></ol><p>Mysql8.0语法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create user supdriver@% identified by &#x27;密码&#x27;；</span><br><span class="line"></span><br><span class="line">grant all privileges on stock.MaoTai to supdriver@%</span><br></pre></td></tr></table></figure><h3 id="代码封装"><a href="#代码封装" class="headerlink" title="代码封装"></a>代码封装</h3><p>对于数据库的操作主要是封装几个接口，所以就直接把有关的函数声明在<code>DBManager.py</code>模块中，而不封装成类了。</p><p>主要操作就是连接到数据库，然后创建<code>cursor</code>指针用于执行<code>mysql</code>语句并获取返回值</p><p><em>注:host为mysql所在服务器的公有ip,本文将作者自己服务器的实际ip改成了本地路由环回的127.0.0.1</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"></span><br><span class="line">stockDB = pymysql.Connect(</span><br><span class="line">    host=<span class="string">&#x27;47.99.48.121&#x27;</span>,</span><br><span class="line">    port=<span class="number">3306</span>,</span><br><span class="line">    user=<span class="string">&#x27;supdriver&#x27;</span>,</span><br><span class="line">    password=<span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    db=<span class="string">&#x27;stock&#x27;</span>,</span><br><span class="line">    charset=<span class="string">&#x27;utf8&#x27;</span>,</span><br><span class="line">    autocommit=<span class="literal">True</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sendData</span>(<span class="params">items</span>):</span><br><span class="line">    stockDB.ping(reconnect=<span class="literal">True</span>)</span><br><span class="line">    cursor = stockDB.cursor()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;开始向数据库插入数据&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> items:</span><br><span class="line">        sql=(<span class="string">f&quot;insert into MaoTai values (<span class="subst">&#123;item[<span class="number">0</span>]&#125;</span>,&quot;</span></span><br><span class="line">             <span class="string">f&quot;<span class="subst">&#123;item[<span class="number">1</span>]&#125;</span>,&quot;</span></span><br><span class="line">             <span class="string">f&quot;<span class="subst">&#123;item[<span class="number">2</span>]&#125;</span>,&quot;</span></span><br><span class="line">             <span class="string">f&quot;<span class="subst">&#123;item[<span class="number">3</span>]&#125;</span>,&quot;</span></span><br><span class="line">             <span class="string">f&quot;<span class="subst">&#123;item[<span class="number">4</span>]&#125;</span>,&quot;</span></span><br><span class="line">             <span class="string">f&quot;<span class="subst">&#123;item[<span class="number">5</span>]&#125;</span>,&quot;</span></span><br><span class="line">             <span class="string">f&quot;<span class="subst">&#123;item[<span class="number">6</span>]&#125;</span>,&quot;</span></span><br><span class="line">             <span class="string">f&quot;<span class="subst">&#123;item[<span class="number">7</span>]&#125;</span>,&quot;</span></span><br><span class="line">             <span class="string">f&quot;<span class="subst">&#123;item[<span class="number">8</span>]&#125;</span>,&quot;</span></span><br><span class="line">             <span class="string">f&quot;<span class="subst">&#123;item[<span class="number">9</span>]&#125;</span>);&quot;</span>)</span><br><span class="line">        <span class="comment"># print(sql)</span></span><br><span class="line">        cursor.execute(sql)</span><br><span class="line">        <span class="comment"># print(cursor.fetchall())</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;插入数据成功，总计<span class="subst">&#123;<span class="built_in">len</span>(items)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getAllData</span>(<span class="params">stockDB</span>):</span><br><span class="line">    stockDB.ping(reconnect=<span class="literal">True</span>)</span><br><span class="line">    cursor = stockDB.cursor()</span><br><span class="line">    sql= <span class="string">&quot;select * from MaoTai&quot;</span></span><br><span class="line">    cursor.execute(sql)</span><br><span class="line">    <span class="keyword">return</span> cursor.fetchall()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getLatestData</span>():</span><br><span class="line">    stockDB.ping(reconnect=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    cursor=stockDB.cursor()</span><br><span class="line">    sql=<span class="string">&quot;select * from MaoTai order by timesamp desc&quot;</span></span><br><span class="line">    cursor.execute(sql)</span><br><span class="line">    alldata = cursor.fetchall()</span><br><span class="line">    resList = []</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> alldata:</span><br><span class="line">        resList.append(line)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> resList</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">closeDB</span>():</span><br><span class="line">    stockDB.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">clearDB</span>():</span><br><span class="line">    stockDB.ping(reconnect=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    cursor = stockDB.cursor()</span><br><span class="line">    sql=<span class="string">&#x27;delete from MaoTai&#x27;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;开始清理数据库&quot;</span>)</span><br><span class="line">    cursor.execute(sql)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;清理完成&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="GUI可视化和K图绘制"><a href="#GUI可视化和K图绘制" class="headerlink" title="GUI可视化和K图绘制"></a>GUI可视化和K图绘制</h2><p>接下来就是整个项目的重头戏，经过前面的封装，数据的获取，储存和预处理已经完成</p><p>我们这里使用的可视化模块叫做<a href="https://dearpygui.readthedocs.io/en/latest/index.html#">dearpygui</a>,<em>后面简称<code>dpg</code></em></p><p>关于可视化组件的上下文，将交由<code>dearpygui</code>自动为维护,这里对<code>dpg</code>不多作介绍，先介绍最重要的一个概念：<code>dpg</code>中所有的组件都有自己的<code>uuid</code>用于维护，因此对组件的管理就是对组件<code>id</code>的管理，其中<code>id</code>既可以是整型也可以是字符串</p><h3 id="页面设计"><a href="#页面设计" class="headerlink" title="页面设计"></a>页面设计</h3><p>做工程要有蓝图，做可视化当然要有页面设计来指导代码实现，否则想到哪做到哪会十分缺乏效率。我们预期的页面设计如下</p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/OLSIC_mainDesign01108329.png"></p><h3 id="封装主窗口类并显示"><a href="#封装主窗口类并显示" class="headerlink" title="封装主窗口类并显示"></a>封装主窗口类并显示</h3><p>所有的dpg的可视化组件需要创建在dpg的上下文中，所以要封装类，就得使用其提供的<code>dpg.stage()</code>来在类里创建临时上下文</p><blockquote><p>DVWrapper.py</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> dearpygui.dearpygui <span class="keyword">as</span> dpg</span><br><span class="line"><span class="keyword">from</span> SnowBallCrawler <span class="keyword">import</span>  *</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Window</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,label,tag</span>):</span><br><span class="line">        <span class="keyword">with</span> dpg.stage() <span class="keyword">as</span> stage: <span class="comment"># 创建临时上下文</span></span><br><span class="line">            self.<span class="built_in">id</span> = dpg.add_window(label=label,tag=tag) <span class="comment"># 在里面创建一个window组件</span></span><br><span class="line">        self.stage = stage <span class="comment"># 储存临时上下文的id</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add_child</span>(<span class="params">self,child</span>): <span class="comment"># 直接添加含有self.id的自定义类为孩子</span></span><br><span class="line">        dpg.move_item(child.<span class="built_in">id</span>,parent=self.<span class="built_in">id</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add_childID</span>(<span class="params">self,childID</span>): <span class="comment"># 按照id添加孩子</span></span><br><span class="line">        dpg.move_item(childID,parent=self.<span class="built_in">id</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">submit</span>(<span class="params">self</span>): <span class="comment"># 将临时上下文合并到主dpg上下文,效果上是让组件可见</span></span><br><span class="line">        dpg.unstage(self.stage)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在<code>DVWrapper.py</code>中封装好<code>Window</code>类后，我们在<code>DataVisual.py</code>中创建<code>dpg</code>的上下文并将<code>Window</code>类实例化出来</p><blockquote><p>DataVisual.py</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> DVWrapper <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> DBManager <span class="keyword">as</span> dbm</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">dpg.create_context() <span class="comment"># 创建dpg上下文</span></span><br><span class="line"></span><br><span class="line">main_win = Window(label=<span class="string">&quot;main_win&quot;</span>,tag=<span class="string">&quot;main_win&quot;</span>) <span class="comment"># 实例化</span></span><br><span class="line"></span><br><span class="line">main_win.submit() <span class="comment"># 提交组件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 以下的代码为固定代码框架的一部分，不多作讲解</span></span><br><span class="line">dpg.create_viewport(title=<span class="string">&#x27;Custom Title&#x27;</span>, width=<span class="number">1400</span>, height=<span class="number">600</span>)</span><br><span class="line">dpg.setup_dearpygui()</span><br><span class="line">dpg.show_viewport()</span><br><span class="line">dpg.set_primary_window(<span class="string">&quot;main_win&quot;</span>, <span class="literal">True</span>) <span class="comment"># 真正设置初始窗口(可选)</span></span><br><span class="line">dpg.start_dearpygui()</span><br><span class="line"></span><br><span class="line">dpg.destroy_context()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="封装子窗口类"><a href="#封装子窗口类" class="headerlink" title="封装子窗口类"></a>封装子窗口类</h3><p>光有主窗口还不够，还需要子窗口来限制未来要展示的表格，防止表格过长，占用主窗口过多的空间</p><blockquote><p>DVWrapper.py</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Child_Window</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,width=<span class="number">1200</span>,height=<span class="number">300</span>,tag=TOP_CHILD_WINDOW</span>):</span><br><span class="line">        <span class="keyword">with</span> dpg.stage():</span><br><span class="line">            self.<span class="built_in">id</span> = dpg.add_child_window(tag=tag,width=width,height=height)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add_child</span>(<span class="params">self,child</span>): <span class="comment"># 提供增加子组件的接口</span></span><br><span class="line">        dpg.move_item(child.<span class="built_in">id</span>,parent=self.<span class="built_in">id</span>)</span><br></pre></td></tr></table></figure><h3 id="封装Table类"><a href="#封装Table类" class="headerlink" title="封装Table类"></a>封装Table类</h3><p>我们封装一个<code>Table</code>类来执行更新表格和显示表格的功能</p><blockquote><p>DVWrapper.py</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">mystampToNumStr</span>(<span class="params">stamp</span>): <span class="comment"># 封装一个把毫秒级时间戳转换成年月日的函数</span></span><br><span class="line">    date = time.strftime(<span class="string">&quot;%Y/%m/%d&quot;</span>, time.localtime(<span class="built_in">int</span>(stamp / <span class="number">1000.0</span>)))</span><br><span class="line">    <span class="keyword">return</span> date</span><br><span class="line"></span><br><span class="line">TOP_CHILD_WINDOW = <span class="string">&quot;top_child_win&quot;</span> <span class="comment"># 定义默认的子窗口id</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 准备一个储存列名称的列表，方便建立表格</span></span><br><span class="line">columns = [<span class="string">&#x27;序号&#x27;</span>,<span class="string">&#x27;时间&#x27;</span>,<span class="string">&#x27;成交量(手)&#x27;</span>,<span class="string">&#x27;开盘价&#x27;</span>,<span class="string">&#x27;最高价&#x27;</span>,<span class="string">&#x27;最低价&#x27;</span>,<span class="string">&#x27;收盘价&#x27;</span>,<span class="string">&#x27;涨跌额&#x27;</span>,<span class="string">&#x27;涨跌幅&#x27;</span>,<span class="string">&#x27;换手率&#x27;</span>,<span class="string">&#x27;成交额(亿)&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DataTable</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,tag=<span class="string">&#x27;main table&#x27;</span></span>):</span><br><span class="line">        <span class="keyword">with</span> dpg.stage(): <span class="comment"># 创建临时上下文</span></span><br><span class="line">            self.<span class="built_in">id</span> = dpg.add_table(header_row=<span class="literal">True</span>, policy=dpg.mvTable_SizingFixedFit, row_background=<span class="literal">True</span>, reorderable=<span class="literal">True</span>,</span><br><span class="line">                   resizable=<span class="literal">True</span>, no_host_extendX=<span class="literal">False</span>, hideable=<span class="literal">True</span>,</span><br><span class="line">                   borders_innerV=<span class="literal">True</span>, delay_search=<span class="literal">True</span>, borders_outerV=<span class="literal">True</span>, borders_innerH=<span class="literal">True</span>,</span><br><span class="line">                   borders_outerH=<span class="literal">True</span>,tag=tag)  <span class="comment"># 创建一个会自动伸缩，可修改列宽度的，比较自由的表格</span></span><br><span class="line"></span><br><span class="line">            dpg.push_container_stack(self.<span class="built_in">id</span>) <span class="comment"># 展开表格组件的上下文，下面创建的组件自动成为表格的子组件</span></span><br><span class="line">            <span class="comment"># 添加表格的列</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(columns)):</span><br><span class="line">                dpg.add_table_column(label=columns[i],width_stretch=<span class="literal">True</span>, init_width_or_weight=<span class="number">0.0</span>)</span><br><span class="line"></span><br><span class="line">            dpg.pop_container_stack() <span class="comment"># 关闭表格的上下文</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">clearData</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 清除列表</span></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> dpg.get_item_children(self.<span class="built_in">id</span>,<span class="number">1</span>):</span><br><span class="line">            dpg.delete_item(item)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">updateData</span>(<span class="params">self,items</span>): <span class="comment"># 上传数据到表格</span></span><br><span class="line"></span><br><span class="line">        dpg.push_container_stack(self.<span class="built_in">id</span>) <span class="comment"># 打开表格的上下文</span></span><br><span class="line">        row = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> items:</span><br><span class="line">            row+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">with</span> dpg.table_row():</span><br><span class="line">                dpg.add_text(<span class="built_in">str</span>(row)) <span class="comment"># 输入行号到行号列</span></span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(item)):</span><br><span class="line">                    <span class="keyword">if</span>(j == <span class="number">0</span>): <span class="comment"># 时间要转换成时间戳</span></span><br><span class="line">                        date = mystampToNumStr(item[<span class="number">0</span>])</span><br><span class="line">                        dpg.add_text(date)</span><br><span class="line">                    <span class="keyword">elif</span>(j==<span class="number">10</span>):</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        dpg.add_text(item[j])</span><br><span class="line"></span><br><span class="line">        dpg.pop_container_stack()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="封装KPlot类"><a href="#封装KPlot类" class="headerlink" title="封装KPlot类"></a>封装KPlot类</h3><p>KPlot对外只负责<code>接受数据</code>和<code>绘制统计图</code>，而内部的工作有：</p><ul><li>解析数据</li><li>创建图标</li><li>绘制图标</li><li>提供鼠标悬停提示</li></ul><blockquote><p>DVWrapper.py</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">KPlot</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">with</span> dpg.stage():</span><br><span class="line">            <span class="comment"># 创建一个plot组件</span></span><br><span class="line">            <span class="keyword">with</span> dpg.plot(label=<span class="string">&quot;贵州茅台股票日K图&quot;</span>,tag=<span class="string">&#x27;kplot&#x27;</span>,height=-<span class="number">1</span>,width=-<span class="number">1</span>,show=<span class="literal">False</span>) <span class="keyword">as</span> self.<span class="built_in">id</span>:</span><br><span class="line">                dpg.add_plot_legend()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">draw</span>(<span class="params">self,fetch_data</span>):</span><br><span class="line">        xData=[]</span><br><span class="line">        <span class="comment"># 这里使用原生字典+列表解析获取到的数据</span></span><br><span class="line">        yDatas=&#123;<span class="string">&quot;volume&quot;</span>:[],<span class="string">&quot;open&quot;</span>:[],<span class="string">&quot;high&quot;</span>:[],<span class="string">&quot;low&quot;</span>:[],</span><br><span class="line">                <span class="string">&quot;close&quot;</span>:[],<span class="string">&quot;chg&quot;</span>:[],<span class="string">&quot;percent&quot;</span>:[],</span><br><span class="line">                <span class="string">&quot;turnoverrate&quot;</span>:[],<span class="string">&quot;amount&quot;</span>:[]&#125;</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> fetch_data:</span><br><span class="line">            line = <span class="built_in">list</span>(line) <span class="comment">#将元组转成列表，这样才能执行pop操作</span></span><br><span class="line"></span><br><span class="line">            xData.append(line.pop(<span class="number">0</span>)/<span class="number">1000</span>)</span><br><span class="line">            yDatas[<span class="string">&quot;volume&quot;</span>].append(line.pop(<span class="number">0</span>))</span><br><span class="line">            yDatas[<span class="string">&quot;open&quot;</span>].append(line.pop(<span class="number">0</span>))</span><br><span class="line">            yDatas[<span class="string">&quot;high&quot;</span>].append(line.pop(<span class="number">0</span>))</span><br><span class="line">            yDatas[<span class="string">&quot;low&quot;</span>].append(line.pop(<span class="number">0</span>))</span><br><span class="line">            yDatas[<span class="string">&#x27;close&#x27;</span>].append(line.pop(<span class="number">0</span>))</span><br><span class="line">            yDatas[<span class="string">&#x27;chg&#x27;</span>].append(line.pop(<span class="number">0</span>))</span><br><span class="line">            yDatas[<span class="string">&#x27;percent&#x27;</span>].append(line.pop(<span class="number">0</span>))</span><br><span class="line">            yDatas[<span class="string">&#x27;turnoverrate&#x27;</span>].append(line.pop(<span class="number">0</span>))</span><br><span class="line">            yDatas[<span class="string">&#x27;amount&#x27;</span>].append(line.pop(<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">custom_tooltip_handler</span>(<span class="params">sender,app_data</span>): <span class="comment">#声明一个回调函数，用于在鼠标上悬停显示每天的股票参数</span></span><br><span class="line">            x_data,y_data=dpg.get_plot_mouse_pos()</span><br><span class="line">            date = mystampToNumStr(x_data*<span class="number">1000</span>)  <span class="comment"># 将横坐标时间戳转换成具体日期</span></span><br><span class="line">            index = <span class="number">0</span></span><br><span class="line">            <span class="comment"># 通过日期反向寻找下标，然后再通过下标找到当天股票的数据</span></span><br><span class="line">            <span class="keyword">while</span>( index &lt; <span class="built_in">len</span>(xData) <span class="keyword">and</span> date != mystampToNumStr(xData[index]*<span class="number">1000</span>) ):</span><br><span class="line">                index+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span>(index &lt; <span class="built_in">len</span>(xData)):</span><br><span class="line">                <span class="comment"># 通过setValue设置悬停显示的信息</span></span><br><span class="line">                dpg.set_value(<span class="string">&quot;volume tip&quot;</span>,<span class="string">f&quot;时间:<span class="subst">&#123;date&#125;</span> \n &quot;</span></span><br><span class="line">                                           <span class="string">f&quot;成交量:<span class="subst">&#123;yDatas[<span class="string">&#x27;volume&#x27;</span>][index]&#125;</span>\n&quot;</span></span><br><span class="line">                                           <span class="string">f&quot;开盘价:<span class="subst">&#123;yDatas[<span class="string">&#x27;open&#x27;</span>][index]&#125;</span>\n&quot;</span></span><br><span class="line">                                           <span class="string">f&quot;最高价:<span class="subst">&#123;yDatas[<span class="string">&#x27;high&#x27;</span>][index]&#125;</span>\n&quot;</span></span><br><span class="line">                                           <span class="string">f&quot;最低价:<span class="subst">&#123;yDatas[<span class="string">&#x27;low&#x27;</span>][index]&#125;</span>\n&quot;</span></span><br><span class="line">                                           <span class="string">f&quot;收盘价:<span class="subst">&#123;yDatas[<span class="string">&#x27;close&#x27;</span>][index]&#125;</span>\n&quot;</span></span><br><span class="line">                                           <span class="string">f&quot;涨跌额:<span class="subst">&#123;yDatas[<span class="string">&#x27;chg&#x27;</span>][index]&#125;</span>\n&quot;</span></span><br><span class="line">                                           <span class="string">f&quot;涨跌幅<span class="subst">&#123;yDatas[<span class="string">&#x27;percent&#x27;</span>][index]&#125;</span>\n&quot;</span></span><br><span class="line">                                           <span class="string">f&quot;换手率:<span class="subst">&#123;yDatas[<span class="string">&#x27;turnoverrate&#x27;</span>][index]&#125;</span>\n&quot;</span></span><br><span class="line">                                           <span class="string">f&quot;成交额:<span class="subst">&#123;yDatas[<span class="string">&#x27;amount&#x27;</span>][index]&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">with</span> dpg.handler_registry(tag=<span class="string">&quot;volume hander&quot;</span>):</span><br><span class="line">            <span class="comment"># 将鼠标移动事件的回调函数绑定成上面的自定义函数</span></span><br><span class="line">            dpg.add_mouse_move_handler(callback=custom_tooltip_handler)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 准备开始绘制曲线</span></span><br><span class="line">        dpg.push_container_stack(self.<span class="built_in">id</span>)</span><br><span class="line">        xaxis = dpg.add_plot_axis(dpg.mvXAxis,label=<span class="string">&quot;日期&quot;</span>,time=<span class="literal">True</span>) <span class="comment"># 创建横坐标,并标记为以时间为横坐标</span></span><br><span class="line">        dpg.add_plot_axis(dpg.mvYAxis,label=<span class="string">&#x27;开盘价&#x27;</span>,tag=<span class="string">&quot;open&quot;</span>) <span class="comment"># 创建纵坐标1</span></span><br><span class="line">        dpg.add_plot_axis(dpg.mvYAxis,label=<span class="string">&#x27;换手率&#x27;</span>,tag=<span class="string">&quot;turnoverrate&quot;</span>) <span class="comment"># 创建纵坐标2</span></span><br><span class="line">        dpg.add_plot_axis(dpg.mvYAxis,label=<span class="string">&#x27;交易额&#x27;</span>,tag=<span class="string">&quot;amount&quot;</span>) <span class="comment"># 创建纵坐标3</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        dpg.add_line_series(xData,yDatas[<span class="string">&quot;volume&quot;</span>],parent=<span class="string">&quot;amount&quot;</span>,label=<span class="string">&quot;成交量&quot;</span>) <span class="comment"># 绘制折线图</span></span><br><span class="line">        <span class="comment"># 绘制K图</span></span><br><span class="line">        s1id = dpg.add_candle_series(xData,opens=yDatas[<span class="string">&#x27;open&#x27;</span>],closes=yDatas[<span class="string">&#x27;close&#x27;</span>],lows=yDatas[<span class="string">&#x27;low&#x27;</span>],highs=yDatas[<span class="string">&#x27;high&#x27;</span>],parent=<span class="string">&#x27;open&#x27;</span>,label=<span class="string">&#x27;K图&#x27;</span>,time_unit=dpg.mvTimeUnit_Day)</span><br><span class="line">        dpg.add_line_series(xData,yDatas[<span class="string">&quot;open&quot;</span>],parent=<span class="string">&#x27;open&#x27;</span>,label=<span class="string">&quot;开盘价&quot;</span>) <span class="comment"># 绘制折线图，下同</span></span><br><span class="line">        dpg.add_line_series(xData,yDatas[<span class="string">&quot;high&quot;</span>],parent=<span class="string">&#x27;open&#x27;</span>,label=<span class="string">&quot;最高价&quot;</span>)</span><br><span class="line">        dpg.add_line_series(xData,yDatas[<span class="string">&quot;low&quot;</span>],parent=<span class="string">&#x27;open&#x27;</span>,label=<span class="string">&#x27;最低价&#x27;</span>)</span><br><span class="line">        dpg.add_line_series(xData,yDatas[<span class="string">&quot;close&quot;</span>],parent=<span class="string">&#x27;open&#x27;</span>,label=<span class="string">&#x27;收盘价&#x27;</span>)</span><br><span class="line">        dpg.add_line_series(xData,yDatas[<span class="string">&quot;chg&quot;</span>],parent=<span class="string">&#x27;turnoverrate&#x27;</span>,label=<span class="string">&#x27;涨跌额&#x27;</span>)</span><br><span class="line">        dpg.add_line_series(xData,yDatas[<span class="string">&quot;percent&quot;</span>],parent=<span class="string">&#x27;turnoverrate&#x27;</span>,label=<span class="string">&#x27;涨跌幅&#x27;</span>)</span><br><span class="line">        dpg.add_line_series(xData,yDatas[<span class="string">&quot;turnoverrate&quot;</span>],parent=<span class="string">&#x27;turnoverrate&#x27;</span>,label=<span class="string">&#x27;换手率&#x27;</span>)</span><br><span class="line">        dpg.add_line_series(xData,yDatas[<span class="string">&quot;amount&quot;</span>],parent=<span class="string">&#x27;amount&#x27;</span>,label=<span class="string">&#x27;成交额&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        dpg.fit_axis_data(xaxis) <span class="comment"># 使横坐标自适应，最终显示为具体日期</span></span><br><span class="line">        <span class="keyword">with</span> dpg.tooltip(s1id,label=<span class="string">&#x27;tool tip&#x27;</span>,tag=<span class="string">&quot;tool tip&quot;</span>): <span class="comment"># 创建鼠标悬停显示的组件</span></span><br><span class="line">            dpg.add_text(<span class="string">&quot;Hover the plot&quot;</span>,tag=<span class="string">&quot;volume tip&quot;</span>)</span><br><span class="line"></span><br><span class="line">        dpg.pop_container_stack()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="封装MenuBar类"><a href="#封装MenuBar类" class="headerlink" title="封装MenuBar类"></a>封装MenuBar类</h3><p><code>dpg</code>的<code>menu_bar</code>组件就只是单纯的菜单栏，内部是空的，所以得先封装<code>MenuItem</code>类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MenuItem</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,menubar,label,tag,target</span>): <span class="comment"># 菜单选项与多个组件有关</span></span><br><span class="line">        self.parent = menubar.<span class="built_in">id</span> <span class="comment"># 储存parent的id</span></span><br><span class="line">        self.target = target <span class="comment"># 储存目标空间的id</span></span><br><span class="line">        dpg.push_container_stack(self.parent)  <span class="comment"># 将自己添加到parent中</span></span><br><span class="line">        self.<span class="built_in">id</span> = dpg.add_menu_item(label=label,tag=tag,user_data=[menubar,self])</span><br><span class="line">        dpg.pop_container_stack()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">HideCallback</span>(<span class="params">self</span>):</span><br><span class="line">        current_visible = dpg.is_item_visible(self.target)  <span class="comment"># 获取当前可见性</span></span><br><span class="line">        <span class="keyword">if</span> current_visible:</span><br><span class="line">            dpg.hide_item(self.target) <span class="comment"># 若可见，则隐藏</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">setCallback</span>(<span class="params">self,callback</span>): <span class="comment"># 设置当菜单选项被点击时调用的回调函数</span></span><br><span class="line">        dpg.set_item_callback(self.<span class="built_in">id</span>,callback=callback)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MenuBar</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,tag=<span class="string">&#x27;main menu&#x27;</span></span>):</span><br><span class="line">        self.children = [] <span class="comment"># 列表用于管理所有子组件（惨淡选项）</span></span><br><span class="line">        <span class="keyword">with</span> dpg.stage():</span><br><span class="line">            self.<span class="built_in">id</span> = dpg.add_menu_bar(tag=tag)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add_item</span>(<span class="params">self,label,tag,target,font</span>): <span class="comment"># 设计思想上，菜单选项必须能过管理它对应的目标组件，所以需要一个target成员变量储存目标id</span></span><br><span class="line">        self.children.append(MenuItem(self,label=label,tag=tag,target=target))</span><br><span class="line">        child_id = self.children[-<span class="number">1</span>].<span class="built_in">id</span></span><br><span class="line">        dpg.bind_item_font(child_id,font) <span class="comment"># 绑定菜单选项的字体(由外部提供)</span></span><br><span class="line">        self.children[-<span class="number">1</span>].HideCallback() <span class="comment"># 新的孩子默认调用一下使目标隐藏的回调函数</span></span><br><span class="line">        <span class="keyword">return</span> child_id <span class="comment"># 返回新插入孩子的id,外边外界绑定回调函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hide_children</span>(<span class="params">self</span>):<span class="comment"># 提供使所有被控组件隐藏的接口(不是让菜单选项隐藏)</span></span><br><span class="line">        <span class="keyword">for</span> child <span class="keyword">in</span> self.children:</span><br><span class="line">            child.HideCallback() <span class="comment"># 规定MenuItem类必须有一个HideCallback回调函数</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="封装水平按钮组"><a href="#封装水平按钮组" class="headerlink" title="封装水平按钮组"></a>封装水平按钮组</h3><p>虽然目前只有一个按钮，但是为了方便以后在同一行放更多的按钮，我们选择再额外封装一个<code>Group</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HorGroup</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,width=<span class="number">40</span></span>):<span class="comment"># 提供可设置的宽度</span></span><br><span class="line">        <span class="keyword">with</span> dpg.stage():</span><br><span class="line">            <span class="comment"># horizontal=True,设置组内的组件水平放置</span></span><br><span class="line">            self.<span class="built_in">id</span> = dpg.add_group(horizontal=<span class="literal">True</span>,width=width)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add_child</span>(<span class="params">self,child</span>): <span class="comment">#  提供增加子组件的接口</span></span><br><span class="line">        dpg.move_item(child.<span class="built_in">id</span>,parent=self.<span class="built_in">id</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add_spacer</span>(<span class="params">self</span>):<span class="comment">#  提供增加空位的接口</span></span><br><span class="line">        dpg.push_container_stack(self.<span class="built_in">id</span>)</span><br><span class="line">        dpg.add_spacer()</span><br><span class="line">        dpg.pop_container_stack()</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Button</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,label,tag</span>):</span><br><span class="line">        <span class="keyword">with</span> dpg.stage():</span><br><span class="line">            self.<span class="built_in">id</span>=dpg.add_button(label=label,tag=tag,width=<span class="number">150</span>,height=<span class="number">40</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">setcallback</span>(<span class="params">self,callback</span>):</span><br><span class="line">        dpg.set_item_callback(self.<span class="built_in">id</span>,callback=callback)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="类实例化和构建可视化页面"><a href="#类实例化和构建可视化页面" class="headerlink" title="类实例化和构建可视化页面"></a>类实例化和构建可视化页面</h3><p>特别的，由于<code>dpg</code>默认不支持中文字体，所以要在项目里准备一个支持中文自己的文件，并在程序中使用该字体，才能正常显示中文</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> dearpygui.dearpygui <span class="keyword">as</span> dpg</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> DVWrapper <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> DBManager <span class="keyword">as</span> dbm</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">maotai = GZMaoTai()</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getTimestamp</span>():<span class="comment"># 获取秒级的当前时间戳</span></span><br><span class="line">    t=time.time()</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>(<span class="built_in">round</span>(t*<span class="number">1000</span>))</span><br><span class="line"></span><br><span class="line">dpg.create_context()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">commonMenuCallback</span>(<span class="params">sender,app_data,user_data</span>): <span class="comment"># 声明通用的菜单选项的回调函数</span></span><br><span class="line">    user_data[<span class="number">0</span>].hide_children() <span class="comment">#规定user_data[0]为菜单对象,隐藏所有被控组件</span></span><br><span class="line">    dpg.show_item(user_data[<span class="number">1</span>].target) <span class="comment"># 最后再只显示自己</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">DBUpdateCallback</span>(<span class="params">sender,app_data</span>):  <span class="comment"># 声明按下按钮的回调函数</span></span><br><span class="line">    dpg.set_item_label(sender,<span class="string">&quot;数据更新中...&quot;</span>) <span class="comment">#更改按钮显示内容</span></span><br><span class="line">    dpg.disable_item(sender) <span class="comment"># 调用函数期间使按钮无效化</span></span><br><span class="line">    dbm.clearDB() <span class="comment"># 清空数据库</span></span><br><span class="line">    my_table.clearData() <span class="comment"># 情况表格</span></span><br><span class="line">    items = maotai.get_response(getTimestamp())  <span class="comment"># 获取最新数据</span></span><br><span class="line">    dbm.sendData(items)  <span class="comment"># 向数据库发送数据</span></span><br><span class="line">    fetch_data = dbm.getLatestData()  <span class="comment"># 从数据库获取数据</span></span><br><span class="line">    my_table.updateData(fetch_data)  <span class="comment"># 更新表格</span></span><br><span class="line">    dpg.set_item_label(sender,<span class="string">&quot;更新数据库数据&quot;</span>)  <span class="comment"># 改回按钮的显示内容</span></span><br><span class="line">    dpg.enable_item((sender)) <span class="comment"># 重新启用按钮</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">######  设置字体 ###########</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> dpg.font_registry():</span><br><span class="line">    <span class="keyword">with</span> dpg.font(<span class="string">&quot;./fonts/msyh.ttc&quot;</span>,<span class="number">20</span>) <span class="keyword">as</span> default_font:</span><br><span class="line">        dpg.add_font_range_hint(dpg.mvFontRangeHint_Chinese_Simplified_Common)</span><br><span class="line">    <span class="keyword">with</span> dpg.font(<span class="string">&quot;./fonts/msyh.ttc&quot;</span>,<span class="number">25</span>) <span class="keyword">as</span> big_font:</span><br><span class="line">        dpg.add_font_range_hint(dpg.mvFontRangeHint_Chinese_Simplified_Common)</span><br><span class="line">    <span class="keyword">with</span> dpg.font(<span class="string">&quot;./fonts/msyh.ttc&quot;</span>,<span class="number">20</span>) <span class="keyword">as</span> menufont:</span><br><span class="line">        dpg.add_font_range_hint(dpg.mvFontRangeHint_Chinese_Simplified_Common)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">###### 程序主要内容 ########</span></span><br><span class="line"><span class="comment"># 构建可视化组件</span></span><br><span class="line">my_table = DataTable() <span class="comment"># 实例化表格</span></span><br><span class="line"></span><br><span class="line">update_button = Button(label=<span class="string">&quot;更新数据库数据&quot;</span>,tag=<span class="string">&quot;update button&quot;</span>) <span class="comment"># 实例化按钮</span></span><br><span class="line">update_button.setcallback(DBUpdateCallback)  <span class="comment"># 设置回调函数</span></span><br><span class="line"></span><br><span class="line">kplot = KPlot() <span class="comment"># 实例化图标</span></span><br><span class="line"></span><br><span class="line">menubar = MenuBar() <span class="comment"># 实例化菜单栏</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加菜单栏选项</span></span><br><span class="line">table_menu = menubar.add_item(label=<span class="string">&quot;表格&quot;</span>,tag=<span class="string">&quot;table&quot;</span>,target=my_table.<span class="built_in">id</span>,font=menufont)</span><br><span class="line">kplot_menu = menubar.add_item(label=<span class="string">&quot;日K图&quot;</span>,tag=<span class="string">&quot;Kplot&quot;</span>,target=kplot.<span class="built_in">id</span>,font=menufont)</span><br><span class="line"><span class="comment"># 绑定惨淡了选项的回调函数</span></span><br><span class="line">dpg.set_item_callback(table_menu,commonMenuCallback)</span><br><span class="line">dpg.set_item_callback(kplot_menu,commonMenuCallback)</span><br><span class="line"><span class="comment"># 创建窗口</span></span><br><span class="line">main_win = Window(label=<span class="string">&quot;main_win&quot;</span>,tag=<span class="string">&quot;main_win&quot;</span>)</span><br><span class="line"><span class="comment"># 创建子窗口</span></span><br><span class="line">top_child_win = Child_Window(width=-<span class="number">1</span>,height=<span class="number">400</span>)</span><br><span class="line">top_child_win.add_child(my_table)</span><br><span class="line">top_child_win.add_child(kplot)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 构建父子关系</span></span><br><span class="line">dpg.bind_font(default_font)</span><br><span class="line">dpg.bind_item_font(update_button.<span class="built_in">id</span>,big_font)</span><br><span class="line">dpg.bind_item_font(menubar.<span class="built_in">id</span>,menufont)</span><br><span class="line">main_win.add_child(menubar)</span><br><span class="line">main_win.add_child(top_child_win)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">button_group = HorGroup(width=<span class="number">300</span>)</span><br><span class="line">button_group.add_spacer()</span><br><span class="line">inner_group = HorGroup()</span><br><span class="line">inner_group.add_child(update_button)</span><br><span class="line"><span class="comment"># inner_group.add_child(clear_button)</span></span><br><span class="line">button_group.add_child(inner_group)</span><br><span class="line">button_group.add_spacer()</span><br><span class="line">main_win.add_child(button_group)</span><br><span class="line"></span><br><span class="line">main_win.submit()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># items = maotai.get_response(getTimestamp())</span></span><br><span class="line"></span><br><span class="line">fetch_data = dbm.getLatestData()</span><br><span class="line">my_table.updateData(fetch_data)</span><br><span class="line">kplot.draw(fetch_data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dbm.closeDB()</span><br><span class="line">dpg.create_viewport(title=<span class="string">&#x27;Custom Title&#x27;</span>, width=<span class="number">1400</span>, height=<span class="number">600</span>)</span><br><span class="line">dpg.setup_dearpygui()</span><br><span class="line">dpg.show_viewport()</span><br><span class="line">dpg.set_primary_window(<span class="string">&quot;main_win&quot;</span>, <span class="literal">True</span>) <span class="comment"># 真正设置初始窗口</span></span><br><span class="line">dpg.start_dearpygui()</span><br><span class="line"></span><br><span class="line">dpg.destroy_context()</span><br></pre></td></tr></table></figure><h1 id="成品展示"><a href="#成品展示" class="headerlink" title="成品展示"></a>成品展示</h1><p><em>(文件较大，请耐心等待加载)</em></p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202410091543883.gif"></p><h1 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h1><p>在本次项目中，我们使用了互联网爬虫技术和可视化技术完成了项目目标，能够方便地查询股票数据和分析股票的日K图。</p><p><a href="https://github.com/sis-shen/OLSIC">戳我去github仓库🔗</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【python项目实践】ACVA航空公司客户价值分析</title>
      <link href="/2024/09/03/ACVA/"/>
      <url>/2024/09/03/ACVA/</url>
      
        <content type="html"><![CDATA[<h1 id="背景分析"><a href="#背景分析" class="headerlink" title="背景分析"></a>背景分析</h1><h2 id="航空公司现状"><a href="#航空公司现状" class="headerlink" title="航空公司现状"></a>航空公司现状</h2><h4 id="行业内竞争"><a href="#行业内竞争" class="headerlink" title="行业内竞争"></a>行业内竞争</h4><p>民航的竞争除了三大航空公司之间的竞争外，还将加入新崛起的各类小型航空公司、民营航空公司，甚至国外航空巨头。航空产品<strong>生产过剩,产品同质化</strong>特征愈加明显，于是航空公司从<strong>价格、服务</strong>间的竞争逐渐转向对<strong>客户</strong>的竞争</p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/airliness.png"></p><h2 id="行业外竞争"><a href="#行业外竞争" class="headerlink" title="行业外竞争"></a>行业外竞争</h2><p>随着<strong>高铁</strong>、动车等铁路运输的兴建，航空公司受到巨大冲击</p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/transportalrad.png"></p><p><em>如上图所示，经过2010到2015年的发展，铁路运输对航空运输的冲击越发明显</em></p><h2 id="航空公司数据特征说明"><a href="#航空公司数据特征说明" class="headerlink" title="航空公司数据特征说明"></a>航空公司数据特征说明</h2><ul><li>目前航空公司已经积累了大量的会员档案信息和其乘坐航班记录</li><li>就本项目已获取的数据，以2014-03-31为结束时间，选取宽度为<strong>两年</strong>的时间段作为分析观测窗口，抽取观测窗口内有乘机记录的所有客户的详细数据形成的历史数据，44个特征，总共62988条记录。</li></ul><p>数据特征记录说明如下表所示:</p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/ACVA_TABLE1.png"><br><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/ACVA_TABLE2.png"><br><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/ACVA_TABLE3.png"></p><h2 id="结合数据的项目目标"><a href="#结合数据的项目目标" class="headerlink" title="结合数据的项目目标"></a>结合数据的项目目标</h2><p>结合目前航空公司的数据情况，可以实现以下目标</p><ul><li>借助航空公司客户数据，对客户进行分类</li><li>对不同的客户类别<code>进行特征分析</code>，比较不同类别客户的<code>客户价值</code></li><li>对不同价值的客户类别提供<code>个性化服务</code>,制定相应的<code>营销策略</code></li></ul><h2 id="了解客户价值分析"><a href="#了解客户价值分析" class="headerlink" title="了解客户价值分析"></a>了解客户价值分析</h2><p>客户营销战略倡导者<em>Jay</em> &amp; <em>Adam Curry</em> 从国外数百家公司进行了客户营销实施的经验中提炼了如下经验</p><ul><li>公司<strong>收入</strong>的<code>80%</code>来自顶端的<code>20%</code>客户</li><li><code>20%</code>的客户其利<code>润率100%</code></li><li><code>90%</code>以上的收入来自<strong>现有</strong>客户</li><li><strong>大部分的营销预算</strong>经常被用在非现有客户上</li><li><code>5%</code>至<code>30%</code>的客户在客户金字塔中具有<strong>升级潜力</strong></li><li>客户金字塔中客户升级<code>2%</code>，意味着营销收入增加<code>10%</code>,利润增加<code>50%</code></li></ul><p>也许这些经验并不完全准确，但是它解释了新时代<code>客户分化</code>的趋势，也说明了对客户价值分析的<strong>迫切性</strong>和<strong>必要性</strong></p><h2 id="项目流程图"><a href="#项目流程图" class="headerlink" title="项目流程图"></a>项目流程图</h2><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/ACVA_flow_char.png"></p><h1 id="代码实现业务功能"><a href="#代码实现业务功能" class="headerlink" title="代码实现业务功能"></a>代码实现业务功能</h1><h2 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h2><h3 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h3><p>这里主要用三个文件夹，分别储存<code>代码</code>，<code>原始数据</code>,<code>临时文件</code></p><ul><li><code>codes</code>       代码文件夹</li><li><code>data_raw</code>    原始数据文件夹</li><li><code>tmp</code>         临时文件文件夹</li></ul><h2 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h2><p>本业务系统采用一个<code>main.py</code>执行主要业务逻辑，封装多个模块和类实现具体业务，以达到主要业务逻辑清晰，代码封装性强，易于维护和复用的优点</p><p>主要的代码文件有:</p><ul><li>main.py       执行主要逻辑</li><li>log.py        提供日志器</li><li>data_cleaner  实现清洗数据</li><li>LEDNX.py      构建和提取五大特征</li><li>radar_char.py 绘制结果雷达图</li></ul><h2 id="实现一个简单的日志器"><a href="#实现一个简单的日志器" class="headerlink" title="实现一个简单的日志器"></a>实现一个简单的日志器</h2><p>一般日志器有<code>日志等级</code>，<code>日志时间</code>，和<code>日志内容</code>三大部分，不过本次业务与时间关联性不大，就只打印两个部分</p><blockquote><p>log.py</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">###### 实现日志系统 ########</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义日志等级</span></span><br><span class="line">LOG_INFO = <span class="string">&quot;Info&quot;</span></span><br><span class="line">LOG_ERROR = <span class="string">&quot;Error&quot;</span></span><br><span class="line">LOG_WANING = <span class="string">&quot;Warning&quot;</span></span><br><span class="line">LOG_FATAL = <span class="string">&quot;Fatal&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Log</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self,level,*msgs</span>): <span class="comment"># 重载()运算符</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[&quot;</span>, level, <span class="string">&quot;]&quot;</span>,end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> msg <span class="keyword">in</span> msgs:</span><br><span class="line">            <span class="built_in">print</span>(msg)</span><br><span class="line">        <span class="comment"># 本项目与时间关系不大，日志系统不打印时间</span></span><br></pre></td></tr></table></figure><p>这里使用了<code>__call__</code>对<code>()</code>操作符的<code>重载</code>，和<code>*mgs</code>达到了<code>传递任意数量参数</code>的语法特性</p><p>这样以后打印日志可以方便地把对象当函数用</p><h2 id="程序入口-从数据源提取数据"><a href="#程序入口-从数据源提取数据" class="headerlink" title="程序入口 &amp; 从数据源提取数据"></a>程序入口 &amp; 从数据源提取数据</h2><p>我们将<code>main.py</code>作为项目的程序入口</p><blockquote><p>main.py</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">######### 主程序入口 #############</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> KMeans</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> log <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> data_clean <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LRFMC <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"></span><br><span class="line">    log = Log()  <span class="comment"># 实例化一个日志器</span></span><br><span class="line">    data_cleaner = DataCleaner() <span class="comment">#实例化数据清洗器</span></span><br><span class="line">    LRFMCobj = LRFMC()  <span class="comment"># 实例化模型处理器</span></span><br></pre></td></tr></table></figure><p>这里的数据源为<code>.csv</code>文件，所以我们要用到<code>pandas</code>模块读取文件到表格中</p><p>这里代码不多，就直接写在<code>main.py</code>里了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ...上略...</span></span><br><span class="line"><span class="comment">#data_cleaner = DataCleaner() #实例化数据清洗器</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从数据源获取数据</span></span><br><span class="line">airline_data = pd.read_csv(<span class="string">&quot;../data_raw/air_data.csv&quot;</span>,</span><br><span class="line">    encoding=<span class="string">&quot;gb18030&quot;</span>)  <span class="comment"># 导入航空数据</span></span><br><span class="line">log(LOG_INFO,<span class="string">&#x27;原始数据的形状为：&#x27;</span>, airline_data.shape)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="预处理航空公司数据"><a href="#预处理航空公司数据" class="headerlink" title="预处理航空公司数据"></a>预处理航空公司数据</h2><p>航空公司客户原始数据存在少量的<code>缺失值</code>和<code>异常值</code>，需要清洗后才能用于分析。</p><h3 id="缺失值处理"><a href="#缺失值处理" class="headerlink" title="缺失值处理"></a>缺失值处理</h3><p>通过对数据观察发现原始数据中存在票价为空值，票价最小值为0，折扣率最小值为0，总飞行公里数大于0的记录。票价为空值的数据可能是客户不存在乘机记录造成。</p><p>处理方法：丢弃票价为空的记录</p><p>具体实现： 考虑到与票价有关的特征有<code>SUM_YR_1</code>和<code>SUM_YR_2</code>两条，逻辑上两条特征数据都为<code>0</code>才算<code>缺失值</code>,所以分别提取两条对应的<code>布尔值列表</code>，并用<code>逻辑与</code>合并，用于数据表格的切片</p><p><em>我们先定义好成员函数，最后封装到DataCleaner类中</em></p><blockquote><p>data_cleaner.py</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">notNull</span>(<span class="params">self,airline_data</span>):  <span class="comment"># 缺失值处理：去除票价为空的记录</span></span><br><span class="line">    exp1 = airline_data[<span class="string">&quot;SUM_YR_1&quot;</span>].notnull()</span><br><span class="line">    exp2 = airline_data[<span class="string">&quot;SUM_YR_2&quot;</span>].notnull()</span><br><span class="line">    exp = exp1 &amp; exp2  <span class="comment"># 按位逻辑与,获取所需的布尔值列表</span></span><br><span class="line">    <span class="comment"># airline_notnull = airline_data.loc[exp, :]  # exp提供布尔值竖列表， &#x27;:&#x27;默认无参时，切片所有行,完成去除操作</span></span><br><span class="line">    airline_notnull = airline_data[exp] <span class="comment">#  这是上一句的简化写法（使用更多的缺省参数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> airline_notnull</span><br></pre></td></tr></table></figure><h3 id="异常值"><a href="#异常值" class="headerlink" title="异常值"></a>异常值</h3><p>其他的数据可能是客户乘坐<code>0折机票</code>或者<code>积分兑换</code>造成。由于原始数据量大，这类数据所占比例较小，对于问题影响不大，因此对其进行丢弃处理。</p><p>处理方法：丢弃<strong>票价为0，平均折扣率为0，总飞行公里数大于0的记录。</strong></p><p>具体处理：采用<code>index1</code>和<code>index2</code>先保留总票价不为<code>0</code>的记录,然后用<code>index3</code>筛选出总里程<code>SEG_KM_SUM``&gt;0</code>且平均折扣率<code>avg_discount``!=0</code>的记录,使用布尔值列表<code>(index1 | index2) &amp; index3</code>进行筛选，保留所需数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">notOutlier</span>(<span class="params">self,airline_data</span>):</span><br><span class="line">    index1 = airline_data[<span class="string">&quot;SUM_YR_1&quot;</span>].notnull()</span><br><span class="line">    index2 = airline_data[<span class="string">&quot;SUM_YR_2&quot;</span>] != <span class="number">0</span>  <span class="comment"># 效果和上一句的notnull()一样,都是生成bool array</span></span><br><span class="line">    index3 = (airline_data[<span class="string">&quot;SEG_KM_SUM&quot;</span>] &gt; <span class="number">0</span>) &amp; \</span><br><span class="line">             (airline_data[<span class="string">&quot;avg_discount&quot;</span>] != <span class="number">0</span>)  <span class="comment"># 折扣且总里程不为0的机票</span></span><br><span class="line">    airline = airline_data[(index1 | index2) &amp; index3]  <span class="comment"># 丢弃票价为0，或折扣率为0，且总里程&gt;0的异常值</span></span><br><span class="line">    <span class="keyword">return</span> airline</span><br></pre></td></tr></table></figure><h3 id="封装DataCleaner类"><a href="#封装DataCleaner类" class="headerlink" title="封装DataCleaner类"></a>封装DataCleaner类</h3><p>将用于清理数据的函数整合到一个类中，方便维护，添加或修改新的清理规则也很可以很方便地找到<code>DataCleaner</code>类，在里面集中维护s</p><blockquote><p>data_cleaner.py</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DataCleaner</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">notNull</span>(<span class="params">self,airline_data</span>):  <span class="comment"># 缺失值处理：去除票价为空的记录</span></span><br><span class="line">        exp1 = airline_data[<span class="string">&quot;SUM_YR_1&quot;</span>].notnull()</span><br><span class="line">        exp2 = airline_data[<span class="string">&quot;SUM_YR_2&quot;</span>].notnull()</span><br><span class="line">        exp = exp1 &amp; exp2  <span class="comment"># 按位逻辑与,获取所需的布尔值列表</span></span><br><span class="line">        <span class="comment">#airline_notnull = airline_data.loc[exp, :]  # exp提供布尔值竖列表， &#x27;:&#x27;默认无参时，切片所有行,完成去除操作</span></span><br><span class="line">        airline_notnull = airline_data[exp] <span class="comment">#  这是上一句的简化写法（使用更多的缺省参数</span></span><br><span class="line">        <span class="keyword">return</span> airline_notnull</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">notOutlier</span>(<span class="params">self,airline_data</span>):</span><br><span class="line">        index1 = airline_data[<span class="string">&quot;SUM_YR_1&quot;</span>].notnull()</span><br><span class="line">        index2 = airline_data[<span class="string">&quot;SUM_YR_2&quot;</span>] != <span class="number">0</span>  <span class="comment"># 效果和上一句的notnull()一样,都是生成bool array</span></span><br><span class="line">        index3 = (airline_data[<span class="string">&quot;SEG_KM_SUM&quot;</span>] &gt; <span class="number">0</span>) &amp; \</span><br><span class="line">                 (airline_data[<span class="string">&quot;avg_discount&quot;</span>] != <span class="number">0</span>)  <span class="comment"># 折扣且总里程不为0的机票</span></span><br><span class="line">        airline = airline_data[(index1 | index2) &amp; index3]  <span class="comment"># 丢弃票价为0，或折扣率为0，且总里程&gt;0的异常值</span></span><br><span class="line">        <span class="keyword">return</span> airline</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="RFM到LFRMC模型的介绍"><a href="#RFM到LFRMC模型的介绍" class="headerlink" title="RFM到LFRMC模型的介绍"></a>RFM到LFRMC模型的介绍</h2><h3 id="RFM模型介绍"><a href="#RFM模型介绍" class="headerlink" title="RFM模型介绍"></a>RFM模型介绍</h3><p>本项目的目标是客户价值分析，即通过航空公司客户数据识别不同价值的客户，识别客户价值应用最广泛的模型是RFM模型。</p><blockquote><ul><li><strong>R</strong>（<code>Recency</code>）指的是最近一次消费时间与截止时间的间隔。通常情况下，最近一次消费时间与截止时间的间隔越短，对即时提供的商品或是服务也最有可能感兴趣。</li><li><strong>F</strong>（<code>Frequency</code>）指顾客在某段时间内所消费的次数。可以说消费频率越高的顾客，也是满意度越高的顾客，其忠诚度也就越高，顾客价值也就越大。</li><li><strong>M</strong>（<code>Monetary</code>）指顾客在某段时间内所消费的金额。消费金额越大的顾客，他们的消费能力自然也就越大，这就是所谓“20%的顾客贡献了80%的销售额”的二八法则。</li></ul></blockquote><h3 id="RFM模型结果解读"><a href="#RFM模型结果解读" class="headerlink" title="RFM模型结果解读"></a>RFM模型结果解读</h3><p>RFM模型包括三个特征，使用<strong>三维坐标系</strong>进行展示，如图所示。X轴表示<code>Recency</code>，Y轴表示<code>Frequency</code>，Z轴表示<code>Monetary</code>，每个轴一般会分成5级表示程度，1为最小，5为最大</p><p><em>如图，不同的区域有有不同的营销策略</em></p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/RFM_model_res.png"></p><h3 id="传统RFM模型在航空行业的缺陷"><a href="#传统RFM模型在航空行业的缺陷" class="headerlink" title="传统RFM模型在航空行业的缺陷"></a>传统RFM模型在航空行业的缺陷</h3><p>在RFM模型中，消费金额表示在一段时间内，客户购买该企业产品金额的总和，由于航空票价受到运输距离，舱位等级等多种因素影响，同样消费金额的不同旅客对航空公司的价值是不同的，因此这个特征并不适合用于航空公司的客户价值分析。</p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/ACVA_RFM_LOw.png"></p><h3 id="航空客户价值分析的LRFMC模型"><a href="#航空客户价值分析的LRFMC模型" class="headerlink" title="航空客户价值分析的LRFMC模型"></a>航空客户价值分析的LRFMC模型</h3><p>为了弥补传统RFM模型在实际应用中的缺陷，本次项目使用了适用于航空客户价值分析的<code>LRFMC模型</code></p><p>本项目选择客户在一定时间内累积的飞行里程M和客户在一定时间内乘坐舱位所对应的折扣系数的平均值C两个特征代替消费金额。此外，航空公司会员入会时间的长短在一定程度上能够影响客户价值，所以在模型中增加客户关系长度L，作为区分客户的另一特征。</p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/ACVA_LRFMC.png"></p><h2 id="构建航空客户价值分析的关键特征"><a href="#构建航空客户价值分析的关键特征" class="headerlink" title="构建航空客户价值分析的关键特征"></a>构建航空客户价值分析的关键特征</h2><p>这里依然使用模块封装和类封装，在<code>LRFMC.py</code>中封装<code>LRFMC</code>类来完成模型相关的数据处理</p><h3 id="选取关键特征-和-构建L特征"><a href="#选取关键特征-和-构建L特征" class="headerlink" title="选取关键特征 和 构建L特征"></a>选取关键特征 和 构建L特征</h3><p>我们首先选取上图相关特征的列到<code>airline_selection</code>中，用于构建<code>L</code>特征和后面选取后四列与<code>L</code>列合并</p><blockquote><p>LRFMC.py</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">######## 构建 LRFMC模型 ########</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> log <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LRFMC</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.log = Log()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getFeatures</span>(<span class="params">self,airline</span>):</span><br><span class="line">        <span class="comment"># 选取需求特征</span></span><br><span class="line">        airline_selection = airline[[<span class="string">&quot;FFP_DATE&quot;</span>,<span class="string">&quot;LOAD_TIME&quot;</span>,</span><br><span class="line">                                     <span class="string">&quot;FLIGHT_COUNT&quot;</span>,<span class="string">&quot;LAST_TO_END&quot;</span>,</span><br><span class="line">                                     <span class="string">&quot;avg_discount&quot;</span>,<span class="string">&quot;SEG_KM_SUM&quot;</span>]]</span><br><span class="line">        <span class="comment"># 构建L特征</span></span><br><span class="line">        L = pd.to_datetime(airline_selection[<span class="string">&quot;LOAD_TIME&quot;</span>]) \</span><br><span class="line">            - pd.to_datetime(airline_selection[<span class="string">&quot;FFP_DATE&quot;</span>])</span><br><span class="line">        self.log(LOG_DEBUG,<span class="string">&quot;\n&quot;</span>,L[:<span class="number">5</span>])  <span class="comment">#测试前五行</span></span><br><span class="line">        <span class="comment"># 转成月份</span></span><br><span class="line">        L = L.astype(<span class="string">&quot;str&quot;</span>).<span class="built_in">str</span>.split().<span class="built_in">str</span>[<span class="number">0</span>]</span><br><span class="line">        L = L.astype(<span class="string">&quot;int&quot;</span>)/<span class="number">30</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#合并特征</span></span><br><span class="line">        airline_features = pd.concat([L,</span><br><span class="line">                airline_selection.iloc[:,<span class="number">2</span>:]],axis = <span class="number">1</span>)  <span class="comment">#axis=1使函数按列合并,[:,2:]舍弃了原本的前两列</span></span><br><span class="line">        airline_features =airline_features.rename(columns=&#123;<span class="number">0</span>:<span class="string">&quot;L&quot;</span>&#125;) <span class="comment"># 重命名没有名字的列</span></span><br><span class="line">        self.log(LOG_DEBUG,<span class="string">&quot;\n&quot;</span>,airline_features.head())  <span class="comment">#缺省参数为5，打印前五行</span></span><br><span class="line">        <span class="keyword">return</span> airline_features</span><br></pre></td></tr></table></figure><h3 id="标准化"><a href="#标准化" class="headerlink" title="标准化"></a>标准化</h3><p>完成五个特征的构建以后，对每个特征数据分布情况进行分析，其数据的取值范围如下表所示。从表中数据可以发现，<strong>五个特征的取值范围数据差异较大</strong>，为了消除数量级数据带来的影响，需要对数据做<code>标准化处理</code>。</p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/ACVA_Stadert_table.png"></p><p>这里使用 <code>sklearn</code>模块中的 <code>StandardScaler</code>类来自动标准化数据，然后我们将标准化后的数据再转成<code>pandas</code>表格，最后储存到临时文件<code>airline_scale.xlsx</code>中</p><blockquote><p>LRFMC.py</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">storeStandData</span>(<span class="params">self,airline_features</span>):</span><br><span class="line">    data = StandardScaler().fit_transform(airline_features)</span><br><span class="line">    SDF = pd.DataFrame(data);  <span class="comment">#获取 standardDataFrame(SDF)</span></span><br><span class="line">    SDF = SDF.rename(columns=&#123;<span class="number">0</span>:<span class="string">&quot;L&quot;</span>,<span class="number">1</span>:<span class="string">&quot;F&quot;</span>,<span class="number">2</span>:<span class="string">&quot;R&quot;</span>,<span class="number">3</span>:<span class="string">&quot;C&quot;</span>,<span class="number">4</span>:<span class="string">&quot;M&quot;</span>&#125;)</span><br><span class="line">    self.log(LOG_INFO,<span class="string">&quot;标准化后的前五行的LRFMC五个特征为\n&quot;</span>,SDF.head())</span><br><span class="line">    SDF.to_excel(<span class="string">&quot;../tmp/airline_scale.xlsx&quot;</span>)  <span class="comment">##储存值tmp文件夹</span></span><br></pre></td></tr></table></figure><p>前五行标准化前后的结果如下</p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/acva_sta_raw.png"></p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/ACVA_STA.png"></p><h2 id="了解和使用K-Means聚类算法"><a href="#了解和使用K-Means聚类算法" class="headerlink" title="了解和使用K-Means聚类算法"></a>了解和使用<code>K-Means</code>聚类算法</h2><p>即使经过了一系列预处理和模型建模，我们手上的数据依然还是比较原始，只有经过分类过的数据才更有分析价值，而自然数据一般都难以直接分类，需要用聚类算法进行分类，这里就用到了<code>K-Means</code>聚类算法</p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>K-Means聚类算法是一种基于质心的划分方法，输入聚类个数k，以及包含n个数据对象的数据库，输出满足误差平方和最小标准的k个聚类。算法步骤如下:</p><ul><li>从n个样本数据中随机选取k个对象作为初始的聚类中心。</li><li>分别计算每个样本到各个聚类质心的距离，将样本分配到距离最近的那个聚类中心类别中。</li><li>所有样本分配完成后，重新计算k个聚类的中心。</li><li>与前一次计算得到的k个聚类中心比较，如果聚类中心发生变化，转(2)，否则转(5)。</li><li>当质心不发生变化时停止并输出聚类结果。</li></ul><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/ACVA_KMEANS.png"></p><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>K-Means聚类算法是在数值类型数据的基础上进行研究，然而数据分析的样本复杂多样，因此要求不仅能够对特征为数值类型的数据进行分析，还要适应数据类型的变化，对不同特征做不同变换，以满足算法的要求。</p><h3 id="获取KMeans对象"><a href="#获取KMeans对象" class="headerlink" title="获取KMeans对象"></a>获取KMeans对象</h3><p>sklearn的cluster模块提供了KMeans函数构建K-Means聚类模型</p><p>翻阅其源代码(下图)，可以看到<code>KMeans</code>是一个<strong>类</strong>，且构造函数有大量缺省参数，因此实例化<code>KMeans</code>对象时，只需提供无缺省的参数，和调整关键缺省参数即可</p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/K-Means_org.png"></p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/ACVA_Kmeans_para.png"></p><p>这里我们只显式传参<code>n_clusters</code>和<code>random_state</code>,其中后一个参数用时间戳</p><p>因为本身<code>KMeans</code>就封装地很好，这部分代码就写在<code>main.py</code>的主逻辑中</p><blockquote><p>main.py</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 对象实例化</span></span><br><span class="line">k = <span class="number">5</span> <span class="comment">## 确定聚类中心数，这里我们预期聚类5类客户</span></span><br><span class="line">kmeans_model = KMeans(n_clusters=k,random_state=<span class="built_in">int</span>(time.time()))  <span class="comment"># 实例化对象</span></span><br><span class="line">kmeans_model = kmeans_model.fit(airline_scale)  <span class="comment"># 用准备好的数据训练模型</span></span><br><span class="line">centers = kmeans_model.cluster_centers_</span><br><span class="line">log(LOG_INFO,<span class="string">&quot;五个聚类中心为\n&quot;</span>,centers)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 统计不同类别样本的数目</span></span><br><span class="line">r1 = pd.Series(kmeans_model.labels_).value_counts()</span><br><span class="line">log(LOG_INFO,<span class="string">&quot;最终每个类别的数目为\n&quot;</span>,r1)</span><br></pre></td></tr></table></figure><p>最后聚类的结果类似下表</p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/ACVA_CLUSTER_RES.png"></p><p>至此数据的分析，建模和聚类已经完成，数据处理部分告一段落，接下来是可视化处理</p><h2 id="可视化雷达图"><a href="#可视化雷达图" class="headerlink" title="可视化雷达图"></a>可视化雷达图</h2><p>这里使用<code>matplotlib.pyplot</code>模块作图，<code>numpy</code>二次处理数据,封装代码到<code>RadarDrawer</code>类中并用<code>__call__</code>重载<code>()</code>操作符</p><p>值得注意的是:</p><ul><li>因为这里使用了雷达图，所以绘制图形时使用<code>极坐标</code>会更方便</li><li>因为这里使用了中文文字，而默认字体不支持中文，会报错，所以要<strong>提前设置中文字体</strong></li></ul><blockquote><p>radar_chart.py</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RadarDrawer</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, kmeans_moudel, n_clusters</span>):</span><br><span class="line">        <span class="comment"># 设置支持中文的字体</span></span><br><span class="line">        plt.rc(<span class="string">&quot;font&quot;</span>,family=<span class="string">&quot;Microsoft YaHei&quot;</span>)</span><br><span class="line">        <span class="comment"># 标签</span></span><br><span class="line">        labels = np.array([<span class="string">u&#x27;ZL&#x27;</span>,<span class="string">u&#x27;ZR&#x27;</span>,<span class="string">u&#x27;ZF&#x27;</span>,<span class="string">u&#x27;ZM&#x27;</span>,<span class="string">u&#x27;ZC&#x27;</span>])</span><br><span class="line"></span><br><span class="line">        plot_data = kmeans_moudel.cluster_centers_</span><br><span class="line">        <span class="comment"># 指定颜色</span></span><br><span class="line">        color = [<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;g&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;y&#x27;</span>]</span><br><span class="line">        <span class="comment"># 计算雷达图的角度</span></span><br><span class="line">        angles = np.linspace(<span class="number">0</span>,<span class="number">2</span>*np.pi,n_clusters,endpoint=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 闭合(首尾列相同) 并用np把pandas的DataFrame转成原生数组</span></span><br><span class="line">        plot_data = np.concatenate((plot_data,plot_data[:,[<span class="number">0</span>]]),axis = <span class="number">1</span>)</span><br><span class="line">        angles_org = angles</span><br><span class="line">        angles = np.concatenate((angles,[angles[<span class="number">0</span>]]))</span><br><span class="line"></span><br><span class="line">        fig = plt.figure(figsize=(<span class="number">6</span>,<span class="number">6</span>),dpi = <span class="number">160</span>)</span><br><span class="line">        <span class="comment">#polar参数</span></span><br><span class="line">        ax = fig.add_subplot(<span class="number">111</span>, polar=<span class="literal">True</span>)  <span class="comment"># 设置坐标为极坐标</span></span><br><span class="line">        <span class="comment"># 画若干个五边形</span></span><br><span class="line">        floor = np.floor(plot_data.<span class="built_in">min</span>())   <span class="comment"># 大于最小值的最大整数</span></span><br><span class="line">        ceil = np.ceil(plot_data.<span class="built_in">max</span>())     <span class="comment"># 小于最小值的最小整数</span></span><br><span class="line">        n = <span class="built_in">len</span>(labels)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> np.arange(floor,ceil+<span class="number">0.5</span>, <span class="number">0.5</span>):</span><br><span class="line">            ax.plot(angles,[i] *(n+<span class="number">1</span>),<span class="string">&#x27;-.&#x27;</span>,lw=<span class="number">0.5</span>,color=<span class="string">&#x27;black&#x27;</span>)</span><br><span class="line">        <span class="comment"># 话不同客户群的分割线</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(plot_data)):</span><br><span class="line">            ax.plot(angles,plot_data[i],color = color[i],</span><br><span class="line">                    label=<span class="string">&#x27;客户群&#x27;</span>+<span class="built_in">str</span>(i+<span class="number">1</span>),linewidth=<span class="number">2</span>, linestyle=<span class="string">&#x27;-.&#x27;</span>)</span><br><span class="line">        ax.set_rgrids(np.arange(<span class="number">0</span>,<span class="number">2.5</span>, <span class="number">0.5</span>))  <span class="comment"># 画出每层的权重</span></span><br><span class="line">        ax.set_thetagrids(angles_org* <span class="number">180</span>/np.pi,labels)  <span class="comment"># 设置显示的角度为度数制</span></span><br><span class="line">        plt.legend(loc=<span class="string">&#x27;lower right&#x27;</span>,bbox_to_anchor=(<span class="number">1.1</span>, -<span class="number">0.1</span>))  <span class="comment">#设置图例位置在画布外</span></span><br><span class="line">        <span class="comment">#plt.legend()</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#ax.set_theta_zero_location(&#x27;N&#x27;)         # 设置极坐标的起点（即0°）在正北方向</span></span><br><span class="line">        ax.spines[<span class="string">&#x27;polar&#x27;</span>].set_visible(<span class="literal">False</span>)   <span class="comment"># 不显示极坐标最外面的圈</span></span><br><span class="line">        ax.grid(<span class="literal">False</span>)                          <span class="comment"># 不显示默认分割线</span></span><br><span class="line">        plt.savefig(<span class="string">&quot;../tmp/ACVA_img.png&quot;</span>)      <span class="comment"># 储存图像的临时文件</span></span><br><span class="line">        plt.show()</span><br></pre></td></tr></table></figure><h2 id="重新组织main-py"><a href="#重新组织main-py" class="headerlink" title="重新组织main.py"></a>重新组织main.py</h2><p>至此所有的功能已经实现，并封装到了各个模块和类中，所以我们再重新组织一次<code>main.py</code>，并最终定档其中的代码</p><blockquote><p>main.py</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">######### 主程序入口 #############</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> KMeans</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> log <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> data_clean <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LRFMC <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> radar_chart <span class="keyword">import</span>  *</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"></span><br><span class="line">    log = Log()  <span class="comment"># 实例化一个日志器</span></span><br><span class="line">    data_cleaner = DataCleaner() <span class="comment">#实例化数据清洗器</span></span><br><span class="line">    LRFMCobj = LRFMC() <span class="comment"># 实例化模型处理器</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 从数据源获取数据</span></span><br><span class="line">    airline_data = pd.read_csv(<span class="string">&quot;../data_raw/air_data.csv&quot;</span>,</span><br><span class="line">        encoding=<span class="string">&quot;gb18030&quot;</span>)  <span class="comment"># 导入航空数据</span></span><br><span class="line">    log(LOG_INFO,<span class="string">&#x27;原始数据的形状为：&#x27;</span>, airline_data.shape)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#数据预处理</span></span><br><span class="line">    <span class="comment">## 缺失值处理：去除票价为空的记录</span></span><br><span class="line">    airline_notnull = data_cleaner.notNull(airline_data)</span><br><span class="line">    log(LOG_INFO,<span class="string">&#x27;删除缺失记录后数据的形状为：&#x27;</span>, airline_notnull.shape)</span><br><span class="line"></span><br><span class="line">    <span class="comment">## 异常值处理: 只保留票价非零的，或者平均折扣率不为0且总飞行公里数大于0的记录。</span></span><br><span class="line">    airline = data_cleaner.notOutlier(airline_notnull)</span><br><span class="line">    log(LOG_INFO,<span class="string">&#x27;删除异常记录后数据的形状为：&#x27;</span>, airline.shape)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 构建LRFMC五大特征</span></span><br><span class="line">    airline_features = LRFMCobj.getFeatures(airline)</span><br><span class="line">    LRFMCobj.storeStandData(airline_features)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取KMeans对象</span></span><br><span class="line">    <span class="comment">## 准备数据</span></span><br><span class="line">    airline_scale = pd.read_excel(<span class="string">&quot;../tmp/airline_scale.xlsx&quot;</span>)</span><br><span class="line">    airline_scale = airline_scale.iloc[:,<span class="number">1</span>:]  <span class="comment"># 切掉第一列的作为行数标志的数字</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">## 对象实例化</span></span><br><span class="line">    k = <span class="number">5</span> <span class="comment">## 确定聚类中心数，这里我们预期聚类5类客户</span></span><br><span class="line">    kmeans_model = KMeans(n_clusters=k,random_state=<span class="built_in">int</span>(time.time()))  <span class="comment"># 实例化对象</span></span><br><span class="line">    kmeans_model = kmeans_model.fit(airline_scale)  <span class="comment"># 用准备好的数据训练模型</span></span><br><span class="line">    centers = kmeans_model.cluster_centers_</span><br><span class="line">    log(LOG_INFO,<span class="string">&quot;五个聚类中心为\n&quot;</span>,centers)</span><br><span class="line"></span><br><span class="line">    <span class="comment">## 统计不同类别样本的数目</span></span><br><span class="line">    r1 = pd.Series(kmeans_model.labels_).value_counts()</span><br><span class="line">    log(LOG_INFO,<span class="string">&quot;最终每个类别的数目为\n&quot;</span>,r1)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 作出图样</span></span><br><span class="line">    RadarDrawer()(kmeans_model,n_clusters=k)</span><br><span class="line">    log(LOG_INFO,<span class="string">&quot;完成作图&quot;</span>)</span><br></pre></td></tr></table></figure><p>可以看到，经过一系列封装，<code>main.py</code>只有寥寥50多行，确已经体现了主要的 业务逻辑</p><h1 id="分析聚类结果"><a href="#分析聚类结果" class="headerlink" title="分析聚类结果"></a>分析聚类结果</h1><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/ACVA_output.png"></p><p>基于特征描述，本项目定义五个等级的客户类别：重要保持客户，重要发展客户，重要挽留客户，一般客户，低价值客户</p><h1 id="模型应用"><a href="#模型应用" class="headerlink" title="模型应用"></a>模型应用</h1><p>根据对各个客户群进行特征分析，采取下面的一些营销手段和策略，为航空公司的价值客户群管理提供参考</p><ul><li><code>会员的升级与保级</code>：航空公司可以在对会员升级或保级进行评价的时间点之前，对那些接近但尚未达到要求的较高消费客户进行适当提醒甚至采取一些促销活动，刺激他们通过消费达到相应标准。这样既可以获得收益，同时也提高了客户的满意度，增加了公司的精英会员。</li><li><code>首次兑换</code>：采取的措施是从数据库中提取出接近但尚未达到首次兑换标准的会员，对他们进行提醒或促销，使他们通过消费达到标准。一旦实现了首次兑换，客户在本公司进行再次消费兑换就比在其他公司进行兑换要容易许多，在一定程度上等于提高了转移的成本。</li><li><code>交叉销售</code>：通过发行联名卡等与非航空类企业的合作，使客户在其他企业的消费过程中获得本公司的积分，增强与公司的联系，提高他们的忠诚度。</li></ul><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本项目结合航空公司客户价值分析的案例，重点介绍了数据分析算法中K-Means聚类算法在客户价值分析中的应用。针对RFM客户价值分析模型的不足，使用K-Means算法构建了航空客户价值分析LRFMC模型，详细描述了数据分析的整个过程。</p><h1 id="github项目文件-和-相关外部链接"><a href="#github项目文件-和-相关外部链接" class="headerlink" title="github项目文件 和 相关外部链接"></a>github项目文件 和 相关外部链接</h1><p><a href="https://github.com/sis-shen/ACVA">戳我去github仓库🔗</a></p><p><a href="https://github.com/scikit-learn/scikit-learn/blob/fd237278e/sklearn/cluster/_kmeans.py#L745">戳我去KMeans源码🔗</a></p><p><a href="https://pandas.pydata.org/docs/">戳我去pandas文档下载🔗</a></p><p><a href="https://matplotlib.org/stable/api/index">戳我去matplotlib的API文档🔗</a></p><p><a href="https://numpy.org/doc/stable/">戳我去numpy文档🔗</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>手撕红黑树</title>
      <link href="/2024/09/03/RBTree/"/>
      <url>/2024/09/03/RBTree/</url>
      
        <content type="html"><![CDATA[<h1 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h1><p>虽然<code>AVL树</code>作为绝对的平衡搜索二叉树，有着极高的查询效率，但正因为其严格的要求，修改<code>AVL树</code>的某个结点时，可能要一路调整到根节点，效率低下。为了解决这一痛点，略微没那么严格的<strong>近似平衡搜索二叉树</strong>，即<code>红黑树</code>被提出</p><h2 id="红黑树的概念"><a href="#红黑树的概念" class="headerlink" title="红黑树的概念"></a>红黑树的概念</h2><p>红黑树，是一种二叉搜索树，但在每个结点上<code>增加一个存储位表示结点的颜色</code>，可以是<code>Red</code>或<code>Black</code>。 通过对任何一条从根到叶子的路径上各个结点着色方式的限制，<strong>红黑树确保没有一条路径会比其他路径长出俩倍</strong>，因而是<strong>接近平衡</strong>的。</p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/RBTree_RBT.png"></p><h2 id="红黑树的性质"><a href="#红黑树的性质" class="headerlink" title="红黑树的性质"></a>红黑树的性质</h2><p>首先与一般的定义不同，在红黑树中将<code>空指针</code>(上图为<code>NIL</code>)作为<code>叶子节点</code>,然后我们来讨论具体的性质</p><ol><li>每个结点不是<code>红色</code>就是<code>黑色</code></li><li>根节点必定是<code>黑色</code>的</li><li>如果一个结点是<code>红色</code>的,则它的两个<strong>孩子结点</strong>是<code>黑色</code>的</li><li>对于每个结点，该结点到其所有后代叶结点的简单路径上，均包含<strong>相同数目</strong>的<code>黑色</code>结点</li><li>每个<strong>叶子结点</strong>都是<code>黑色</code>的此处的叶子结点指的是<code>空结点NIL</code></li></ol><p><strong>思考：为什么满足上面的性质，红黑树就能保证：其最长路径中节点个数不会超过最短路径节点个数的两倍？</strong></p><blockquote><p>红黑树的性质保证了从根节点到所有叶子结点（空结点）的路径上，<strong>包含相同数量的黑色结点</strong>。这是红黑树平衡性的重要保证，以下是如何保证最长路径不会超过最短路径两倍的具体解释：</p><ol><li>黑色高度的定义：</li></ol><ul><li>对于红黑树中的每个结点，定义其黑色高度为从该结点到叶子结点的路径上黑色结点的数量。根据性质 4，这个数量在所有路径上都是相同的。</li><li>设定黑色高度为<code>h</code>。那么从根到任意叶子结点的路径都包含<code>h</code>个黑色结点。</li></ul><ol start="2"><li>红色结点的插入：</li></ol><ul><li>根据性质3，如果一个结点是红色的，则它的两个孩子结点是黑色的。这就意味着每个红色结点必定有两个黑色的孩子。</li><li>因此，从根到叶子结点的路径上，红色结点与黑色结点交替出现，红色结点之间的路径长度会相对较短。</li></ul><ol start="3"><li>路径长度的关系：</li></ol><ul><li>根到一个叶子结点的路径的最长可能路径是最短路径的两倍。这是因为每个红色结点都在路径上增加了一个额外的层级，但它们只增加了一个红色结点的高度，而黑色结点的数量不变。</li><li>如果某条路径上有 <code>r</code> 个红色结点，那么该路径的总长度将是 <code>h + r</code>，其中 <code>h</code> 是黑色结点的数量。因为红色结点的数量 <code>r</code> 可以最大等于 <code>h</code>，所以最长路径的长度 <code>h + r</code>最大为 <code>2h</code>，即<strong>最长路径的长度不会超过最短路径的两倍</strong>。</li></ul></blockquote><h2 id="红黑树的实现"><a href="#红黑树的实现" class="headerlink" title="红黑树的实现"></a>红黑树的实现</h2><p>这里我们仿照<code>STL30</code>的源码,再用更简洁易懂的代码形式实现红黑树,<em>比如节点和迭代器的双层设计，这里就不使用了</em></p><h3 id="红黑树结点"><a href="#红黑树结点" class="headerlink" title="红黑树结点"></a>红黑树结点</h3><ul><li>因为要经常访问父结点，所以这里用三叉链表维护树结构</li><li>红黑树的节点需要一个变量表示颜色，这里用<code>typedef</code>把<code>bool</code>类型封装为<code>Color</code>类</li><li>使用模板来存储泛类型的值</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">bool</span> Color;<span class="comment">//只有红黑两种颜色，正好使用bool类型</span></span><br><span class="line"><span class="type">const</span> Color Red = <span class="literal">false</span>;<span class="comment">//定义两种颜色</span></span><br><span class="line"><span class="type">const</span> Color Black = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//红黑树结点的定义</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ValueType</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">RBTreeNode</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">typedef</span> RBTreeNode&lt;ValueType&gt; Node;<span class="comment">//简化代码</span></span><br><span class="line">Node* _left;</span><br><span class="line">Node* _right;</span><br><span class="line">Node* _parent;</span><br><span class="line">Color _color;</span><br><span class="line"></span><br><span class="line">ValueType _value;</span><br><span class="line"><span class="built_in">RBTreeNode</span>(<span class="type">const</span> ValueType&amp; val, Color color)</span><br><span class="line">:_value(val)</span><br><span class="line">, _color(color)</span><br><span class="line">, _left(<span class="literal">nullptr</span>)</span><br><span class="line">, _right(<span class="literal">nullptr</span>)</span><br><span class="line">, _parent(<span class="literal">nullptr</span>)</span><br><span class="line">&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="红黑树的基本结构"><a href="#红黑树的基本结构" class="headerlink" title="红黑树的基本结构"></a>红黑树的基本结构</h3><ul><li>模板参数:红黑树也是<code>KV</code>类型的二叉树，所以模板参数有:<ul><li><code>K</code>:即Key,节点使用<code>K</code>类型的参数比较</li><li><code>V</code>:即ValueType,构造红黑树结点时传入的模板参数</li><li><code>KeyOfValue</code>:因为节点将<code>Key</code>值也存在了节点的值域，所以需要外部传入<code>仿函数KeyOfValue</code>将Key值取出</li><li><code>Compare</code>:允许外部自定义<code>K类型</code>的比较规则</li></ul></li><li>typedef封装:<ul><li><code>typedef RBTreeNode&lt;V&gt; Node;</code></li></ul></li><li>私有成员变量:<ul><li><code>Compare _cmp</code>:声明一个仿函数成员变量，整个对象里都能直接调用</li><li><code>KeyOfValue _kof</code>:用处同上</li><li><code>Node* _header</code></li></ul></li><li>默认构造函数：<ul><li>使用缺省传入<code>const Compare&amp;</code>类型定义的<code>std::greater&lt;K&gt;()</code>临时对象</li><li>创建哨兵位作为头结点，使后续对根结点的调整与一般情况统一</li></ul></li><li>私有函数<code>GetRoot()</code> <code>left()</code> <code>right()</code><ul><li>将对根节点的获取封装起来，使代码更直观</li><li>简化代码，获取左右子树</li></ul></li></ul><p>至于迭代器的封装，我们在<a href="#iterator">后文实现</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">K</span>,<span class="keyword">class</span> <span class="title class_">V</span>,<span class="keyword">class</span> <span class="title class_">KeyOfValue</span>,<span class="keyword">class</span> <span class="title class_">Compare</span> = std::greater&lt;<span class="type">int</span>&gt; &gt;</span><br><span class="line"><span class="keyword">class</span> RBTree</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">typedef</span> RBTreeNode&lt;V&gt; Node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">RBTree</span>(<span class="type">const</span> Compare&amp; cmp =<span class="built_in">Compare</span>())</span><br><span class="line">:_cmp(cmp), _header(<span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//创建哨兵位头结点，使后面调整树形状不用区分根节点</span></span><br><span class="line">_header = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="built_in">V</span>(), Black);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function">Node* <span class="title">GetRoot</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (_header-&gt;_parent == _header)<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> _header-&gt;_parent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node* <span class="title">SetRoot</span><span class="params">(Node* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">root-&gt;_parent = _header;</span><br><span class="line">_header-&gt;_parent = root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node* <span class="title">left</span><span class="params">(Node* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">return</span> root-&gt;_left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node* <span class="title">right</span><span class="params">(Node* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">return</span> root-&gt;_right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Compare _cmp;</span><br><span class="line">KeyOfValue _kof;</span><br><span class="line">Node* _header;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="红黑树的插入"><a href="#红黑树的插入" class="headerlink" title="红黑树的插入"></a>红黑树的插入</h3><p>和<code>AVL树</code>一样，红黑树的插入也分为两步<code>新增结点</code>和<code>调整</code></p><h4 id="新增结点"><a href="#新增结点" class="headerlink" title="新增结点"></a>新增结点</h4><p>关于根结点的颜色，前面的<a href="#%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8">规定性质</a>里也说了，根节点为黑色，这里在重申一下为什么一定是黑色</p><blockquote><ol><li>简化性质的维护：根节点为黑色可以简化在插入和删除操作后维持红黑树性质的过程。特别是在插入节点时，新的节点（通常为红色）可能违反了红黑树的性质。根节点为黑色确保了在树的高度平衡和黑色节点数量保持一致的情况下，维护这些性质更加容易。</li><li>平衡树的高度：红黑树的性质确保了树的高度约为 ( \log(n) )，其中 ( n ) 是树中节点的数量。通过将根节点设为黑色，红黑树的黑色高度（从根到所有叶子节点的黑色节点数目）得到保证，从而有助于维护树的平衡。</li><li>避免违反性质：如果根节点允许是红色，可能会导致在某些情况下难以保证红色节点的数量平衡，特别是在连续插入和删除操作之后。将根节点设为黑色可以避免这种复杂情况，从而简化了实现和维护过程。</li></ol></blockquote><p>首先我们先写个<code>Find</code>函数防止插入重复数据</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Find</span><span class="params">(<span class="type">const</span> K&amp; key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Node* prev = <span class="literal">nullptr</span>;</span><br><span class="line">Node* cur = <span class="built_in">GetRoot</span>();</span><br><span class="line"><span class="keyword">while</span> (cur)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (_cmp(_kof(cur-&gt;_value), key))<span class="comment">//相等或在左子树</span></span><br><span class="line">&#123;</span><br><span class="line">prev = cur;</span><br><span class="line">cur = <span class="built_in">left</span>(cur);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cur = <span class="built_in">right</span>(cur);<span class="comment">//可能在右子树</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (prev == <span class="literal">nullptr</span> || _cmp(_kof(prev-&gt;_value),key))<span class="comment">//一直向右走或一直向左走</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//走到头的过程中左转了一次之后一直向右走</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于新结点（非根）的颜色,这里规定为<code>红色</code>，使新结点对红黑树中<code>黑树</code>高度的影响最小</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Node* proot = <span class="built_in">GetRoot</span>();</span><br><span class="line"><span class="keyword">if</span> (proot == <span class="literal">nullptr</span>)<span class="comment">//树为空</span></span><br><span class="line">&#123;</span><br><span class="line">Node* newnode = <span class="keyword">new</span> <span class="built_in">Node</span>(value, Black);</span><br><span class="line">newnode-&gt;_parent = _header;</span><br><span class="line">_header-&gt;_parent = newnode;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Find</span>(_kof(value)))<span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//结点已存在，插入失败</span></span><br><span class="line">Node* cur = proot;</span><br><span class="line">Node* parent = proot-&gt;_parent;</span><br><span class="line"><span class="keyword">while</span> (cur)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (_cmp(_kof(cur-&gt;_value), _kof(value)))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//插在左子树</span></span><br><span class="line">parent = cur;</span><br><span class="line">cur = <span class="built_in">left</span>(cur);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//插在右子树</span></span><br><span class="line">parent = cur;</span><br><span class="line">cur = <span class="built_in">right</span>(cur);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//开始插入</span></span><br><span class="line">Node* newnode = <span class="keyword">new</span> <span class="built_in">Node</span>(value, Red);</span><br><span class="line"><span class="keyword">if</span> (_cmp(_kof(parent-&gt;_value),_kof(value) ))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//插入右子树</span></span><br><span class="line">parent-&gt;_left = newnode;</span><br><span class="line">newnode-&gt;_parent = parent;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">parent-&gt;_right = newnode;</span><br><span class="line">newnode-&gt;_parent = parent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//开始调整</span></span><br><span class="line"><span class="comment">//.......</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="调整红黑树"><a href="#调整红黑树" class="headerlink" title="调整红黑树"></a>调整红黑树</h4><p>每次新节点插入后，都要检测红黑树的性质是否造到破坏</p><p>因为新节点的默认颜色是红色，因此：如果其双亲节点的颜色是黑色，没有违反红黑树任何性质，则不需要调整；但当新插入节点的双亲节点颜色为红色时，就违反了性质三<code>不能有连在一起的红色节点</code>，此时需要对红黑树分情况来讨论:</p><p><strong>约定</strong> <strong><code>cur</code>当前结点,<code>parent</code>为父结点,<code>uncle</code>为叔叔结点,<code>gp</code>为祖父结点</strong></p><h5 id="情况一：直接染色"><a href="#情况一：直接染色" class="headerlink" title="情况一：直接染色"></a>情况一：直接染色</h5><ul><li><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/RBTREE_1.png"></li><li>可以看到这种情况只需染色即可,将<code>gp</code>染色为红色，防止整棵树的<code>黑树高度</code>改变0</li><li>不过当该树为整棵树而不是子树时，根节点(<code>gp</code>)在最后还需染色回黑色（这里留到所有调整的最后）</li><li>当该树为子树，即<code>gp</code>存在父结点时，因为<code>gp</code>变为了红色，还需继续向上调整</li><li><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/RBTREE_1_1.png"></li></ul><h5 id="情况二：单次旋转-染色"><a href="#情况二：单次旋转-染色" class="headerlink" title="情况二：单次旋转+染色"></a>情况二：单次旋转+染色</h5><ul><li><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/RBTREE_2.png"></li><li>图中<code>uncle</code>的情况有两种<ul><li>如果<code>uncle</code>节点不存在，则<code>cur</code>一定是<strong>新插入节点</strong>，因为如果<code>cur</code>不是新插入节点，则<code>cur</code>和<code>parent</code>一定有一个节点的颜色是黑色，就不满足性质4：每条路径黑色节点个数相同。</li><li>如果<code>uncle</code>节点存在，则其一定是黑色的，那么<code>cur</code>节点原来的颜色一定是黑色的，现在看到其是红色的原因是因为<code>cur</code>的子树在<strong>调整的过程中</strong>将<code>cur</code>节点的颜色由黑色改成红色。</li></ul></li><li>调整步骤：<ul><li><code>parent</code>为<code>pg</code>的左孩子，<code>cur</code>为<code>parent</code>的左孩子，则进行右单旋转</li><li><code>parent</code>为<code>pg</code>的右孩子，<code>cur</code>为<code>parent</code>的右孩子，则进行左单旋转</li><li><code>parent</code>-&gt;黑色</li><li><code>pg</code>-&gt;红色</li></ul></li></ul><h5 id="情况三：两次旋转"><a href="#情况三：两次旋转" class="headerlink" title="情况三：两次旋转"></a>情况三：两次旋转</h5><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/RBTREE_3.png"></p><ul><li>如图，一次旋转后变成了<strong>情况二</strong>,所以总共要旋转两次<ul><li><code>parent</code>为<code>gp</code>的左孩子，<code>cur</code>为<code>parent</code>的右孩子，则针对<code>parent</code>做左单旋转</li><li><code>pparent</code>为<code>gp</code>的右孩子，<code>cur</code>为<code>parent</code>的左孩子，则针对<code>parent</code>做右单旋转</li></ul></li><li>变成情况二后按情况二处理即可</li></ul><h5 id="封装代码"><a href="#封装代码" class="headerlink" title="封装代码"></a>封装代码</h5><p>旋转操作的代码量较大，我们选择封装到成员函数中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RotateR</span><span class="params">(Node* node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (node == <span class="literal">nullptr</span>)<span class="built_in">assert</span>(<span class="literal">false</span>);</span><br><span class="line">Node* cur = node;</span><br><span class="line">Node* parent = cur-&gt;_parent;</span><br><span class="line"><span class="keyword">if</span> (parent == <span class="literal">nullptr</span>) <span class="built_in">assert</span>(<span class="literal">false</span>);</span><br><span class="line">Node* gp = parent-&gt;_parent;</span><br><span class="line"><span class="keyword">if</span> (gp == <span class="literal">nullptr</span>) <span class="built_in">assert</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//调整树结构</span></span><br><span class="line">Node* ggp = gp-&gt;_parent;</span><br><span class="line"><span class="keyword">if</span> (gp == ggp-&gt;_left)ggp-&gt;_left = parent;</span><br><span class="line"><span class="keyword">else</span> ggp-&gt;_right = parent;</span><br><span class="line">parent-&gt;_parent = ggp;</span><br><span class="line"></span><br><span class="line">gp-&gt;_left = parent-&gt;_right;</span><br><span class="line"><span class="keyword">if</span> (parent-&gt;_right)parent-&gt;_right-&gt;_parent = gp;</span><br><span class="line">parent-&gt;_right = gp;</span><br><span class="line">gp-&gt;_parent = parent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (gp == <span class="built_in">GetRoot</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">SetRoot</span>(parent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//染色</span></span><br><span class="line">parent-&gt;_color = Black;</span><br><span class="line">gp-&gt;_color = Red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RotateL</span><span class="params">(Node* node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Node* cur = node;</span><br><span class="line"><span class="keyword">if</span> (cur == <span class="literal">nullptr</span>)<span class="built_in">assert</span>(<span class="literal">false</span>);</span><br><span class="line">Node* parent = cur-&gt;_parent;</span><br><span class="line"><span class="keyword">if</span> (parent == <span class="literal">nullptr</span>)<span class="built_in">assert</span>(<span class="literal">false</span>);</span><br><span class="line">Node* gp = parent-&gt;_parent;</span><br><span class="line"><span class="keyword">if</span> (gp == <span class="literal">nullptr</span>)<span class="built_in">assert</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//调整树结构</span></span><br><span class="line">Node* ggp = gp-&gt;_parent;</span><br><span class="line"><span class="keyword">if</span> (ggp-&gt;_left == gp) ggp-&gt;_left = parent;</span><br><span class="line"><span class="keyword">else</span> ggp-&gt;_right = parent;</span><br><span class="line">parent-&gt;_parent = ggp;</span><br><span class="line"></span><br><span class="line">gp-&gt;_right = parent-&gt;_left;</span><br><span class="line"><span class="keyword">if</span> (parent-&gt;_left)parent-&gt;_left-&gt;_parent = gp;</span><br><span class="line">parent-&gt;_left = gp;</span><br><span class="line">gp-&gt;_parent = parent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (gp == <span class="built_in">GetRoot</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">SetRoot</span>(parent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//染色</span></span><br><span class="line">parent-&gt;_color = Black;</span><br><span class="line">gp-&gt;_color = Red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RotateLR</span><span class="params">(Node* node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Node* cur = node;</span><br><span class="line"><span class="keyword">if</span> (cur == <span class="literal">nullptr</span>)<span class="built_in">assert</span>(<span class="literal">false</span>);</span><br><span class="line">Node* parent = cur-&gt;_parent;</span><br><span class="line"><span class="keyword">if</span> (parent == <span class="literal">nullptr</span>)<span class="built_in">assert</span>(<span class="literal">false</span>);</span><br><span class="line">Node* gp = parent-&gt;_parent;</span><br><span class="line"><span class="keyword">if</span> (gp == <span class="literal">nullptr</span>) <span class="built_in">assert</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">parent-&gt;_right = cur-&gt;_left;</span><br><span class="line"><span class="keyword">if</span> (cur-&gt;_left)cur-&gt;_left-&gt;_parent = parent;</span><br><span class="line">cur-&gt;_left = parent;</span><br><span class="line">parent-&gt;_parent = cur;</span><br><span class="line">cur-&gt;_parent = gp;</span><br><span class="line">gp-&gt;_left = cur;</span><br><span class="line"></span><br><span class="line"><span class="built_in">RotateR</span>(parent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RotateRL</span><span class="params">(Node* node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Node* cur = node;</span><br><span class="line"><span class="keyword">if</span> (cur == <span class="literal">nullptr</span>)<span class="built_in">assert</span>(<span class="literal">false</span>);</span><br><span class="line">Node* parent = cur-&gt;_parent;</span><br><span class="line"><span class="keyword">if</span> (parent == <span class="literal">nullptr</span>)<span class="built_in">assert</span>(<span class="literal">false</span>);</span><br><span class="line">Node* gp = parent-&gt;_parent;</span><br><span class="line"><span class="keyword">if</span> (gp == <span class="literal">nullptr</span>) <span class="built_in">assert</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">parent-&gt;_left = cur-&gt;_right;</span><br><span class="line"><span class="keyword">if</span> (cur-&gt;_right)cur-&gt;_right-&gt;_parent = parent;</span><br><span class="line">cur-&gt;_right = parent;</span><br><span class="line">parent-&gt;_parent = cur;</span><br><span class="line">cur-&gt;_parent = gp;</span><br><span class="line">gp-&gt;_right = cur;</span><br><span class="line"></span><br><span class="line"><span class="built_in">RotateL</span>(parent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后将<code>Insert</code>函数补充完整</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Insert</span><span class="params">(<span class="type">const</span> V&amp; value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Node* proot = <span class="built_in">GetRoot</span>();</span><br><span class="line"><span class="keyword">if</span> (proot == <span class="literal">nullptr</span>)<span class="comment">//树为空</span></span><br><span class="line">&#123;</span><br><span class="line">Node* newnode = <span class="keyword">new</span> <span class="built_in">Node</span>(value, Black);</span><br><span class="line">newnode-&gt;_parent = _header;</span><br><span class="line">_header-&gt;_parent = newnode;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Find</span>(_kof(value)))<span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//结点已存在，插入失败</span></span><br><span class="line">Node* cur = proot;</span><br><span class="line">Node* parent = proot-&gt;_parent;</span><br><span class="line"><span class="keyword">while</span> (cur)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (_cmp(_kof(cur-&gt;_value), _kof(value)))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//插在左子树</span></span><br><span class="line">parent = cur;</span><br><span class="line">cur = <span class="built_in">left</span>(cur);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//插在右子树</span></span><br><span class="line">parent = cur;</span><br><span class="line">cur = <span class="built_in">right</span>(cur);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//开始插入</span></span><br><span class="line">Node* newnode = <span class="keyword">new</span> <span class="built_in">Node</span>(value, Red);</span><br><span class="line"><span class="keyword">if</span> (_cmp(_kof(parent-&gt;_value),_kof(value) ))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//插入右子树</span></span><br><span class="line">parent-&gt;_left = newnode;</span><br><span class="line">newnode-&gt;_parent = parent;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">parent-&gt;_right = newnode;</span><br><span class="line">newnode-&gt;_parent = parent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cur = newnode;</span><br><span class="line"><span class="comment">//开始调整</span></span><br><span class="line"><span class="keyword">while</span> (parent != _header &amp;&amp; parent-&gt;_color == Red)</span><br><span class="line">&#123;</span><br><span class="line">Node* gp = parent-&gt;_parent;</span><br><span class="line">Node* uncle = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">if</span> (parent == gp-&gt;_left)uncle = gp-&gt;_right;</span><br><span class="line"><span class="keyword">else</span> uncle = gp-&gt;_left;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (uncle &amp;&amp; uncle-&gt;_color == Red)<span class="comment">//情况一</span></span><br><span class="line">&#123;</span><br><span class="line">parent-&gt;_color = Black;</span><br><span class="line">uncle-&gt;_color = Black;</span><br><span class="line">gp-&gt;_color = Red;</span><br><span class="line"></span><br><span class="line">cur = gp;</span><br><span class="line">parent = gp-&gt;_parent;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (cur == parent-&gt;_left &amp;&amp; parent == gp-&gt;_left)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">RotateR</span>(cur);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (cur == parent-&gt;_right &amp;&amp; parent == gp-&gt;_right)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">RotateL</span>(cur);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (cur == parent-&gt;_right &amp;&amp; parent == gp-&gt;_left)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">RotateLR</span>(cur);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (cur == parent-&gt;_left &amp;&amp; parent == gp-&gt;_right)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">RotateRL</span>(cur);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node* root = <span class="built_in">GetRoot</span>();</span><br><span class="line">root-&gt;_color = Black;<span class="comment">//修改根节点颜色</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="红黑树的删除"><a href="#红黑树的删除" class="headerlink" title="红黑树的删除"></a>红黑树的删除</h3><p><del>让红黑树和进程一起被清理也不是不行</del></p><p><em>under construction</em></p><h3 id="红黑树的验证、高度和遍历"><a href="#红黑树的验证、高度和遍历" class="headerlink" title="红黑树的验证、高度和遍历"></a>红黑树的验证、高度和遍历</h3><p>下面再补充一些获取红黑树参数的接口</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Inorder</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">_Inorder(<span class="built_in">GetRoot</span>());</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;nullptr&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="type">void</span> _Inorder(Node* root)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">_Inorder(root-&gt;_left);</span><br><span class="line">std::cout &lt;&lt; root-&gt;_value &lt;&lt; <span class="string">&quot;-&gt;&quot;</span>;</span><br><span class="line">_Inorder(root-&gt;_right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Height</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _Height(<span class="built_in">GetRoot</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> _Height(Node* root)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> LHeight = _Height(root-&gt;_left);</span><br><span class="line"><span class="type">int</span> RHeight = _Height(root-&gt;_right);</span><br><span class="line"><span class="keyword">if</span> (LHeight &gt; RHeight) <span class="keyword">return</span> LHeight + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> RHeight + <span class="number">1</span>; <span class="comment">//将左右子树相等的情况合并在这里</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsValidRBTree</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Node* root = <span class="built_in">GetRoot</span>();</span><br><span class="line"><span class="keyword">if</span> (root-&gt;_color != Black)<span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//违反根节点染色规则</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> blackCount = <span class="number">0</span>;</span><br><span class="line">Node* cur = root;</span><br><span class="line"><span class="keyword">while</span> (cur)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (cur-&gt;_color == Black) blackCount++;</span><br><span class="line">cur = cur-&gt;_left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">blackCount++;<span class="comment">//cur为nullptr时也算作一个黑节点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> _IsValidRBTree(root,<span class="number">0</span>,blackCount);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="type">bool</span> _IsValidRBTree(Node* root,<span class="type">int</span> cnt,<span class="type">const</span> <span class="type">int</span> blackCount)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">cnt++;</span><br><span class="line"><span class="keyword">if</span> (cnt == blackCount)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//黑色节点数量不相等</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//检测与父结点的染色规则</span></span><br><span class="line"><span class="keyword">if</span> (root-&gt;_color == Red &amp;&amp; root-&gt;_parent-&gt;_color == Red)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="comment">//不能有连续的红色节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (root-&gt;_color == Black) cnt++;</span><br><span class="line"><span class="keyword">return</span> _IsValidRBTree(root-&gt;_left, cnt, blackCount)</span><br><span class="line">&amp;&amp; _IsValidRBTree(root-&gt;_right, cnt, blackCount);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="封装迭代器"><a href="#封装迭代器" class="headerlink" title="封装迭代器"></a>封装迭代器</h3><p>红黑树的迭代器是双向迭代器，所以储存<code>空指针</code>的迭代器没有意义，我们在构造函数上就禁掉用空指针构造</p><h4 id="拷贝构造"><a href="#拷贝构造" class="headerlink" title="拷贝构造"></a><code>拷贝构造</code></h4><p>除了直接构造迭代器，还要提供用<code>const_iterator</code>构造<code>iterator</code>的拷贝构造，而我们依然使用<code>template &lt;class Value,class Ref,class Ptr&gt;</code>作为模板参数，所以要在<code>iterator</code>类型需要在类内手动封装,代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Value</span>,<span class="keyword">class</span> <span class="title class_">Ref</span>,<span class="keyword">class</span> <span class="title class_">Ptr</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">__rbtree_iterator</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">typedef</span> __rbtree_iterator&lt;Value, <span class="type">const</span> Value&amp;, <span class="type">const</span> Value*&gt; const_iterator;</span><br><span class="line"><span class="keyword">typedef</span> __rbtree_iterator&lt;Value, Ref, Ptr&gt; self;</span><br><span class="line"><span class="keyword">typedef</span> RBTreeNode&lt;Value&gt;* linkeType;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">linkType _ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="迭代器的-和–"><a href="#迭代器的-和–" class="headerlink" title="迭代器的++和–"></a>迭代器的++和–</h4><p>迭代器的<code>++</code>和<code>--</code>是按前序遍历的顺序和逆序来访问的，而三叉链表有自己独特的访问方式</p><p><strong><code>++</code></strong></p><ul><li>操作当前结点时，该结点和该节点的左子树已经完成遍历,前序遍历已经走过 <code>左子树</code>-&gt;<code>根</code><ul><li>该节点有右子树时，前序遍历右子树</li><li>该节点没有右子树时，该子树完成遍历，回到根节点<code>root</code>的父节点<code>p</code>再次执行<code>++</code>操作(这里可以用递归),下面介绍循环<ul><li>当根节点<code>root</code>为<code>p</code>的右结点时，<code>p</code>为根节点的子树也完成了遍历，把<code>p</code>作为所在子树的<code>root</code>，执行上一条操作</li><li>当根节点<code>root</code>为<code>p</code>的左结点时，<code>p</code>的左子树完成了遍历，正好下一步访问根节点,即<code>p</code>,返回指向<code>p</code>的迭代器即可</li></ul></li></ul></li></ul><p><strong><code>--</code></strong></p><ul><li>操作当前结点时，该结点和该节点的右子树已经完成遍历,前序遍历已经走过 <code>右子树</code>-&gt;<code>根</code><ul><li>该节点有左子树时，后序遍历右子树</li><li>该节点没有左子树时，该子树完成遍历，回到根节点<code>root</code>的父节点<code>p</code>再次执行<code>--</code>操作(这里可以用递归),下面介绍循环<ul><li>当根节点<code>root</code>为<code>p</code>的左结点时，<code>p</code>为根节点的子树也完成了遍历，把<code>p</code>作为所在子树的<code>root</code>，执行上一条操作</li><li>当根节点<code>root</code>为<code>p</code>的右结点时，<code>p</code>的右子树完成了遍历，正好下一步访问根节点,即<code>p</code>,返回指向<code>p</code>的迭代器即可</li></ul></li></ul></li></ul><p>完整代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Value</span>,<span class="keyword">class</span> <span class="title class_">Ref</span>,<span class="keyword">class</span> <span class="title class_">Ptr</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">__rbtree_iterator</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">typedef</span> __rbtree_iterator&lt;Value, <span class="type">const</span> Value&amp;, <span class="type">const</span> Value*&gt; const_iterator;</span><br><span class="line"><span class="keyword">typedef</span> __rbtree_iterator&lt;Value, Ref, Ptr&gt; self;</span><br><span class="line"><span class="keyword">typedef</span> RBTreeNode&lt;Value&gt;* linkeType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">__rbtree_iterator(<span class="type">const</span> linkeType&amp; ptr)</span><br><span class="line">:_ptr(ptr)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (_ptr == <span class="literal">nullptr</span>)<span class="built_in">exit</span>(<span class="number">-1</span>);<span class="comment">//非法的空迭代器</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__rbtree_iterator(<span class="type">const</span> const_iterator&amp; const_it)</span><br><span class="line">:_ptr(const_it._ptr)</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line">self <span class="keyword">operator</span>++()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (_ptr == <span class="literal">nullptr</span> || _ptr-&gt;_right == _ptr )</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);<span class="comment">//end()迭代器不能++,空迭代器不能加减</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (_ptr-&gt;_right)</span><br><span class="line">&#123;</span><br><span class="line">_ptr = _ptr-&gt;_right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">linkeType parent = _ptr-&gt;_parent;</span><br><span class="line"><span class="keyword">while</span> (parent-&gt;_right == _ptr)</span><br><span class="line">&#123;</span><br><span class="line">_ptr = parent;</span><br><span class="line">parent = _ptr-&gt;_parent;</span><br><span class="line">&#125;</span><br><span class="line">_ptr = parent;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (*<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">self <span class="keyword">operator</span>--()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (_ptr == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);<span class="comment">//非法情况</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (_ptr-&gt;_left == _ptr)<span class="comment">//在头结点</span></span><br><span class="line">&#123;</span><br><span class="line">linkeType right = _ptr-&gt;_parent;<span class="comment">//走到根节点</span></span><br><span class="line"><span class="keyword">while</span> (right)</span><br><span class="line">&#123;</span><br><span class="line">_ptr = right;</span><br><span class="line">right = _ptr-&gt;_right;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (_ptr-&gt;_left)</span><br><span class="line">&#123;</span><br><span class="line">_ptr = _ptr-&gt;_left;</span><br><span class="line">linkeType right = _ptr-&gt;_right;<span class="comment">//寻找左子树的最右结点</span></span><br><span class="line"><span class="keyword">while</span> (right)</span><br><span class="line">&#123;</span><br><span class="line">_ptr = right;</span><br><span class="line">right = _ptr-&gt;_right;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">linkeType parent = _ptr-&gt;_parent;</span><br><span class="line"><span class="keyword">while</span> (parent-&gt;_left == _ptr)</span><br><span class="line">&#123;</span><br><span class="line">_ptr = parent;</span><br><span class="line">parent = _ptr-&gt;_parent;</span><br><span class="line">&#125;</span><br><span class="line">_ptr = parent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Ref <span class="keyword">operator</span>*()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> _ptr-&gt;_value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Ptr <span class="keyword">operator</span>-&gt;()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> &amp;(_ptr-&gt;_value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> self&amp; it)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> _ptr != it._ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> self&amp; it)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> !<span class="keyword">operator</span>!=(it);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">linkeType _ptr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在<code>RBTree</code>类中声明迭代器类并添加接口</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">typedef</span> __rbtree_iterator&lt;V, V&amp;, V*&gt; iterator;</span><br><span class="line"><span class="keyword">typedef</span> __rbtree_iterator&lt;V, <span class="type">const</span> V&amp;, <span class="type">const</span> V*&gt;const_iterator;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">iterator <span class="title">begin</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="built_in">Most_Left</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">iterator <span class="title">end</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">iterator</span>(_header);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">const_iterator <span class="title">begin</span><span class="params">()</span><span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">const_iterator</span>(<span class="built_in">Most_Left</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">const_iterator <span class="title">end</span><span class="params">()</span><span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">const_iterator</span>(_header);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="修改Insert"><a href="#修改Insert" class="headerlink" title="修改Insert"></a>修改Insert</h3><p>封装了迭代器之后，我们就可以让<code>insert</code>承担更多的功能了,让它同时返回<code>bool</code>和<code>iterator/const_iterator</code></p><p><code>std::pair&lt;bool,iterator&gt;</code></p><h3 id="新增关于容量的接口"><a href="#新增关于容量的接口" class="headerlink" title="新增关于容量的接口"></a>新增关于容量的接口</h3><p>这里我们新增一个私有成员变量<code>size_t _size</code>记录红黑树中有效节点个数，此处需要修改一下构造函数和<code>Insert</code>函数，这里就不列出来了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span><span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _size;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span><span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _size == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="新增拷贝构造"><a href="#新增拷贝构造" class="headerlink" title="新增拷贝构造"></a>新增拷贝构造</h3><p>有了迭代器，拷贝构造也十分好写了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">RBTree</span>(<span class="type">const</span> self&amp; rbt)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> value : rbt)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">Insert</span>(value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C语言编译器demo</title>
      <link href="/2024/09/02/compier/"/>
      <url>/2024/09/02/compier/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C++继承</title>
      <link href="/2024/09/02/CppInherit/"/>
      <url>/2024/09/02/CppInherit/</url>
      
        <content type="html"><![CDATA[<h1 id="继承的概念及定义"><a href="#继承的概念及定义" class="headerlink" title="继承的概念及定义"></a>继承的概念及定义</h1><h2 id="继承的概念"><a href="#继承的概念" class="headerlink" title="继承的概念"></a>继承的概念</h2><p><code>继承</code>(inheritance)机制是面向对象程序设计使代码可以<strong>复用</strong>的最重要的手段，它允许程序员在保持原有类特性的基础上进行扩展，增加功能，这样产生新的类，称<code>派生类</code>。继承呈现了面向对象程序设计的<code>层次结构</code>，体现了由简单到复杂的认知过程。以前我们接触的复用都是函数复用，继承是类设计层次的<code>复用</code></p><p>下面用一个简单的示例演示一下继承<br><strong>示例</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Info</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;name:%s age:%d\n&quot;</span>, _name.<span class="built_in">c_str</span>(), _age);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">string _name = <span class="string">&quot;supdriver&quot;</span>;</span><br><span class="line"><span class="type">int</span> _age = <span class="number">24</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:<span class="keyword">public</span> Person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getID</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ID:&quot;</span> &lt;&lt; _ID &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> _ID = <span class="number">114514</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Student stu;</span><br><span class="line">stu.<span class="built_in">Info</span>();</span><br><span class="line">stu.<span class="built_in">getID</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="继承的使用"><a href="#继承的使用" class="headerlink" title="继承的使用"></a>继承的使用</h2><p>当我们准备好一个<code>基类</code>后，便可将其用于<code>派生类</code>的声明</p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Inherit.png"></p><p>由图中可以看到，新的概念：<code>继承方式</code>，而且很巧的是，它和<code>访问限定符</code>的关键字是一一对应的</p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202409030857308.png"></p><p>实际上，它们共同决定了基类成员在派生类内的访问限定符</p><h3 id="继承基类成员访问方式的变化"><a href="#继承基类成员访问方式的变化" class="headerlink" title="继承基类成员访问方式的变化"></a>继承基类成员访问方式的变化</h3><table><thead><tr><th>类成员&#x2F;继承方式</th><th><code>public</code>继承</th><th><code>protected</code>继承</th><th><code>private</code>继承</th></tr></thead><tbody><tr><td>基类的<code>public</code>成员</td><td>派生类的<code>public</code>成员</td><td>派生类的<code>protected</code>成员</td><td>派生类的<code>private</code>成员</td></tr><tr><td>基类的<code>protected</code>成员</td><td>派生类的<code>protected</code>成员</td><td>派生类的<code>protected</code>成员</td><td>派生类的<code>private</code>成员</td></tr><tr><td>基类的<code>private</code>成员</td><td>在派生类中<code>不可见</code></td><td>在派生类中<code>不可见</code></td><td>在派生类中<code>不可见</code></td></tr></tbody></table><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol><li><code>不可见</code>:基类private成员在派生类中无论以什么方式继承都是不可见的。<strong>这里的不可见是指基类的私有成员还是被继承到了派生类对象中，但是语法上限制派生类对象不管在类里面还是类外面都不能去访问它。</strong></li><li><code>protected</code>:基类private成员在派生类中是不能被访问，如果基类成员不想在类外直接被访问，但需要在派生类中能访问，就定义为protected。<strong>可以看出<code>protected</code>保护成员限定符是因继承才出现的。</strong></li><li><code>规律</code>:实际上面的表格我们进行一下总结会发现，基类的私有成员在子类都是不可见。基类的其他成员在子类的访问方式 &#x3D;&#x3D; <code>Min(成员在基类的访问限定符，继承方式)</code>，其中的大小关系为<code>public &gt; protected &gt; private</code></li><li><code>默认行为</code>:使用关键字class时默认的继承方式是private，使用struct时默认的继承方式是public，不过<strong>最好显示</strong>的写出继承方式。</li><li><code>扩展性</code>:在实际运用中一般使用都是public继承，几乎很少使用protetced&#x2F;private继承，也不提倡使用protetced&#x2F;private继承，因为protetced&#x2F;private继承下来的成员都只能在派生类的类里面使用，实际中扩展维护性不强</li></ol><h2 id="派生类的构造函数"><a href="#派生类的构造函数" class="headerlink" title="派生类的构造函数"></a>派生类的构造函数</h2><p>有时基类并不提供无参的默认构造函数,那么如何在派生类的构造函数里<code>显示地调用基类构造函数</code>呢?</p><p>其实编译器的报错也给出了提示</p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/inherit_construct.png"></p><p>可以看到，在初始化列表后面出现了报错:<code>Person不存在默认构造函数</code>,显然，显示调用构造函数的位置在初始化列表。</p><p>那么怎么调用呢？构造函数也是成员函数！除了基类中<code>private</code>修饰的构造函数，派生类中皆可调用父类的成员函数，直接在初始化列表中显式调用即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//基类的公有构造函数</span></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">const</span> string&amp; name, <span class="type">const</span> string&amp; gender, <span class="type">int</span> age)</span><br><span class="line">:_name(name)</span><br><span class="line">,_gender(gender)</span><br><span class="line">,_age(age)</span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Info</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;name:%s age:%d\n&quot;</span>, _name.<span class="built_in">c_str</span>(), _age);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">string _name;</span><br><span class="line">string _gender;</span><br><span class="line"><span class="type">int</span> _age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> :<span class="keyword">public</span> Person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Student</span>(<span class="type">const</span> string&amp; name,<span class="type">const</span> string&amp; gender,<span class="type">int</span> age,<span class="type">int</span> ID)</span><br><span class="line">:<span class="built_in">Person</span>(name,gender,age)<span class="comment">//显式调用父类的构造函数</span></span><br><span class="line">,_ID(ID)</span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getID</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ID:&quot;</span> &lt;&lt; _ID &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> _ID;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Student <span class="title">stu</span><span class="params">(<span class="string">&quot;supdriver&quot;</span>, <span class="string">&quot;male&quot;</span>, <span class="number">24</span>, <span class="number">114514</span>)</span></span>;<span class="comment">//调用构造函数</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="基类和派生类的赋值转化"><a href="#基类和派生类的赋值转化" class="headerlink" title="基类和派生类的赋值转化"></a>基类和派生类的赋值转化</h2><ul><li>派生类对象 可以赋值给 <code>基类的对象</code> &#x2F; <code>基类的指针</code> &#x2F; <code>基类的引用</code>。这里有个形象的说法叫<code>切片</code>或者<code>切割</code>。寓意把派生类中父类那部分切来赋值过去。</li><li>基类对象<strong>不能</strong>赋值给派生类对象</li><li>基类的<code>指针</code>或者<code>引用</code>可以通过强制类型转换赋值给派生类的指针或者引用。但是必须是<strong>基类的指针是指向派生类对象时才是安全的</strong>。</li></ul><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/slice.png"></p><p>下面用一个示例演示一下切片,赋值转换等问题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//基类的公有构造函数</span></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">const</span> string&amp; name, <span class="type">const</span> string&amp; gender, <span class="type">int</span> age)</span><br><span class="line">:_name(name)</span><br><span class="line">,_gender(gender)</span><br><span class="line">,_age(age)</span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Info</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;name:%s age:%d\n&quot;</span>, _name.<span class="built_in">c_str</span>(), _age);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">string _name;</span><br><span class="line">string _gender;</span><br><span class="line"><span class="type">int</span> _age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> :<span class="keyword">public</span> Person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Student</span>(<span class="type">const</span> string&amp; name,<span class="type">const</span> string&amp; gender,<span class="type">int</span> age,<span class="type">int</span> ID)</span><br><span class="line">:<span class="built_in">Person</span>(name,gender,age)<span class="comment">//显式调用父类的构造函数</span></span><br><span class="line">,_ID(ID)</span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getID</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ID:&quot;</span> &lt;&lt; _ID &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> _ID;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Student <span class="title">stu</span><span class="params">(<span class="string">&quot;supdriver&quot;</span>, <span class="string">&quot;male&quot;</span>, <span class="number">24</span>, <span class="number">114514</span>)</span></span>;<span class="comment">//调用构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="function">Person  <span class="title">person</span><span class="params">(stu)</span></span>;<span class="comment">//这里没有显式声明对应的构造函数，而是自动切片</span></span><br><span class="line">Person* pp = &amp;stu;<span class="comment">//父类指针可以指向派生类</span></span><br><span class="line">Person&amp; rp = stu;<span class="comment">//父类引用可以指向派生类</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//stu = person;//父类对象不能赋值给派生类</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//基类的指针可以通过强制类型转换赋值给派生类的指针</span></span><br><span class="line">pp = &amp;stu;</span><br><span class="line">Student* pstu = (Student*)pp;<span class="comment">//指针地址就是指向派生类的，所以这种情况是安全的，合法的</span></span><br><span class="line">pstu-&gt;_ID = <span class="number">233</span>;<span class="comment">//这里并没有越界</span></span><br><span class="line"></span><br><span class="line">pp = &amp;person;</span><br><span class="line">pstu = (Student*)pp;<span class="comment">//这种就是不安全的，可能会越界访问</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="继承中的作用域-隐藏机制"><a href="#继承中的作用域-隐藏机制" class="headerlink" title="继承中的作用域(隐藏机制)"></a>继承中的作用域(<code>隐藏</code>机制)</h2><ol><li>在继承体系中<code>基类</code>和<code>派生类</code>都有独立的作用域(<code>类域</code>)</li><li>子类和父类中有同名成员，<strong>不指定成员所在类域时</strong>，子类成员将屏蔽父类对同名成员的直接访问，这种情况叫<code>隐藏</code>，也叫<code>重定义</code>。</li><li>需要注意的是如果是成员函数的隐藏，只需要<strong>函数名相</strong>同就构成隐藏。</li><li>注意在<strong>实际中</strong>在继承体系里面最好<strong>不要定义同名的成员</strong>。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Info</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;name:%s age:%d\n&quot;</span>, _name.<span class="built_in">c_str</span>(), _age);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">string _name = <span class="string">&quot;supdriver&quot;</span>;</span><br><span class="line"><span class="type">int</span> _age = <span class="number">24</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:<span class="keyword">public</span> Person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Info</span><span class="params">()</span><span class="comment">//同名函数构成隐藏</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;name:%s age:%d\n ID:%d&quot;</span>, _name.<span class="built_in">c_str</span>(), _age,_ID);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> _ID = <span class="number">114514</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Student stu;</span><br><span class="line">stu.<span class="built_in">Info</span>();<span class="comment">//调用Student类内的Info函数，而父类内的被隐藏</span></span><br><span class="line">stu.Person::<span class="built_in">Info</span>();<span class="comment">//显式调用Person内的Info函数</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="隐藏与重载辨析"><a href="#隐藏与重载辨析" class="headerlink" title="隐藏与重载辨析"></a>隐藏与重载辨析</h3><ul><li><code>重载</code>：函数重载是根据同名函数的<code>参数类型</code>和<code>参数顺序</code>选择实际调用的函数，选择的动作只能由编译器完成</li><li><code>隐藏</code>：成员的隐藏是同名成员根据<code>类域</code>的<code>就近原则</code>由编译器自动调用，但也可以通过指定类域，在代码中选择</li></ul><h2 id="派生类的默认成员函数"><a href="#派生类的默认成员函数" class="headerlink" title="派生类的默认成员函数"></a>派生类的默认成员函数</h2><p>6个默认成员函数，“默认”的意思就是指我们不写，编译器会变我们自动生成一个，那么在派生类<br>中，这几个成员函数是如何生成的呢?</p><ol><li>派生类的构造函数必须调用基类的构造函数初始化基类的那一部分成员。如果基类没有默认的构造函数，则必须在派生类构造函数的初始化列表阶段显示调用。</li><li>派生类的拷贝构造函数必须调用基类的拷贝构造完成基类的拷贝初始化。</li><li>派生类的operator&#x3D;必须要调用基类的operator&#x3D;完成基类的复制。</li><li>派生类的析构函数会在被调用完成后自动调用基类的析构函数清理基类成员。因为这样才能保证派生类对象先清理派生类成员再清理基类成员的顺序。</li><li>派生类对象初始化先调用基类构造再调派生类构造。</li><li>派生类对象析构清理先调用派生类析构再调基类的析构。</li><li>因为后续一些场景析构函数需要构成重写，重写的条件之一是函数名相同(这个我们后面会讲解)。那么编译器会对<strong>析构函数名进行特殊处理</strong>，处理成<code>destrutor()</code>，所以父类析构函数不加virtual的情况下，子类析构函数和父类析构函数构成隐藏关系。</li></ol><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202409031848644.png"></p><h2 id="继承与友元函数"><a href="#继承与友元函数" class="headerlink" title="继承与友元函数"></a>继承与友元函数</h2><p>友元关系不能继承，也就是说基类友元不能访问子类私有和保护成员 </p><p>示例如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">Display</span><span class="params">(<span class="type">const</span> Person&amp; p, <span class="type">const</span> Student&amp; s)</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">string _name; <span class="comment">// 姓名</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> : <span class="keyword">public</span> Person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="type">int</span> _stuNum; <span class="comment">// 学号</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Display</span><span class="params">(<span class="type">const</span> Person&amp; p, <span class="type">const</span> Student&amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; p._name &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; s._name &lt;&lt; endl;<span class="comment">//这行代码不会报错，因为_name是继承自Person类的</span></span><br><span class="line">cout &lt;&lt; s._stuNum &lt;&lt; endl;<span class="comment">//这行代码会报错，因为函数没有权限访问Student类自己声明的成员</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person p;</span><br><span class="line">Student s;</span><br><span class="line"><span class="built_in">Display</span>(p, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="继承与静态成员"><a href="#继承与静态成员" class="headerlink" title="继承与静态成员"></a>继承与静态成员</h2><p>基类定义了<code>static静态成员</code>，则<strong>整个继承体系里面只有一个这样的成员</strong>。无论派生出多少个子类，都<strong>只有一个</strong>static成员实例 。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>() &#123; ++_count; &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">string _name; <span class="comment">// 姓名</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> _count; <span class="comment">// 静态成员变量,统计人的个数。</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Person::_count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> : <span class="keyword">public</span> Person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="type">int</span> _stuNum; <span class="comment">// 学号</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Graduate</span> : <span class="keyword">public</span> Student</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">string _seminarCourse; <span class="comment">// 研究科目</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Student s1;</span><br><span class="line">Student s2;</span><br><span class="line">Student s3;</span><br><span class="line">Graduate s4;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot; 人数 :&quot;</span> &lt;&lt; Person::_count &lt;&lt; endl;</span><br><span class="line">Student::_count = <span class="number">0</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot; 人数 :&quot;</span> &lt;&lt; Person::_count &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下</p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202409040748921.png"></p><h2 id="复杂的菱形继承及菱形虚拟继承"><a href="#复杂的菱形继承及菱形虚拟继承" class="headerlink" title="复杂的菱形继承及菱形虚拟继承"></a>复杂的菱形继承及菱形虚拟继承</h2><h3 id="单继承"><a href="#单继承" class="headerlink" title="单继承"></a>单继承</h3><p><code>单继承</code>：一个子类只有<em>一个直接父类</em>时称这个继承关系为<code>单继承</code></p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/single_inherit.png"></p><h3 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h3><p><code>多继承</code>：一个子类有<strong>两个或以上直接父类</strong>时称这个继承关系为<code>多继承</code></p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/multi_inherit.png"></p><h3 id="菱形继承"><a href="#菱形继承" class="headerlink" title="菱形继承"></a>菱形继承</h3><p><code>菱形继承</code>：菱形继承是多继承的一种<strong>特殊情况</strong>。</p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Diamond_Inherit.png"></p><p><code>菱形继承的问题</code>：从下面的对象成员模型构造，可以看出菱形继承有<code>数据冗余</code>和<code>二义性</code>的问题。<br>在Assistant的对象中Person成员会有两份。</p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/IHR_diamond.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line"> string _name ; <span class="comment">// 姓名</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> : <span class="keyword">public</span> Person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span> :</span><br><span class="line"> <span class="type">int</span> _num ; <span class="comment">//学号</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span> : <span class="keyword">public</span> Person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span> :</span><br><span class="line"> <span class="type">int</span> _id ; <span class="comment">// 职工编号</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Assistant</span> : <span class="keyword">public</span> Student, <span class="keyword">public</span> Teacher</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span> :</span><br><span class="line"> string _majorCourse ; <span class="comment">// 主修课程</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 这样会有二义性无法明确知道访问的是哪一个</span></span><br><span class="line">Assistant a ;</span><br><span class="line">a._name = <span class="string">&quot;peter&quot;</span>;</span><br><span class="line"><span class="comment">// 需要显示指定访问哪个父类的成员可以解决二义性问题，但是数据冗余问题无法解决</span></span><br><span class="line">a.Student::_name = <span class="string">&quot;xxx&quot;</span>;</span><br><span class="line">a.Teacher::_name = <span class="string">&quot;yyy&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="虚拟继承"><a href="#虚拟继承" class="headerlink" title="虚拟继承"></a>虚拟继承</h4><p><code>虚拟继承</code>可以解决<strong>菱形继承</strong>的二义性和数据冗余的问题。如上面的继承关系，在Student和Teacher的继承Person时使用<code>虚拟继承</code>，即可解决问题。需要注意的是，<strong>虚拟继承不要在其他地方去使用。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line"> string _name ; <span class="comment">// 姓名</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Person <span class="comment">//虚拟继承共同父类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span> :</span><br><span class="line"> <span class="type">int</span> _num ; <span class="comment">//学号</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Person <span class="comment">//虚拟继承共同父类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span> :</span><br><span class="line"> <span class="type">int</span> _id ; <span class="comment">// 职工编号</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Assistant</span> : <span class="keyword">public</span> Student, <span class="keyword">public</span> Teacher</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span> :</span><br><span class="line"> string _majorCourse ; <span class="comment">// 主修课程</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> Assistant a ;</span><br><span class="line"> a._name = <span class="string">&quot;peter&quot;</span>;<span class="comment">//二义性和数据冗余已被解决</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>虚拟继承解决数据冗余和二义性的原理</strong><br>下图是菱形虚拟继承的内存对象成员模型：这里可以分析出<code>Assistant</code>对象中将<code>Person</code>放到的了对象组成的最下面，这个<code>Person</code>同时属于<code>Student</code>和<code>Teacher</code>，那么<code>Student</code>和<code>Teacher</code>如何去找到公共的<code>Person</code>呢？<strong>这里是通过了<code>Student</code>和<code>Teacher</code>的两个指针，指向的一张表。这两个指针叫<code>虚基表指针</code>，这两个表叫<code>虚基表</code>。虚基表中存的偏移量。通过偏移量可以找到下面的<code>Person</code></strong></p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/INHERIT_virtual.png"></p><h1 id="继承的总结和反思"><a href="#继承的总结和反思" class="headerlink" title="继承的总结和反思"></a>继承的总结和反思</h1><h2 id="尽量不使用多继承，不要设计出菱形继承"><a href="#尽量不使用多继承，不要设计出菱形继承" class="headerlink" title="尽量不使用多继承，不要设计出菱形继承"></a>尽量不使用多继承，不要设计出菱形继承</h2><p>C++语法中的<code>多继承</code>正是其语法复杂性的体现之一。有了多继承，就存在菱形继承，有了菱形继承就有菱形虚拟继承，底层实现就很复杂。所以<strong>一般不建议设计出多继承，一定不要设计出菱形继承</strong>。否则在复杂度及性能上都有问题。</p><h2 id="继承和组成辨析"><a href="#继承和组成辨析" class="headerlink" title="继承和组成辨析"></a>继承和组成辨析</h2><ul><li>public继承是一种<code>is-a</code>的关系。也就是说每个派生类对象都是一个基类对象</li><li>组合是一种<code>has-a</code>的关系。假设B组合了A，每个B对象中都有一个A对象。</li><li>为了提高代码的<code>封装性</code>和<code>解耦合</code>，<a href="https://www.cnblogs.com/nexiyi/archive/2013/06/16/3138568.html">优先使用对象组合，而不是类继承🔗</a></li><li><code>白箱复用</code>：继承允许你根据基类的实现来定义派生类的实现。这种通过生成派生类的复用通常被称为白箱复用(white-box reuse)。术语“白箱”是相对可视性而言：在继承方式中，<strong>基类的内部细节对子类可见</strong> 。继承一定程度<strong>破坏</strong>了基类的封装，基类的改变，对派生类有很大的影响。派生类和基类间的依赖关系很强，<strong>耦合度高</strong>。</li><li><code>黑箱复用</code>：对象组合是类继承之外的另一种复用选择。新的更复杂的功能可以通过组装或组合对象来获得。对象组合要求被组合的对象具有良好定义的接口。这种复用风格被称为黑箱复用(black-box reuse)，因为对象的内部细节是不可见的。对象只以“黑箱”的形式出现。组合类之间没有很强的依赖关系，耦合度低。优先使用对象组合有助于你保持每个类被封装。</li><li>实际尽量多去用组合。组合的耦合度低，代码维护性好。不过继承也有用武之地的，有些关系就适合继承那就用继承，另外要实现多态，也必须要继承。类之间的关系可以用继承，可以用组合，就用组合。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> C++ 继承 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux原生线程 与 互斥锁</title>
      <link href="/2024/08/14/thread/"/>
      <url>/2024/08/14/thread/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h1><p>在一个程序（进程）里的一条执行流就叫做<code>线程</code>(thread),也就是说有多线程功能的进程内，可以有多个线程同时执行</p><p>所以我们可以认为:</p><ul><li>一个进程至少有一个执行进程</li><li>线程在进程内部运行，本质是在进程提供的地址空间内运行</li></ul><p>而对于<code>Linux</code>实现的线程，本质上是轻量化的进程，还是用的<code>task_struct</code>去维护的每一个<strong>线程</strong></p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/thread.png" alt="Linux进程结构"></p><p><strong>关于线程间内存共享</strong><br>如上图所示，线程之间只有<code>栈区</code>是相互<strong>独立</strong>的， 像是<code>全局变量</code>，<code>堆区数据</code>都是共享的</p><h2 id="线程的优点"><a href="#线程的优点" class="headerlink" title="线程的优点"></a>线程的优点</h2><ul><li>创建一个新线程的<code>代价</code>要比创建一个新进程小得多</li><li>与进程之间的<code>切换</code>相比，线程之间的切换需要操作系统做的<code>工作</code>要少很多</li><li>线程占用的<code>资源</code>要比进程少很多</li><li>能充分利用多处理器的可<code>并行</code>数量</li><li>在等待慢速<code>I/O</code>操作结束的同时，程序可执行其他的计算任务</li><li>计算密集型应用，为了能在多处理器系统上运行，将<code>计算分解</code>到多个线程中实现</li><li><code>I/O密集型应用</code>，为了提高性能，将I&#x2F;O操作重叠。线程可以同时等待不同的I&#x2F;O操作。</li></ul><h2 id="线程的缺点"><a href="#线程的缺点" class="headerlink" title="线程的缺点"></a>线程的缺点</h2><h3 id="性能损失"><a href="#性能损失" class="headerlink" title="性能损失"></a>性能损失</h3><p><em>一个很少被外部事件阻塞的计算密集型线程往往无法与共它线程共享同一个处理器。如果计算密集型线程的数量比可用的处理器多，那么可能会有较大的性能损失</em>，这里的<code>性能损失</code>指的是增加了额外的<br><code>同步</code>和<code>调度</code>开销，而<strong>可用的资源不变。</strong></p><h3 id="健壮性降低"><a href="#健壮性降低" class="headerlink" title="健壮性降低"></a>健壮性降低</h3><p>编写多线程需要更全面更深入的考虑，在一个多线程程序里，因时间分配上的细微偏差或者因共享了不该共享的变量而造成不良影响的可能性是很大的，换句话说线程之间是缺乏保护的。</p><h3 id="缺乏访问控制"><a href="#缺乏访问控制" class="headerlink" title="缺乏访问控制"></a>缺乏访问控制</h3><p><code>进程</code>是访问控制的<code>基本粒度</code>，在一个线程中调用某些OS函数会对整个进程造成影响。</p><h3 id="编程难度提高"><a href="#编程难度提高" class="headerlink" title="编程难度提高"></a>编程难度提高</h3><p>编写与调试一个多线程程序比单线程程序困难得多</p><h2 id="线程异常"><a href="#线程异常" class="headerlink" title="线程异常"></a>线程异常</h2><p>所有线程好比铁索连环，如果单个线程出现诸如 <code>除零</code>，<code>野指针</code>等异常问题导致线程崩溃,整个<code>进程</code>，包括所有线程，都会崩溃退出</p><h2 id="线程的用途"><a href="#线程的用途" class="headerlink" title="线程的用途"></a>线程的用途</h2><ul><li>合理的使用多线程，能提高CPU密集型程序的执行效率</li><li>合理的使用多线程，能提高IO密集型程序的用户体验</li></ul><h1 id="线程与进程辨析"><a href="#线程与进程辨析" class="headerlink" title="线程与进程辨析"></a>线程与进程辨析</h1><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>资源分配的基本单位,即每个进程都会分配一套独立的进程地址空间&#x2F;虚拟地址，并且供内部的所有线程共享</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>线程是调度的基本单位，线程共享进程数据，但也拥有自己的一部分数据<span id = "qianwen"></span></p><ul><li><code>线程ID</code></li><li>一组寄存器</li><li>栈</li><li>errno</li><li>信号屏蔽字</li><li>调度优先级</li></ul><p>进程的多个<code>线程共享</code> 同一地址空间,因此<code>Text Segment</code>、<code>Data Segment</code>都是共享的,如果定义一个函数,在各线程<br>中都可以调用,如果定义一个全局变量,在各线程中都可以访问到,除此之外,各线程还共享以下进程资源和环境</p><ul><li>文教描述符表</li><li>每种信号的处理方式(SIG_IGN、SIG_DFL或自定义的信号处理函数)</li><li>当前工作目录</li><li>用户id和组id</li></ul><h1 id="Linux线程控制"><a href="#Linux线程控制" class="headerlink" title="Linux线程控制"></a>Linux线程控制</h1><p>这里介绍POSIX线程库，这是一个第三方线程库，且是个动态库,有以下特点</p><ul><li>与线程有关的函数构成了个完整的系列，绝大多数函数的名字都是以<code>pthread_</code>打头的</li><li>要使用这些函数库，要通过引入头文<code>&lt;pthread.h&gt;</code></li><li>链接这些线程函数库时要使用<strong>编译器</strong>命令的<code>-lpthread</code>选项  <em>很容易忘</em></li></ul><h2 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_create</span><span class="params">(<span class="type">pthread_t</span> *thread, <span class="type">const</span> <span class="type">pthread_attr_t</span> *attr,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">void</span> *(*start_routine) (<span class="type">void</span> *), <span class="type">void</span> *arg)</span></span>;</span><br></pre></td></tr></table></figure><p>使用<code>pthread_create</code>函数创建新线程</p><ul><li>参数<ul><li>thread:输出型参数，返回新线程的<code>线程id</code></li><li>attr:设置线程属性，为<code>nullptr</code>时使用默认属性，一般为<code>nullptr</code></li><li>start_routine:函数地址，即新线程<strong>启动时调用</strong>的函数</li><li>arg:传给<code>start_routine</code>指向函数的参数</li></ul></li><li>返回值:成功返回<code>0</code>，失败返回错误码</li></ul><p>关于错误码</p><blockquote><ul><li>统的一些函数是，成功返回0，失败返回-1，并且对全局变量errno赋值以指示错误。</li><li>threads函数出错时不会设置全局变量errno（而大部分其他POSIX函数会这样做）。而是将错误代码通过返回值返回</li><li>hreads同样也提供了线程内的errno变量，以支持其它使用errno的代码。对于pthreads函数的错误,建议通过返回值业判定，因为读取返回值要比读取线程内的errno变量的开销更小</li></ul></blockquote><blockquote><p>使用示例</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">rout</span><span class="params">(<span class="type">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I&#x27;am thread 1,got arg:%d\n&quot;</span>,*(<span class="type">int</span>*)arg);</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid;<span class="comment">//储存tid的变量</span></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="type">int</span> arg = <span class="number">114514</span>;<span class="comment">//准备参数</span></span><br><span class="line">    <span class="comment">//创建新线程</span></span><br><span class="line">    <span class="keyword">if</span> ((ret = <span class="built_in">pthread_create</span>(&amp;tid, <span class="literal">NULL</span>, rout, &amp;arg)) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//创建失败</span></span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;pthread_create : %s\n&quot;</span>, <span class="built_in">strerror</span>(ret));</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//主线程输出</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I&#x27;am main thread\n&quot;</span>);</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程id及进程地址空间布局"><a href="#线程id及进程地址空间布局" class="headerlink" title="线程id及进程地址空间布局"></a>线程id及进程地址空间布局</h2><ul><li>hread_create函数会产生一个线程id，存放在第一个参数指向的地址中。该线程id和前面说的线程ID(本文用大小写区分)不是一回事。</li><li><a href="#qianwen">前文</a>的<code>线程ID</code>于进程调度的范畴。因为线程是轻量级进程，是操作系统调度器的最小单位，所以需要一个数值来唯一表示该线程。</li><li>hread_create函数第一个参数指向一个虚拟内存单元，该内存单元的地址即为新创建线程的线程ID,属于NPTL线程库的范畴。线程库的后续操作，就是根据该线程ID来操作线程的。</li><li>程库NPTL提供了pthread_self函数，可以获得线程自身的ID:</li></ul><p><code>pthread_t</code> 到底是什么类型呢？取决于实现。对于Linux目前实现的NPTL实现而言，pthread_t类型的线程ID，本质就是一个进程地址空间上的一个地址。</p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202409091528968.png"></p><h2 id="线程终止"><a href="#线程终止" class="headerlink" title="线程终止"></a>线程终止</h2><p>如果需要只终止某个线程而不终止整个进程,可以有三种方法:</p><ul><li>从线程函数<code>return</code>。这种方法对主线程<strong>不适用</strong>,从main函数return相当于调用exit。</li><li>线程可以调用<code>pthread_exit</code>终止自己。</li><li>一个线程可以调用<code>pthread_cancel</code>终止同一进程中的另一个线程。</li></ul><h3 id="pthread-exit函数"><a href="#pthread-exit函数" class="headerlink" title="pthread_exit函数"></a>pthread_exit函数</h3><p><code>void pthread_exit(void *retval);</code></p><p><strong>由子线程本身执行</strong></p><p><code>retval</code>为输出型参数，而函数调用后，该线程退出，栈帧销毁，所以,需要注意,pthread_exit或者return返回的指针所指向的内存单元必须是<code>全局</code>的或者是用<code>malloc</code>分配的,不能在线程函数的栈上分配,因为当其它线程得到这个返回指针时线程函数已经退出了。</p><h3 id="pthread-cancel函数"><a href="#pthread-cancel函数" class="headerlink" title="pthread_cancel函数"></a>pthread_cancel函数</h3><p><code>int pthread_cancel(pthread_t thread);</code></p><p><strong>由主线程向目标线程使用</strong></p><p>用于取消一个正在执行中的线程。</p><h2 id="线程等待"><a href="#线程等待" class="headerlink" title="线程等待"></a>线程等待</h2><p>为什么需要线程等待？<em>这一点可以类比多进程中的进程等待</em></p><ul><li>已经退出的线程，其空间没有被释放，仍然在进程的地址空间内。</li><li>创建新的线程不会复用刚才退出线程的地址空间。</li><li>进程等待可以回收已退出线程的资源</li></ul><h3 id="pthread-join函数"><a href="#pthread-join函数" class="headerlink" title="pthread_join函数"></a>pthread_join函数</h3><p><code>int pthread_join(pthread_t thread, void **retval);</code></p><ul><li><code>thread</code>:线程id</li><li><code>retval</code>:输出型参数，随着线程的结束方式的不同而改变</li><li><code>返回值</code>: 成功返回<code>0</code>，失败返回错误码</li></ul><p>调用该函数的线程将<code>挂起等待</code>,直到目标<code>thread</code>线程终止。</p><p><strong><code>retval</code>详解</strong><br>thread线程以不同的方法终止,通过pthread_join得到的终止状态是不同的，总结如下:</p><ol><li><code>return返回</code>:如果thread线程通过return返回,value_ ptr所指向的单元里存放的是thread线程函数的<code>返回值</code>。</li><li><code>pthread_cancel</code>:如果thread线程被别的线程调用<code>pthread_ cancel异常终止</code>,value_ ptr所指向的单元里存放的是常数<code>PTHREAD_ CANCELED</code>。</li><li><code>pthread_exit</code>:如果thread线程是自己调用pthread_exit终止的,value_ptr所指向的单元存放的是传给pthread_exit的参数。</li><li><code>不感兴趣</code>:如果对thread线程的终止状态不感兴趣,可以传<code>NULL</code>给value_ ptr参数。</li></ol><h2 id="分离线程"><a href="#分离线程" class="headerlink" title="分离线程"></a>分离线程</h2><p>默认情况下，新创建的线程是<code>joinable</code>的，即线程退出后，需要对其进行<code>pthread_join</code>操作，否则有内存泄漏风险</p><p>但如果不关心线程的返回值，此时<code>join</code>是一种负担，这时我们可以通过接口告诉系统，当线程退出时，自动释放线程资源，这个调用接口的操作就是<code>分离线程</code></p><h3 id="pthread-detach函数"><a href="#pthread-detach函数" class="headerlink" title="pthread_detach函数"></a>pthread_detach函数</h3><p><code>int pthread_detach(pthread_t thread);</code></p><p>该函数可以使目标线程分离，配合<code>pthread_self()</code>函数可以<strong>使自己分离</strong></p><p>特别的,<code>joinable</code>和分离是冲突的，分离之后就不能再执行<code>join</code>操作了</p><h2 id="线程互斥"><a href="#线程互斥" class="headerlink" title="线程互斥"></a>线程互斥</h2><p><strong>背景概念补充</strong></p><ul><li><code>临界资源</code>：多线程执行流共享的资源,这些资源在<strong>某一时刻只能被一个线程访问</strong>,这样的资源就叫做<code>临界资源</code></li><li><code>临界区</code>：每个线程内部，访问临界资源的代码，就叫做<code>临界区</code></li><li><code>互斥</code>：任何时刻，互斥保证有且只有一个执行流进入临界区，访问临界资源，通常对临界资源起保护作用</li><li><code>原子性</code>（后面讨论如何实现）：不会被任何调度机制打断的操作，该操作只有两态，要么完成，要么未完成</li></ul><h3 id="互斥量mutex"><a href="#互斥量mutex" class="headerlink" title="互斥量mutex"></a>互斥量mutex</h3><p>大部分情况，线程使用的数据都是局部变量，变量的地址空间在线程栈空间内，这种情况，变量归属单个线程，其他线程无法获得这种变量</p><p>但有时候，很多变量都需要在线程间共享，这样的变量称为共享变量，可以通过数据的共享，完成线程之间的交互。</p><p>多个线程并发的操作共享变量，会带来一些问题。下面有一段代码展示</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 操作共享变量会有问题的售票系统代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> ticket = <span class="number">100</span>;<span class="comment">//抢票程序，预留100张票</span></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">route</span><span class="params">(<span class="type">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> *id = (<span class="type">char</span> *)arg;<span class="comment">//从参数里获取线程名</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">usleep</span>(<span class="number">1000</span>);<span class="comment">//降低每次抢票的速度</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s sells ticket:%d\n&quot;</span>, id, ticket);</span><br><span class="line">            ticket--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> t1, t2, t3, t4;<span class="comment">//准备四个线程id</span></span><br><span class="line">    <span class="type">char</span> name1[] = <span class="string">&quot;thread 1&quot;</span>;<span class="comment">//准备四个线程名</span></span><br><span class="line">    <span class="type">char</span> name2[] = <span class="string">&quot;thread 2&quot;</span>;</span><br><span class="line">    <span class="type">char</span> name3[] = <span class="string">&quot;thread 3&quot;</span>;</span><br><span class="line">    <span class="type">char</span> name4[] = <span class="string">&quot;thread 4&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;t1, <span class="literal">NULL</span>, route, name1);<span class="comment">//创建四个线程</span></span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;t2, <span class="literal">NULL</span>, route, name2);</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;t3, <span class="literal">NULL</span>, route, name3);</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;t4, <span class="literal">NULL</span>, route, name4);</span><br><span class="line">    <span class="built_in">pthread_join</span>(t1, <span class="literal">NULL</span>);<span class="comment">//进程等待</span></span><br><span class="line">    <span class="built_in">pthread_join</span>(t2, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_join</span>(t3, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_join</span>(t4, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>某一次的执行结果</p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/thread10086.png"></p><p>可以看到代码的执行与预期的行为发生了严重误差</p><ul><li>有的票被重复卖出</li><li>有负数的票被卖出</li></ul><p>究其原因，就是全局变量<code>ticket</code>被所有线程共享，对其的访问控制确得不到限制，同时对其进行非原子性的操作时，就会出现<code>数据不一致问题</code>，进而引发一系列问题</p><p>例如对这段代码有如下分析</p><ul><li><code>if</code> 语句判断条件为真以后，代码可以并发的切换到其他线程</li><li><code>usleep</code> 这个模拟漫长业务的过程，在这个<code>漫长的业务过程</code>中，可能有很多个线程会进入该代码段</li><li><code>--ticket</code> 操作本身就不是一个<code>原子操作</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">取出ticket--部分的汇编代码</span><br><span class="line">objdump -d a.out &gt; test.objdump</span><br><span class="line">152 40064b: 8b 05 e3 04 20 00 mov 0x2004e3(%rip),%eax # 600b34 &lt;ticket&gt;</span><br><span class="line">153 400651: 83 e8 01 sub $0x1,%eax</span><br><span class="line">154 400654: 89 05 da 04 20 00 mov %eax,0x2004da(%rip) # 600b34 &lt;ticket&gt;</span><br></pre></td></tr></table></figure><p>显然<code>--</code>操作并不是原子操作，而是对应三条汇编指令</p><ul><li><code>load</code>: 将共享变量<code>ticket</code>从内存加载到寄存器中</li><li><code>update</code>: 更新寄存器里面的值，执行<code>-1</code>操作</li><li><code>store</code>: 将新值，从寄存器写回共享变量<code>ticket</code>的内存地址</li></ul><p><strong>将新值，从寄存器写回共享变量ticket的内存地址</strong></p><ul><li>代码必须要有互斥行为：当代码进入临界区执行时，不允许其他线程进入该临界区。</li><li>如果多个线程同时要求执行临界区的代码，并且临界区没有线程在执行，那么只能允许一个线程进入该临界区。</li><li>如果线程不在临界区中执行，那么该线程不能阻止其他线程进入临界区。</li></ul><p>要做到这三点，本质上就是需要一把锁。Linux上提供的这把锁叫互斥量。</p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/thread_mutex09191134202.png"></p><h3 id="互斥量的接口"><a href="#互斥量的接口" class="headerlink" title="互斥量的接口"></a>互斥量的接口</h3><h4 id="初始化互斥量"><a href="#初始化互斥量" class="headerlink" title="初始化互斥量"></a>初始化互斥量</h4><p>初始化互斥量主要有两种方法</p><ol><li>静态分配<br><code>pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER</code></li><li>动态分配<br><code>int pthread_mutex_init(pthread_mutex_t *restrict_mutex, const pthread_mutexattr_t *restrict_attr);</code></li></ol><ul><li><code>mutex</code>为要初始化的的互斥量的变量地址</li><li><code>attr</code>为可选参数，传<code>nullptr</code>即可</li></ul><h4 id="销毁互斥量"><a href="#销毁互斥量" class="headerlink" title="销毁互斥量"></a>销毁互斥量</h4><p>特别的，<strong>静态分配</strong>的，即使用<code>PTHREAD_MUTEX_INITIALIZER</code>初始化的互斥量不需要手动销毁</p><p>而对于动态分配的互斥量</p><ul><li>不要销毁一个已经加锁的互斥量</li><li>已经销毁的互斥量，要确保后面不会有线程再尝试加锁</li></ul><p>使用的如下函数</p><p><code>int pthread_mutex_destroy(pthread_mutex_t *mutex)；</code></p><h4 id="互斥量加锁和解锁"><a href="#互斥量加锁和解锁" class="headerlink" title="互斥量加锁和解锁"></a>互斥量加锁和解锁</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutex_lock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutex_unlock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span></span>;</span><br></pre></td></tr></table></figure><p>调用 pthread_ lock 时，可能会遇到以下情况:</p><ul><li>互斥量处于<strong>未锁状态</strong>，该函数会将互斥量锁定，同时返回<strong>成功</strong></li><li>发起函数调用时，其他线程已经锁定互斥量，或者存在其他线程同时申请互斥量，但没有竞争到互斥量，那么<code>pthread_ lock</code>调用会陷入<code>阻塞</code>(执行流被挂起)，<strong>等待</strong>互斥量解锁。</li></ul><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/thread_mutex09191134202.png"></p><h4 id="现学现用"><a href="#现学现用" class="headerlink" title="现学现用"></a>现学现用</h4><p>我们来利用锁来改进上面的选票程序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ticket = <span class="number">100</span>;<span class="comment">//抢票程序，预留100张票</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;<span class="comment">//准备一个互斥量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">route</span><span class="params">(<span class="type">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> *id = (<span class="type">char</span> *)arg;<span class="comment">//从参数里获取线程名</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);<span class="comment">//进入if判断前就得加锁，因为判断时ticket也是共享的</span></span><br><span class="line">        <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s sells ticket:%d\n&quot;</span>, id, ticket);</span><br><span class="line">            ticket--;</span><br><span class="line">            <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);<span class="comment">//完成对共享资源的访问，可以释放互斥量</span></span><br><span class="line">            <span class="comment">//usleep不访问共享资源，放在锁外面，以提高多线程并行效率</span></span><br><span class="line">            <span class="built_in">usleep</span>(<span class="number">1000</span>);<span class="comment">//降低每次抢票的速度</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);<span class="comment">//原理同上</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">pthread_mutex_init</span>(&amp;mutex,<span class="literal">nullptr</span>);<span class="comment">//初始化互斥量</span></span><br><span class="line">    <span class="type">pthread_t</span> t1, t2, t3, t4;<span class="comment">//准备四个线程id</span></span><br><span class="line">    <span class="type">char</span> name1[] = <span class="string">&quot;thread 1&quot;</span>;<span class="comment">//准备四个线程名</span></span><br><span class="line">    <span class="type">char</span> name2[] = <span class="string">&quot;thread 2&quot;</span>;</span><br><span class="line">    <span class="type">char</span> name3[] = <span class="string">&quot;thread 3&quot;</span>;</span><br><span class="line">    <span class="type">char</span> name4[] = <span class="string">&quot;thread 4&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;t1, <span class="literal">NULL</span>, route, name1);<span class="comment">//创建四个线程</span></span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;t2, <span class="literal">NULL</span>, route, name2);</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;t3, <span class="literal">NULL</span>, route, name3);</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;t4, <span class="literal">NULL</span>, route, name4);</span><br><span class="line">    <span class="built_in">pthread_join</span>(t1, <span class="literal">NULL</span>);<span class="comment">//进程等待</span></span><br><span class="line">    <span class="built_in">pthread_join</span>(t2, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_join</span>(t3, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_join</span>(t4, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_mutex_destroy</span>(&amp;mutex);<span class="comment">//销毁互斥量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，在代码中我们用互斥量将共享资源<code>ticket</code>保护了起来，使其变成了临界资源，相关的代码区变成了临界区，特别的，临界区的代码越少越好，将例如<code>usleep</code>这样耗时长，又与共享资源无关的代码移出临界区，这样才能最大化多线程并行的效率。</p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/thread_mutex109191850805.png"></p><h2 id="可重入VS线程安全"><a href="#可重入VS线程安全" class="headerlink" title="可重入VS线程安全"></a>可重入VS线程安全</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li><code>线程安全</code>：多个线程并发<code>同一段代码</code>时，不会出现不同的结果。常见对全局变量或者静态变量进行操作，并且没有锁保护的情况下，会出现该问题。</li><li><code>重入</code>：同一个<code>函数</code>被不同的执行流调用，当前一个流程还没有执行完，就有其他的执行流再次进入，我们称之为重入。一个函数在重入的情况下，运行结果不会出现任何不同或者任何问题，则该函数被称为可重入函数，否则，是不可重入函数。</li></ul><h2 id="常见线程不安全的情况"><a href="#常见线程不安全的情况" class="headerlink" title="常见线程不安全的情况"></a>常见线程不安全的情况</h2><ul><li>不保护<code>共享变量</code>的函数</li><li>函数状态随着被调用，<strong>状态发生变化</strong>的函数</li><li>返回指向<code>静态变量指针</code>的函数</li><li>调用<strong>线程不安全函数</strong>的函数</li></ul><h2 id="常见线程安全的情况"><a href="#常见线程安全的情况" class="headerlink" title="常见线程安全的情况"></a>常见线程安全的情况</h2><ul><li>每个线程对全局变量或者静态变量只有<strong>读取的权限</strong>，而没有写入的权限，一般来说这些线程是安全的</li><li>类或者接口对于线程来说都是原子操作</li><li>多个线程之间的切换不会导致该接口的执行结果存在二义性</li></ul><h2 id="常见不可重入的情况"><a href="#常见不可重入的情况" class="headerlink" title="常见不可重入的情况"></a>常见不可重入的情况</h2><ul><li>调用了<code>malloc/free</code>函数，因为<code>malloc</code>函数是用全局链表来管理堆的</li><li>调用了<code>标准I/O库函数</code>，标准I&#x2F;O库的很多实现都以不可重入的方式使用全局数据结构</li><li>可重入函数体内使用了<strong>静态的数据结构</strong></li></ul><h2 id="常见的可重入的情况"><a href="#常见的可重入的情况" class="headerlink" title="常见的可重入的情况"></a>常见的可重入的情况</h2><ul><li>不使用<code>全局变量</code>或<code>静态变量</code></li><li>不使用用<code>malloc</code>或者<code>new</code>开辟出的空间</li><li><strong>不调用</strong>不可重入函数</li><li><strong>不返回静态或全局数据</strong>，所有数据都有函数的调用者提供</li><li>使用本地数据，或者通过制作全局数据的<code>本地拷贝</code>来保护全局数据</li></ul><h2 id="可重入与线程安全的联系"><a href="#可重入与线程安全的联系" class="headerlink" title="可重入与线程安全的联系"></a>可重入与线程安全的联系</h2><ul><li>函数是可重入的，那就是线程安全的   <code>可重入</code>-&gt;<code>线程安全</code></li><li>函数是不可重入的，那就不能由多个线程使用，<code>有可能</code>引发线程安全问题</li><li>如果一个函数中有<code>全局变量</code>，那么这个函数既<strong>不是</strong>线程安全也<strong>不是</strong>可重入的。</li></ul><h2 id="可重入与线程安全的区别"><a href="#可重入与线程安全的区别" class="headerlink" title="可重入与线程安全的区别"></a>可重入与线程安全的区别</h2><ul><li>可重入函数是线程安全函数的一种</li><li>线程安全不一定是可重入的，而可重入函数则一定是线程安全的。</li><li>如果将对临界资源的访问<strong>加上锁</strong>，则这个函数是线程安全的，但如果这个重入函数若锁还未释放则会产生<code>死锁</code>，因此是不可重入的。</li></ul><h2 id="常见锁概念"><a href="#常见锁概念" class="headerlink" title="常见锁概念"></a>常见锁概念</h2><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>死锁是指在一组进程中的各个进程均<strong>占有不会释放的资源</strong>，但因互相申请被其他进程所站用不会释放的资源而处于的<strong>一种永久等待状态。</strong></p><h4 id="死锁四个必要条件"><a href="#死锁四个必要条件" class="headerlink" title="死锁四个必要条件"></a>死锁四个必要条件</h4><ol><li><code>互斥条件</code>：一个资源每次只能被<strong>一个执行流</strong>使用</li><li><code>请求与保持条件</code>：一个执行流因请求资源而阻塞时，对已获得的资源<strong>保持不放</strong></li><li><code>不剥夺条件</code>:一个执行流已获得的资源，在末使用完之前，<strong>不能强行剥夺</strong></li><li><code>循环等待条件</code>:若干执行流之间形成一种头尾相接的<strong>循环等待资源</strong>的关系</li></ol><h4 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h4><ul><li>破坏死锁的四个必要条件</li><li>加锁顺序一致</li><li>避免锁未释放的场景</li><li>资源一次性分配</li></ul><h4 id="避免死锁的算法"><a href="#避免死锁的算法" class="headerlink" title="避免死锁的算法"></a>避免死锁的算法</h4><ul><li>避免死锁算法</li><li>银行家算法</li></ul><h2 id="Linux线程同步"><a href="#Linux线程同步" class="headerlink" title="Linux线程同步"></a>Linux线程同步</h2><h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><p>当<code>一个线程</code>互斥的访问某个变量时，它可能发现在<code>其它线程</code>改变状态之前,它什么也做不了。</p><p><strong>例如</strong>，一个线程访问队列时，发现队列为空，就只能等待，直到其它线程将一个节点添加到队列中，这种情况就要用到条件变量</p><h3 id="同步概念与竞态条件"><a href="#同步概念与竞态条件" class="headerlink" title="同步概念与竞态条件"></a>同步概念与竞态条件</h3><p><code>同步</code>：在保证数据安全的前提下，让线程能够按照<strong>某种特定的顺序</strong>访问临界资源，从而<strong>有效避免饥饿问题</strong>，叫做<code>同步</code></p><p><code>竞态条件</code>：因为<strong>时序问题</strong>，而导致程序异常，我们称之为竞态条件。在线程场景下，这种问题也不难理解</p><h3 id="条件变量函数"><a href="#条件变量函数" class="headerlink" title="条件变量函数"></a>条件变量函数</h3><p><em>初始化</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cond_init</span><span class="params">(<span class="type">pthread_cond_t</span> *restrict_cond,<span class="type">const</span> <span class="type">pthread_condattr_t</span> *restrict_attr)</span></span>;</span><br><span class="line"></span><br><span class="line">    restrict_cond:要初始化的条件变量的地址</span><br><span class="line">    restrict_attr:可选参数，传<span class="literal">nullptr</span>即可</span><br></pre></td></tr></table></figure><p><em>销毁</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cond_destroy</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span></span></span><br></pre></td></tr></table></figure><p><em>等待条件满足(互斥地)</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cond_wait</span><span class="params">(<span class="type">pthread_cond_t</span> *restrict_cond,<span class="type">pthread_mutex_t</span> *restrict_mutex)</span></span>;</span><br><span class="line"></span><br><span class="line">    restrict_cond:目标条件变量的地址</span><br><span class="line">    restrict_mutex:互斥量，用于保护条件变量</span><br></pre></td></tr></table></figure><p><em>唤醒等待</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cond_broadcast</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cond_signal</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_cond_t</span> cond;   <span class="comment">// 创建信号量</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex; <span class="comment">// 创建互斥量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">chicken</span><span class="params">(<span class="type">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_cond_wait</span>(&amp;cond, &amp;mutex);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;鸡哥获得了一个篮球\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">kunkun</span><span class="params">(<span class="type">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;坤坤扔出了一个篮球[%d]\n&quot;</span>,i);</span><br><span class="line">        <span class="built_in">pthread_cond_signal</span>(&amp;cond);</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> t1, t2;</span><br><span class="line">    <span class="built_in">pthread_cond_init</span>(&amp;cond, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_mutex_init</span>(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;t1, <span class="literal">NULL</span>, chicken, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;t2, <span class="literal">NULL</span>, kunkun, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_join</span>(t1, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_join</span>(t2, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_mutex_destroy</span>(&amp;mutex);</span><br><span class="line">    <span class="built_in">pthread_cond_destroy</span>(&amp;cond);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在如上代码中,<code>chicken</code>线程负责等待条件变量(这里具象化为获取篮球),<code>kunkun</code>线程负责唤醒信号量（这里具象化为扔出篮球）</p><p>特别的，本段代码通过<code>for</code>循环控制<code>kunkun</code>线程只唤醒五次信号量，而<code>chicken</code>线程工作在死循环中，我们看一下代码的输出</p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/thread_signal9192008788.png"></p><p>可以看到，<code>kunkun</code>线程按照预期执行了5次循环，而<code>chicken</code>却也因为条件变量的控制，只执行了<code>5次</code>循环</p><h3 id="为什么pthread-cond-wait需要互斥量"><a href="#为什么pthread-cond-wait需要互斥量" class="headerlink" title="为什么pthread_cond_wait需要互斥量?"></a>为什么<code>pthread_cond_wait</code>需要互斥量?</h3><ul><li><code>条件等待</code>是线程间同步的一种手段，如果只有一个线程，条件不满足，一直等下去都不会满足，所以必须要有<strong>另一个线程</strong>通过某些操作，改变共享变量，使原先不满足的条件变得满足，并且友好的<strong>通知等待</strong>在条件变量上的线程。</li><li>条件不会无缘无故的突然变得满足了，必然会牵扯到<strong>共享数据的变化</strong>。所以一定要用<strong>互斥锁来保护</strong>。没有互斥锁就无法安全的获取和修改共享数据。</li></ul><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/thraed_sig_mutex09192026148.png"></p><p>按照上面的说法，我们设计出如下的错误代码：先上锁，发现条件不满足，解锁，然后等待在条件变量上不就行了，如下代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误的设计</span></span><br><span class="line"><span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line"><span class="keyword">while</span> (condition_is_false)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line">    <span class="comment">// 解锁之后，等待之前，条件可能已经满足，信号已经发出，但是该信号可能被错过</span></span><br><span class="line">    <span class="built_in">pthread_cond_wait</span>(&amp;cond);</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br></pre></td></tr></table></figure><ul><li>由于解锁和等待不是原子操作。调用解锁之后,<code>pthread_cond_wait</code>之前，如果已经有其他线程获取到互斥量，摒弃条件满足，发送了信号，那么 <code>pthread_cond_wait</code>将错过这个信号，可能会导致线程永远阻塞在这个<code>pthread_cond_wait</code>。所以解锁和等待必须是一个原子操作。</li><li><code>int pthread_cond_wait(pthread_cond_ t *cond,pthread_mutex_ t * mutex);</code> 进入该函数后，会去看条件量等于<code>0</code>不？等于，就把互斥量变成<code>1</code>，直到<code>cond_ wait</code>返回，把条件量改成<code>1</code>，把互斥量恢复成原样。</li></ul><h3 id="条件变量使用规范"><a href="#条件变量使用规范" class="headerlink" title="条件变量使用规范"></a>条件变量使用规范</h3><p><em>等待条件代码</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutex_lock(&amp;mutex);</span><br><span class="line">while (条件为假）</span><br><span class="line">    pthread_cond_wait(cond, mutex);</span><br><span class="line">修改条件</span><br><span class="line">pthread_mutex_unlock(&amp;mutex);</span><br></pre></td></tr></table></figure><p><em>给条件发送信号代码</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutex_lock(&amp;mutex);</span><br><span class="line">设置条件为真</span><br><span class="line">pthread_cond_signal(cond);</span><br><span class="line">pthread_mutex_unlock(&amp;mutex);</span><br></pre></td></tr></table></figure><h2 id="生产者消费者模型"><a href="#生产者消费者模型" class="headerlink" title="生产者消费者模型"></a>生产者消费者模型</h2><p>生产者消费者模式就是通过一个<strong>容器</strong>来解决生产者和消费者的<strong>强耦合</strong>问题。生产者和消费者彼此之间不直接通讯，而通过<strong>阻塞队列来进行通讯</strong>，所以生产者生产完数据之后不用等待消费者处理，直接扔给阻塞队列，消费者不找生产者要数据，而是直接从阻塞队列里取，阻塞队列就相当于<strong>一个缓冲区</strong>，平衡了生产者和消费者的处理能力。这个阻塞队列就是用来给生产者和消费者<strong>解耦</strong>的。</p><h3 id="生产者消费者模型的有点"><a href="#生产者消费者模型的有点" class="headerlink" title="生产者消费者模型的有点"></a>生产者消费者模型的有点</h3><ul><li>解耦</li><li>支持并发</li><li>支持忙闲不均</li></ul><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/thread_PCM09192237411.png"></p><h3 id="基于BlockingQueue的生产者消费者模型"><a href="#基于BlockingQueue的生产者消费者模型" class="headerlink" title="基于BlockingQueue的生产者消费者模型"></a>基于BlockingQueue的生产者消费者模型</h3><p>在多线程编程中阻塞队列(<code>Blocking Queue</code>)是一种常用于实现生产者和消费者模型的数据结构。其与普通的队列区别在于，当队列<strong>为空</strong>时，从队列获取元素的操作将会被<strong>阻塞</strong>，直到队列中被放入了元素；当队列<strong>满时</strong>，往队列里存放元素的操作也会被<strong>阻塞</strong>，直到有元素被从队列中取出(以上的操作都是基于不同的线程来说的，线程在对阻塞队列进程操作时会被阻塞)</p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/THread_BlockQ09192244045.png"></p><h2 id="POSIX信号量"><a href="#POSIX信号量" class="headerlink" title="POSIX信号量"></a>POSIX信号量</h2><p>POSIX信号量和SystemV信号量作用相同，都是用于同步操作，达到无冲突的访问共享资源目的。 但POSIX可以用于线程间同步。</p><p><em>初始化信号量</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_init</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">int</span> pshared, <span class="type">unsigned</span> <span class="type">int</span> value)</span></span>;</span><br><span class="line">参数：</span><br><span class="line">pshared:<span class="number">0</span>表示线程间共享，非零表示进程间共享</span><br><span class="line">value：信号量初始值</span><br></pre></td></tr></table></figure><p><em>销毁信号量</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_destroy</span><span class="params">(<span class="type">sem_t</span> *sem)</span></span>;</span><br></pre></td></tr></table></figure><p><em>等待信号量</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">功能：等待信号量，会将信号量的值减<span class="number">1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_wait</span><span class="params">(<span class="type">sem_t</span> *sem)</span></span>; <span class="comment">//P()</span></span><br></pre></td></tr></table></figure><p>发布信号量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">功能：发布信号量，表示资源使用完毕，可以归还资源了。将信号量值加<span class="number">1</span>。</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_post</span><span class="params">(<span class="type">sem_t</span> *sem)</span></span>;<span class="comment">//V()</span></span><br></pre></td></tr></table></figure><p>上一节生产者-消费者的例子是基于queue的,其空间可以动态分配,现在基于固定大小的环形队列重写这个程序<br>（POSIX信号量）</p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202409222124291.png"></p><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>一种线程使用模式。线程过多会带来调度开销，进而影响缓存局部性和整体性能。而线程池维护着多个线程，等待着<br>监督管理者分配可并发执行的任务。这避免了在处理短时间任务时创建与销毁线程的代价。线程池不仅能够保证内核的充分利<br>用，还能防止过分调度。可用线程数量应该取决于可用的并发处理器、处理器内核、内存、网络sockets等的数量。</p><h3 id="线程池的应用场景："><a href="#线程池的应用场景：" class="headerlink" title="线程池的应用场景："></a>线程池的应用场景：</h3><ol><li>需要大量的线程来完成任务，且完成任务的<strong>时间比较短</strong>。 WEB服务器完成网页请求这样的任务，使用线程池技术是非常合适的。因<strong>为单个任务小，而任务数量巨大</strong>，你可以想象一个热门网站的点击次数。 但对于长时间的任务，比如一个Telnet连接请求，线程池的优点就不明显了。因为Telnet会话时间比线程的创建时间大多了。</li><li>对性能要求苛刻的应用，比如要求<strong>服务器迅速响应客户请求</strong>。</li><li>接受突发性的大量请求，但不至于使服务器因此产生大量线程的应用。突发性大量客户请求，在没有线程池情况下，将产生大量线程，虽然理论上大部分操作系统线程数目最大值不是问题，短时间内产生大量线程可能使内存到达极限，出现错误.</li></ol><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ThreadInfo</span><span class="comment">//储存线程信息</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    std::string name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> defaultnum = <span class="number">5</span>;<span class="comment">//默认5个线程</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Task</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Lock</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;_mutex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Unlock</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;_mutex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Wakeup</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">pthread_cond_signal</span>(&amp;_cond);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ThreadSleep</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">pthread_cond_wait</span>(&amp;_cond,&amp;_mutex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IsQueueEmpty</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _tasks.<span class="built_in">empty</span>();<span class="comment">//封装一下接口</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">GetThreadName</span><span class="params">(<span class="type">pthread_t</span> tid)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span> &amp;ti:_threads)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(tid == ti.tid) <span class="keyword">return</span> ti.name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;None&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Task <span class="title">Pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//确认只在加锁的情况下调用</span></span><br><span class="line">        Task t = _tasks.<span class="built_in">front</span>();</span><br><span class="line">        _tasks.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ThreadPool</span>(<span class="type">int</span> num = defaultnum):_threads(num)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_init</span>(&amp;_mutex,<span class="literal">nullptr</span>);</span><br><span class="line">        <span class="built_in">pthread_cond_init</span>(&amp;_cond,<span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">ThreadPool</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_destroy</span>(&amp;_mutex);</span><br><span class="line">        <span class="built_in">pthread_cond_destroy</span>(&amp;_cond);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> *<span class="title">HandlerTask</span><span class="params">(<span class="type">void</span>* args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ThreadPool&lt;Task&gt; *tp = <span class="keyword">static_cast</span>&lt;ThreadPool&lt;Task&gt; *&gt;(args);</span><br><span class="line">        std::string name = tp-&gt;<span class="built_in">GetThreadName</span>(<span class="built_in">pthread_self</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// std::cout&lt;&lt;&quot;get this success&quot;&lt;&lt;std::endl;//DEBUG</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            tp-&gt;<span class="built_in">Lock</span>();</span><br><span class="line">            <span class="keyword">while</span>(tp-&gt;<span class="built_in">IsQueueEmpty</span>())<span class="comment">//访问临界资源</span></span><br><span class="line">            &#123;</span><br><span class="line">                tp-&gt;<span class="built_in">ThreadSleep</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// std::cout&lt;&lt;&quot;task ready&quot;&lt;&lt;std::endl; //DEBUG</span></span><br><span class="line">            Task t = tp-&gt;<span class="built_in">Pop</span>();</span><br><span class="line">            <span class="comment">// std::cout&lt;&lt;&quot;Pop success&quot;&lt;&lt;std::endl; //DEBUG</span></span><br><span class="line">            tp-&gt;<span class="built_in">Unlock</span>();</span><br><span class="line"></span><br><span class="line">            <span class="built_in">t</span>();<span class="comment">//处理线程私有的任务，不需要加锁,可以并发</span></span><br><span class="line">            std::cout&lt;&lt;name&lt;&lt;<span class="string">&quot; run :result :&quot;</span> &lt;&lt; t._result&lt;&lt;std::endl;</span><br><span class="line">            <span class="built_in">sleep</span>(<span class="number">4</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> num = _threads.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;num;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            _threads[i].name = <span class="string">&quot;thread-&quot;</span>+std::<span class="built_in">to_string</span>(i);</span><br><span class="line">            <span class="built_in">pthread_create</span>(&amp;(_threads[i].tid),<span class="literal">nullptr</span>,HandlerTask,<span class="keyword">this</span>);</span><br><span class="line">            std::cout&lt;&lt;_threads[i].name&lt;&lt;<span class="string">&quot; create successfully&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Push</span><span class="params">(<span class="type">const</span> Task&amp; t)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">Lock</span>();</span><br><span class="line">        _tasks.<span class="built_in">push</span>(t);<span class="comment">//推送任务</span></span><br><span class="line">        <span class="built_in">Wakeup</span>();</span><br><span class="line">        <span class="built_in">Unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;ThreadInfo&gt; _threads;<span class="comment">//线程池</span></span><br><span class="line">    std::queue&lt;Task&gt; _tasks;<span class="comment">//任务队列</span></span><br><span class="line"></span><br><span class="line">    <span class="type">pthread_mutex_t</span> _mutex;<span class="comment">//锁</span></span><br><span class="line">    <span class="type">pthread_cond_t</span> _cond;<span class="comment">//条件队列</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="线程安全的单例模式"><a href="#线程安全的单例模式" class="headerlink" title="线程安全的单例模式"></a>线程安全的单例模式</h2><p>单例模式是一种”经典的，常用的，常考的”<strong>设计模式</strong></p><p>某些类, 只应该具有一个对象(实例), 就称之为单例</p><p>在很多服务器开发场景中, 经常需要让服务器加载很多的数据 (上百G) 到内存中. 此时往往要用一个单例的类来<strong>管理</strong>这些数据</p><h3 id="饿汉实现方式和懒汉实现方式"><a href="#饿汉实现方式和懒汉实现方式" class="headerlink" title="饿汉实现方式和懒汉实现方式"></a>饿汉实现方式和懒汉实现方式</h3><p>单例的实现主要有两种方式。</p><p><em>[洗完的例子]</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">吃完饭, 立刻洗碗, 这种就是饿汉方式. 因为下一顿吃的时候可以立刻拿着碗就能吃饭.</span><br><span class="line">吃完饭, 先把碗放下, 然后下一顿饭用到这个碗了再洗碗, 就是懒汉方式.</span><br></pre></td></tr></table></figure><p>懒汉方式最核心的思想是 “延时加载”. 从而能够优化服务器的启动速度.</p><h3 id="饿汉方式实现"><a href="#饿汉方式实现" class="headerlink" title="饿汉方式实现"></a>饿汉方式实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="type">static</span> T data;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> T* <span class="title">GetInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>只要通过 <code>Singleton</code> 这个包装类来使用 T 对象, 则一个进程中只有一个<code>static T</code> 对象的实例.</p><h3 id="懒汉方式实现"><a href="#懒汉方式实现" class="headerlink" title="懒汉方式实现"></a>懒汉方式实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="type">static</span> T* inst;<span class="comment">//声明指针</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> T* <span class="title">GetInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (inst == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            inst = <span class="keyword">new</span> <span class="built_in">T</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> inst;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>存在一个严重的问题, 线程不安全</strong></p><p>因为<code>inst</code>是多个进程共享的资源，对其进行判空操作，也要用锁保护起来</p><p><strong>线程安全的版本实现</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 懒汉模式, 线程安全</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">static</span> T *inst; <span class="comment">// 需要设置 volatile 关键字, 否则可能被编译器优化-&gt;被放到寄存器中.</span></span><br><span class="line">    <span class="type">static</span> std::mutex lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> T *<span class="title">GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (inst == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;                <span class="comment">// 双重判定空指针, 降低锁冲突的概率, 提高性能.</span></span><br><span class="line">            lock.<span class="built_in">lock</span>(); <span class="comment">// 使用互斥锁, 保证多线程情况下也只调用一次 new.</span></span><br><span class="line">            <span class="keyword">if</span> (inst == <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                inst = <span class="keyword">new</span> <span class="built_in">T</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            lock.<span class="built_in">unlock</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> inst;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>特别注意</strong></p><ol><li>加锁解锁的位置</li><li>双重if判定，避免不必要的锁竞争</li><li><code>volatile</code>关键字防止过度优化</li></ol><h2 id="STL-智能指针和线程安全"><a href="#STL-智能指针和线程安全" class="headerlink" title="STL,智能指针和线程安全"></a>STL,智能指针和线程安全</h2><h3 id="STL库是不是线程安全的"><a href="#STL库是不是线程安全的" class="headerlink" title="STL库是不是线程安全的"></a>STL库是不是线程安全的</h3><p>原因是, STL 的设计初衷是将性能挖掘到极致, <strong>而一旦涉及到加锁保证线程安全, 会对性能造成巨大的影响</strong>.而且对于不同的容器, 加锁方式的不同, 性能可能也不同(例如hash表的锁表和锁桶).因此 STL <strong>默认不是线程安全</strong>. 如果需要在多线程环境下使用, 往往需要调用者自行保证线程安全.</p><h3 id="智能指针是线程安全的"><a href="#智能指针是线程安全的" class="headerlink" title="智能指针是线程安全的"></a>智能指针是线程安全的</h3><ul><li><p><code>unique_ptr</code>, 由于只是在<code>当前代码块范围内</code>生效, 因此不涉及线程安全问</p></li><li><p><code>shared_ptr</code>, 多个对象需要共用一个引用计数变量, 所以会存在线程安全问题. 但是标准库实现的时候考虑到了这<br>个问题, 基于原子操作(CAS)的方式保证 shared_ptr 能够高效, 原子的操作引用计数.</p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Ssystem V 共享内存</title>
      <link href="/2024/08/14/shmd/"/>
      <url>/2024/08/14/shmd/</url>
      
        <content type="html"><![CDATA[<p>共享内存区是最快的IPC形式。一旦这样的内存映射到共享它的进程的地址空间，这些进程间数据传递<strong>不再涉及</strong>到<br><code>内核</code>，换句话说是进程不再通过执行进入内核的系统调用来传递彼此的数据,而是直接使用内存中的共享区。</p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/shared_mm.png"></p><p>我们接下来认识一下常用的接口</p><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><h2 id="shmget-创建共享内存"><a href="#shmget-创建共享内存" class="headerlink" title="shmget 创建共享内存"></a>shmget 创建共享内存</h2><p>需要同时引入<code>&lt;sys/ipc.h&gt;</code> <code>&lt;sys/shm.h&gt;</code></p><p><code>int shmget(key_t key, size_t size, int shmflg);</code></p><ul><li><code>key</code> 是生成<code>共享内存标示符</code>的 关键字,唯一的<code>key</code>值能返回唯一的<code>共享内存标示符</code>,这是获得同一个共享内存的关键参数</li><li><code>size</code>是指共享内存的大小,按字节算</li><li><code>shmflg</code>是一个位图,控制创建时的行为和 共享内存文件的<code>权限</code>(缺省时为<code>0</code>),常见选项如下<ul><li><code>IPC_CREAT</code>:单独一个时，如果申请的共享内存不存在，就创建，然后返回；若存在，则获取并返回</li><li><code>IPC_CREAT | IPC_EXCL</code>: 如果申请的共享内存不存在，则创建；若存在，则出错并返回<code>-1</code></li><li><code>IPC_EXCL</code>:不能单独使用</li><li><code>IPC_CREAT | 0666</code>:创建一个权限为<code>0666</code>的共享内存文件,注：<code>0666</code>可改成其它权限</li></ul></li><li><code>返回值</code>：若成功，则返回<code>共享内存标示符</code> ;若失败，则返回<code>-1</code></li></ul><p>由上可知，保证<code>key</code>的唯一性是获得同一个共享内存的关键步骤，那么如何获得唯一的<code>key_t</code>类型的呢？</p><p>这里使用新的接口<code>ftok</code>,（需同时引入<code>&lt;sys/types.h&gt;</code> 和 <code>&lt;sys/ipc.h&gt;</code>）</p><p><code>key_t ftok(const char *pathname, int proj_id);</code></p><ul><li><code>pathname</code>:必须指向一个存在的目录，或者有权限的文件</li><li><code>proj_id</code>: 该参数必须是<strong>非零</strong>的且至少有八位有效位的整型,可传<code>0x8888</code>这样的大整型</li><li><code>返回值</code>：成功时生成<code>key</code>,失败时返回<code>-1</code></li></ul><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/keytoshmid.png"></p><p>经过一系列操作便可以创建共享内存了</p><h3 id="查看共享内存"><a href="#查看共享内存" class="headerlink" title="查看共享内存"></a>查看共享内存</h3><p>在<code>shell</code>命令里输入命令<code>ipcs -m</code>就可以看到的共享内存列表</p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202408142027880.png"></p><p>可以看到我创建了一个大小为<code>1145</code>比特的共享内存</p><p>然而共享内存的声明周期与内核相同，必须要<strong>手动</strong>删除，所以在命令行上还有指令<code>ipcrm -m</code>指令删除共享内存</p><p>那么应该用表里的<code>key</code>还是<code>shmid</code>呢？结论是在用户层，统一使用<code>shmid</code>管理共享内存（毕竟全称就是 <code>共享内存描述符</code>）</p><p>例如上图就需要输入<code>ipcrm -m 0</code></p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202408142026217.png"></p><p>可以看到共享内存被删掉了</p><h3 id="共享内存的权限"><a href="#共享内存的权限" class="headerlink" title="共享内存的权限"></a>共享内存的权限</h3><p><code>ipcs -m</code>列表中的<code>perms</code>列就是共享内存文件的权限，没错，共享内存也是文件</p><p>当创建时没指定权限时，则默认为<code>全0</code>，若要指定权限,需要在<code>shmflg</code>处在<code>|</code>上权限，例如<code>0666</code></p><h3 id="共享内存的挂接数"><a href="#共享内存的挂接数" class="headerlink" title="共享内存的挂接数"></a>共享内存的挂接数</h3><p><code>ipcs -m</code>列表中的<code>nattch</code>下标注了共享内存的挂接数</p><h2 id="shmat-挂接共享内存"><a href="#shmat-挂接共享内存" class="headerlink" title="shmat 挂接共享内存"></a>shmat 挂接共享内存</h2><p><code>void *shmat(int shmid, const void *shmaddr, int shmflg);</code></p><ul><li><code>shmid</code>:前面获取的<code>共享内存描述符</code></li><li><code>shmadder</code>:一般传<code>nullptr</code>让系统自动选择挂接用的共享内存段地址</li><li><code>shmflg</code>:位图<ul><li><code>0</code>:传<code>0</code>时默认以<code>读写模式</code>挂接</li><li><code>SHM_RDONLY</code>: 以<code>只读模式</code>挂接</li><li><strong>没有</strong>只写模式挂接</li></ul></li><li><code>返回值</code>: 若成功，返回共享内存段地址；若失败，返回<code>(void *) -1</code></li></ul><h3 id="shmdt-取消挂接"><a href="#shmdt-取消挂接" class="headerlink" title="shmdt 取消挂接"></a>shmdt 取消挂接</h3><p>虽然进程退出时会自动取消挂接，但如果要在进程内取消挂接，就要用<code>shmdt</code>函数取消挂接</p><p><code>int shmdt(const void *shmaddr);</code></p><p>把<code>shmat</code>返回的指针传进去即可</p><h3 id="读写共享区内存"><a href="#读写共享区内存" class="headerlink" title="读写共享区内存"></a>读写共享区内存</h3><p>挂接上的进程是真正意义上的看到同一块内存，而且完全可以像<code>malloc</code>申请出的一段内存一样操作,比如把共享区的内存当成字符串的缓冲区,直接把标准输入用<code>fgets</code>拷贝到共享内存中</p><p>不过默认的共享内存并没有同步互斥行为,需要额外控制,比如使用<code>FIFO命名管道</code>来完成同步操作</p><h2 id="shmctl-控制共享内存"><a href="#shmctl-控制共享内存" class="headerlink" title="shmctl 控制共享内存"></a>shmctl 控制共享内存</h2><p><code>int shmctl(int shmid, int cmd, struct shmid_ds *buf);</code></p><p>该函数内容较多，下面只列举常见用法，更多信息请查阅<code>man</code>手册</p><ul><li><code>shmid</code>:共享内存描述符</li><li><code>cmd</code>:控制指令，有很多种<ul><li><code>IPC_RMID</code>:由共享内存创建者调用，声明该段共享内存已经取消挂接，传该参数时，后面的<code>buf</code>可传<code>nullptr</code></li><li><code>IPC_STAT</code>:获取共享内存的状态并拷贝到<code>buf</code>指向的内存中</li></ul></li><li><code>buf</code>:输出型参数,指向输出的内存缓冲区</li></ul><p><code>shmid_ds</code>的部分声明如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shmid_ds</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span> <span class="title">shm_perm</span>;</span>    <span class="comment">/* Ownership and permissions */</span></span><br><span class="line">    <span class="type">size_t</span>          shm_segsz;   <span class="comment">/* Size of segment (bytes) */</span></span><br><span class="line">    <span class="type">time_t</span>          shm_atime;   <span class="comment">/* Last attach time */</span></span><br><span class="line">    <span class="type">time_t</span>          shm_dtime;   <span class="comment">/* Last detach time */</span></span><br><span class="line">    <span class="type">time_t</span>          shm_ctime;   <span class="comment">/* Last change time */</span></span><br><span class="line">    <span class="type">pid_t</span>           shm_cpid;    <span class="comment">/* PID of creator */</span></span><br><span class="line">    <span class="type">pid_t</span>           shm_lpid;    <span class="comment">/* PID of last shmat(2)/shmdt(2) */</span></span><br><span class="line">    <span class="type">shmatt_t</span>        shm_nattch;  <span class="comment">/* No. of current attaches */</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="进程互斥"><a href="#进程互斥" class="headerlink" title="进程互斥"></a>进程互斥</h2><p>由于各进程要求共享资源，而且有些资源需要互斥使用，因此各进程间<strong>竞争使用</strong>这些资源，进程的这种关系为进程的互斥。</p><ul><li><code>临街资源</code>:系统中某些资源一次只允许一个进程使用，称这样的资源为<code>临界资源</code>或<code>互斥资源</code>。<em>就好比一个萝卜一个坑</em></li><li><code>临界区</code>: 在进程中涉及到互斥资源的<strong>程序段</strong>叫<code>临界区</code></li><li><code>同步</code>: 内存共享中的同步，主要指使<code>写入</code>和<code>读取</code>操作<code>互斥</code>，使二者有明确的先后顺序，能够在共享内存中一次写入或读取完整报文</li></ul><p>在共享内存中，使用<code>FIFO命名管道</code>建立另一条进程间通信，就能较为简单地完成同步功能：</p><ol><li>读端等待命名管道的信息</li><li>写端完成写入后利用命名管道，写入完成写入的信息，并等待读端的应答</li><li>读端接收到命名管道的信息后，才开始读取共享内存的内容</li><li>读端完成任务后向写端发送应答，写端返回第<code>1</code>步</li><li>写端开始继续写入</li></ol><h1 id="附加：System-V-消息队列-和-信号量"><a href="#附加：System-V-消息队列-和-信号量" class="headerlink" title="附加：System V 消息队列 和 信号量"></a>附加：System V 消息队列 和 信号量</h1><p>System V 还提供了消息队列和信号量用于进程间通信</p><h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/sharedmsg.png"></p><p>消息队列是由内核维护的一种数据结构,用法和普通的队列一样，可以<code>push</code>和<code>pop</code>数据块，用于进程间通信</p><h2 id="接口-1"><a href="#接口-1" class="headerlink" title="接口"></a>接口</h2><h3 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="msgget"><a href="#msgget" class="headerlink" title="msgget"></a>msgget</h3><p><code>int msgget(key_t key, int msgflg);</code></p><p>用于申请消息队列并获得<code>消息队列id</code></p><ul><li><code>key</code>:用法和获取与上一致，这里不赘述了</li><li><code>msgflg</code>:创建消息队列的选项，<strong>基本和上文<code>shmget</code>相同</strong>,内容较多，完整内容需翻阅<code>man</code>手册<ul><li><code>IPC_CREAT</code>:单独一个时，如果申请的共享内存不存在，就创建，然后返回；若存在，则获取并返回</li><li><code>IPC_CREAT | IPC_EXCL</code>: 如果申请的共享内存不存在，则创建；若存在，则出错并返回<code>-1</code></li><li><code>IPC_EXCL</code>:不能单独使用</li><li><code>IPC_CREAT | 0666</code>:创建一个权限为<code>0666</code>的共享内存文件,注：<code>0666</code>可改成其它权限</li></ul></li><li><code>返回值</code>：若成功，则返回<code>消息队列id</code> ;若失败，则返回<code>-1</code></li></ul><h4 id="查看消息队列"><a href="#查看消息队列" class="headerlink" title="查看消息队列"></a>查看消息队列</h4><p><code>ipcs -q</code>可以查看所有可用的消息队列，剩余操作与上文相同</p><h3 id="msgctl"><a href="#msgctl" class="headerlink" title="msgctl"></a>msgctl</h3><p><code>int msgctl(int msqid, int cmd, struct msqid_ds *buf);</code></p><p><code>msgctl</code>可用于控制消息队列</p><p>该函数内容较多，下面只列举常见用法，更多信息请查阅<code>man</code>手册</p><ul><li><code>msqid</code>:共享内存描述符</li><li><code>cmd</code>:控制指令，有很多种<ul><li><code>IPC_RMID</code>:由共享内存创建者调用，声明该段共享内存已经取消挂接，传该参数时，后面的<code>buf</code>可传<code>nullptr</code></li><li><code>IPC_STAT</code>:获取共享内存的状态并拷贝到<code>buf</code>指向的内存中</li></ul></li><li><code>buf</code>:输出型参数,指向输出的内存缓冲区</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msqid_ds</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span> <span class="title">msg_perm</span>;</span>   <span class="comment">/* Ownership and permissions */</span></span><br><span class="line">    <span class="type">time_t</span>          msg_stime;  <span class="comment">/* Time of last msgsnd(2) */</span></span><br><span class="line">    <span class="type">time_t</span>          msg_rtime;  <span class="comment">/* Time of last msgrcv(2) */</span></span><br><span class="line">    <span class="type">time_t</span>          msg_ctime;  <span class="comment">/* Time of creation or last</span></span><br><span class="line"><span class="comment">                                  modification by msgctl() */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>   msg_cbytes; <span class="comment">/* # of bytes in queue */</span></span><br><span class="line">    <span class="type">msgqnum_t</span>       msg_qnum;   <span class="comment">/* # number of messages in queue */</span></span><br><span class="line">    <span class="type">msglen_t</span>        msg_qbytes; <span class="comment">/* Maximum # of bytes in queue */</span></span><br><span class="line">    <span class="type">pid_t</span>           msg_lspid;  <span class="comment">/* PID of last msgsnd(2) */</span></span><br><span class="line">    <span class="type">pid_t</span>           msg_lrpid;  <span class="comment">/* PID of last msgrcv(2) */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="向消息队列收发消息"><a href="#向消息队列收发消息" class="headerlink" title="向消息队列收发消息"></a>向消息队列收发消息</h3><h4 id="msgsnd"><a href="#msgsnd" class="headerlink" title="msgsnd"></a>msgsnd</h4><p><code>int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg);</code></p><p><code>msgsnd</code>用于向消息队列发送消息</p><ul><li><code>msqid</code>:消息队列的<code>id</code></li><li><code>msgp</code>:是指向结构体数据块(消息)的指针</li><li><code>msgsz</code>:数据块的大小，按字节算</li><li><code>msgflg</code>: 位图,具体选项详见<code>man</code>手册，一般使用可以为<code>0</code></li><li>返回值：失败时返回<code>-1</code>,成功时返回<code>0</code></li></ul><p>其中,<code>msgp</code>要遵循如下格式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span> &#123;</span></span><br><span class="line">    <span class="type">long</span> mtype;       <span class="comment">/* 消息的类型,必须&gt; 0 */</span></span><br><span class="line">    <span class="type">char</span> mtext[<span class="number">1</span>];    <span class="comment">/* 消息的数据，长度可比1大 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中第一个成员必须是<code>long mtype</code>,且大于<code>0</code>。<br>而第二个成员是字符数组用于储存字节数据，长度没有限制，因此函数传参也是<code>void*</code>,适配各种长度的结构体指针</p><h4 id="msgrcv"><a href="#msgrcv" class="headerlink" title="msgrcv"></a>msgrcv</h4><p><code>ssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp,int msgflg);</code></p><p><code>msgrcv</code>用于从消息队列中接收数据（消息）</p><ul><li><code>msqid</code>:消息队列的<code>id</code></li><li><code>msgp</code>:是指向数据块(消息)的指针</li><li><code>msgsz</code>:数据块的大小，按字节算</li><li><code>msgtyp</code>:消息的类型</li><li><code>msgflg</code>: 位图,具体选项详见<code>man</code>手册，一般使用可以为<code>0</code></li><li>返回值：失败时返回<code>-1</code>,成功时返回读取的字节数</li></ul><h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>信号量的本质是是一种计数器，但它特殊在只能<code>互斥访问</code>,它本身就是一种互斥资源,但也可用于描述另一种临界资源的多少</p><p>信号量的工作原理:</p><ol><li>申请计数器成功，就表示我有访问资源的<strong>权限</strong>了</li><li>申请了计数器资源，不代表当前我要访问资源了。当前只是预定了资源</li><li>计数器可以有效保证进入共享资源的执行流的量</li></ol><h2 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h2><p>当信号量只能为<code>0</code>或<code>1</code>时,即<code>二元信号量</code>，该信号量就可以作为一把<code>互斥锁</code>来使用，访问前申请信号量，访问完毕再释放信号量即可</p><h3 id="系统调用接口"><a href="#系统调用接口" class="headerlink" title="系统调用接口"></a>系统调用接口</h3><p>这里不作详细介绍，具体用法请翻阅<code>man</code>手册</p><ul><li><code>semget</code>用于获取一个或多个信号量</li><li><code>semctl</code>用于控制信号量，可以<code>初始化</code>，<code>删除</code>，<code>获取状态参数</code>等</li><li><code>semop</code>用于获取信号量或释放信号量</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux日志系统</title>
      <link href="/2024/08/13/logSystem/"/>
      <url>/2024/08/13/logSystem/</url>
      
        <content type="html"><![CDATA[<h1 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h1><p>首先看看AI对日志系统的重要性是怎么解释的</p><blockquote><p>日志系统在软件开发和运维中扮演着至关重要的角色，主要体现在以下几个方面：</p><p><code>问题排查和调试</code>：日志记录了系统运行过程中的重要信息，包括错误信息、异常堆栈、接口调用信息等。开发人员可以通过分析日志快速定位问题，减少排查时间，提高开发效率。</p><p><code>性能监控</code>：通过记录应用程序的性能指标（如响应时间、请求吞吐量等），开发团队可以监控系统的健康状态，发现性能瓶颈并进行优化。</p><p><code>安全审计</code>：日志可以记录用户的操作和系统事件，为后期的安全审计提供依据。一旦发生安全事件，通过分析日志可以追踪到攻击来源和攻击方式。</p><p><code>用户行为分析</code>：通过对日志进行分析，开发团队可以了解用户的使用习惯和需求，这有助于改进产品功能和用户体验。</p><p><code>合规要求</code>：在许多行业中，日志记录是合规的要求之一。维护完整的日志记录可以帮助企业满足法律法规和行业标准。</p><p><code>系统健康监控</code>：通过实时监控日志，可以及时发现系统异常，进行预警和自动化处理，从而提高系统的可用性和稳定性。</p><p><code>故障恢复</code>：在系统出现故障时，日志记录可以帮助开发和运维人员还原问题发生前的状态，从而有助于快速恢复系统。</p></blockquote><p>总之，良好的日志系统能够帮助开发和运维团队提高效率、强化安全、提升用户体验，并确保系统的稳定性和可靠性。因此，在系统设计时，合理规划和实施日志记录机制是非常必要的。</p><p>因此出于学习实践的目的，和方便日后自己打印日志，我们可以先自己用C++封装一个简单的日志系统</p><h1 id="基本功能要求"><a href="#基本功能要求" class="headerlink" title="基本功能要求"></a>基本功能要求</h1><ul><li>打印日志等级</li><li>打印日志日期和时间</li><li>格式化打印日志消息</li><li>可选择输出到显示器，还是单个文件，还是按等级分文件</li></ul><p>功能缺陷：没有完善清理日志文件的功能，因此不能投入到真正的项目中，否则时间长了可能造成日志文件过大的问题</p><h1 id="头文件-和-宏定义"><a href="#头文件-和-宏定义" class="headerlink" title="头文件 和 宏定义"></a>头文件 和 宏定义</h1><p>本次要用到的头文件依然较多,而用到的宏定义有文件名和缓冲区大小，因为有时日志要打印到文件中，所以要准备一个文件名</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_FILE <span class="string">&quot;log.txt&quot;</span><span class="comment">//日志文件名</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE 1024  <span class="comment">//缓冲区大小</span></span></span><br></pre></td></tr></table></figure><h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><p>日志系统中要用到较多选项，这里使用枚举最为直观和简洁</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">OUT_MODE</span><span class="comment">//输出模式</span></span><br><span class="line">&#123;</span><br><span class="line">    Screen,  <span class="comment">//输出到显示器</span></span><br><span class="line">    OneFile, <span class="comment">//输出到一个文件</span></span><br><span class="line">    MultiFile<span class="comment">//按等级输出到多个文件</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">LEVEL</span> <span class="comment">//日志等级</span></span><br><span class="line">&#123;</span><br><span class="line">    Info,    <span class="comment">//一般信息</span></span><br><span class="line">    Debug,   <span class="comment">//debug日志</span></span><br><span class="line">    Warning, <span class="comment">//警告</span></span><br><span class="line">    Error,   <span class="comment">//错误</span></span><br><span class="line">    Fatal    <span class="comment">//失败</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="类的基本构成"><a href="#类的基本构成" class="headerlink" title="类的基本构成"></a>类的基本构成</h1><p>这里我们封装一个<code>Log</code>类,</p><ul><li>储存一个私有成员变量<code>_om</code>(output mode) </li><li>重载<code>operator()()</code>使其有仿函数的功能</li><li>声明<code>enable</code>函数用于切换输出模式</li><li>声明<code>levelToString</code>将<code>LEVEL</code>的枚举类型转换为<code>string</code>类</li><li>声明<code>printLog</code>用于调用不同接口打印日志</li><li>声明<code>printMultiFile</code>用于向指定<code>文件名</code>打印日志</li><li>声明<code>printMultiFile</code>用于向指定<code>日志等级</code>的文件打印日志</li></ul><h1 id="功能突破"><a href="#功能突破" class="headerlink" title="功能突破"></a>功能突破</h1><p>有个别功能由于平时不常用&#x2F;没见过，需要特别的突破一下</p><h2 id="打印日期和时间"><a href="#打印日期和时间" class="headerlink" title="打印日期和时间"></a>打印日期和时间</h2><p>我们都知道在<code>&lt;time.h&gt;</code>中提供了<code>time()</code>函数获取时间戳，但如何方便地获取年月日和时分秒呢？</p><p>这里要引出里面的另一个接口<code>localtime()</code>了</p><p><code>struct tm *localtime(const time_t *timep);</code></p><p>可以看到，给它一个时间戳的指针，它就会返回一个<code>struct tm</code>结构体的指针，我们再来看看结构体里有什么</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tm</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> tm_sec;         <span class="comment">/* seconds */</span>           <span class="comment">//秒</span></span><br><span class="line">    <span class="type">int</span> tm_min;         <span class="comment">/* minutes */</span>           <span class="comment">//分钟</span></span><br><span class="line">    <span class="type">int</span> tm_hour;        <span class="comment">/* hours */</span>             <span class="comment">//小时</span></span><br><span class="line">    <span class="type">int</span> tm_mday;        <span class="comment">/* day of the month */</span>  <span class="comment">//一个月的中的第几天</span></span><br><span class="line">    <span class="type">int</span> tm_mon;         <span class="comment">/* month */</span>             <span class="comment">//月份(从0月开始)</span></span><br><span class="line">    <span class="type">int</span> tm_year;        <span class="comment">/* year */</span>              <span class="comment">//年份,从1900年为0年开始</span></span><br><span class="line">    <span class="type">int</span> tm_wday;        <span class="comment">/* day of the week */</span>   <span class="comment">//一周的第几天</span></span><br><span class="line">    <span class="type">int</span> tm_yday;        <span class="comment">/* day in the year */</span>   <span class="comment">//一年中的第几天</span></span><br><span class="line">    <span class="type">int</span> tm_isdst;       <span class="comment">/* daylight saving time */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到，借助<code>localtime()</code>函数可以方便地获取详细时间,简化了代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> leftBuffer[SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">time_t</span> t = <span class="built_in">time</span>(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">tm</span> *ctime = <span class="built_in">localtime</span>(&amp;t);<span class="comment">//获取时间</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">snprintf</span>(leftBuffer,<span class="built_in">sizeof</span>(leftBuffer),<span class="string">&quot;[%s][%d-%d-%d %d:%d:%d]&quot;</span>,<span class="built_in">levelToString</span>(level).<span class="built_in">c_str</span>(),<span class="number">1900</span>+ctime-&gt;tm_year,<span class="number">1</span>+ctime-&gt;tm_mon,ctime-&gt;tm_mday,</span><br><span class="line">    ctime-&gt;tm_hour,ctime-&gt;tm_min,ctime-&gt;tm_sec);</span><br></pre></td></tr></table></figure><p><em>levelToString()函数后文再介绍</em></p><h2 id="可变参数列表-与-格式化字符串"><a href="#可变参数列表-与-格式化字符串" class="headerlink" title="可变参数列表 与 格式化字符串"></a>可变参数列表 与 格式化字符串</h2><p>为了能让函数能够接受<code>格式化字符串</code>来方便打印日志，重载<code>operator()()</code>时要仿照<code>printf()</code>的函数声明</p><p><code>void operator()(LEVEL level,const char *format,...)</code></p><p>如上，最后一个参数用<code>...</code></p><p>那么如何取出来呢？这里就要用到头文件<code>stdarg.h</code>的接口了</p><p>首先用<code>va_list</code>声明一个变量<code>s</code>，</p><p>然后用<code>va_start()</code>初始化<code>s</code>,因为函数的形参是从右往左实例化的，，所以还要传<code>...</code>左边第一个参数给它定位,例如<code>va_start(s,format)</code></p><p>使用<code>va_start()</code>初始化后便可以调用其它函数了</p><p>而在使用完的最后，还要调用<code>va_end()</code>来结束对变量<code>s</code>的使用,例如<code>va_end(s)</code></p><h3 id="va-arg"><a href="#va-arg" class="headerlink" title="va_arg()"></a>va_arg()</h3><p><code>type va_arg(va_list ap, type);</code></p><p>这个<code>宏函数</code>可以传类型作为参数，并从参数列表取出对应的参数</p><p>以写一个n个数相加的函数为例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">nsum</span><span class="params">(<span class="type">int</span> n,...)</span><span class="comment">//参数n表示n个数相加</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    va_list ap;</span><br><span class="line">    <span class="built_in">va_start</span>(ap,n);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> num = <span class="built_in">va_arg</span>(ap,<span class="type">int</span>);<span class="comment">//每次获取一个int 参数</span></span><br><span class="line">        sum+=num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">va_end</span>(ap);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">nsum</span>(<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)&lt;&lt;endl;<span class="comment">//输出5个数相加</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到我们用<code>va_arg</code>实现了任意参数数量的整型相加</p><h3 id="vsnprintf"><a href="#vsnprintf" class="headerlink" title="vsnprintf()"></a>vsnprintf()</h3><p><code>int vsnprintf(char *str, size_t size, const char *format, va_list ap);</code></p><ul><li><code>str</code>:存放字符串的缓冲区指针</li><li><code>size</code>:缓冲区大小</li><li><code>format</code>原格式字符串</li><li><code>ap</code>: va_list类型的变量</li></ul><p>有了这个函数就可以方便地把可变参数列表打印到字符串里了</p><p>例如在本文的<code>Log</code>类中,</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将内容输出到缓冲区中</span></span><br><span class="line">va_list s;</span><br><span class="line"><span class="built_in">va_start</span>(s,format);</span><br><span class="line"><span class="type">char</span> rightBuffer[SIZE];</span><br><span class="line"><span class="built_in">vsnprintf</span>(rightBuffer,<span class="built_in">sizeof</span>(rightBuffer),format,s);</span><br><span class="line"><span class="built_in">va_end</span>(s);</span><br></pre></td></tr></table></figure><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><p>剩下的部分就比较简单了，也就不分开讲解了，直接放出完整代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_FILE <span class="string">&quot;log.txt&quot;</span><span class="comment">//日志文件名</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE 1024  <span class="comment">//缓冲区大小</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">OUT_MODE</span><span class="comment">//输出模式</span></span><br><span class="line">&#123;</span><br><span class="line">    Screen,  <span class="comment">//输出到显示器</span></span><br><span class="line">    OneFile, <span class="comment">//输出到一个文件</span></span><br><span class="line">    MultiFile<span class="comment">//按等级输出到多个文件</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">LEVEL</span> <span class="comment">//日志等级</span></span><br><span class="line">&#123;</span><br><span class="line">    Info,    <span class="comment">//一般信息</span></span><br><span class="line">    Debug,   <span class="comment">//debug日志</span></span><br><span class="line">    Warning, <span class="comment">//警告</span></span><br><span class="line">    Error,   <span class="comment">//错误</span></span><br><span class="line">    Fatal    <span class="comment">//失败</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Log</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Log</span>(OUT_MODE om = Screen):_om(om)<span class="comment">//默认构造函数</span></span><br><span class="line">    &#123;&#125;</span><br><span class="line">    ~<span class="built_in">Log</span>()&#123;&#125;<span class="comment">//没有特殊用处</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">enable</span><span class="params">(OUT_MODE om)</span><span class="comment">//启用指定的输出模式</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _om = om;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">std::string <span class="title">levelToString</span><span class="params">(LEVEL level)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (level)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> Info:<span class="keyword">return</span> <span class="string">&quot;Info&quot;</span>;</span><br><span class="line">            <span class="keyword">case</span> Debug:<span class="keyword">return</span> <span class="string">&quot;Debug&quot;</span>;</span><br><span class="line">            <span class="keyword">case</span> Warning:<span class="keyword">return</span> <span class="string">&quot;Warning&quot;</span>;</span><br><span class="line">            <span class="keyword">case</span> Error:<span class="keyword">return</span> <span class="string">&quot;Error&quot;</span>;</span><br><span class="line">            <span class="keyword">case</span> Fatal:<span class="keyword">return</span> <span class="string">&quot;Fatal&quot;</span>;</span><br><span class="line">        <span class="keyword">default</span>: <span class="keyword">return</span> <span class="string">&quot;None&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(LEVEL level,<span class="type">const</span> <span class="type">char</span> *format,...)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">char</span> leftBuffer[SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">time_t</span> t = <span class="built_in">time</span>(<span class="literal">nullptr</span>);</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">tm</span> *ctime = <span class="built_in">localtime</span>(&amp;t);<span class="comment">//获取时间</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">snprintf</span>(leftBuffer,<span class="built_in">sizeof</span>(leftBuffer),<span class="string">&quot;[%s][%d-%d-%d %d:%d:%d]&quot;</span>,<span class="built_in">levelToString</span>(level).<span class="built_in">c_str</span>(),<span class="number">1900</span>+ctime-&gt;tm_year,<span class="number">1</span>+ctime-&gt;tm_mon,ctime-&gt;tm_mday,</span><br><span class="line">            ctime-&gt;tm_hour,ctime-&gt;tm_min,ctime-&gt;tm_sec);</span><br><span class="line"></span><br><span class="line">        va_list s;</span><br><span class="line">        <span class="built_in">va_start</span>(s,format);</span><br><span class="line">        <span class="type">char</span> rightBuffer[SIZE];</span><br><span class="line">        <span class="built_in">vsnprintf</span>(rightBuffer,<span class="built_in">sizeof</span>(rightBuffer),format,s);</span><br><span class="line">        <span class="built_in">va_end</span>(s);</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> logtxt[SIZE*<span class="number">2</span>];</span><br><span class="line">        <span class="built_in">snprintf</span>(logtxt,<span class="built_in">sizeof</span>(logtxt),<span class="string">&quot;%s %s&quot;</span>,leftBuffer,rightBuffer);</span><br><span class="line">        <span class="built_in">printLog</span>(level,logtxt);;<span class="comment">//打印日志</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printLog</span><span class="params">(LEVEL level, <span class="type">const</span> std::string&amp; logtxt)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span>(_om)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> Screen:std::cout&lt;&lt;logtxt&lt;&lt;std::endl;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OneFile:<span class="built_in">printOneFile</span>(LOG_FILE,logtxt);<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MultiFile:<span class="built_in">printMultiFile</span>(level,logtxt);<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>: <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printOneFile</span><span class="params">(<span class="type">const</span> std::string&amp; logname,<span class="type">const</span> std::string&amp; logtxt)</span><span class="comment">//传两个参数用于代码复用</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> fd = <span class="built_in">open</span>(logname.<span class="built_in">c_str</span>(), O_WRONLY|O_CREAT|O_APPEND,<span class="number">0666</span>);</span><br><span class="line">        <span class="keyword">if</span>(fd&lt;<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">write</span>(fd,logtxt.<span class="built_in">c_str</span>(),logtxt.<span class="built_in">size</span>());</span><br><span class="line">        <span class="built_in">close</span>(fd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printMultiFile</span><span class="params">(LEVEL level,<span class="type">const</span> std::string logtxt)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::string filename = LOG_FILE;<span class="comment">//构建文件名</span></span><br><span class="line">        filename+= <span class="string">&quot;.&quot;</span>;</span><br><span class="line">        filename += <span class="built_in">levelToString</span>(level);</span><br><span class="line">        <span class="built_in">printOneFile</span>(filename,logtxt);<span class="comment">//复用代码</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    OUT_MODE _om = Screen;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Linux C++ 日志 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手撕AVL树</title>
      <link href="/2024/08/12/AVLTree/"/>
      <url>/2024/08/12/AVLTree/</url>
      
        <content type="html"><![CDATA[<h1 id="AVL树的概念"><a href="#AVL树的概念" class="headerlink" title="AVL树的概念"></a>AVL树的概念</h1><h2 id="二叉搜索树的不足"><a href="#二叉搜索树的不足" class="headerlink" title="二叉搜索树的不足"></a>二叉搜索树的不足</h2><p>二叉搜索树虽可以缩短查找的效率，但如果数据有序或接近有序二叉搜索树将<strong>退化</strong>为<code>单支树</code>，查找元素相当于在顺序表中搜索元素，效率低下。</p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/lajibstree2.png"></p><h2 id="AVL树的提出"><a href="#AVL树的提出" class="headerlink" title="AVL树的提出"></a>AVL树的提出</h2><p>两位俄罗斯的数学家<em>G.M.Adelson-Velskii</em>和<em>E.M.Landis</em>在1962年发明了一种解决上述问题的方法：<br><strong>当向二叉搜索树中插入新结点后，如果能保证每个结点的左右子树高度之差的绝对值不超过1(需要对树中的结点进行调整)</strong>,即构建一颗<code>绝对的平衡搜索二叉树</code>，即可降低树的高度，从而减少平均搜索长度。</p><p><strong>定义</strong>: 一棵AVL树或者是空树，或者是具有以下性质的二<code>叉搜索树</code>：</p><ul><li>它的左右子树都是AVL树</li><li>左右子树高度之差(简称<code>平衡因子</code>)的绝对值不超过1(-1&#x2F;0&#x2F;1)</li></ul><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/aaaAVL80.png"></p><p>如果一棵二叉搜索树是高度平衡的，它就是AVL树。如果它有n个结点，其高度可保持在<code>O(log_2 n)</code>,搜索的时间复杂度<code>O(log_2 n)</code></p><h1 id="封装AVL树"><a href="#封装AVL树" class="headerlink" title="封装AVL树"></a>封装AVL树</h1><h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="封装AVL树的节点"><a href="#封装AVL树的节点" class="headerlink" title="封装AVL树的节点"></a>封装AVL树的节点</h2><ul><li>这里采用<code>键值(KV)</code>类型的二叉树节点,使其泛用性更高</li><li>并增加指向父节点的指针构造三叉链表，来<strong>简化</strong>对二叉树的调整，但代价是<strong>维护成本</strong>变高(多了一个指针要维护)。</li><li>引入<code>平衡因子</code>:<ul><li><code>-1</code>表示左子树比右子树高<code>1</code>层  <em>左&gt;右</em></li><li><code>0</code>表示左右子树等高           <em>左&#x3D;右</em></li><li><code>1</code>表示右子树比左子树高<code>1</code>层   <em>左&lt;右</em></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">K</span>,<span class="keyword">class</span> <span class="title class_">V</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AVLTreeNode</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">typedef</span> AVLTreeNode&lt;K, V&gt; Node;<span class="comment">//使用typedef简化代码</span></span><br><span class="line">Node* _left;                   </span><br><span class="line">Node* _right;</span><br><span class="line">Node* _parent;</span><br><span class="line">std::pair&lt;K, V&gt; _kv; <span class="comment">//节点储存的键值对</span></span><br><span class="line"><span class="type">int</span> _bf;<span class="comment">// ballance factor 平衡因子</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数，但不提供无参的默认构造函数</span></span><br><span class="line"><span class="built_in">AVLTreeNode</span>(<span class="type">const</span> std::pair&lt;K, V&gt;&amp; kv)</span><br><span class="line">:_left(<span class="literal">nullptr</span>)</span><br><span class="line">, _right(<span class="literal">nullptr</span>)</span><br><span class="line">, _parent(<span class="literal">nullptr</span>)</span><br><span class="line">, _kv(kv)</span><br><span class="line">, _bf(<span class="number">0</span>)</span><br><span class="line">&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="规定AVLTree类的框架"><a href="#规定AVLTree类的框架" class="headerlink" title="规定AVLTree类的框架"></a>规定AVLTree类的框架</h2><p>首先确定成员变量,这里仅用<code>_root</code>指向二叉树，具体的维护由<code>成员函数</code>完成</p><p>代码简化方面，使用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> AVLTreeNode&lt;K, V&gt; Node;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;K,V&gt; PKV;</span><br></pre></td></tr></table></figure><p>简化代码</p><p>然后是准备实现的<code>成员函数</code></p><p><strong>公共接口</strong></p><ul><li><code>Insert</code>插入节点</li><li><code>Inorder</code>前序遍历打印节点，用于debug</li><li><code>IsBalance</code>检测是否平衡</li><li><code>Height</code>获取子树高度</li></ul><p><strong>私有接口</strong></p><ul><li><code>RotateL</code>向左旋转子树，用于维护平衡</li><li><code>RotateR</code>向右旋转子树，用于维护平衡</li><li><code>RotateLR</code>向左再向右旋转子树，用于维护平衡</li><li><code>RotateRL</code>向右再向左旋转子树，用于维护平衡</li></ul><p>实现AVL树的核心就是实现这四个<strong>旋转操作</strong>,并再在<code>insert</code>中回调。所以<code>Insert</code>函数我们放到最后再实现</p><h2 id="默认构造函数"><a href="#默认构造函数" class="headerlink" title="默认构造函数"></a>默认构造函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">V</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AVLTree</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">typedef</span> AVLTreeNode&lt;K, V&gt; Node;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;K, V&gt; PKV;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">AVLTree</span>() :_root(<span class="literal">nullptr</span>) &#123;&#125;<span class="comment">//默认构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Node* _root;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Inorder函数"><a href="#Inorder函数" class="headerlink" title="Inorder函数"></a>Inorder函数</h2><p>公共的<code>Inorder</code>接口为无参函数,内部调用另外定义的<code>_Inorder</code>子函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">AVLTree</span>() :_root(<span class="literal">nullptr</span>) &#123;&#125;<span class="comment">//默认构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Inorder</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">_Inorder(_root);</span><br><span class="line">std::cout&lt;&lt;<span class="string">&quot;nullptr&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="type">void</span> _Inorder(Node* root)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">_Inorder(root-&gt;_left);</span><br><span class="line">std::cout &lt;&lt; root-&gt;_kv.second &lt;&lt; <span class="string">&quot;-&gt;&quot;</span>;</span><br><span class="line">_Inorder(root-&gt;_right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Height函数"><a href="#Height函数" class="headerlink" title="Height函数"></a>Height函数</h2><p>同上，使用<code>_Height</code>子函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Height</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _Height(_root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> _Height(Node* root)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> LHeight = _Height(root-&gt;_left);</span><br><span class="line"><span class="type">int</span> RHeight = _Height(root-&gt;_right);</span><br><span class="line"><span class="keyword">if</span> (LHeight &gt; RHeight) <span class="keyword">return</span> LHeight + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> RHeight + <span class="number">1</span>; <span class="comment">//将左右子树相等的情况合并在这里</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="IsBalance函数"><a href="#IsBalance函数" class="headerlink" title="IsBalance函数"></a>IsBalance函数</h2><p>同上，使用<code>_Balance</code>子函数</p><p>这里要较为严格，<strong>可靠</strong>地地判定平衡,而平衡因子由我们自己维护，作为判定的依据，并<strong>不可靠</strong>，相比之下,计算左右子树的高度差<strong>更可靠</strong>,所以这里回调<code>_Height</code>函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsBalance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _IsBalance(_root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">bool</span> _IsBalance(Node* root)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="type">bool</span> left = _IsBalance(root-&gt;_left);</span><br><span class="line"><span class="type">bool</span> right = _IsBalance(root-&gt; - _right);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (left == <span class="literal">false</span> || right == <span class="literal">false</span>) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//先判定左右子树</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> LHeight = _Height(root-&gt;_left);</span><br><span class="line"><span class="type">int</span> RHeight = _Height(root-&gt;_right);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (LHeight - RHeight &gt;= <span class="number">2</span> || LHeight - RHeight &lt;= <span class="number">-2</span>)<span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//最后判定根</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Insert函数"><a href="#Insert函数" class="headerlink" title="Insert函数"></a>Insert函数</h2><p><code>Insert</code>函数主要按步骤实现以下功能</p><ol><li><code>插入节点</code>:先按照二叉搜索树的规则将节点插入到AVL树中</li><li><code>维护平衡</code>:新节点插入后，AVL树的平衡性可能会遭到破坏，此时就需要更新平衡因子，并检测是否破坏了AVL树</li></ol><h3 id="插入节点"><a href="#插入节点" class="headerlink" title="插入节点"></a>插入节点</h3><p>具体插入方式与<code>平衡搜索二叉树</code>基本相同,但是还要额外维护<code>_parent</code>指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Insert</span><span class="params">(<span class="type">const</span> PKV&amp; kv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Cmp cmp;<span class="comment">//仿函数实例化一个对象</span></span><br><span class="line"><span class="keyword">if</span> (_root == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">_root = <span class="keyword">new</span> <span class="built_in">Node</span>(kv);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">Node* cur = _root;</span><br><span class="line">Node* parent = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="comment">//寻找插入位置</span></span><br><span class="line"><span class="keyword">while</span> (cur)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (cur-&gt;_kv.first == kv.first)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//该键下的节点已存在，发生冲突</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">cmp</span>(cur-&gt;_kv.first, kv.first))<span class="comment">//根比节点&quot;大&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">parent = cur;</span><br><span class="line">cur = cur-&gt;_left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="comment">//根比节点小</span></span><br><span class="line">&#123;</span><br><span class="line">parent = cur;</span><br><span class="line">cur = cur-&gt;_right;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//开始插入</span></span><br><span class="line">Node* node = <span class="keyword">new</span> <span class="built_in">Node</span>(kv);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">cmp</span>(parent-&gt;_kv.first, kv.first))<span class="comment">//应该插入左边</span></span><br><span class="line">&#123;</span><br><span class="line">parent-&gt;_left = node;</span><br><span class="line">node-&gt;_parent = parent;</span><br><span class="line">parent-&gt;_bf -= <span class="number">1</span>;<span class="comment">//_bf越小，左子树越高</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="comment">//插入右子树</span></span><br><span class="line">&#123;</span><br><span class="line">parent-&gt;_right = node;</span><br><span class="line">node-&gt;_parent = parent;</span><br><span class="line">parent-&gt;_bf += <span class="number">1</span>;<span class="comment">//_bf越大，右子树越高</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//插入完成，准备开始维护平衡</span></span><br><span class="line"><span class="comment">//.....</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="维护平衡"><a href="#维护平衡" class="headerlink" title="维护平衡"></a>维护平衡</h3><p>插入节点的所有父级子树的高度都有可能受到其影响，所以要<strong>一路向上递归</strong>维护，直至某棵子树的高度不变,或者到达根节点</p><p>下面我们一一枚举所有情况,并逐一解决</p><ul><li>父节点<code>_bf == 0</code><ul><li>右子树高度增加: <code>_bf = 1</code>,且父节点高度增加，需继续<strong>向上调整</strong></li><li>左子树高度增加: <code>_bf = -1</code>,且父节点高度增加，需继续<strong>向上调整</strong></li></ul></li><li>父节点<code>_bf == -1</code><ul><li>右子树高度增加: <code>_bf = 0</code>,父节点高度不变，停止调整</li><li>左子树高度增加: <code>_bf = -2</code>,平衡被打破,需要<strong>旋转调整</strong>, <em>下文详细讨论</em></li></ul></li><li>父节点<code>_bf == 1</code><ul><li>右子树高度增加: <code>_bf = 2</code>,平衡被打破,需要<strong>旋转调整</strong>, <em>下文详细讨论</em></li><li>左子树高度增加: <code>_bf = 0</code>,父节点高度不变，停止调整</li></ul></li></ul><p>可以看到，需要调整调整的情况有两大方向，接下来详细介绍调整方法</p><h4 id="RotateR-bf-2且子树的左子树超高"><a href="#RotateR-bf-2且子树的左子树超高" class="headerlink" title="RotateR :_bf == -2且子树的左子树超高"></a><code>RotateR </code>:<code>_bf == -2</code>且子树的左子树超高</h4><p>根据约定，<code>_bf == -2</code>表示左子树比右子树高<code>2</code>，所以我们要先通过向右旋转操作减少左子树高度</p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202409021916938.png"></p><p>如图所示,通过向右旋转，成功地降低了左子树的高度，而根据<code>左子树</code>的平衡因子，又可以分为以下两种情况</p><ul><li><code>-1</code>:旋转后平衡性得到维护，但整棵树的高度由<code>h+2</code>降低到了<code>h-1</code>,总高度<code>-1</code>,与原本的高度<code>+1</code>相抵消,停止调整</li><li><code>0</code>:非法情况,不可能左右子树同时超高</li><li><code>1</code>:不存在的情况，因为破坏了左子树超高的前提</li></ul><p>以上分析可知，一次向右旋转已经可以解决<strong>两种</strong>情况了，所以我们着手实现<code>RotateR</code></p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/RotateR2.gif"></p><p>如上图所示，我们要对树里的父子关系作出调整，以此改变高度。</p><p>然后除了图中的内容，我们还要维护一系列<code>_bf</code>,指针之类的内容</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RotateR</span><span class="params">(Node* parent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (parent == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">Node* child = parent-&gt;_left;</span><br><span class="line"></span><br><span class="line"><span class="comment">//维护树的结构</span></span><br><span class="line">parent-&gt;_left = child-&gt;_right;<span class="comment">//过继子树的右子树</span></span><br><span class="line">child-&gt;_right = parent;<span class="comment">//重构树结构</span></span><br><span class="line">Node* grandParent = parent-&gt;_parent;<span class="comment">//维护祖父节点</span></span><br><span class="line">child-&gt;_parent = grandParent;<span class="comment">//维护child</span></span><br><span class="line">parent-&gt;_parent = child;</span><br><span class="line"><span class="keyword">if</span> (grandParent)<span class="comment">//如果不是根节点</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//维护根节点的父节点的子树</span></span><br><span class="line"><span class="keyword">if</span> (parent == grandParent-&gt;_left) grandParent-&gt;_left = child;</span><br><span class="line"><span class="keyword">else</span> grandParent-&gt;_right = child;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//维护平衡因子</span></span><br><span class="line"><span class="keyword">if</span> (child-&gt;_bf == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">child-&gt;_bf = <span class="number">0</span>;</span><br><span class="line">parent-&gt;_bf = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (child-&gt;_bf == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">assert</span>(<span class="literal">false</span>);<span class="comment">//不存在的情况</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">assert</span>(<span class="literal">false</span>);<span class="comment">//需要多次旋转时不应该调用该函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (parent == _root)</span><br><span class="line">&#123;</span><br><span class="line">_root = child;<span class="comment">//更新根节点</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="RotateL-bf-2且子树的右子树超高"><a href="#RotateL-bf-2且子树的右子树超高" class="headerlink" title="RotateL:_bf == 2且子树的右子树超高"></a><code>RotateL</code>:<code>_bf == 2</code>且子树的右子树超高</h4><p>根据约定，<code>_bf == -2</code>表示右子树比左子树高<code>2</code>，所以我们要先通过向左旋转操作减少右子树高度</p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202409030810533.png"></p><p>如图所示,通过向左旋转，成功地降低了右子树的高度，而根据<code>右子树</code>的平衡因子，又可以分为以下三种情况</p><ul><li><code>-1</code>:旋转后平衡性得到维护，但整棵树的高度由<code>h+2</code>降低到了<code>h-1</code>,总高度<code>-1</code>,需继续<strong>向上调整</strong></li><li><code>0</code>:非法情况,不可能左右子树同时超高</li><li><code>1</code>:不存在的情况，因为破坏了子树的右子树超高的前提</li></ul><p>以上分析可知，一次向左旋转已经可以解决<strong>两种</strong>情况了，所以我们先实现<code>RotateL</code><br>和<code>RotateL</code>一样，我们要对树里的父子关系作出调整，以此改变高度。</p><p>然后除了图中的内容，我们还要维护一系列<code>_bf</code>,指针之类的内容</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RotateL</span><span class="params">(Node* parent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (parent == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">Node* child = parent-&gt;_right;</span><br><span class="line"><span class="comment">//维护树结构</span></span><br><span class="line">parent-&gt;_right = child-&gt;_left;<span class="comment">//过继子树</span></span><br><span class="line">child-&gt;_left = parent;<span class="comment">//重构树结构</span></span><br><span class="line">Node* grandParent = parent-&gt;_parent;<span class="comment">//维护祖父节点</span></span><br><span class="line">child-&gt;_parent = grandParent;<span class="comment">//维护_parent</span></span><br><span class="line">parent-&gt;_parent = child;<span class="comment">//维护_parent</span></span><br><span class="line"><span class="keyword">if</span> (grandParent)<span class="comment">//如果不是根节点</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//维护祖父节点的子树</span></span><br><span class="line"><span class="keyword">if</span> (parent == grandParent-&gt;_left) grandParent-&gt;_left = child;</span><br><span class="line"><span class="keyword">else</span> grandParent-&gt;_right = child;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//维护平衡因子</span></span><br><span class="line"><span class="keyword">if</span> (child-&gt;_bf == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">child-&gt;_bf = <span class="number">0</span>;</span><br><span class="line">parent-&gt;_bf = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (child-&gt;_bf == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">assert</span>(<span class="literal">false</span>);<span class="comment">//不存在的情况</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">assert</span>(<span class="literal">false</span>);<span class="comment">//需要多次旋转时不应该调用该函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (parent == _root)</span><br><span class="line">&#123;</span><br><span class="line">_root = child;<span class="comment">//更新根节点</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="RotateRL-bf-2且子树的右子树超高"><a href="#RotateRL-bf-2且子树的右子树超高" class="headerlink" title="RotateRL:_bf == -2且子树的右子树超高"></a><code>RotateRL</code>:<code>_bf == -2</code>且子树的右子树超高</h4><p>当出现该情况时，单纯的向右旋转并不顶用,效果如下图</p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/RotateR_err.png"></p><p>所以说我们要先调整左子树的平衡因子(左子树向左旋转)，再最后进行向右旋转</p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/ROtateLR_re.png"></p><p>如上图，通过两次旋转，完成了整体的平衡因子的维护</p><p><strong>高度变化</strong>：整棵树的高度由<code>h+3</code>变成了<code>h+2</code>,高度减少了<code>1</code>,与原本的高度<code>+1</code>向抵消，停止调整</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RotateLR</span><span class="params">(Node* parent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (parent == <span class="literal">nullptr</span>) <span class="keyword">return</span>;<span class="comment">//错误情况</span></span><br><span class="line">Node* Lchild = parent-&gt;_left;</span><br><span class="line"><span class="keyword">if</span> (Lchild == <span class="literal">nullptr</span>) <span class="keyword">return</span>;<span class="comment">//错误情况</span></span><br><span class="line">Node* Rchild = Lchild-&gt;_right;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先旋转左子树</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//维护树结构</span></span><br><span class="line">Lchild-&gt;_right = Rchild-&gt;_left;</span><br><span class="line">Rchild-&gt;_left = Lchild;</span><br><span class="line">Lchild-&gt;_parent = Rchild;</span><br><span class="line">parent-&gt;_left = Rchild;</span><br><span class="line">Rchild-&gt;_parent = parent;</span><br><span class="line"></span><br><span class="line"><span class="comment">//维护_bf</span></span><br><span class="line"><span class="keyword">if</span> (Lchild-&gt;_bf == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">Lchild-&gt;_bf = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//_bf == -1 或 0都是非法的</span></span><br><span class="line"><span class="built_in">assert</span>(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//再向右旋转</span></span><br><span class="line">Node* child = parent-&gt;_left;</span><br><span class="line"></span><br><span class="line"><span class="comment">//维护树结构</span></span><br><span class="line">parent-&gt;_left = child-&gt;_right;</span><br><span class="line">child-&gt;_right = parent;</span><br><span class="line"></span><br><span class="line">Node* grandParent = parent-&gt;_parent;</span><br><span class="line">child-&gt;_parent = grandParent;</span><br><span class="line">parent-&gt;_parent = child;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (grandParent)<span class="comment">//不是根节点</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (parent == grandParent-&gt;_left)grandParent-&gt;_left = child;</span><br><span class="line"><span class="keyword">else</span> grandParent-&gt;_right = child;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//维护_bf</span></span><br><span class="line">parent-&gt;_bf = <span class="number">-1</span>;</span><br><span class="line">child-&gt;_bf = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (parent == _root)</span><br><span class="line">&#123;</span><br><span class="line">_root = child;<span class="comment">//更新根节点</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="RotateLR-bf-2且子树的左子树超高"><a href="#RotateLR-bf-2且子树的左子树超高" class="headerlink" title="RotateLR:bf == 2且子树的左子树超高"></a><code>RotateLR</code>:<code>bf == 2</code>且子树的左子树超高</h4><p>具体情况与上一个接口相同，一次旋转无法完成任务，需要先向右旋转右子树调节平衡因子,再向左旋转，完成平衡的维护</p><p><strong>高度变化</strong>：整棵树的高度由<code>h+3</code>变成了<code>h+2</code>,高度减少了<code>1</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RotateRL</span><span class="params">(Node* parent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//先向右旋转子树</span></span><br><span class="line">Node* Rchild = parent-&gt;_right;</span><br><span class="line">Node* Lchild = Rchild-&gt;_left;</span><br><span class="line"></span><br><span class="line"><span class="comment">//维护树结构</span></span><br><span class="line">Rchild-&gt;_left = Lchild-&gt;_right;</span><br><span class="line">Lchild-&gt;_right = Rchild;</span><br><span class="line">Rchild-&gt;_parent = Lchild;</span><br><span class="line">Lchild-&gt;_parent = parent;</span><br><span class="line">parent-&gt;_right = Lchild;</span><br><span class="line"></span><br><span class="line"><span class="comment">//维护_bf</span></span><br><span class="line"><span class="keyword">if</span> (Rchild-&gt;_bf == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">Rchild-&gt;_bf = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">assert</span>(<span class="literal">false</span>);<span class="comment">//非法的情况</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//再向左旋转</span></span><br><span class="line">Node* child = parent-&gt;_right;</span><br><span class="line"></span><br><span class="line">parent-&gt;_right = child-&gt;_left;<span class="comment">//过继左子树</span></span><br><span class="line">child-&gt;_left = parent;</span><br><span class="line">parent-&gt;_parent = child;</span><br><span class="line">Node* grandParent = parent-&gt;_parent;</span><br><span class="line">child-&gt;_parent = grandParent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (grandParent)<span class="comment">//如果不是根节点</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (parent == grandParent-&gt;_left)grandParent-&gt;_left = child;</span><br><span class="line"><span class="keyword">else</span> grandParent-&gt;_right = child;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//维护_bf</span></span><br><span class="line">parent-&gt;_bf = <span class="number">-1</span>;</span><br><span class="line">child-&gt;_bf = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (parent == _root)</span><br><span class="line">&#123;</span><br><span class="line">_root = child;<span class="comment">//更新根节点</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="完成Insert中调整二叉树的代码"><a href="#完成Insert中调整二叉树的代码" class="headerlink" title="完成Insert中调整二叉树的代码"></a>完成Insert中调整二叉树的代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Insert</span><span class="params">(<span class="type">const</span> PKV&amp; kv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Cmp cmp;<span class="comment">//仿函数实例化一个对象</span></span><br><span class="line"><span class="keyword">if</span> (_root == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">_root = <span class="keyword">new</span> <span class="built_in">Node</span>(kv);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">Node* cur = _root;</span><br><span class="line">Node* parent = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="comment">//寻找插入位置</span></span><br><span class="line"><span class="keyword">while</span> (cur)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (cur-&gt;_kv.first == kv.first)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//该键下的节点已存在，发生冲突</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">cmp</span>(cur-&gt;_kv.first, kv.first))<span class="comment">//根比节点&quot;大&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">parent = cur;</span><br><span class="line">cur = cur-&gt;_left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="comment">//根比节点小</span></span><br><span class="line">&#123;</span><br><span class="line">parent = cur;</span><br><span class="line">cur = cur-&gt;_right;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//开始插入</span></span><br><span class="line">Node* node = <span class="keyword">new</span> <span class="built_in">Node</span>(kv);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">cmp</span>(parent-&gt;_kv.first, kv.first))<span class="comment">//应该插入左边</span></span><br><span class="line">&#123;</span><br><span class="line">parent-&gt;_left = node;</span><br><span class="line">node-&gt;_parent = parent;</span><br><span class="line">parent-&gt;_bf -= <span class="number">1</span>;<span class="comment">//_bf越小，左子树越高</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="comment">//插入右子树</span></span><br><span class="line">&#123;</span><br><span class="line">parent-&gt;_right = node;</span><br><span class="line">node-&gt;_parent = parent;</span><br><span class="line">parent-&gt;_bf += <span class="number">1</span>;<span class="comment">//_bf越大，右子树越高</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//插入完成，准备开始维护平衡</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (parent-&gt;_bf == <span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (parent-&gt;_bf == <span class="number">1</span> || parent-&gt;_bf == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//子树高度增加</span></span><br><span class="line">node = parent;</span><br><span class="line">parent = parent-&gt;_parent;</span><br><span class="line"><span class="keyword">if</span> (parent == <span class="literal">nullptr</span>)<span class="keyword">break</span>;<span class="comment">//走到根节点了</span></span><br><span class="line"><span class="keyword">if</span> (node == parent-&gt;_left)</span><br><span class="line">&#123;</span><br><span class="line">parent-&gt;_bf -= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (node == parent-&gt;_right)</span><br><span class="line">&#123;</span><br><span class="line">parent-&gt;_bf += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">assert</span>(<span class="literal">false</span>);<span class="comment">//非法情况</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (parent-&gt;_bf == <span class="number">-2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (parent-&gt;_left-&gt;_bf == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">assert</span>(<span class="literal">false</span>);<span class="comment">//非法情况,不可能左右子树同时超高</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (parent-&gt;_left-&gt;_bf == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//子树的左子树超高</span></span><br><span class="line"><span class="built_in">RotateR</span>(parent);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (parent-&gt;_left-&gt;_bf == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//子树的右子树超高</span></span><br><span class="line"><span class="built_in">RotateLR</span>(parent);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (parent-&gt;_bf == <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (parent-&gt;_right-&gt;_bf == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">assert</span>(<span class="literal">false</span>);<span class="comment">//非法情况,不可能左右子树同时超高</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (parent-&gt;_right-&gt;_bf == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//子树的右子树超高</span></span><br><span class="line"><span class="built_in">RotateL</span>(parent);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (parent-&gt;_right-&gt;_bf == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//子树的左子树超高</span></span><br><span class="line"><span class="built_in">RotateRL</span>(parent);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">assert</span>(<span class="literal">false</span>);<span class="comment">//非法情况</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>我们来写个简单的<code>main</code>函数测试一下我们封装的<code>AVL树</code></p><blockquote><p>main.cpp</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AVLTree.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">AVLTree&lt;<span class="type">int</span>,<span class="type">int</span>&gt; avt;<span class="comment">//实例化一个对象</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i)<span class="comment">//准备100个数据</span></span><br><span class="line">&#123;</span><br><span class="line">avt.<span class="built_in">Insert</span>(&#123; i,i &#125;);<span class="comment">//插入数据</span></span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt;<span class="string">&quot;Height &quot;</span> &lt;&lt; avt.<span class="built_in">Height</span>() &lt;&lt; endl;   <span class="comment">//检查高度</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;IsBalance &quot;</span> &lt;&lt; avt.<span class="built_in">IsBalance</span>() &lt;&lt; endl; <span class="comment">//检测平衡</span></span><br><span class="line">avt.<span class="built_in">Inorder</span>();<span class="comment">//检测搜索树的特性</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来看看结果</p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202409030818252.png"></p><p>可以看到,<code>100</code>个数据下，而且还是按顺序插入，<code>AVL树</code>的高度只有<code>7</code>，很好得提高了搜索效率</p><h1 id="AVL树的性能"><a href="#AVL树的性能" class="headerlink" title="AVL树的性能"></a>AVL树的性能</h1><p>AVL树是一棵绝<strong>对平衡的二叉搜索树</strong>，其要求每个节点的左右子树高度差的绝对值都不超过1，这样可以保证查询时高效的时间复杂度，即$log_2 (N)$。但是如果要对AVL树做一些结构修改的操作，性能非常低下，比如：插入时要维护其绝对平衡，旋转的次数比较多，更差的是在删除时，有可能一直要让旋转持续到根的位置。因此：如果需要一种查询高效且有序的数据结构，而且数据的个数为静态的(即不会改变)，可以考虑AVL树，<strong>但一个结构经常修改，就不太适合。</strong></p><h1 id="改造成-红黑树"><a href="#改造成-红黑树" class="headerlink" title="改造成 红黑树"></a>改造成 红黑树</h1><p>目前的<code>AVL树</code>只是实现了最基本的功能，增删查改只支持了<code>增</code>,剩下的内容可自行完善，或者跟随作者的脚步，将<code>AVL树</code>改成<code>红黑树</code>,增加其修改的性能,并进一步完善增删查改的功能，以及封装<code>迭代器</code>等，最后将<code>红黑树</code>封装成我们自己的<code>set</code>类和<code>map</code>类</p><p><a href="https://www.supdriver.top/2024/09/03/RBTree/">戳我前往红黑树篇🔗</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C++特殊类的设计</title>
      <link href="/2024/08/12/spclass/"/>
      <url>/2024/08/12/spclass/</url>
      
        <content type="html"><![CDATA[<p>接下来我们设计一些C++的常用特殊类，同时加深对C++类和对象的理解</p><h1 id="设计一个不能被拷贝的类"><a href="#设计一个不能被拷贝的类" class="headerlink" title="设计一个不能被拷贝的类"></a>设计一个不能被拷贝的类</h1><p>拷贝只会放生在两个场景中：<code>拷贝构造函数</code>以及<code>赋值运算符重载</code>，因此想要让一个类禁止拷贝，只需<strong>让该类不能调用拷贝构造函数以及赋值运算符重载即可。</strong></p><p><em>C++98</em></p><p>将拷贝构造和赋值重载只<code>私有声明</code>且<strong>不定义</strong>即可</p><p><strong>分析</strong>：</p><ol><li>设为私有：防止类外调用，还能<strong>防止类外定义</strong>重新实现拷贝功能</li><li>只声明不定义：防止类内成员函数对其调用<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++98</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NoCopy</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:<span class="comment">//设置成私有</span></span><br><span class="line"><span class="built_in">NoCopy</span>(<span class="type">const</span> NoCopy&amp;);</span><br><span class="line">NoCopy&amp; <span class="keyword">operator</span>=(<span class="type">const</span> NoCopy&amp;);<span class="comment">//只声明不定义</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><p><em>C++11</em></p><p>C++11扩展了<code>delete</code>关键字的用法，可用于删除成员函数，尤其是<strong>删除默认成员函数</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++11</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CopyBan</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">CopyBan</span>(<span class="type">const</span> CopyBan&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">CopyBan&amp; <span class="keyword">operator</span>=(<span class="type">const</span> CopyBan&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="设计一个类，只能在堆上创建对象"><a href="#设计一个类，只能在堆上创建对象" class="headerlink" title="设计一个类，只能在堆上创建对象"></a>设计一个类，只能在堆上创建对象</h1><p>既然涉及到类实例化成对象（如下图），势必绕不开构造函数,但实际上对类的设计者来说，通过控制构造函数来控制用户的行为难以实现。所以我们选择把<code>拷贝构造函数</code>禁掉，把<code>赋值运算重载</code>禁掉,把<code>默认构造函数</code>私有化，然后单独提供静态成员函数</p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202409231355404.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HeapOnly</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">static</span> HeapOnly* <span class="title">GenerateObj</span><span class="params">()</span><span class="comment">//提供静态成员函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">HeapOnly</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">HeapOnly</span>();<span class="comment">//私有化默认构造函数</span></span><br><span class="line"><span class="built_in">HeapOnly</span>(<span class="type">const</span> HeapOnly&amp;) = <span class="keyword">delete</span>;<span class="comment">//禁掉拷贝构造</span></span><br><span class="line">HeapOnly&amp; <span class="keyword">operator</span>=(<span class="type">const</span> HeapOnly&amp;) = <span class="keyword">delete</span>;<span class="comment">//删除赋值运算重载</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="设计一个类，只能在栈上创建对象"><a href="#设计一个类，只能在栈上创建对象" class="headerlink" title="设计一个类，只能在栈上创建对象"></a>设计一个类，只能在栈上创建对象</h1><p>除了要把构造函数私有化，还要把<code>operator new</code>和<code>operator delete</code>重载禁掉，然后提供在返回栈上创建的对象的静态成员函数</p><p><em>赋值运算符重载函数只返回栈上的对象，所以不用管它</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StackOnly</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">static</span> StackOnly <span class="title">CreatObj</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">StackOnly</span>();<span class="comment">//返回临时对象的拷贝</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">StackOnly</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">StackOnly</span>(<span class="type">const</span> StackOnly&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span> </span>= <span class="keyword">delete</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* ptr)</span> </span>= <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="设计一个类，不能被继承"><a href="#设计一个类，不能被继承" class="headerlink" title="设计一个类，不能被继承"></a>设计一个类，不能被继承</h1><p><em>C++98</em></p><p>将构造函数私有化，派生类中调用不到基类的构造函数，就会继承失败</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NoInherit</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">static</span> NoInherit <span class="title">GenerateInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">NoInherit</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">NoInherit</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><em>C++11</em></p><p>C++11提供了<code>final</code>关键字，被<code>final</code>修饰的类不能被继承</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">InheritBan</span> <span class="keyword">final</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="设计一个类，只能创建一个对象-单例模式"><a href="#设计一个类，只能创建一个对象-单例模式" class="headerlink" title="设计一个类，只能创建一个对象(单例模式)"></a>设计一个类，只能创建一个对象(单例模式)</h1><p>单例模式：<br>一个类只能创建一个对象，即单例模式，该模式可以保证系统中该类只有一个实例，并提供一个<br>访问它的全局访问点，该实例被所有程序模块共享。比如在某个服务器程序中，该服务器的配置<br>信息存放在一个文件中，这些配置数据由一个单例对象统一读取，然后服务进程中的其他对象再<br>通过这个单例对象获取这些配置信息，这种方式简化了在复杂环境下的配置管理。</p><p>懒汉方式最核心的思想是 “延时加载”. 从而能够优化服务器的启动速度.</p><h3 id="饿汉方式实现"><a href="#饿汉方式实现" class="headerlink" title="饿汉方式实现"></a>饿汉方式实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="type">static</span> T data;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> T* <span class="title">GetInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>只要通过 <code>Singleton</code> 这个包装类来使用 T 对象, 则一个进程中只有一个<code>static T</code> 对象的实例.</p><h3 id="懒汉方式实现"><a href="#懒汉方式实现" class="headerlink" title="懒汉方式实现"></a>懒汉方式实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="type">static</span> T* inst;<span class="comment">//声明指针</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> T* <span class="title">GetInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (inst == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            inst = <span class="keyword">new</span> <span class="built_in">T</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> inst;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>存在一个严重的问题, 线程不安全</strong></p><p>因为<code>inst</code>是多个进程共享的资源，对其进行判空操作，也要用锁保护起来</p><p><strong>线程安全的版本实现</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 懒汉模式, 线程安全</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">static</span> T *inst; <span class="comment">// 需要设置 volatile 关键字, 否则可能被编译器优化-&gt;被放到寄存器中.</span></span><br><span class="line">    <span class="type">static</span> std::mutex lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> T *<span class="title">GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (inst == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;                <span class="comment">// 双重判定空指针, 降低锁冲突的概率, 提高性能.</span></span><br><span class="line">            lock.<span class="built_in">lock</span>(); <span class="comment">// 使用互斥锁, 保证多线程情况下也只调用一次 new.</span></span><br><span class="line">            <span class="keyword">if</span> (inst == <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                inst = <span class="keyword">new</span> <span class="built_in">T</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            lock.<span class="built_in">unlock</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> inst;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>特别注意</strong></p><ol><li>加锁解锁的位置</li><li>双重if判定，避免不必要的锁竞争</li><li><code>volatile</code>关键字防止过度优化</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>进程间通信</title>
      <link href="/2024/08/02/progressMSG/"/>
      <url>/2024/08/02/progressMSG/</url>
      
        <content type="html"><![CDATA[<p>本篇博客更偏向于总括和导航,部分概念更细致的介绍将内嵌链接在文章中</p><p><strong>重点内容</strong></p><ul><li>初识进程间通信</li><li>管道</li><li>消息队列</li><li>共享内存</li><li>信号量</li></ul><h1 id="进程间通信的目的"><a href="#进程间通信的目的" class="headerlink" title="进程间通信的目的"></a>进程间通信的目的</h1><ul><li>数据传输： 一个进程需要将它的数据<strong>发送</strong>给另一个进程</li><li>资源共享： 多个进程之间<strong>共享</strong>同样的资源</li><li>通知事件：一个进程需要向另一个或一组进程<strong>发送消息</strong>，<strong>通知</strong>它（它们）发生了某种事件（如子进程终止时要通知父进程）</li><li>进程控制： 有些进程希望<strong>完全控制</strong>另一个进程的执行（如Debug进程），此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变</li></ul><h1 id="进程间通信的主要方式"><a href="#进程间通信的主要方式" class="headerlink" title="进程间通信的主要方式"></a>进程间通信的主要方式</h1><ul><li>管道</li><li>System V进程间通信</li><li>POSIX进程间通信</li></ul><h1 id="进程间通信的分类"><a href="#进程间通信的分类" class="headerlink" title="进程间通信的分类"></a>进程间通信的分类</h1><h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><ul><li>匿名管道</li><li>命名管道</li></ul><h2 id="System-V-IPC"><a href="#System-V-IPC" class="headerlink" title="System V IPC"></a>System V IPC</h2><ul><li>System V 消息队列</li><li>SysTem V 共享内存</li><li>System V 信号量</li></ul><h2 id="POSIX-IPC"><a href="#POSIX-IPC" class="headerlink" title="POSIX IPC"></a>POSIX IPC</h2><ul><li>消息队列</li><li>共享内存</li><li>信号量</li><li>互斥量</li><li>条件变量</li><li>读写锁</li></ul><h1 id="管道-1"><a href="#管道-1" class="headerlink" title="管道"></a>管道</h1><p>怎么使用？<a href="https://www.supdriver.top/2024/08/02/pipe/">戳我去管道博客🔗</a></p><p>首先，管道是Unix中最古老的进程间通信的形式。它用于进程间的<strong>单向</strong>通信</p><p>那么具体是怎样实现的呢？从标题里就可以发现，是基于<code>文件</code></p><p>既然一个文件可以被多个进程打开，那么不妨将文件作为两个进程通信的<strong>媒介</strong>。但是一般位于磁盘上的文件，IO效率相比于<code>CPU</code>，<code>内存</code>之类的读写速度慢了几个数量级，但文件是可以被加载到内存中的，而专门建立在<strong>内存中</strong>,而没有磁盘文件，专门用于进程间通信的<strong>内存级</strong>文件，我们就叫它<code>管道文件</code></p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-08-09_21-19-22.png"></p><p><em>管道文件由内核维护</em></p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-08-10_17-52-20.png"><br><em>管道文件是单向的，可以是父进程-&gt;子进程，也可以子进程-&gt;父进程</em></p><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>头文件提供了宏<code>PIPE_BUF</code>,规定了保证原子性读写操作的最大字节数</p><ul><li>当要写入的数据量不大于<code>PIPE_BUF</code>时，linux将保证写入的原子性。</li><li>当要写入的数据量大于<code>PIPE_BUF</code>时，linux将不再保证写入的原子性。</li></ul><h2 id="管道特点"><a href="#管道特点" class="headerlink" title="管道特点"></a>管道特点</h2><ul><li>管道提供流式服务</li><li>一般而言，进程退出，管道释放，所以管道的生命周期随进程</li><li>一般而言，内核会对管道操作进行<strong>同步与互斥</strong></li><li>一个管道只有一个通信方向，数据只能向一个方向流动；需要<strong>双方</strong>通信时，需要建立起<strong>两个</strong>管道</li></ul><h1 id="system-V共享内存"><a href="#system-V共享内存" class="headerlink" title="system V共享内存"></a>system V共享内存</h1><p>共享内存区是最快的IPC形式。一旦这样的内存映射到共享它的进程的地址空间，这些进程间数据传递<strong>不再涉及</strong>到<br><code>内核</code>，换句话说是进程不再通过执行进入内核的系统调用来传递彼此的数据,而是直接使用内存中的共享区。</p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/shared_mm.png"></p><h2 id="读写共享区内存"><a href="#读写共享区内存" class="headerlink" title="读写共享区内存"></a>读写共享区内存</h2><p>挂接上的进程是真正意义上的看到同一块内存，而且完全可以像<code>malloc</code>申请出的一段内存一样操作,比如把共享区的内存当成字符串的缓冲区,直接把标准输入用<code>fgets</code>拷贝到共享内存中</p><p>不过默认的共享内存并没有同步互斥行为,需要额外控制,比如使用<code>FIFO命名管道</code>来完成同步操作</p><p><a href="https://www.supdriver.top/2024/08/14/shmd/">戳我去具体介绍🔗</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>进程间通信--匿名管道与命名管道</title>
      <link href="/2024/08/02/pipe/"/>
      <url>/2024/08/02/pipe/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是管道文件"><a href="#什么是管道文件" class="headerlink" title="什么是管道文件"></a>什么是管道文件</h1><p>首先，管道是Unix中最古老的进程间通信的形式。它用于进程间的<strong>单向</strong>通信</p><p>那么具体是怎样实现的呢？从标题里就可以发现，是基于<code>文件</code></p><p>既然一个文件可以被多个进程打开，那么不妨将文件作为两个进程通信的<strong>媒介</strong>。但是一般位于磁盘上的文件，IO效率相比于<code>CPU</code>，<code>内存</code>之类的读写速度慢了几个数量级，但文件是可以被加载到内存中的，而专门建立在<strong>内存中</strong>,而没有磁盘文件，专门用于进程间通信的<strong>内存级</strong>文件，我们就叫它<code>管道文件</code></p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-08-09_21-19-22.png"></p><p><em>管道文件由内核维护</em></p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-08-10_17-52-20.png"><br><em>管道文件是单向的，可以是父进程-&gt;子进程，也可以子进程-&gt;父进程</em></p><h2 id="管道读写规则"><a href="#管道读写规则" class="headerlink" title="管道读写规则"></a>管道读写规则</h2><ul><li>写端未关闭，但读端<strong>无数据</strong>可读时<ul><li>(默认)<code>O_NONBLOCK disable</code>：<code>read</code>调用阻塞，即进程暂停执行，一直等到有数据来到为止。</li><li><code>O_NONBLOCK enable</code>：<code>read</code>调用返回<code>-1</code>，<code>errno</code>值为<code>EAGAIN</code>。</li></ul></li><li>读端未关闭，但写端写入管道已经<strong>写满</strong>时<ul><li>(默认)<code> O_NONBLOCK disable</code>： <code>write</code>调用阻塞，直到有进程读走数据</li><li><code>O_NONBLOCK enable</code>：<code>wrtie</code>调用返回<code>-1</code>，<code>errno</code>值为<code>EAGAIN</code></li></ul></li><li>若写端关闭,则<code>read</code>返回<code>0</code></li><li>若读端关闭,则<code>write</code>操作会产生信号<code>SIGPIPE</code>,进而可能导致<code>write</code>进程<strong>退出</strong></li></ul><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>头文件提供了宏<code>PIPE_BUF</code>,规定了保证原子性读写操作的最大字节数</p><ul><li>当要写入的数据量不大于<code>PIPE_BUF</code>时，linux将保证写入的原子性。</li><li>当要写入的数据量大于<code>PIPE_BUF</code>时，linux将不再保证写入的原子性。</li></ul><h2 id="管道特点"><a href="#管道特点" class="headerlink" title="管道特点"></a>管道特点</h2><ul><li>管道提供流式服务</li><li>一般而言，进程退出，管道释放，所以管道的生命周期随进程</li><li>一般而言，内核会对管道操作进行<strong>同步与互斥</strong></li><li>一个管道只有一个通信方向，数据只能向一个方向流动；需要<strong>双方</strong>通信时，需要建立起<strong>两个</strong>管道</li></ul><h1 id="匿名管道"><a href="#匿名管道" class="headerlink" title="匿名管道"></a>匿名管道</h1><p>匿名管道主要用于<code>父子进程</code>间的通信</p><p>用到的接口是来自<code>&lt;unistd.h&gt;</code>的接口<code>pipe</code></p><p><code>int pipe(int pipefd[2]);</code></p><p>可以看到有一个输出型参数<code>pipefd</code>数组，其中规定<code>pipefd[0]</code>储存了管道文件的<code>读端fd</code>,<code>pipefd[1]</code>储存了管道文件的<code>写端fd</code></p><p>要利用管道通信时，必须用<code>close</code>一方关闭写端而另一端关闭读端</p><h2 id="示例-子进程发送报文，父进程接受模型"><a href="#示例-子进程发送报文，父进程接受模型" class="headerlink" title="示例 子进程发送报文，父进程接受模型"></a>示例 子进程发送报文，父进程接受模型</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NUM 1024</span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//child</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Writer</span><span class="params">(<span class="type">int</span> wfd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> s = <span class="string">&quot;hello,I am child&quot;</span>;<span class="comment">//准备子进程的报文</span></span><br><span class="line">    <span class="type">pid_t</span> self = getpid();</span><br><span class="line">    <span class="type">int</span> number = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buffer[NUM] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(number--)</span><br><span class="line">    &#123;</span><br><span class="line">        buffer[<span class="number">0</span>] = <span class="number">0</span>;<span class="comment">//清空字符串</span></span><br><span class="line">        <span class="built_in">snprintf</span>(buffer,<span class="keyword">sizeof</span>(buffer),<span class="string">&quot;%s-%d-%d\n&quot;</span>,s.c_str(),self,number);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//发送/写入报文</span></span><br><span class="line">        write(wfd,buffer,<span class="built_in">strlen</span>(buffer));</span><br><span class="line"></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//father</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Reader</span><span class="params">(<span class="type">int</span> rfd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buffer[NUM];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        buffer[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="type">ssize_t</span> n = read(rfd,buffer,<span class="keyword">sizeof</span>(buffer));</span><br><span class="line">        <span class="keyword">if</span>(n &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            buffer[n] = <span class="number">0</span>;<span class="comment">//恢复成字符串</span></span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;father get a message &gt;&gt; &quot;</span>&lt;&lt;buffer&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> pipefd[N] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> n = pipe(pipefd);</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">pid_t</span> id = fork();</span><br><span class="line">    <span class="keyword">if</span>(id  &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(id == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//子进程</span></span><br><span class="line">        close(pipefd[<span class="number">0</span>]);<span class="comment">//关闭读</span></span><br><span class="line">        </span><br><span class="line">        Writer(pipefd[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        close(pipefd[<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        close(pipefd[<span class="number">1</span>]);<span class="comment">//关闭写</span></span><br><span class="line"></span><br><span class="line">        Reader(pipefd[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="type">pid_t</span> rid = waitpid(id,nullptr,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(id &lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">        close(pipefd[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小小项目–进程池"><a href="#小小项目–进程池" class="headerlink" title="小小项目–进程池"></a>小小项目–进程池</h2><p>详见<a href="https://www.supdriver.top/2024/08/02/processPool/">此博客🔗</a></p><h1 id="命名管道"><a href="#命名管道" class="headerlink" title="命名管道"></a>命名管道</h1><p>匿名管道无非实现不相关进程（无亲缘关系）的进程间通信，因此要用到命名管道来实现这个功能</p><p>命名管道文件,即<code>FIFO</code>文件，是一种用于不相关进程间通信的特殊类型的文件</p><h2 id="命令行上创建"><a href="#命令行上创建" class="headerlink" title="命令行上创建"></a>命令行上创建</h2><p>使用<code>mkfifo</code>可以在命令行上创建命名管道</p><p>例<code>mkfile fifo_file</code></p><h2 id="程序内创建和删除"><a href="#程序内创建和删除" class="headerlink" title="程序内创建和删除"></a>程序内创建和删除</h2><p>使用接口<code>mkfifo</code>创建,注：要同时引用头文件<code>sys/types.h</code>和<code>sys/stat.h</code></p><p>函数声明如下</p><p><code>int mkfifo(const char *pathname, mode_t mode);</code></p><ul><li>返回值：成功时返回<code>0</code>,失败时返回<code>-1</code>,并设置<code>errno</code></li><li><code>pathname</code>：文件名（当前目录），或者路径+文件名</li><li><code>mode</code> 新创建的管道文件的权限,一般用<code>0644</code>或<code>0664</code></li></ul><p>使用<code>unlink</code>删除文件,引用自头文件<code>&lt;unistd.h&gt;</code></p><p><code>int unlink(const char *pathname);</code></p><ul><li>返回值：成功时返回<code>0</code>,失败时返回<code>-1</code>,并设置<code>errno</code></li><li><code>pathname</code>：文件名（当前目录），或者路径+文件名</li></ul><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>由一个进程<code>写模式</code>打开，同时由另一个进程<code>读模式</code>打开，便可建立进程间通信，其余操作与匿名管道相同</p><h2 id="命名管道的打开规则"><a href="#命名管道的打开规则" class="headerlink" title="命名管道的打开规则"></a>命名管道的打开规则</h2><ul><li><code>读模式</code>打开<code>FIFO</code>文件时<ul><li><code>O_NONBLOCK disable</code>：阻塞等待直到有相应进程为写而打开该<code>FIFO</code></li><li><code>O_NONBLOCK enable</code>：立刻返回成功</li></ul></li><li><code>写模式</code>打开<code>FIFO</code>文件时<ul><li><code>O_NONBLOCK disable</code>：阻塞直到有相应进程为读而打开该<code>FIFO</code></li><li><code> O_NONBLOCK enable</code>：立刻返回失败，错误码为<code>ENXIO</code></li></ul></li></ul><h2 id="示例-命名管道实现-客户端-向-服务端通信"><a href="#示例-命名管道实现-客户端-向-服务端通信" class="headerlink" title="示例 命名管道实现 客户端 向 服务端通信"></a>示例 命名管道实现 客户端 向 服务端通信</h2><h3 id="makefile"><a href="#makefile" class="headerlink" title="makefile"></a>makefile</h3><p>小技巧：这里在最前面使用伪目标<code>all</code>，这样在使用<code>make</code>命令时能编译多个目标文件</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><span class="keyword">.PHONY</span>:all</span></span><br><span class="line"><span class="section">all:sever client</span></span><br><span class="line"></span><br><span class="line"><span class="section">sever:sever.cpp</span></span><br><span class="line">g++ -o <span class="variable">$@</span> <span class="variable">$^</span> -std=c++11</span><br><span class="line"><span class="section">client:client.cpp</span></span><br><span class="line">g++ -o <span class="variable">$@</span> <span class="variable">$^</span> -std=c++11</span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>:cl </span></span><br><span class="line"><span class="section">cl:</span></span><br><span class="line">rm -f sever client</span><br></pre></td></tr></table></figure><h3 id="comm-hpp"><a href="#comm-hpp" class="headerlink" title="comm.hpp"></a>comm.hpp</h3><p>使用同一个头文件能方便地统一<code>fifo</code>文件的路径，以及统一退出码的约定等</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FIFO_NAME <span class="string">&quot;./myfifo&quot;</span> <span class="comment">//设置管道文件名</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MODE 0664 <span class="comment">//设置管道文件的权限</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span><span class="comment">//枚举错误码</span></span><br><span class="line">&#123;</span><br><span class="line">    FIFO_CREAT_ERR = <span class="number">1</span>,</span><br><span class="line">    FIFO_DELETE_ERR,</span><br><span class="line">    FIFO_OPEN_ERR</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="sever-cpp"><a href="#sever-cpp" class="headerlink" title="sever.cpp"></a>sever.cpp</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;comm.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建信道</span></span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">mkfifo</span>(FIFO_NAME,MODE);</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">-1</span>)<span class="comment">//创建失败</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;mkfifo&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(FIFO_CREAT_ERR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打开信道</span></span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">open</span>(FIFO_NAME,O_RDONLY);<span class="comment">//只读模式打开FIFO</span></span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)<span class="comment">//打开失败</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(FIFO_OPEN_ERR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//开始通信</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;[@]sever start running&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> buffer[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">int</span> sz = <span class="built_in">read</span>(fd,buffer,<span class="built_in">sizeof</span>(buffer)<span class="number">-1</span>);<span class="comment">//给结尾\0预留位置</span></span><br><span class="line">        <span class="keyword">if</span>(sz &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            buffer[sz] = <span class="number">0</span>;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;client say# &quot;</span>&lt;&lt;buffer&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(sz == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//写端关闭</span></span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;client quit, sever will quie later...&quot;</span> &lt;&lt;endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭信道</span></span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="type">int</span> m = <span class="built_in">unlink</span>(FIFO_NAME);</span><br><span class="line">    <span class="keyword">if</span>(m == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;unlink&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(FIFO_DELETE_ERR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="client-cpp"><a href="#client-cpp" class="headerlink" title="client.cpp"></a>client.cpp</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;comm.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">open</span>(FIFO_NAME,O_WRONLY);<span class="comment">//只读模式打开</span></span><br><span class="line">    <span class="keyword">if</span>(fd &lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(FIFO_OPEN_ERR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string line;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Please enter@ &quot;</span>;</span><br><span class="line">        <span class="built_in">getline</span>(cin,line);<span class="comment">//获取输入</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">write</span>(fd,line.<span class="built_in">c_str</span>(),line.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h3><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-08-13_16-49-49.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Linux】简易进程池</title>
      <link href="/2024/08/02/processPool/"/>
      <url>/2024/08/02/processPool/</url>
      
        <content type="html"><![CDATA[<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p><code>匿名管道</code>可用于父子进程间的通讯，于是可以有父进程创建多个子进程形成<code>进程池</code>，并通过<code>匿名管道</code>文件向各个子进程<code>派发任务</code></p><p><a href="https://www.supdriver.top/2024/08/02/pipe/">戳我去管道原理🔗</a></p><p>这里使用C++编写进程池代码，在程序中创建多个进程，并在父进程中使用自定义类<code>channel</code>用于描述和管理子进程,然后在<code>task.hpp</code>中模拟一些任务给主程序随机派发</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="代码规范"><a href="#代码规范" class="headerlink" title="代码规范"></a>代码规范</h2><p>这次对形参有了新的规范,这里用<code>variable</code>代指形参名</p><ul><li>输入: <code>const &amp;variable</code></li><li>输出: <code>*variable</code></li><li>输入输出: <code>&amp;variable</code></li></ul><h2 id="准备makefile文件"><a href="#准备makefile文件" class="headerlink" title="准备makefile文件"></a>准备makefile文件</h2><p>这里使用<code>g++</code>编译，规定语法标准为<code>C++11</code></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">processPool:processPool.cc</span></span><br><span class="line">g++ -o <span class="variable">$@</span> <span class="variable">$^</span> -std=c++11</span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>:clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm -rf processPool</span><br></pre></td></tr></table></figure><h2 id="准备任务文件"><a href="#准备任务文件" class="headerlink" title="准备任务文件"></a>准备任务文件</h2><p>首先要准备前后需要用到的头文件,然后构建模拟任务，并提供加载任务列表的函数</p><blockquote><p><code>task.hpp</code></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="type">task_t</span>)</span><span class="params">()</span></span>;<span class="comment">//定义函数指针</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">task1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;PVZ 刷新日志&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">task2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout&lt;&lt; <span class="string">&quot;PVZ 生成阳光&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">task3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;PVZ 检测更新&quot;</span> &lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">task4</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;PVZ 使用能量豆&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LoadTask</span><span class="params">(std::vector&lt;<span class="type">task_t</span>&gt;*tasks)</span><span class="comment">//载入任务列表的接口</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tasks-&gt;<span class="built_in">push_back</span>(task1);</span><br><span class="line">    tasks-&gt;<span class="built_in">push_back</span>(task2);</span><br><span class="line">    tasks-&gt;<span class="built_in">push_back</span>(task3);</span><br><span class="line">    tasks-&gt;<span class="built_in">push_back</span>(task4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="编写主程序"><a href="#编写主程序" class="headerlink" title="编写主程序"></a>编写主程序</h2><p>主程序文件名为<code>processPool.cc</code>,我们按类和接口从上往下编程</p><h3 id="描述和组织"><a href="#描述和组织" class="headerlink" title="描述和组织"></a>描述和组织</h3><p>我们把头文件准备好,然后定义最大进程数和创建任务列表,接着创建<code>channel</code>类来描述每个进程池中的子进程</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;task.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span><span class="comment">//获取时间戳</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> processNum = <span class="number">5</span>;<span class="comment">//最大进程数</span></span><br><span class="line">std::vector&lt;<span class="type">task_t</span>&gt; tasks;<span class="comment">//承载任务的映射列表</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//先描述</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">channel</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">channel</span>(<span class="type">int</span> cmdfd,<span class="type">pid_t</span> slaverid,std::string&amp; name)</span><br><span class="line">    :_cmdfd(cmdfd),_slaverid(slaverid),_processname(name)</span><br><span class="line">    &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> _cmdfd;                    <span class="comment">//发送任务的文件描述符</span></span><br><span class="line">    <span class="type">pid_t</span> _slaverid;               <span class="comment">//子进程的id </span></span><br><span class="line">    std::string _processname;             <span class="comment">//子进程的名字  --方便打印日志</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="slaver函数"><a href="#slaver函数" class="headerlink" title="slaver函数"></a>slaver函数</h3><p>创建子进程后，子进程都进入<code>slaver</code>函数等待获取任务</p><p>这里统一采用<code>输入重定向</code>，在创建子进程后，进入<code>slaver()</code>前先把标准输入重定向到管道文件,然后从标准输入读取<code>任务码</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">slaver</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> cmdcode = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n = <span class="built_in">read</span>(<span class="number">0</span>,&amp;cmdcode,<span class="built_in">sizeof</span>(<span class="type">int</span>));<span class="comment">//读取任务码</span></span><br><span class="line">        <span class="keyword">if</span>(n == <span class="built_in">sizeof</span>(<span class="type">int</span>))<span class="comment">//成功获取任务码</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//std::cout&lt;&lt;&quot;child say@ &quot;&lt;&lt;&quot;get cmdcode: &quot;&lt;&lt;cmdcode&lt;&lt;std::endl;//DEBUG</span></span><br><span class="line">            <span class="keyword">if</span>(cmdcode &gt;=<span class="number">0</span> &amp;&amp; cmdcode &lt; tasks.<span class="built_in">size</span>())<span class="comment">//输入合法的输入码</span></span><br><span class="line">            &#123;</span><br><span class="line">                tasks[cmdcode]();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">//输出错误信息</span></span><br><span class="line">            &#123;</span><br><span class="line">                std::cout&lt;&lt;<span class="string">&quot;wrong cmdcode: &quot;</span>&lt;&lt;cmdcode </span><br><span class="line">                    &lt;&lt;<span class="string">&quot; max size: &quot;</span>&lt;&lt;tasks.<span class="built_in">size</span>()&lt;&lt;std::endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="InnitChannels"><a href="#InnitChannels" class="headerlink" title="InnitChannels"></a>InnitChannels</h3><p>该函数用鱼创建子进程,创建子进程，并封装进频道类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitChannels</span><span class="params">(std::vector&lt;channel&gt;* channels)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;processNum;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> n = <span class="built_in">pipe</span>(pipefd);</span><br><span class="line">        <span class="built_in">assert</span>(!n);</span><br><span class="line">        (<span class="type">void</span>)n;<span class="comment">//调用一下n</span></span><br><span class="line"></span><br><span class="line">        <span class="type">pid_t</span> id = fork();</span><br><span class="line">        <span class="keyword">if</span>(id == <span class="number">0</span>)<span class="comment">//child</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">close</span>(pipefd[<span class="number">1</span>]);</span><br><span class="line">            <span class="built_in">dup2</span>(pipefd[<span class="number">0</span>],<span class="number">0</span>);<span class="comment">//子进程输入重定向</span></span><br><span class="line">            <span class="built_in">slaver</span>();</span><br><span class="line">            std::cout&lt;&lt;<span class="string">&quot;proccess &quot;</span>&lt;&lt; <span class="built_in">getpid</span>() &lt;&lt; <span class="string">&quot; quit&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">//father</span></span><br><span class="line">        <span class="built_in">close</span>(pipefd[<span class="number">0</span>]);</span><br><span class="line">        std::string name = <span class="string">&quot;process-&quot;</span>+std::<span class="built_in">to_string</span>(i);</span><br><span class="line">        channels-&gt;<span class="built_in">push_back</span>(<span class="built_in">channel</span>(pipefd[<span class="number">1</span>],id,name));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="channelDEBUG"><a href="#channelDEBUG" class="headerlink" title="channelDEBUG"></a>channelDEBUG</h3><p>这里封装一个用于测试创建频道的<code>DEBUG</code>函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Debug</span><span class="params">(<span class="type">const</span> std::vector&lt;channel&gt; channels)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;c:channels)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout&lt;&lt;c._cmdfd &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; c._slaverid&lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; c._processname &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ctrlSlaver"><a href="#ctrlSlaver" class="headerlink" title="ctrlSlaver"></a>ctrlSlaver</h3><p>这里封装一个<code>ctrlSlaver</code>用于控制子进程，也就是用于派发任务的函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ctrlSlaver</span><span class="params">(<span class="type">const</span> std::vector&lt;channel&gt; &amp;channels)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)<span class="comment">//随机派发10个任务</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> cmdcode = <span class="built_in">rand</span>() % tasks.<span class="built_in">size</span>();<span class="comment">//获取随机任务码</span></span><br><span class="line">        <span class="type">int</span> select_num = <span class="built_in">rand</span>()%channels.<span class="built_in">size</span>();<span class="comment">//获取选择码</span></span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;father say# &quot;</span>&lt;&lt;<span class="string">&quot;taskcode: &quot;</span>&lt;&lt;cmdcode&lt;&lt;<span class="string">&quot; send to &quot;</span>&lt;&lt;channels[select_num]._processname</span><br><span class="line">            &lt;&lt; std::endl;<span class="comment">//输出日志</span></span><br><span class="line">        <span class="built_in">write</span>(channels[select_num]._cmdfd,&amp;cmdcode,<span class="built_in">sizeof</span>(cmdcode));<span class="comment">//写入任务码，派发任务</span></span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="QuitProcess"><a href="#QuitProcess" class="headerlink" title="QuitProcess"></a>QuitProcess</h3><p>最后当然要有父进程控制关闭子进程，并回收僵尸进程</p><p>因为<code>InitChannels</code>中管道文件的处理比较粗糙，会发生如下图的关系，所以关闭时两步操作一定要放在两个循环中</p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-08-13_11-25-01.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuitProcess</span><span class="params">(<span class="type">const</span> std::vector&lt;channel&gt;&amp; channels)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//因为创建子进程时管道文件的连接没有进一步处理，关系复杂，所以下面两个循环一定要分开来</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span> &amp;c:channels)<span class="built_in">close</span>(c._cmdfd);<span class="comment">//关闭主进程管道文件的写端，使子进程的read函数读取失败，返回0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span> &amp;c:channels)<span class="built_in">waitpid</span>(c._slaverid,<span class="literal">nullptr</span>,<span class="number">0</span>);<span class="comment">//阻塞等待子进程，回收僵尸进程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h3><p>经过上文一系列封装,<code>main</code>函数就可以简洁明了地描述子进程的运行过程了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">nullptr</span>) ^ <span class="built_in">getpid</span>()^<span class="number">1023</span>);<span class="comment">//种随机数种子</span></span><br><span class="line">    std::vector&lt;channel&gt; channels;</span><br><span class="line">    <span class="comment">//1.初始化</span></span><br><span class="line">    <span class="built_in">LoadTask</span>(&amp;tasks);<span class="comment">//必须先载入任务再产生子进程，否则子进程看不到任务列表</span></span><br><span class="line">    <span class="built_in">InitChannels</span>(&amp;channels);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//测试函数</span></span><br><span class="line">    <span class="comment">//Debug(channels);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.控制子进程</span></span><br><span class="line">    <span class="built_in">ctrlSlaver</span>(channels);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.关闭进程池</span></span><br><span class="line">    <span class="built_in">QuitProcess</span>(channels);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="源文件"><a href="#源文件" class="headerlink" title="源文件"></a>源文件</h1><p><a href="https://github.com/sis-shen/Linux_Code/tree/main/pipe_use">戳我去github仓库🔗</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【数据结构】一步到胃，键值对版二叉搜索树</title>
      <link href="/2024/07/27/BSTree/"/>
      <url>/2024/07/27/BSTree/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是二叉搜索树"><a href="#什么是二叉搜索树" class="headerlink" title="什么是二叉搜索树"></a>什么是二叉搜索树</h1><p>二叉搜索树的<code>定义</code>是一颗二叉树的所有节点满足:<code>根的左右孩子存在时，满足 左孩子 &lt; 根 &lt; 右孩子</code></p><p><code>递归定义</code>则是:</p><ol><li><code>左子树的根</code> &lt; <code>根</code> &lt; <code>右子树的根</code></li><li><code>左子树是二叉搜索树</code>,<code>右子树是二叉搜索树</code></li></ol><h2 id="写一个验证二叉搜索树的函数"><a href="#写一个验证二叉搜索树的函数" class="headerlink" title="写一个验证二叉搜索树的函数"></a>写一个验证二叉搜索树的函数</h2><p><a href="https://leetcode.cn/problems/validate-binary-search-tree/">Leetecode题目链接🔗</a></p><h1 id="封装一个二叉树类"><a href="#封装一个二叉树类" class="headerlink" title="封装一个二叉树类"></a>封装一个二叉树类</h1><h2 id="文件布置"><a href="#文件布置" class="headerlink" title="文件布置"></a>文件布置</h2><ul><li><code>BSTree.h</code>用于声明和实现<code>BSTree</code>类</li><li><code>test.cpp</code>用于测试</li></ul><h3 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h3><p><code>BSTree.h</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>test.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;BSTree.h&quot;</span></span></span><br></pre></td></tr></table></figure><h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> key_value</span><br></pre></td></tr></table></figure><p>这里使用<code>key_value</code>作为命名空间，表示这是键值表示的搜索二叉树</p><h2 id="定义节点"><a href="#定义节点" class="headerlink" title="定义节点"></a>定义节点</h2><p>二叉树的节点用于储存<code>键值对</code>和<code>左右指针</code>，并提供<code>默认构造函数</code>,使用<code>初始化列表</code>初始化成员变量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">K</span>,<span class="keyword">class</span> <span class="title class_">V</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BSTNode</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BSTNode</span>(<span class="type">const</span> K&amp; key = <span class="built_in">K</span>(), <span class="type">const</span> V&amp; value = <span class="built_in">V</span>())</span><br><span class="line">        :_left(<span class="literal">nullptr</span>)</span><br><span class="line">        , _right(<span class="literal">nullptr</span>)</span><br><span class="line">        , _key(key)</span><br><span class="line">        , _value(value)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    BSTNode&lt;K, V&gt;* _left;<span class="comment">//指向左子树</span></span><br><span class="line">    BSTNode&lt;K, V&gt;* _right;<span class="comment">//指向右子树</span></span><br><span class="line">    K _key;<span class="comment">//储存键</span></span><br><span class="line">    V _value;<span class="comment">//储存值</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="封装二叉搜索树"><a href="#封装二叉搜索树" class="headerlink" title="封装二叉搜索树"></a>封装二叉搜索树</h2><p><code>Binary Search Tree</code>,这里用简称<code>BSTree</code>封装</p><h3 id="基本架构"><a href="#基本架构" class="headerlink" title="基本架构"></a>基本架构</h3><p>鉴于该类的接口基本依赖于成员变量，所以先组织好成员变量</p><p>作为一颗<code>二叉树类</code>,成员变量仅需一个<code>指向根的指</code>针即可</p><p>再次之前先用<code>typedef</code>定义一个<code>节点类</code>出来用于简化代码</p><p>最后提供一个<code>默认构造函数</code>将<code>_root</code>初始化为<code>nullptr</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">K</span>,<span class="keyword">class</span> <span class="title class_">V</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BSTree</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">typedef</span> BSTNode&lt;K, V&gt; Node;<span class="comment">//使用typedef简化代码</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">BSTree</span>() :_root(<span class="literal">nullptr</span>) &#123;&#125;<span class="comment">//提供默认构造函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Node* _root;<span class="comment">//指向根节点的指针作为成员变量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="insert函数"><a href="#insert函数" class="headerlink" title="insert函数"></a><code>insert</code>函数</h3><p>准备好后第一个接口就是<code>insert</code>,用于构建搜索二叉树</p><p>这里需要考虑的情况有</p><ul><li>空树时的插入</li><li>插入的<code>key</code>已存在</li><li>一般情况下成功的插入</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> K&amp; key, <span class="type">const</span> V&amp; value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (_root == <span class="literal">nullptr</span>)<span class="comment">//空树</span></span><br><span class="line">    &#123;</span><br><span class="line">        _root = <span class="keyword">new</span> <span class="built_in">Node</span>(key, value);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node* cur = _root;</span><br><span class="line">    Node* parent = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (key &lt; cur-&gt;_key)<span class="comment">//key比当前节点小，往左子树走</span></span><br><span class="line">        &#123;</span><br><span class="line">            parent = cur;</span><br><span class="line">            cur = cur-&gt;_left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; cur-&gt;_key)<span class="comment">//往右子树走</span></span><br><span class="line">        &#123;</span><br><span class="line">            parent = cur;</span><br><span class="line">            cur = cur-&gt;_right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//key已存在，插入失败</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//此时cur为nullptr, parent为cur的结点</span></span><br><span class="line">    <span class="keyword">if</span> (key &lt; parent-&gt;_key)parent-&gt;_left = <span class="keyword">new</span> <span class="built_in">Node</span>(key, value);</span><br><span class="line">    <span class="keyword">else</span> parent-&gt;_right = <span class="keyword">new</span> <span class="built_in">Node</span>(key, value);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//成功插入</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="in-order函数"><a href="#in-order函数" class="headerlink" title="in_order函数"></a><code>in_order</code>函数</h3><p>使用此函数<code>前序遍历打印</code>二叉树来验证其满足<code>搜索树</code>的性质</p><p>这里使用递归打印,所以要借助<code>_in_order</code>子函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">in_order</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _in_order(_root);<span class="comment">//传入根结点</span></span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">void</span> _in_order(Node* root)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        _in_order(root-&gt;_left);<span class="comment">//先访问左结点</span></span><br><span class="line">        std::cout &lt;&lt; root-&gt;_value &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; std::endl;<span class="comment">//再访问根结点</span></span><br><span class="line">        _in_order(root-&gt;_right);<span class="comment">//最后访问右结点</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>然后写一段测试代码测试性质</p><blockquote><p>test.cpp</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;BSTree.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">arr</span><span class="params">(&#123; <span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">7</span> &#125;)</span></span>;<span class="comment">//准备待插入的键值对</span></span><br><span class="line">key_value::BSTree&lt;<span class="type">int</span>, <span class="type">int</span>&gt; bst;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); ++i)</span><br><span class="line">&#123;</span><br><span class="line">bst.<span class="built_in">insert</span>(arr[i],arr[i]);<span class="comment">//这里使键值相同，方便观察</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bst.<span class="built_in">in_order</span>();<span class="comment">//测试</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="find函数"><a href="#find函数" class="headerlink" title="find函数"></a><code>find</code>函数</h3><p>可以用<code>find</code>函数查找对应<code>key</code>的结点。</p><p>同时观察可知，控制<code>cur</code>和<code>parent</code>的移动的代码段和前面的函数很像，所以给<code>find</code>函数分出来一个<code>_find</code>子函数，并使它返回<code>pair&lt;Node*,Node*&gt;</code>，将这两个指针返回利于其它函数对<code>_find</code>的回调</p><p>同时为了简化代码，继续用<code>typedef</code>封装类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> std::pair&lt; Node*, Node* &gt; PNN;<span class="comment">//简化代码</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">const</span> K&amp; key)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _find(key).first != <span class="literal">nullptr</span>;<span class="comment">//检查是否找到</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"></span><br><span class="line">    PNN _find(<span class="type">const</span> K&amp; key)<span class="comment">//返回PNN用于简化其它接口</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (_root == <span class="literal">nullptr</span>) <span class="keyword">return</span> &#123;<span class="literal">nullptr</span>,<span class="literal">nullptr</span>&#125;;</span><br><span class="line">        Node* cur = _root;</span><br><span class="line">        Node* parent = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (key &lt; cur-&gt;_key)<span class="comment">//key比当前节点小，往左子树走</span></span><br><span class="line">            &#123;</span><br><span class="line">                parent = cur;</span><br><span class="line">                cur = cur-&gt;_left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; cur-&gt;_key)<span class="comment">//往右子树走</span></span><br><span class="line">            &#123;</span><br><span class="line">                parent = cur;</span><br><span class="line">                cur = cur-&gt;_right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//找到key</span></span><br><span class="line">                <span class="keyword">return</span> &#123; cur,parent &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//没找到key,cur为nullptr</span></span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="literal">nullptr</span>,parent &#125;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="重写insert函数"><a href="#重写insert函数" class="headerlink" title="重写insert函数"></a>重写<code>insert</code>函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> K&amp; key, <span class="type">const</span> V&amp; value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (_root == <span class="literal">nullptr</span>)<span class="comment">//空树</span></span><br><span class="line">    &#123;</span><br><span class="line">        _root = <span class="keyword">new</span> <span class="built_in">Node</span>(key, value);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//====修改的部分====</span></span><br><span class="line">    PNN pnn = _find(key);</span><br><span class="line"></span><br><span class="line">    Node* cur = pnn.first;</span><br><span class="line">    Node* parent = pnn.second;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cur != <span class="literal">nullptr</span>)<span class="comment">//该key已存在，插入失败</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//================</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//此时cur为nullptr, parent为cur的结点</span></span><br><span class="line">    <span class="keyword">if</span> (key &lt; parent-&gt;_key)parent-&gt;_left = <span class="keyword">new</span> <span class="built_in">Node</span>(key, value);</span><br><span class="line">    <span class="keyword">else</span> parent-&gt;_right = <span class="keyword">new</span> <span class="built_in">Node</span>(key, value);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//成功插入</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="erase函数"><a href="#erase函数" class="headerlink" title="erase函数"></a><code>erase</code>函数</h3><p>这里也可以复用<code>_find</code>来方便地删除结点</p><p>这里要考虑的情况有:</p><ul><li>树为空</li><li>删除最后一个结点</li><li>删除根节点</li><li>左子树为空（包括叶子结点）</li><li>右子树为空</li><li>删除一般的结点</li></ul><p>当树有<code>&gt;=2</code>个结点，且要删除<code>非叶子</code>结点时，要考虑<code>结点替换</code>，否则二叉树会断掉，这里一般两种策略，取左子树的最右结点（最大结点），或取右子树的最左结点（最小结点）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">erase</span><span class="params">(<span class="type">const</span> K&amp; key)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (_root == <span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//空树无法删除</span></span><br><span class="line">        <span class="keyword">if</span> (_root-&gt;_key == key &amp;&amp; _root-&gt;_left == <span class="literal">nullptr</span> &amp;&amp; _root-&gt;_right == <span class="literal">nullptr</span>)<span class="comment">//删除最后一个结点</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> _root;</span><br><span class="line">            _root = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        PNN pnn = _find(key);</span><br><span class="line">        Node* cur = pnn.first;</span><br><span class="line">        Node* parent = pnn.second;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//没找到该结点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//下面的cur必不为空</span></span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;_left == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur == _root)<span class="comment">//为根节点时要替换根节点</span></span><br><span class="line">            &#123;</span><br><span class="line">                Node* right = _root-&gt;_right;</span><br><span class="line">                <span class="keyword">delete</span> _root;</span><br><span class="line">                _root = right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//没有左子树，则直接移除结点,右子树替代原结点</span></span><br><span class="line">            <span class="keyword">if</span> (cur == parent-&gt;_left) parent-&gt;_left = cur-&gt;_right;</span><br><span class="line">            <span class="keyword">else</span> parent-&gt;_right = cur-&gt;_right;</span><br><span class="line">            <span class="keyword">delete</span> cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cur-&gt;_right == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur == _root)</span><br><span class="line">            &#123;</span><br><span class="line">                Node* left = _root-&gt;_left;</span><br><span class="line">                <span class="keyword">delete</span> _root;</span><br><span class="line">                _root = left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//直接过继左子树</span></span><br><span class="line">            <span class="keyword">if</span> (cur == parent-&gt;_left)parent-&gt;_left = cur-&gt;_left;</span><br><span class="line">            <span class="keyword">else</span> parent-&gt;_right = cur-&gt;_left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//找到左子树的最右结点</span></span><br><span class="line">            Node* _cur = cur-&gt;_left;</span><br><span class="line">            Node* _parent = cur;</span><br><span class="line">            <span class="keyword">while</span> (_cur-&gt;_right != <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                _parent = _cur;</span><br><span class="line">                _cur = _cur-&gt;_right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//移走结点</span></span><br><span class="line">            <span class="keyword">if</span> (_cur == _parent-&gt;_left) _parent-&gt;_left = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">else</span> _parent-&gt;_right = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="comment">//获取cur的左右结点,必须再移走结点后，否则可能出现指向自己的结点</span></span><br><span class="line">            _cur-&gt;_left = cur-&gt;_left;</span><br><span class="line">            _cur-&gt;_right = cur-&gt;_right;</span><br><span class="line">            <span class="comment">//代替cur的位置</span></span><br><span class="line">            <span class="keyword">if</span> (cur == _root)<span class="comment">//删除根结点时</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">delete</span> _root;</span><br><span class="line">                _root = _cur;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span><span class="comment">//删除普通结点时</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (cur == parent-&gt;_left) parent-&gt;_left = _cur;</span><br><span class="line">                <span class="keyword">else</span> parent-&gt;_right = _cur;</span><br><span class="line">                <span class="keyword">delete</span> cur;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="拷贝构造"><a href="#拷贝构造" class="headerlink" title="拷贝构造"></a>拷贝构造</h3><p>利用二叉树的性质，可以再构建个<code>copy</code>子函数来递归拷贝</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BSTree</span>(<span class="type">const</span> BSTree&lt;K&gt;&amp; t)</span><br><span class="line">    &#123;</span><br><span class="line">        _root = <span class="built_in">Copy</span>(t._root);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">copy</span><span class="params">(Node* root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;<span class="comment">//递归出口</span></span><br><span class="line">        Node* pnode = <span class="keyword">new</span> <span class="built_in">Node</span>(root-&gt;_key, root-&gt;_value);<span class="comment">//复制结点</span></span><br><span class="line">        pnode-&gt;_left = <span class="built_in">copy</span>(root-&gt;_left);</span><br><span class="line">        pnode-&gt;_right = <span class="built_in">copy</span>(root-&gt;_right);</span><br><span class="line">        <span class="keyword">return</span> pnode;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><p>这里也用<code>destroy</code>子函数来递归地后序遍历依次删除各个结点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">BSTree</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">destroy</span>(_root);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">destroy</span><span class="params">(Node* root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">destroy</span>(root-&gt;_left);</span><br><span class="line">        <span class="built_in">destroy</span>(root-&gt;_right);</span><br><span class="line">        <span class="keyword">delete</span> root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>至此，一个基本的二叉搜索树已封装完成</p><p>实现的功能有</p><ul><li>构建二叉搜索树</li><li>拷贝复制二叉树</li><li>按<code>key</code>值查找</li><li>按<code>key</code>值删除</li></ul><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> key_value</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">K</span>,<span class="keyword">class</span> <span class="title class_">V</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BSTNode</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">BSTNode</span>(<span class="type">const</span> K&amp; key = <span class="built_in">K</span>(), <span class="type">const</span> V&amp; value = <span class="built_in">V</span>())</span><br><span class="line">:_left(<span class="literal">nullptr</span>)</span><br><span class="line">, _right(<span class="literal">nullptr</span>)</span><br><span class="line">, _key(key)</span><br><span class="line">, _value(value)</span><br><span class="line">&#123;&#125;</span><br><span class="line">BSTNode&lt;K, V&gt;* _left;<span class="comment">//指向左子树</span></span><br><span class="line">BSTNode&lt;K, V&gt;* _right;<span class="comment">//指向右子树</span></span><br><span class="line">K _key;<span class="comment">//储存键</span></span><br><span class="line">V _value;<span class="comment">//储存值</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">K</span>,<span class="keyword">class</span> <span class="title class_">V</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BSTree</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">typedef</span> BSTNode&lt;K, V&gt; Node;<span class="comment">//使用typedef简化代码</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">BSTree</span>() :_root(<span class="literal">nullptr</span>) &#123;&#125;<span class="comment">//提供默认构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">BSTree</span>(<span class="type">const</span> BSTree&lt;K, V&gt;&amp; bst)</span><br><span class="line">&#123;</span><br><span class="line">_root = <span class="built_in">copy</span>(bst._root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">BSTree</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">destroy</span>(_root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> K&amp; key, <span class="type">const</span> V&amp; value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (_root == <span class="literal">nullptr</span>)<span class="comment">//空树</span></span><br><span class="line">&#123;</span><br><span class="line">_root = <span class="keyword">new</span> <span class="built_in">Node</span>(key, value);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//====修改的部分====</span></span><br><span class="line">PNN pnn = _find(key);</span><br><span class="line"></span><br><span class="line">Node* cur = pnn.first;</span><br><span class="line">Node* parent = pnn.second;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cur != <span class="literal">nullptr</span>)<span class="comment">//该key已存在，插入失败</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//此时cur为nullptr, parent为cur的结点</span></span><br><span class="line"><span class="keyword">if</span> (key &lt; parent-&gt;_key)parent-&gt;_left = <span class="keyword">new</span> <span class="built_in">Node</span>(key, value);</span><br><span class="line"><span class="keyword">else</span> parent-&gt;_right = <span class="keyword">new</span> <span class="built_in">Node</span>(key, value);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//成功插入</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">in_order</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">_in_order(_root);<span class="comment">//传入根结点</span></span><br><span class="line">std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="type">void</span> _in_order(Node* root)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">_in_order(root-&gt;_left);<span class="comment">//先访问左结点</span></span><br><span class="line">std::cout &lt;&lt; root-&gt;_value &lt;&lt; <span class="string">&quot; &quot;</span>;<span class="comment">//再访问根结点</span></span><br><span class="line">_in_order(root-&gt;_right);<span class="comment">//最后访问右结点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt; Node*, Node* &gt; PNN;<span class="comment">//简化代码</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">const</span> K&amp; key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _find(key).first != <span class="literal">nullptr</span>;<span class="comment">//检查是否找到</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"></span><br><span class="line">PNN _find(<span class="type">const</span> K&amp; key)<span class="comment">//返回PNN用于简化其它接口</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (_root == <span class="literal">nullptr</span>) <span class="keyword">return</span> &#123;<span class="literal">nullptr</span>,<span class="literal">nullptr</span>&#125;;</span><br><span class="line">Node* cur = _root;</span><br><span class="line">Node* parent = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">while</span> (cur)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (key &lt; cur-&gt;_key)<span class="comment">//key比当前节点小，往左子树走</span></span><br><span class="line">&#123;</span><br><span class="line">parent = cur;</span><br><span class="line">cur = cur-&gt;_left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (key &gt; cur-&gt;_key)<span class="comment">//往右子树走</span></span><br><span class="line">&#123;</span><br><span class="line">parent = cur;</span><br><span class="line">cur = cur-&gt;_right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//找到key</span></span><br><span class="line"><span class="keyword">return</span> &#123; cur,parent &#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//没找到key,cur为nullptr</span></span><br><span class="line"><span class="keyword">return</span> &#123; <span class="literal">nullptr</span>,parent &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">erase</span><span class="params">(<span class="type">const</span> K&amp; key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (_root == <span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//空树无法删除</span></span><br><span class="line"><span class="keyword">if</span> (_root-&gt;_key == key &amp;&amp; _root-&gt;_left == <span class="literal">nullptr</span> &amp;&amp; _root-&gt;_right == <span class="literal">nullptr</span>)<span class="comment">//删除最后一个结点</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> _root;</span><br><span class="line">_root = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line">PNN pnn = _find(key);</span><br><span class="line">Node* cur = pnn.first;</span><br><span class="line">Node* parent = pnn.second;</span><br><span class="line"><span class="keyword">if</span> (cur == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//没找到该结点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//下面的cur必不为空</span></span><br><span class="line"><span class="keyword">if</span>(cur-&gt;_left == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (cur == _root)<span class="comment">//为根节点时要替换根节点</span></span><br><span class="line">&#123;</span><br><span class="line">Node* right = _root-&gt;_right;</span><br><span class="line"><span class="keyword">delete</span> _root;</span><br><span class="line">_root = right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//没有左子树，则直接移除结点,右子树替代原结点</span></span><br><span class="line"><span class="keyword">if</span> (cur == parent-&gt;_left) parent-&gt;_left = cur-&gt;_right;</span><br><span class="line"><span class="keyword">else</span> parent-&gt;_right = cur-&gt;_right;</span><br><span class="line"><span class="keyword">delete</span> cur;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (cur-&gt;_right == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (cur == _root)</span><br><span class="line">&#123;</span><br><span class="line">Node* left = _root-&gt;_left;</span><br><span class="line"><span class="keyword">delete</span> _root;</span><br><span class="line">_root = left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//直接过继左子树</span></span><br><span class="line"><span class="keyword">if</span> (cur == parent-&gt;_left)parent-&gt;_left = cur-&gt;_left;</span><br><span class="line"><span class="keyword">else</span> parent-&gt;_right = cur-&gt;_left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//找到左子树的最右结点</span></span><br><span class="line">Node* _cur = cur-&gt;_left;</span><br><span class="line">Node* _parent = cur;</span><br><span class="line"><span class="keyword">while</span> (_cur-&gt;_right != <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">_parent = _cur;</span><br><span class="line">_cur = _cur-&gt;_right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//移走结点</span></span><br><span class="line"><span class="keyword">if</span> (_cur == _parent-&gt;_left) _parent-&gt;_left = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">else</span> _parent-&gt;_right = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="comment">//获取cur的左右结点,必须再移走结点后，否则可能出现指向自己的结点</span></span><br><span class="line">_cur-&gt;_left = cur-&gt;_left;</span><br><span class="line">_cur-&gt;_right = cur-&gt;_right;</span><br><span class="line"><span class="comment">//代替cur的位置</span></span><br><span class="line"><span class="keyword">if</span> (cur == _root)<span class="comment">//删除根结点时</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> _root;</span><br><span class="line">_root = _cur;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span><span class="comment">//删除普通结点时</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (cur == parent-&gt;_left) parent-&gt;_left = _cur;</span><br><span class="line"><span class="keyword">else</span> parent-&gt;_right = _cur;</span><br><span class="line"><span class="keyword">delete</span> cur;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="function">Node* <span class="title">copy</span><span class="params">(Node* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;<span class="comment">//递归出口</span></span><br><span class="line">Node* pnode = <span class="keyword">new</span> <span class="built_in">Node</span>(root-&gt;_key, root-&gt;_value);<span class="comment">//复制结点</span></span><br><span class="line">pnode-&gt;_left = <span class="built_in">copy</span>(root-&gt;_left);</span><br><span class="line">pnode-&gt;_right = <span class="built_in">copy</span>(root-&gt;_right);</span><br><span class="line"><span class="keyword">return</span> pnode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">destroy</span><span class="params">(Node* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">destroy</span>(root-&gt;_left);</span><br><span class="line"><span class="built_in">destroy</span>(root-&gt;_right);</span><br><span class="line"><span class="keyword">delete</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Node* _root;<span class="comment">//指向根节点的指针作为成员变量</span></span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 二叉树 搜索树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件缓冲区</title>
      <link href="/2024/07/26/c-file-cache/"/>
      <url>/2024/07/26/c-file-cache/</url>
      
        <content type="html"><![CDATA[<p>前置博客 <a href="https://www.supdriver.top/2024/07/10/basicIO/">基础IO</a></p><h1 id="为什么有缓冲"><a href="#为什么有缓冲" class="headerlink" title="为什么有缓冲"></a>为什么有缓冲</h1><p>因为<code>磁盘的读写</code>与<code>内存的读写</code>操作速度相比，磁盘的读写是相差数量级的慢，所以为了提高内存<strong>多次</strong>，<strong>频繁</strong>读写磁盘文件的效率，<code>缓冲区</code>被投入使用。尤其是内存内容<strong>写入</strong>磁盘时，常常先写入<code>内存级缓冲区</code>，再在特定规则下一次性将<code>缓冲区</code>的内容写入磁盘</p><p>**本文以<code>C语言</code>提供的用户级缓冲区为例介绍缓冲区</p><h1 id="缓冲区的刷新规则"><a href="#缓冲区的刷新规则" class="headerlink" title="缓冲区的刷新规则"></a>缓冲区的刷新规则</h1><p>首先当一个进程<strong>正常退出</strong>时，会先刷新缓冲区再关闭文件,此时必定有一次刷新</p><p>而当进程<strong>运行时</strong>缓冲区的刷新策略主要有以下三种</p><ul><li><code>无缓冲</code> 内容直接写入文件</li><li><code>行缓冲</code> 输入一般内容不刷新，遇到<code>\n</code>时刷新一次缓冲区</li><li><code>全缓冲</code> 缓冲区有容量限制，<strong>满了</strong>之后就刷新</li></ul><h1 id="认识一下C语言的缓冲区"><a href="#认识一下C语言的缓冲区" class="headerlink" title="认识一下C语言的缓冲区"></a>认识一下C语言的缓冲区</h1><p><em>这里的系统环境是Linux</em></p><h2 id="刷新规则"><a href="#刷新规则" class="headerlink" title="刷新规则"></a>刷新规则</h2><p>运行如下代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    FILE* pfile = fopen(<span class="string">&quot;file.txt&quot;</span>,<span class="string">&quot;w&quot;</span>);<span class="comment">//打开空文件</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>,<span class="string">&quot;stdout&quot;</span>);<span class="comment">//向标准输出输出</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;strerr&quot;</span>);<span class="comment">//向标准错误输出输出</span></span><br><span class="line">    <span class="built_in">fprintf</span>(pfile,<span class="string">&quot;file&quot;</span>);<span class="comment">//向文件输出</span></span><br><span class="line">    _exit(<span class="number">0</span>);<span class="comment">//不刷新缓冲区，直接退出</span></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>终端和文件的内容为:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stderr</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到只有<code>标准错误输出</code>有实际的输出,而<code>标准输出</code>和<code>文件输出</code>都没有输出</p><p>目前可以得出：</p><ul><li><code>标准错误输出</code>是<code>无缓冲</code>的刷新规则</li></ul><p>因此我们再运行如下代码，再输出内容后面加上<code>\n</code>换行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    FILE* pfile = fopen(<span class="string">&quot;file.txt&quot;</span>,<span class="string">&quot;w&quot;</span>);<span class="comment">//打开空文件</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>,<span class="string">&quot;stdout\n&quot;</span>);<span class="comment">//向标准输出输出</span></span><br><span class="line">    <span class="built_in">fprintf</span>(pfile,<span class="string">&quot;file\n&quot;</span>);<span class="comment">//向文件输出</span></span><br><span class="line">    _exit(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>终端输出内容为</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stdout</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>而文件依然为空</strong></p><p>由此可得:</p><ul><li><code>标准输出</code>遵循<code>行缓冲</code>的刷新规则</li><li><code>文件输出</code>遵循<code>全缓冲</code>的刷新规则</li></ul><h2 id="缓冲区在fork中的行为"><a href="#缓冲区在fork中的行为" class="headerlink" title="缓冲区在fork中的行为"></a>缓冲区在fork中的行为</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello1 &quot;</span>);<span class="comment">//父进程向标准输出打印一句话</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>,<span class="string">&quot;hello2 &quot;</span>);<span class="comment">//父进程向标准输出打印一句话</span></span><br><span class="line"></span><br><span class="line">    fork();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上段代码的输出内容为</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello1 hello2 hello1 hello2 </span><br></pre></td></tr></table></figure><p>可见<code>fork</code>前的缓冲区内容被打印了两次（父子进程各一次），所以<code>fork</code>也会复制<code>缓冲区</code>的内容</p><p>实际上<code>缓冲区</code>属于进程的一部分，且<code>fork</code>时遵循<code>写时拷贝</code></p><h1 id="模拟封装Linux下C语言的文件接口（包括缓冲区）"><a href="#模拟封装Linux下C语言的文件接口（包括缓冲区）" class="headerlink" title="模拟封装Linux下C语言的文件接口（包括缓冲区）"></a>模拟封装Linux下C语言的文件接口（包括缓冲区）</h1><h2 id="主要目标"><a href="#主要目标" class="headerlink" title="主要目标"></a>主要目标</h2><p>采用<code>Mystdio.h</code>声明，<code>Mystdio.c</code>实现的方式，封装<code>read</code>,<code>write</code>,<code>close</code>系统调用接口。并提供用户级缓冲区和缓冲区的刷新等功能</p><h2 id="声明结构体和接口"><a href="#声明结构体和接口" class="headerlink" title="声明结构体和接口"></a>声明结构体和接口</h2><p>我们先把主要的接口和主要的内容做出来看看封装效果</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MYSTDIO_H__ <span class="comment">//利用预编译防止头文件被重复编译</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MYSTDIO_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//声明文件结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">IO_FILE</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> fileno;</span><br><span class="line">&#125;_FILE;</span><br><span class="line"></span><br><span class="line">_FILE * _fopen(<span class="type">const</span> <span class="type">char</span> *filename,<span class="type">const</span> <span class="type">char</span> *flag);</span><br><span class="line"><span class="type">int</span> _fwrite(_FILE* fp,<span class="type">const</span> <span class="type">char</span>*s, <span class="type">int</span> len);</span><br><span class="line"><span class="type">void</span> _fclose(_FILE* fp);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br></pre></td></tr></table></figure><h2 id="实现无缓冲区的接口"><a href="#实现无缓冲区的接口" class="headerlink" title="实现无缓冲区的接口"></a>实现无缓冲区的接口</h2><p>实现的部分由<code>Mystdio.c</code>完成</p><h3 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h3><p>这里的头文件要能够提供使用系统调用接口,以及调用堆区的接口,所以 头文件如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Mystdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="fopen函数"><a href="#fopen函数" class="headerlink" title="_fopen函数"></a>_fopen函数</h3><p>我们先模拟实现<code>fopen</code>函数的主要功能，主要实现<code>&quot;w&quot;``&quot;a&quot;``&quot;r&quot;</code>的打开模式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FILE_MODE 0666 <span class="comment">//设置默认的文件权限</span></span></span><br><span class="line"></span><br><span class="line">_FILE * _fopen(<span class="type">const</span> <span class="type">char</span> *filename,<span class="type">const</span> <span class="type">char</span> *flag)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> f = <span class="number">0</span>;<span class="comment">//准备空位图</span></span><br><span class="line">    <span class="type">int</span> fd = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(flag,<span class="string">&quot;w&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        f = (O_CREAT|O_WRONLY|O_TRUNC);</span><br><span class="line">        fd = open(filename,f,FILE_MODE);<span class="comment">//打开文件</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strcmp</span>(flag,<span class="string">&quot;a&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        f = (O_CREAT|O_WRONLY|O_APPEND);</span><br><span class="line">        fd = open(filename,f,FILE_MODE);<span class="comment">//打开文件</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strcmp</span>(flag,<span class="string">&quot;w&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        f = O_RDONLY;</span><br><span class="line">        fd = open(filename,f);<span class="comment">//打开文件</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">NULL</span>;<span class="comment">//非法的打开模式</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;<span class="comment">//打开失败</span></span><br><span class="line">    </span><br><span class="line">    _FILE *fp = (_FILE*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(_FILE));<span class="comment">//创建_FILE结构体</span></span><br><span class="line">    fp-&gt;fileno = fp;<span class="comment">//设置_FILE结构体</span></span><br><span class="line">    <span class="keyword">return</span> fp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="fwrite函数-————无缓冲区"><a href="#fwrite函数-————无缓冲区" class="headerlink" title="_fwrite函数 ————无缓冲区"></a>_fwrite函数 ————无缓冲区</h3><p>然后是先简单地写一个没有缓冲区的<code>_fwrite</code></p><p>带缓冲区版本的稍后添加</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> _fwrite(_FILE *fp,<span class="type">const</span> <span class="type">char</span>* s,<span class="type">int</span> len)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> wrtie(fp-&gt;fileno,s,len);<span class="comment">//无缓冲区的写入版本</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="fclose函数-————不刷新缓冲区"><a href="#fclose函数-————不刷新缓冲区" class="headerlink" title="_fclose函数 ————不刷新缓冲区"></a>_fclose函数 ————不刷新缓冲区</h3><p>这里也是先写个没缓冲区的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> _fclose(_FILE* fp)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(fp == <span class="literal">NULL</span>) <span class="keyword">return</span>;<span class="comment">//防止空指针</span></span><br><span class="line">    close(fp-&gt;fileno);<span class="comment">//关闭文件</span></span><br><span class="line">    <span class="built_in">free</span>(fp);<span class="comment">//释放资源</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="为接口适配缓冲区"><a href="#为接口适配缓冲区" class="headerlink" title="为接口适配缓冲区"></a>为接口适配缓冲区</h2><h3 id="为-FILE结构体添加输入输出缓冲区"><a href="#为-FILE结构体添加输入输出缓冲区" class="headerlink" title="为_FILE结构体添加输入输出缓冲区"></a>为<code>_FILE</code>结构体添加输入输出缓冲区</h3><p><code>缓冲区</code>和<code>刷新规则标志</code>声明在结构体中，使每个打开的文件都有独立的用户级缓冲区和刷新规则</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE 1024 <span class="comment">//定义缓冲区大小</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FLUSH_NONE 0 <span class="comment">//无缓冲</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FLUSH_LINE 1 <span class="comment">//行缓冲</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FLUSH_ALL 2 <span class="comment">//全缓冲</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">IO_FILE</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> fileno;<span class="comment">//文件描述符</span></span><br><span class="line">    <span class="type">int</span> flag; <span class="comment">//刷新规则标志</span></span><br><span class="line">    <span class="type">char</span> inbuffer[SIZE];<span class="comment">//输入缓冲区</span></span><br><span class="line">    <span class="type">int</span> in_pos;<span class="comment">//输入缓冲区指针</span></span><br><span class="line">    <span class="type">char</span> outbuffer[SIZE];<span class="comment">//输出缓冲区</span></span><br><span class="line">    <span class="type">int</span> out_pos;<span class="comment">//输出缓冲区指针</span></span><br><span class="line">&#125;_FILE;</span><br></pre></td></tr></table></figure><h3 id="fopen添加语句"><a href="#fopen添加语句" class="headerlink" title="fopen添加语句"></a>fopen添加语句</h3><p><code>fopen</code>仅需添加几句用于初始化的代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//_FILE *fp = (_FILE*)malloc(sizeof(_FILE)); //申该语句之前都不变</span></span><br><span class="line">fp-&gt;fileno = fd;<span class="comment">//储存文件描述符</span></span><br><span class="line">fp-&gt;flag = FLUSH_LINE;<span class="comment">//设置为行刷新</span></span><br><span class="line">fp-&gt;in_pos = <span class="number">0</span>;<span class="comment">//指针置0</span></span><br><span class="line">fp-&gt;out_pos = <span class="number">0</span>;<span class="comment">//指针置0</span></span><br><span class="line"><span class="comment">//return fp;  //这句也不变</span></span><br></pre></td></tr></table></figure><h3 id="fwrite重写"><a href="#fwrite重写" class="headerlink" title="fwrite重写"></a>fwrite重写</h3><p><code>fwrite</code>要根据不同的刷新方式进行写入</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> _fwrite(_FILE *fp,<span class="type">const</span> <span class="type">char</span>* s,<span class="type">int</span> len)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;(fp-&gt;outbuffer[fp-&gt;out_pos]),s,len);<span class="comment">//将内容拷贝至缓冲区指定位置</span></span><br><span class="line">    fp-&gt;out_pos +=len;<span class="comment">//简易偏移out_pos</span></span><br><span class="line">    <span class="keyword">if</span>(fp-&gt;fileno == FLUSH_NONE)</span><br><span class="line">    &#123;</span><br><span class="line">        write(fp-&gt;fileno,s,fp-&gt;out_pos);<span class="comment">//无缓冲区的写入版本</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(fp-&gt;flag == FLUSH_LINE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(fp-&gt;outbuffer[fp-&gt;out_pos<span class="number">-1</span>] == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            write(fp-&gt;fileno,s,fp-&gt;out_pos);<span class="comment">//立即刷新</span></span><br><span class="line">            fp-&gt;out_pos = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> len;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(fp-&gt;flag == FLUSH_ALL)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(fp-&gt;out_pos == SIZE)</span><br><span class="line">        &#123;</span><br><span class="line">            write(fp-&gt;fileno,s,fp-&gt;out_pos);<span class="comment">//立即刷新</span></span><br><span class="line">            fp-&gt;out_pos = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> len;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="添加-fflush和修改-fclose"><a href="#添加-fflush和修改-fclose" class="headerlink" title="添加_fflush和修改_fclose"></a>添加<code>_fflush</code>和修改<code>_fclose</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> _fflush(_FILE* fp)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(fp-&gt;out_pos &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        write(fp-&gt;fileno,fp-&gt;outbuffer,fp-&gt;out_pos);<span class="comment">//立即刷新</span></span><br><span class="line">        fp-&gt;out_pos = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> _fclose(_FILE* fp)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(fp == <span class="literal">NULL</span>) <span class="keyword">return</span>;<span class="comment">//防止空指针</span></span><br><span class="line">    _fflush(fp);<span class="comment">//刷新缓冲区</span></span><br><span class="line">    close(fp-&gt;fileno);<span class="comment">//关闭文件</span></span><br><span class="line">    <span class="built_in">free</span>(fp);<span class="comment">//释放资源</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>至此,我们已经封装了基本的写入功能,更多的细节可自行完善</p><p><a href="https://github.com/sis-shen/Linux_Code/tree/main/mystdio">戳我去github仓库🔗</a> 查看源文件</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux文件系统</title>
      <link href="/2024/07/26/filesys/"/>
      <url>/2024/07/26/filesys/</url>
      
        <content type="html"><![CDATA[<h1 id="文件系统的组织方式"><a href="#文件系统的组织方式" class="headerlink" title="文件系统的组织方式"></a>文件系统的组织方式</h1><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-08-06_14-22-47.png"></p><p>这里介绍一下<code>Block Group</code>里的分区内容</p><ul><li><code>超级块</code>(Super Block): <strong>存放文件系统本身的结构信息</strong>。记录的信息主要有：<code>bolck</code>(数据块) 和 <code>inode</code>(属性块)的总量，<br><strong>未使用</strong>的<code>block</code>和<code>inode</code>的数量，一个<code>block</code>和<code>inode</code>的大小，最近一次挂载的时间，最近一次写入数据的<br>时间，最近一次检验磁盘的时间等其他文件系统的相关信息。Super Block的信息被破坏，可以说整个<br>文件系统结构就被破坏了</li><li><code>GDT</code>(Group Descriptor Table): 块组描述符，描述块组属性信息。这里不作详细介绍</li><li><code>块位图</code>(Block Bitmap):位图中的<code>比特位</code>记录着Data Block中哪个数据块已经被占用，哪个数据块没有被占用</li><li><code>inode位图</code>(inode Bitmap):每个<code>比特位</code>表示一个inode是否空闲可用。</li><li><code>inode表</code>(inode Table):每一个<code>inode</code>存放了各自文件的<code>属性</code>，如文件大小，所有者，最近修改时间等</li><li><code>数据区</code>：存放文件内容</li></ul><h1 id="Linux系统中文件的增删查改"><a href="#Linux系统中文件的增删查改" class="headerlink" title="Linux系统中文件的增删查改"></a>Linux系统中文件的增删查改</h1><p>Linux中，每一个文件都有自己的inode,而每一个inode有自己的inode编号（按分区为单位）</p><p>特别的：尽管inode储存了文件的属性，文件名并不属于inode</p><h2 id="理解目录文件"><a href="#理解目录文件" class="headerlink" title="理解目录文件"></a>理解目录文件</h2><p><code>目录</code>也是<code>文件</code>!目录也有自己的<code>inode</code>和数据块</p><p>目录的数据块<strong>储存</strong>了该目录下，文件的<strong>文件名</strong>和文件<code>inode</code>的映射关系</p><h2 id="创建文件的过程"><a href="#创建文件的过程" class="headerlink" title="创建文件的过程"></a>创建文件的过程</h2><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-08-06_16-44-21.png"></p><p>创建文件主要有以下4个操作</p><ol><li><code>存储属性</code>:内核先找到一个空闲的<code>inode</code>(图中是263467)。<strong>内核</strong>把文件信息记录其中。</li><li><code>存储数据</code>:该文件需要存储在三个数据块，<strong>内核</strong>找到了三个空闲块:300,600,800。然后将<strong>内核缓冲区</strong>的第一块数据复制到300，下一块复制到600，依次类推</li><li><code>记录分配情况</code>:文件内容按顺序300,600,800存放。内核在inode上的磁盘分布区记录了上述块列表</li><li><code>添加文件名到目录</code>:通过写入目录文件，将文件名和inode的建立映射关系(这里是将文件名cab与inode 263467建立联系)</li></ol><h1 id="Linux中的硬链接和软链接"><a href="#Linux中的硬链接和软链接" class="headerlink" title="Linux中的硬链接和软链接"></a>Linux中的硬链接和软链接</h1><p>Linux文件系统中特别<strong>重要</strong>*的一点是：文件系统使用<code>inode</code>管理文件，<strong>而不是</strong>文件名，所以使用<code>inode</code>唯一指定文件。也就是说找到了<code>inode</code>才是真正找到了<code>文件</code></p><p>基于此理论，我们可以更好地理解<code>软链接</code>和<code>硬链接</code></p><h2 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h2><p>使用<code>ln -s &lt;原文件名&gt; &lt;软链接文件名&gt;</code>指令可以建立软链接,<code>-s</code>参数就是指定创建软链接文件</p><p>例如在已有<code>file.txt</code>的情况下,使用<code>ln -s file.txt soft-link</code>在当前文件夹创建软链接文件<code>soft-link</code>,指向文件<code>file.txt</code></p><p>然后我们输入<code>ls -li</code>查看这两个文件</p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-08-06_21-54-47.png"></p><p>可以看到软链接文件和原文件的inode是不同的，且两个文件的硬链接数(第二个框框)都是<code>1</code>,说明软链接是一个文件系统意义上的<code>新文件</code></p><p><code>软链接文件</code>可类比与<code>Windows</code>下的快捷方式</p><h2 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h2><p>使用<code>ln &lt;原文件名&gt; &lt;硬链接文件名&gt;</code>指令可以建立硬链接。</p><p>例如在已有<code>file.txt</code>的情况下,使用<code>ln file.txt hard-link</code>在当前文件夹创建软链接文件<code>hard-link</code>,与文件<code>file.txt</code><strong>等价</strong></p><p>然后我们输入<code>ls -li</code>查看这”两个”文件</p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-08-06_22-06-39.png"></p><p>可以看到它们的<code>inode</code>是完全一样的，那么基于上文文件系统对文件的视角，这”两个”文件完全就是<strong>同一个文件!</strong>,或者说<code>hard-link</code>是<code>file.txt</code>的<code>别名</code>，同时我们也能看到<code>硬链接引用计数</code>变成了<code>2</code></p><p>在引入了<code>硬链接引用计数</code>的概念下，删除目录中的一个文件，只是删除该目录下<code>文件名</code>和<code>inode</code>的映射关系，并使该文件的<code>引用计数</code>减去<code>1</code>,当其<strong>归零</strong>时，才会真正释放磁盘上的文件资源</p><h3 id="目录的硬链接数"><a href="#目录的硬链接数" class="headerlink" title="目录的硬链接数"></a>目录的硬链接数</h3><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-08-06_22-36-40.png"></p><p>对于每一个普通目录（除了根目录），至少有父目录下自己的<code>文件名</code>和该目录下的<code>.</code>文件<code>2</code>个<code>硬链接</code>，而在其内部创建的每个<code>子目录</code>又会储存一个名为<code>..</code>的硬连接，所以普通目录的硬连接数会<code>&gt;=2</code></p><p>因此为了防止文件系统结构混乱，操作系统<strong>不允许</strong>用户对目录建立<code>硬链接</code></p><h3 id="删除链接文件"><a href="#删除链接文件" class="headerlink" title="删除链接文件"></a>删除链接文件</h3><p><code>rm</code>不一定能删除链接文件，此时可以用<code>unlink</code>命令</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言文件操作</title>
      <link href="/2024/07/15/cfileop/"/>
      <url>/2024/07/15/cfileop/</url>
      
        <content type="html"><![CDATA[<h1 id="用户级文件操作"><a href="#用户级文件操作" class="headerlink" title="用户级文件操作"></a>用户级文件操作</h1><p><code>C语言</code>的文件操作也是用户级的文件操作，通过<code>FILE</code>对象来<strong>管理</strong>每一个<code>被打开的文件</code>，以及提供了<strong>用户级</strong>文件缓冲区，因此还涉及到冲刷缓冲区等问题</p><h2 id="FILE-类"><a href="#FILE-类" class="headerlink" title="FILE 类"></a><code>FILE</code> 类</h2><p><code>FILE</code>类描述了一个文件流。里面存储了<strong>文件控制</strong>所需的信息:</p><ul><li>指向自身缓冲区的的<code>指针</code></li><li>位置指示器</li><li>状态指示器</li></ul><p>所以<code>C语言</code>中对文件的管理就是对<code>FILE</code>对象的管理</p><h1 id="基础操作-针对一般文件"><a href="#基础操作-针对一般文件" class="headerlink" title="基础操作 - 针对一般文件"></a>基础操作 - 针对一般文件</h1><h2 id="基础示例"><a href="#基础示例" class="headerlink" title="基础示例"></a>基础示例</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">FILE* pfile = fopen(<span class="string">&quot;file.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);<span class="comment">//&quot;w&quot;模式打开文件file.txt</span></span><br><span class="line"><span class="type">int</span> code = <span class="number">1</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* msg = <span class="string">&quot;this is a msg&quot;</span>;</span><br><span class="line"><span class="built_in">fprintf</span>(pfile, <span class="string">&quot;get msg : %s code:%d&quot;</span>, msg, code);<span class="comment">//格式化输出字符串</span></span><br><span class="line">fclose(pfile);<span class="comment">//冲刷缓冲区并关闭文件</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码创建了一个<code>file.txt</code>文件，输入<code>格式化字符串</code>(就和使用printf打印一样)。然后用<code>flcose</code>关闭文件流</p><h2 id="fopen-打开文件"><a href="#fopen-打开文件" class="headerlink" title="fopen 打开文件"></a>fopen 打开文件</h2><p><code>fopen</code>能够打开以各种<code>模式</code>磁盘上的文件</p><p><code>FILE* fopen( const char * filename, const char * mode );</code></p><p><strong>返回值</strong>:</p><ul><li>成功时，返回一个不为空的<code>FILE*</code>指针，用于控制该文件</li><li>失败时，返回<code>NULL</code>空指针并设置了全局变量<code>errno</code></li></ul><h3 id="常见模式"><a href="#常见模式" class="headerlink" title="常见模式"></a>常见模式</h3><p>| 模式 | 简述 |<br>| &#x3D;&#x3D;&#x3D; | &#x3D;&#x3D;&#x3D; |<br>| <code>&quot;w&quot;</code> | 创建一个<strong>新的空文件</strong>用于输出操作。如果已存在<code>同名文件</code>,清除原文件并当作新文件处理 |<br>| <code>&quot;r&quot;</code> | 只读模式打开文件。且该文件必须存在 |<br>| <code>&quot;a&quot;</code> | 打开已有文件时，仅用于在文件末尾<code>追加</code>新的内容。并且重定位函数<code>(fseek,fsetpos,reweind)</code>会被忽略，即使成功调用，也没有效果；当文件不存在时，会创建一个新的空文件 |<br>| “<code>r+</code>“ | 读写模式打开已有文件，<strong>不会清除</strong>原文件内容,并且读写时均从文件开头开始。打开后第一次操作为写入时，从文件头部开始逐字符覆盖原文件。<strong>注</strong>读写模式同时只能<code>读</code>或<code>写</code>的一种，第一次取决于先进行哪种操作，可以用<code>fseek</code>函数转换读写模式 |<br>| “<code>w+</code>“ | 读写模式打开新文件，若存在，则清除原文件内容;读写模式的切换和<code>&quot;r+&quot;</code>模式相同，唯一的区别就是打开时是否清除原文件内容 |<br>| “<code>a+</code>“ | 从文件末尾打开读写模式，<strong>不会清除原文件内容</strong>，若打开后第一次操作为写，则从文件末尾开始；若第一次操作为读，则从头开始；读写模式的切换同上 |</p><h3 id="二进制模式"><a href="#二进制模式" class="headerlink" title="二进制模式"></a>二进制模式</h3><p>如果要以二进制模式打开文件，只需要在上面的模式末尾加上字符<code>b</code></p><p>若有<code>+</code>,则<code>b</code>既可以放在末尾也可以放在中间</p><ul><li><code>r+b</code> <code>w+b</code> <code>a+b</code></li><li><code>rb+</code> <code>wb+</code> <code>ab+</code></li></ul><h3 id="强制新建文件"><a href="#强制新建文件" class="headerlink" title="强制新建文件"></a>强制新建文件</h3><p>新的C语言标准,<code>C2011</code>(不是C++11),添加了一种新的说明符<code>w</code>,可以被添加在任意<code>&quot;w&quot;</code>后面</p><ul><li><code>&quot;wx&quot;</code> <code>&quot;wbx&quot;</code> <code>&quot;w+x&quot;</code>  <code>&quot;w+bx&quot;</code>&#x2F;<code>&quot;wb+x&quot;</code></li></ul><p>当文件<strong>存在</strong>时,<code>w</code>会<strong>强制</strong><code>fopen</code>函数失败,返回一个<code>NULL</code>空指针</p><h2 id="freopen-重定向文件流"><a href="#freopen-重定向文件流" class="headerlink" title="freopen 重定向文件流"></a>freopen 重定向文件流</h2><p><code>FILE* freopen ( const char *filename, const char *mode, FILE * pFile );</code></p><ul><li>如果传入了新的文件名(与<code>pFile</code>控制的文件相比),该函数会<strong>关闭</strong><code>pFile</code>原本指向的文件流，并取消关联。然后<strong>不论</strong>是否成功关闭，<code>freopen</code>会用和<code>fopen</code>同样的方式打开该文件</li><li>如果文件名还是原文件，则只会改变打开模式</li></ul><p><strong>返回值</strong>:</p><ul><li>成功时，返回<code>pFile</code>内储存的地址</li><li>失败时，返回<code>NULL</code></li></ul><h3 id="特别的"><a href="#特别的" class="headerlink" title="特别的"></a>特别的</h3><p><code>freopen</code>用于进程的输入输出重定向会特别有用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">freopen (<span class="string">&quot;outfile.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,<span class="built_in">stdout</span>);<span class="comment">//标准输出重定向到文件</span></span><br><span class="line"></span><br><span class="line">freopen (<span class="string">&quot;readfile.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,<span class="built_in">stdin</span>);<span class="comment">//标准输入重定向到文件</span></span><br><span class="line"></span><br><span class="line">freopen (<span class="string">&quot;errdfile.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,<span class="built_in">stderr</span>);<span class="comment">//标准错误输出重定向到文件</span></span><br></pre></td></tr></table></figure><h2 id="重定位-文件流位置指示器-stream-position-indicator"><a href="#重定位-文件流位置指示器-stream-position-indicator" class="headerlink" title="重定位 文件流位置指示器(stream position indicator)"></a>重定位 文件流位置指示器(stream position indicator)</h2><h3 id="文件的抽象内存结构"><a href="#文件的抽象内存结构" class="headerlink" title="文件的抽象内存结构"></a>文件的抽象内存结构</h3><p>首先我们要明确一下文件的内存结构，如下图</p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-20_21-23-32.png"></p><p>这里及下文用图中的<code>ptr</code>代指标题的中的 <code>文件流位置指示器</code>,这个<code>ptr</code>决定了每一次对文件的<code>读/写</code>操作的<strong>起点</strong>,同时每一次<code>读/写</code>操作都会使<code>ptr</code>自动往后走，因此要显示控制<code>ptr</code>，就得使用<code>fseek,fsetpos</code>等接口</p><h2 id="fseek-重定位"><a href="#fseek-重定位" class="headerlink" title="fseek 重定位"></a>fseek 重定位</h2><p><code>int fseek ( FILE *pFile, long int offset, int origin );</code></p><p><code>fseek</code>能过直接重定位<code>ptr</code>所指的</p><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ul><li><code>pFile</code>：用于控制文件的<code>FILE*</code>类型指针</li><li><code>offset</code>：则是<strong>偏移量</strong>，长整型，表示偏移多少字节</li><li><code>origin</code>：该形参标注了<strong>偏移量</strong>相对于哪个位置计算<strong>实际位置</strong></li></ul><p><code>origin</code>有三个宏可以选<br>| 宏 | 实际位置 |<br>| <code>SEEK_SET</code> | 偏移量从<code>文件头</code>开始算 |<br>| <code>SEEK_CUR</code> | 偏移量从<code>当前文件指针ptr(上文介绍的)所在位置</code>开始算 |<br>| <code>SEEK_END</code> | 偏移量从<code>文件尾</code>开始算 |</p><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><ul><li>成功时,返回<code>0</code></li><li>失败时，返回<code>非零值</code>，同时，<strong>这条语句失效</strong>,上文说的<code>ptr</code>没有改变</li></ul><h2 id="fgetpos-和-fsetpos-设置-ptr"><a href="#fgetpos-和-fsetpos-设置-ptr" class="headerlink" title="fgetpos 和 fsetpos 设置 ptr"></a>fgetpos 和 fsetpos 设置 ptr</h2><p>可以用<code>fgetpos</code>获取<code>ptr</code>的当前位置，并使用<code>输出型参数</code>输出一个<code>fpos_t</code>类型的变量，而<code>fsetpos</code>可以用<code>fpos_t</code>类型的形参设置<code>ptr</code>的当前位置</p><p>就好比<code>ptr</code>是当前坐标，每次<code>fgetpos</code>得到一个传送点信息，而<code>fsetpos</code>就可以用这个传送点信息传送<code>ptr</code>过去</p><p><em>示例如下</em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//准备一个文件</span></span><br><span class="line">FILE* pfile = fopen(<span class="string">&quot;file.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);<span class="comment">//&quot;w&quot;模式打开文件file.txt</span></span><br><span class="line"><span class="type">int</span> code = <span class="number">1</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* msg = <span class="string">&quot;this is a msg&quot;</span>;</span><br><span class="line"><span class="built_in">fprintf</span>(pfile, <span class="string">&quot;get msg : %s code:%d&quot;</span>, msg, code);</span><br><span class="line">fclose(pfile);</span><br><span class="line"><span class="comment">//===========</span></span><br><span class="line"></span><br><span class="line"><span class="type">fpos_t</span> pos1,pos2;</span><br><span class="line">pfile = fopen(<span class="string">&quot;file.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"></span><br><span class="line">fgetpos(pfile, &amp;pos1);</span><br><span class="line">fgetc(pfile);</span><br><span class="line">fgetpos(pfile, &amp;pos2);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">fsetpos(pfile, &amp;pos2);<span class="comment">//循环令ptr指向第二个字符</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;第2个字符为: %c\n&quot;</span>, fgetc(pfile));</span><br><span class="line">&#125;                                                     </span><br><span class="line">fsetpos(pfile, &amp;pos1);<span class="comment">//令ptr指向第一个字符</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;第1个字符为: %c\n&quot;</span>, fgetc(pfile));</span><br><span class="line"></span><br><span class="line">fclose(pfile);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">第2个字符为: e</span><br><span class="line">第2个字符为: e</span><br><span class="line">第2个字符为: e</span><br><span class="line">第1个字符为: g</span><br></pre></td></tr></table></figure><h2 id="fclose-关闭文件流"><a href="#fclose-关闭文件流" class="headerlink" title="fclose 关闭文件流"></a>fclose 关闭文件流</h2><p>可以用<code>fclose</code>显式地关闭文件流</p><p>用法为<code>fclose(pFile);</code></p><p>进程正常退出时，也会自动关闭文件流</p><h2 id="fprintf-格式化输出字符串"><a href="#fprintf-格式化输出字符串" class="headerlink" title="fprintf 格式化输出字符串"></a>fprintf 格式化输出字符串</h2><p><code>fprintf</code>能格式化输出字符串到指定文件流，除了要<strong>指定</strong>文件流，格式化字符串的方式和<code>printf</code>一样</p><ul><li>且<code>fprintf(stdout,format,...)</code>和<code>printf(format,...)</code>效果一样</li></ul><h2 id="fputs-输出字符串"><a href="#fputs-输出字符串" class="headerlink" title="fputs 输出字符串"></a>fputs 输出字符串</h2><p><code>int fputs ( const char * str, FILE * stream );</code></p><p><code>fputs</code>能将<code>C语言</code>的字符串输入到指定文件流中</p><h2 id="fwrite-输出内存数据块"><a href="#fwrite-输出内存数据块" class="headerlink" title="fwrite 输出内存数据块"></a>fwrite 输出内存数据块</h2><p><code>size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);</code></p><ul><li><code>ptr</code>是指向<code>内存数据块</code>的指针</li><li><code>size</code>是每个<code>数组元素</code>的大小</li><li><code>nmemb</code>是元素数量</li><li><code>stream</code>是文件流</li></ul><p>fwrite可以向指定文件流输入特定大小的内存数据块</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">FILE* pfile = fopen(<span class="string">&quot;file.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);<span class="comment">//&quot;w&quot;模式打开文件file.txt</span></span><br><span class="line"><span class="type">char</span> msg[] = <span class="string">&quot;this is a msg&quot;</span>;</span><br><span class="line">fwrite(msg, <span class="keyword">sizeof</span>(<span class="type">char</span>), <span class="built_in">strlen</span>(msg), pfile);</span><br><span class="line"></span><br><span class="line">fclose(pfile);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="fscanf-格式化输入"><a href="#fscanf-格式化输入" class="headerlink" title="fscanf 格式化输入"></a>fscanf 格式化输入</h2><p><code>fscanf</code>能像<code>scanf</code>读取标准输入流一样,读取指定文件流</p><ul><li>且<code>scanf(stdin,format,...)</code>和<code>printf(format,...)</code>效果一样</li></ul><h2 id="fgets-获取一行"><a href="#fgets-获取一行" class="headerlink" title="fgets 获取一行"></a>fgets 获取一行</h2><p><code>char * fgets (char *str, int num, FILE *stream );</code></p><h3 id="行为"><a href="#行为" class="headerlink" title="行为"></a>行为</h3><p><code>fgets</code>会一直读取直到<code>换行符</code>或<code>EOF文件结尾</code>结束读取，但<code>换行符</code>作为<strong>非法</strong>字符不会被拷贝到形参<code>str</code>中</p><ul><li>字符串结尾的<code>\0</code>会被自动添加,且<strong>计算</strong>在读入的<strong>最大字符数</strong></li><li><code>fgets</code>和<code>gets</code>有很大差别，它需要<strong>指定</strong>最大的读入字符数</li></ul><h3 id="形参"><a href="#形参" class="headerlink" title="形参"></a>形参</h3><ul><li><code>str</code>为传入的字符数组作为缓冲区</li><li><code>num</code>为拷贝的最大字符数，<strong>包括</strong>自动添加的结尾<code>\0</code></li><li><code>stream</code>为指定的文件流</li></ul><h3 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h3><ul><li>成功时，返回<code>str</code>的值</li><li>失败时，返回<code>NULL</code></li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//准备一个文件</span></span><br><span class="line">FILE* pfile = fopen(<span class="string">&quot;file.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);<span class="comment">//&quot;w&quot;模式打开文件file.txt</span></span><br><span class="line"><span class="type">int</span> code = <span class="number">1</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* msg = <span class="string">&quot;this is a msg&quot;</span>;</span><br><span class="line"><span class="built_in">fprintf</span>(pfile, <span class="string">&quot;get msg : %s code:%d&quot;</span>, msg, code);</span><br><span class="line">fclose(pfile);</span><br><span class="line"><span class="comment">//=====</span></span><br><span class="line"></span><br><span class="line">pfile = fopen(<span class="string">&quot;file.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"><span class="type">char</span> str[<span class="number">5</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">fgets(str, <span class="keyword">sizeof</span>(str), pfile);<span class="comment">//除去自动添加的\0,最多从文件里读入4个字符</span></span><br><span class="line"><span class="built_in">printf</span>(str);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;|&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get |</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>=C++= sizeof关键字详解</title>
      <link href="/2024/07/10/cppsizeof/"/>
      <url>/2024/07/10/cppsizeof/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>sizeof</code>作为C&#x2F;C++关键字,基本用法是求<code>字节大小</code>，但仅仅这一项用法在细节上就有很多说法了</p><h2 id="求内置类型变量的大小"><a href="#求内置类型变量的大小" class="headerlink" title="求内置类型变量的大小"></a>求内置类型变量的大小</h2><p>有两种写法，以<code>int a = 0</code>的变量<code>a</code>为例</p><ul><li><code>sizeof a</code></li><li><code>sizeof(a)</code></li></ul><p>都可以求变量<code>a</code>的大小，但<strong>注意</strong>，该变量的大小仅与<code>变量类型</code>有关，而与值无关</p><h2 id="求内置类型的大小"><a href="#求内置类型的大小" class="headerlink" title="求内置类型的大小"></a>求内置类型的大小</h2><p>求类型大小时必须<strong>加上括号</strong></p><p>例如<code>sizeof(int)</code></p><h2 id="求数组的大小"><a href="#求数组的大小" class="headerlink" title="求数组的大小"></a>求数组的大小</h2><ul><li>当数组声明在<code>全局</code>或<code>sizeof</code>处于数组声明语句的<code>局部作用范围</code>时,能够用<code>sizeof(&lt;数组名&gt;)</code>求数组大小</li><li>当数组名经过<strong>函数传参</strong>或<code>加减常量运算</code>后，退化为<code>指针变量</code>,类型大小在<code>32位机器</code>中为<code>4</code>,<code>64位机器</code>中为<code>8</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> g_arr[<span class="number">10</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> st_arr[])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(st_arr) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//此处退化为指针变量，输出4或8</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> arr[<span class="number">10</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(g_arr) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//输出40</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(arr) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//输出40</span></span><br><span class="line">func(arr);<span class="comment">//输出4/8</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="求类-对象的大小"><a href="#求类-对象的大小" class="headerlink" title="求类&#x2F;对象的大小"></a>求类&#x2F;对象的大小</h2><h3 id="一般情况的内存对齐"><a href="#一般情况的内存对齐" class="headerlink" title="一般情况的内存对齐"></a>一般情况的内存对齐</h3><p>为了访问效率问题，类的大小遵循<code>内存对齐</code>规则，计算理论大小时需考虑<code>成员变量的大小</code>和<code>内存对齐</code>,而不考虑普通成员函数,这里不详细讨论</p><h2 id="含有虚函数"><a href="#含有虚函数" class="headerlink" title="含有虚函数"></a>含有虚函数</h2><p>C++的编译器一旦发现一个类型中<strong>有虚函数</strong>，就会为该类型生成<code>虚函数表</code>，每一个实例化出的<code>对象</code>都含有一个<code>指向虚函数表的指针</code>。所以<code>sizeof</code>求出来的值还要考虑<code>该指针</code>以及<code>内存对齐</code>等因素</p><h3 id="没有成员变量的特殊情况"><a href="#没有成员变量的特殊情况" class="headerlink" title="没有成员变量的特殊情况"></a>没有成员变量的特殊情况</h3><h4 id="没有成员函数"><a href="#没有成员函数" class="headerlink" title="没有成员函数"></a>没有成员函数</h4><p>这样的类型可以称为<code>空类型</code>,因为这样的类型实例化后不含任何信息,本来求<code>sizeof</code>应该是<code>O</code>，但考虑实际使用时，我们需将类<strong>实例化</strong>为对象，它必须在内存中占有一定的空间，否则无法使用或管理这些实例。至于分配内存，由编译器决定。但出于节省不必要的内存占用原则，理应分配最小内存单元，即<code>1字节</code>。正好在<code>VisualStudio</code>中，每个空类型的实例占用<code>1字节</code>的空间。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//空类型</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">sizeof</span>(A);<span class="comment">//visual studio 中值为1</span></span><br></pre></td></tr></table></figure><h4 id="只有普通的成员函数"><a href="#只有普通的成员函数" class="headerlink" title="只有普通的成员函数"></a>只有普通的成员函数</h4><p>和上一条一样也是<code>1字节</code>。因为考虑实例化时，调用这些普通成员函数只需知道<code>函数地址</code>即可，而这些函数地址只与用户自定义的<code>类</code>有关，而与实例化出来的<code>对象</code>无关，所以不会在<code>对象</code>中存储相关信息，不会改变其大小。</p><h4 id="含有虚函数-1"><a href="#含有虚函数-1" class="headerlink" title="含有虚函数"></a>含有虚函数</h4><p>实例化出的<code>对象</code>含有了指向虚函数的<code>指针</code>,所以<code>sizeof</code>求出来的大小为一个<code>指针</code>的大小，<code>32位机器</code>求得<code>4</code>字节,<code>64位机器</code>求得<code>8</code>字节</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>基础IO</title>
      <link href="/2024/07/10/basicIO/"/>
      <url>/2024/07/10/basicIO/</url>
      
        <content type="html"><![CDATA[<h1 id="共识原理"><a href="#共识原理" class="headerlink" title="共识原理"></a>共识原理</h1><ul><li>文件 &#x3D; 内容 + 属性</li><li>被打开的文件需要加载到内存中</li><li><strong>内存中</strong>的文件需要被操作系统<strong>管理</strong></li></ul><h1 id="用户级文件接口"><a href="#用户级文件接口" class="headerlink" title="用户级文件接口"></a>用户级文件接口</h1><p><a href="https://www.supdriver.top/2024/05/14/cpp-file-op/">详见C++文件操作</a></p><p><a href="https://www.supdriver.top/2024/07/15/cfileop/">详见C语言文件操作</a></p><h1 id="Linux系统调用接口"><a href="#Linux系统调用接口" class="headerlink" title="Linux系统调用接口"></a>Linux系统调用接口</h1><h2 id="fd-文件描述符-与访问文件的本质"><a href="#fd-文件描述符-与访问文件的本质" class="headerlink" title="fd 文件描述符 与访问文件的本质"></a>fd 文件描述符 与访问文件的本质</h2><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-24_17-10-26.png"></p><p><code>fd</code>(<em>file descriptor</em>),即文件描述符,下文的系统调用接口经常以<code>fd</code>命名变量，<code>fd</code>是整形变量，作为数组下标，用于管理<strong>打开的文件</strong></p><p>可以看到,一个进程通过<code>struct files _struct</code>里的指针数组，管理多个同时打开的文件</p><p>且每个进程启动时，会默认打开三个文件,且默认<code>fd</code>固定</p><ol><li>stdout</li></ol><h2 id="read"><a href="#read" class="headerlink" title="read"></a>read</h2><p><strong>所需头文件</strong><br><code>#include &lt;unistd.h&gt;</code><br><strong>声明</strong><br><code>ssize_t read(int fd, void *buf, size_t count);</code></p><p><strong>参数</strong></p><ul><li><code>fd</code>即为目标文件的文件描述符</li><li><code>buf</code>为要从文件读取字节到的内存地址</li><li><code>count</code>为最大读取字节数</li></ul><p><strong>返回值</strong></p><ul><li>若成功，返回读取文件的字节数,类型为<code>ssize_t</code>,是层层封装的<code>long int</code></li><li>若失败，返回<code>-1</code>,并设置<code>errno</code>的值</li></ul><h2 id="write"><a href="#write" class="headerlink" title="write"></a>write</h2><p><strong>所需头文件</strong><br><code>#include &lt;unistd.h&gt;</code><br><strong>声明</strong><br><code>ssize_t write(int fd, const void *buf, size_t count);</code></p><p><strong>参数</strong></p><ul><li><code>fd</code> 为目标文件的文件描述符</li><li><code>buf</code>为要写入文件的<code>源内存地址</code>,输入字节数量取决于<code>count</code>形参</li><li><code>count</code>为要输入的字节数量,若要输入为字符串，且要输入字符串的全部内容，建议使用<code>strlen(buf)</code>，防止输入<code>\0</code>,因为对于<strong>文件</strong>来说，<code>\0</code>是<strong>非法字符</strong></li></ul><p><strong>返回值</strong></p><ul><li>若成功，返回写入文件的字节数,类型为<code>ssize_t</code>,是层层封装的<code>long int</code></li><li>若失败，返回<code>-1</code>,并设置<code>errno</code>的值</li></ul><p><strong>特别的</strong><br><code>read</code>函数从文件中读取的是<code>字节</code>内容，不把读取的内容看作字符串，因此，<strong>不会自动</strong>添加<code>\0</code>在写入<code>buf</code>内容的结尾</p><p><em>用法见后文对<code>open</code>的介绍</em></p><h2 id="open"><a href="#open" class="headerlink" title="open"></a>open</h2><p><strong>所需头文件</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br></pre></td></tr></table></figure><p><strong>声明</strong><br><code>int open(const char *pathname, int flags);</code><br><code>int open(const char *pathname, int flags，mode_t mode);</code></p><p><strong>参数</strong>:</p><ul><li><code>pathname</code>为文件路径，若只有文件名，则默认在当前工作路径搜索</li><li><code>flag</code>则是一个<code>位图</code>,而<strong>不应</strong>看作整型参数，传参时可用<code>|</code>位运算传递多个参数到位图中,例如<code>O_CREAT | O_WRONLY</code></li><li><code>mode</code>则是在<strong>创建</strong>文件时,传入权限信息,这里使用<code>八进制表示法</code>，例如传入<code>0666</code><br><strong>返回值</strong>:</li><li>若成功，返回打开文件的<code>fd</code>值</li><li>若失败，则返回<code>-1</code></li></ul><h3 id="写入操作"><a href="#写入操作" class="headerlink" title="写入操作"></a>写入操作</h3><p>相关的<code>flags</code></p><ul><li><code>O_WRONLY</code> 仅写入</li><li><code>O_CREAT</code> 如果文件不存在，就创建，<strong>注</strong>新文件的权限由<code>open</code>函数传入的<code>mode</code>参数决定</li><li><code>O_TRUNC</code> 如果文件已存在且是<code>常规文件</code>,并且打开的模式组合<strong>支持写入操作</strong>(<code>O_RDWR</code>或<code>O_WRONLY</code>),该文件内容将会被清除。但如果该文件是<code>FIFO</code>(命名管道)文件或<code>终端设备文件</code>，则<code>O_TRUNC</code>将会被<strong>忽略</strong></li><li><code>O_EXCL</code> 保证此次<code>open</code>操作打开新文件。<strong>必须</strong>和<code>O_CREAT</code>联合使用，否则打开<strong>失败</strong>。若<code>pathname</code>存在，即该路径的文件存在时，也会打开<strong>失败</strong></li></ul><h4 id="打开已有文件并写入"><a href="#打开已有文件并写入" class="headerlink" title="打开已有文件并写入"></a>打开已有文件并写入</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//前提是log.txt已存在</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;log.txt&quot;</span>,O_WRONLY,<span class="number">0666</span>);<span class="comment">//只写模式打开文件</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span> msg[] = <span class="string">&quot;this is a msg&quot;</span>;<span class="comment">//准备字符串</span></span><br><span class="line">    write(fd,msg,<span class="built_in">strlen</span>(msg));<span class="comment">//写入</span></span><br><span class="line">    close(fd);<span class="comment">//关闭文件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当原本<code>log.txt</code>为空文件时</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this is a msg</span><br></pre></td></tr></table></figure><p>当原<code>log.txt</code>不为空且内容长度大于程序输入的<code>msg</code>时，发生<code>部分覆写</code></p><p>例如原内容为<code>0000111100001111</code>时，执行后为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this is a msg111</span><br></pre></td></tr></table></figure><p>可以看到有一部分没有被覆盖</p><h4 id="打开空文件-或-创建空文件"><a href="#打开空文件-或-创建空文件" class="headerlink" title="打开空文件 或 创建空文件"></a>打开空文件 或 创建空文件</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//唯一的区别是这里的参数</span></span><br><span class="line">    <span class="comment">//O_CREAT可以创建空文件</span></span><br><span class="line">    <span class="comment">//O_TRUNC保证打开已有文件时，清空原文内容</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;log.txt&quot;</span>,O_CREAT|O_WRONLY|O_TRUNC,<span class="number">0666</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span> msg[] = <span class="string">&quot;this is a msg&quot;</span>;</span><br><span class="line">    write(fd,msg,<span class="built_in">strlen</span>(msg));</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="追加写入"><a href="#追加写入" class="headerlink" title="追加写入"></a>追加写入</h4><p>追加写入只需把<code>O_TRUNC</code>改成<code>O_APPEND</code>即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;log.txt&quot;</span>,O_CREAT|O_WRONLY|O_APPEND,<span class="number">0666</span>);<span class="comment">//追加模式打开文化</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span> msg[] = <span class="string">&quot;this is a msg&quot;</span>;</span><br><span class="line">    write(fd,msg,<span class="built_in">strlen</span>(msg));</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们事先删除<code>log.txt</code>文件，然后运行两次编译出的程序,可以获得如下内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this is a msgthis is a msg</span><br></pre></td></tr></table></figure><p>可以看到内容追加了两次</p><h3 id="读取操作"><a href="#读取操作" class="headerlink" title="读取操作"></a>读取操作</h3><p>相关的<code>flags</code></p><ul><li><code>O_RDONLY</code>只读模式打开文件</li><li><code>O_RDWR</code> 读写模式打开文件</li></ul><h4 id="只读模式读取内容"><a href="#只读模式读取内容" class="headerlink" title="只读模式读取内容"></a>只读模式读取内容</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;log.txt&quot;</span>,O_RDONLY);</span><br><span class="line">    <span class="type">char</span>* buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">ssize_t</span> n = read(fd,buf,<span class="keyword">sizeof</span>(buf)<span class="number">-1</span>);<span class="comment">//这里要储存字符串，所以要留一位给\0</span></span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">0</span>) perror(<span class="string">&quot;read&quot;</span>);<span class="comment">//打开失败，输出错误信息</span></span><br><span class="line">    <span class="keyword">else</span> buf[n] = <span class="string">&#x27;\0&#x27;</span>;<span class="comment">//添加结尾</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,buf);<span class="comment">//打印读取到的内容</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现准备内容为<code>123456</code>的<code>log.txt</code>文件</p><p>然后运行<code>./mycmd</code></p><p>得到输出和文件内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">456</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zzz456</span><br></pre></td></tr></table></figure><p>关于<code>read</code>没读取到前面新写入的<code>zzz</code>,是因为<code>wtrite</code>和<code>read</code>操作都是从文件的<code>同一处继续</code>操作的，并不会发生回退</p><h2 id="close"><a href="#close" class="headerlink" title="close"></a>close</h2><p><code>int close(int fd);</code></p><p>用于冲刷缓冲区，并<strong>关闭</strong>一个文件描述符</p><h2 id="dup2-文件重定向"><a href="#dup2-文件重定向" class="headerlink" title="dup2 文件重定向"></a>dup2 文件重定向</h2><p><code>int dup2(int oldfd, int newfd);</code></p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-24_19-55-30.png"></p><p>如图所示，<code>dup2</code>能将<code>oldfd</code>对应的数组元素<code>覆盖</code>到<code>newfd</code>对应的数组元素处，完成对<code>newfd</code>对应文件的重定向</p><p>图中就是完成了对<code>标准输出</code>的重定向,像<code>printf</code>之类的函数会直接输出内容到文件中,而不是显示器</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;log.txt&quot;</span>,O_RDWR|O_CREAT|O_TRUNC,<span class="number">0666</span>);<span class="comment">//打开一个新的空文件</span></span><br><span class="line">    dup2(fd,<span class="number">1</span>);<span class="comment">//标准输出重定向</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;output1\n&quot;</span>);<span class="comment">//输出</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;output2\n&quot;</span>);<span class="comment">//输出</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行代码后，可以看到<code>终端</code><strong>没有输出</strong></p><p>而打开<code>log.txt</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">output1</span><br><span class="line">output2</span><br></pre></td></tr></table></figure><h1 id="子进程-与-父进程的文件关系"><a href="#子进程-与-父进程的文件关系" class="headerlink" title="子进程 与 父进程的文件关系"></a>子进程 与 父进程的文件关系</h1><h2 id="子进程对父进程的拷贝"><a href="#子进程对父进程的拷贝" class="headerlink" title="子进程对父进程的拷贝"></a>子进程对父进程的拷贝</h2><p>先运行一段代码测试 子进程是否<strong>继承</strong>父进程的打开文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;log.txt&quot;</span>,O_RDWR|O_CREAT|O_TRUNC|O_APPEND);<span class="comment">//追加模式打开一个新文件</span></span><br><span class="line">    dup2(fd,<span class="number">1</span>);<span class="comment">//在fork前就打开文件</span></span><br><span class="line"></span><br><span class="line">    <span class="type">pid_t</span> id = fork();<span class="comment">//创建子进程</span></span><br><span class="line">    <span class="keyword">if</span>(id == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child output\n&quot;</span>);<span class="comment">//子进程输出到文件</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        waitpid(id,<span class="number">0</span>,<span class="number">0</span>);<span class="comment">//阻塞等待子进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent output\n&quot;</span>);<span class="comment">//父进程输出</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码中，我们在<code>fork</code><strong>之前</strong>完成了对标准输出的<strong>重定向</strong>,然后<code>fork</code>之后令父进程和子进程进行不同的标准输出</p><p>运行结果为父进程和子进程的<code>标准输出</code>都<strong>重定向</strong>到了文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">child output</span><br><span class="line">parent output</span><br></pre></td></tr></table></figure><h2 id="子进程和父进程的-独立性"><a href="#子进程和父进程的-独立性" class="headerlink" title="子进程和父进程的 独立性"></a>子进程和父进程的 独立性</h2><p>接下来一段代码测试 父进程 和 子进程 的打开文件是否独立</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;log.txt&quot;</span>,O_RDWR|O_CREAT|O_TRUNC|O_APPEND);<span class="comment">//追加模式打开一个新文件</span></span><br><span class="line"></span><br><span class="line">    <span class="type">pid_t</span> id = fork();<span class="comment">//创建子进程</span></span><br><span class="line">    <span class="keyword">if</span>(id == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        dup2(fd,<span class="number">1</span>);<span class="comment">//只有子进程重定向了标准输出</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child output\n&quot;</span>);<span class="comment">//子进程输出到文件</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        waitpid(id,<span class="number">0</span>,<span class="number">0</span>);<span class="comment">//阻塞等待子进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent output\n&quot;</span>);<span class="comment">//父进程输出</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们在<code>fork</code>之前都不进行重定向，<code>fork</code>后仅对子进程进行了标准输出重定向，而父进程不作任何重定向</p><p>在运行后发现子进程的输出重定向不会影响父进程,二者有<code>独立性</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parent output</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">child output</span><br></pre></td></tr></table></figure><h1 id="进程替换"><a href="#进程替换" class="headerlink" title="进程替换"></a>进程替换</h1><p>先在同级文件夹准备一个待替换的程序</p><blockquote><p>execute.c</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;exe output\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后运行<code>gcc -o execute execute.c</code>编译获得一个程序</p><p>然后准备主程序</p><blockquote><p>mycmd.c</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;log.txt&quot;</span>,O_RDWR|O_CREAT|O_TRUNC|O_APPEND);<span class="comment">//追加模式打开一个新文件</span></span><br><span class="line"></span><br><span class="line">    <span class="type">pid_t</span> id = fork();<span class="comment">//创建子进程</span></span><br><span class="line">    <span class="keyword">if</span>(id == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        dup2(fd,<span class="number">1</span>);<span class="comment">//只有子进程重定向了标准输出</span></span><br><span class="line">        execvp(<span class="string">&quot;./execute&quot;</span>,<span class="literal">NULL</span>);<span class="comment">//进程替换</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        waitpid(id,<span class="number">0</span>,<span class="number">0</span>);<span class="comment">//阻塞等待子进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent wait success\n&quot;</span>);<span class="comment">//父进程输出</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们使子进程<strong>先</strong>标准输出重定向， <strong>再</strong>进行进程替换，发现替换后的进程，也是标准输出重定向的状态</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exe output</span><br></pre></td></tr></table></figure><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>进程替换<strong>不会</strong>改变原进程的文件打开状态和重定向关系</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识动静态库</title>
      <link href="/2024/07/08/libs/"/>
      <url>/2024/07/08/libs/</url>
      
        <content type="html"><![CDATA[<h1 id="静态库-a"><a href="#静态库-a" class="headerlink" title="静态库(.a)"></a>静态库(.a)</h1><p>程序在<strong>编译链接</strong>的时候把库的代码链接到可执行文件中。编译出的程序<strong>运行时不再需要</strong>静态库</p><h2 id="生成和使用静态库"><a href="#生成和使用静态库" class="headerlink" title="生成和使用静态库"></a>生成和使用静态库</h2><p>这里使用<code>gcc</code>编译获得<code>.o</code>链接文件，再用<code>gnu</code>归档工具中的<code>ar</code>指令配合<code>-rc</code>选项(replace and create)封装库文件,最后借助<code>makefile</code>简化文件目录的封装操作</p><p>使用第三方库时,还可以使用<code>ar -tv</code>查看库中的目录列表</p><ul><li>t:列出静态库中的文件</li><li>v:verbose 详细信息</li></ul><p>使用静态库：</p><p><code>gcc</code>编译时使用第三方静态库必须包含以下选项：</p><ul><li><code>-I</code>指定头文件目录</li><li><code>-L</code>指定库路径</li><li><code>-l</code>指定库名（不加空格）,库名要把<code>文件名</code>前面去掉<code>lib</code>,后面去掉<code>.a</code>才是真正的库名</li></ul><p>否则编译器不知道头文件在哪，或者不知道链接哪个库</p><h3 id="库搜索路径"><a href="#库搜索路径" class="headerlink" title="库搜索路径"></a>库搜索路径</h3><p>库的搜索会按照一定的顺序</p><ol><li>从左到右搜索-L指定的目录。</li><li>由环境变量指定的目录 （<code>LIBRARY_PATH</code>）</li><li>由系统指定的目录<ul><li><code>/usr/lib</code></li><li><code>/usr/local/lib</code></li></ul></li></ol><h3 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h3><p>测试程序（共<code>5</code>个文件）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/////////////add.h/////////////////</span></span><br><span class="line"> <span class="meta">#<span class="keyword">ifndef</span> __ADD_H__</span></span><br><span class="line"> <span class="meta">#<span class="keyword">define</span> __ADD_H__ </span></span><br><span class="line"> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>; </span><br><span class="line"> <span class="meta">#<span class="keyword">endif</span> <span class="comment">// __ADD_H__</span></span></span><br><span class="line"> <span class="comment">/////////////add.c/////////////////</span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;add.h&quot;</span></span></span><br><span class="line"> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line"> &#123;</span><br><span class="line"> <span class="keyword">return</span> a + b;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/////////////sub.h/////////////////</span></span><br><span class="line"> <span class="meta">#<span class="keyword">ifndef</span> __SUB_H__</span></span><br><span class="line"> <span class="meta">#<span class="keyword">define</span> __SUB_H__ </span></span><br><span class="line"> <span class="type">int</span> <span class="title function_">sub</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>; </span><br><span class="line"> <span class="meta">#<span class="keyword">endif</span> <span class="comment">// __SUB_H__</span></span></span><br><span class="line"> <span class="comment">/////////////add.c/////////////////</span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;add.h&quot;</span></span></span><br><span class="line"> <span class="type">int</span> <span class="title function_">sub</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line"> &#123;</span><br><span class="line"> <span class="keyword">return</span> a - b;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">///////////main.c////////////////</span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;add.h&quot;</span></span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sub.h&quot;</span></span></span><br><span class="line"> </span><br><span class="line"> <span class="type">int</span> <span class="title function_">main</span><span class="params">( <span class="type">void</span> )</span></span><br><span class="line"> &#123;</span><br><span class="line"> <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"> <span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;add(10, 20)=%d\n&quot;</span>, a, b, add(a, b));</span><br><span class="line"> a = <span class="number">100</span>;</span><br><span class="line"> b = <span class="number">20</span>;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;sub(%d,%d)=%d\n&quot;</span>, a, b, sub(a, b));</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后我们编写<code>makefile</code>文件</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">lib = libmymath.a</span><br><span class="line"></span><br><span class="line"><span class="variable">$(lib)</span>:add.o sub.o </span><br><span class="line">ar -rc <span class="variable">$@</span> add.o sub.o </span><br><span class="line"></span><br><span class="line"><span class="section">add.o:add.c </span></span><br><span class="line">gcc -c add.c -o add.o</span><br><span class="line"></span><br><span class="line"><span class="section">sub.o:sub.c</span></span><br><span class="line">gcc -c sub.c -o sub.o</span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>:clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm -f *.o *.a </span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>:output </span></span><br><span class="line"><span class="section">output:</span></span><br><span class="line">mkdir -p lib/<span class="keyword">include</span></span><br><span class="line">mkdir -p lib/mymathlib</span><br><span class="line">cp *.h lib/<span class="keyword">include</span></span><br><span class="line">cp *.a lib/mymathlib</span><br></pre></td></tr></table></figure><p><code>lib</code>作为<code>makefile</code>中的变量，储存了<code>库名</code>，默认的<code>make</code>指令用于打包库文件,其依赖的<code>add.o</code>和<code>sub.o</code>会自动调用后两句编译产生。</p><p><code>make output</code>指令自动准备好目录并拷贝头文件和静态库</p><p>然后编译产生可执行程序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc main.c -o mycmd -I ./lib/include -L ./lib/mymathlib -lmymath</span><br></pre></td></tr></table></figure><p>注意,使用第三方库时<code>-I</code>,<code>-L</code>和<code>-l</code>缺一不可</p><p>但如果安装了第三方库时，即将<code>库文件/库文件的软链接</code>拷贝至<code>/lib64/</code>，将<code>头文件/头文件的软链接</code>拷贝至<code>/usr/inlude/</code>，使<code>gcc</code>能够自动搜索到路径，则编译时只需用<code>-l</code>指定<code>库名</code>即可</p><h1 id="动态库-so"><a href="#动态库-so" class="headerlink" title="动态库(.so)"></a>动态库(.so)</h1><p>动态库的作用是使程序在<strong>运行时</strong>才去链接动态库的代码，多个程序共享使用库的代码，从而使编译出的可执行文件更小，节省磁盘空间。使用动态库时，动态库也要<strong>加载到内存中</strong></p><h2 id="使用动态库底层的过程"><a href="#使用动态库底层的过程" class="headerlink" title="使用动态库底层的过程"></a>使用动态库底层的过程</h2><ol><li>使用动态库编译可执行程序：一个与动态库链接的可执行文件仅仅包含它用到的函数入口地址的一个表，而不是外部函数所在目标文件的整个机器码</li><li>动态链接: 在可执行文件开始运行以前，外部函数的机器码由操作系统从磁盘上的该动态库中复制(加载)到内存中，这个过程称为<code>动态链接</code>（dynamic linking）</li><li>运行时调用动态库：调用来自动态库的函数时，实现函数功能的机器码将由动态库提供</li></ol><h2 id="生成和使用动态库"><a href="#生成和使用动态库" class="headerlink" title="生成和使用动态库"></a>生成和使用动态库</h2><p>这里使用<code>gcc</code>加<code>-fPIC</code>(产生位置无关码position independent code)和<code>-c</code>编译获得<code>.o</code>链接文件，再用<code>gcc</code>指令配合封装库文件,最后借助<code>makefile</code>简化文件目录的封装操作</p><p>使用动态库：</p><p><code>gcc</code>编译时使用第三方静态库必须包含以下选项：</p><ul><li><code>-I</code>指定头文件目录</li><li><code>-L</code>指定库路径</li><li><code>-l</code>指定库名（不加空格）,库名要把<code>文件名</code>前面去掉<code>lib</code>,后面去掉<code>.a</code>才是真正的库名</li></ul><p>否则编译器不知道头文件在哪，或者不知道链接哪个库</p><p>特别的，当动静态库同时存在时，<code>gcc</code>默认优先使用动态库，除非加<code>-static</code>参数</p><p><strong>但是</strong>，仅仅编译出可执行文件还不够，因为可执行文件还<strong>找不到</strong>动态库,所以我们还得告诉系统中的<code>加载器</code>，我们的动态库在哪,所以我们要把动态库安装到<code>/lib64/</code>,拷贝文件或建立软连接都可以（需要<code>sudo</code>或<code>root</code>权限）</p><p>亦或者修改环境变量<code>LD_LIBRARY_PATH</code></p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>文件代码同上，这里展示<code>makefile</code>文件</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">lib = mymathlib.a</span><br><span class="line"></span><br><span class="line"><span class="variable">$(lib)</span>:add.o sub.o </span><br><span class="line">gcc -shared -o libmymath.so *.o </span><br><span class="line"></span><br><span class="line"><span class="section">add.o:add.c </span></span><br><span class="line">gcc -fPIC -c add.c -o add.o </span><br><span class="line"></span><br><span class="line"><span class="section">sub.o:sub.c</span></span><br><span class="line">gcc -fPIC -c sub.c -o sub.o</span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>:clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm -f *.o *.a </span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>:output </span></span><br><span class="line"><span class="section">output:</span></span><br><span class="line">mkdir -p lib/<span class="keyword">include</span></span><br><span class="line">mkdir -p lib/mymathlib</span><br><span class="line">cp *.h lib/<span class="keyword">include</span></span><br><span class="line">cp *.so lib/mymathlib</span><br></pre></td></tr></table></figure><h3 id="库搜索路径-1"><a href="#库搜索路径-1" class="headerlink" title="库搜索路径"></a>库搜索路径</h3><p>库的搜索会按照一定的顺序</p><ol><li>从左到右搜索-L指定的目录。</li><li>由环境变量指定的目录 （<code>LIBRARY_PATH</code>）</li><li>由系统指定的目录<ul><li><code>/usr/lib</code></li><li><code>/usr/local/lib</code></li></ul></li></ol><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>库文件命名规则<code>libxxx.a</code>&#x2F;<code>libxxx.so</code></p><p>库文件名称-&gt;库名：去掉前缀<code>lib</code>,去掉后缀<code>.so</code>&#x2F;<code>.a</code></p><p>使用动态库的可执行程序需要<code>安装动态库</code>或修改环境变量<code>LD_LIBRARY_PATH</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> 动态库 静态库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>fork子进程,进程退出与等待</title>
      <link href="/2024/07/07/fork/"/>
      <url>/2024/07/07/fork/</url>
      
        <content type="html"><![CDATA[<h1 id="认识fork"><a href="#认识fork" class="headerlink" title="认识fork()"></a>认识<code>fork()</code></h1><p>头文件<code>&lt;unistd.h&gt;</code>提供的<code>fork()</code>函数用于从已有的<code>原进程</code>创建一个新的<code>子进程</code>，而原进程在关系式称为<code>父进程</code></p><h2 id="fork-的返回值"><a href="#fork-的返回值" class="headerlink" title="fork()的返回值"></a>fork()的返回值</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> id = fork();</span><br></pre></td></tr></table></figure><p>父子进程中<code>fork()</code>函数的返回值(此处用变量<code>id</code>储存)是不同的:</p><p><strong>父进程</strong>里<code>id</code>的值为子进程的<code>PID</code>,其值<code>&gt;0</code>;<strong>子进程</strong>里<code>id</code>值固定为<code>0</code></p><ul><li><code>id &gt; 0</code> 父进程</li><li><code>id == 0</code> 子进程</li><li><code>id &lt; 0</code> fork()失败</li></ul><h2 id="分流"><a href="#分流" class="headerlink" title="分流"></a>分流</h2><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-09_13-00-38.png"></p><p>利用父子进程中<code>fork()</code>返回值的不同，可以用<code>if...else...</code>进行分流，让父子进程执行不同的代码</p><h2 id="fork-的过程"><a href="#fork-的过程" class="headerlink" title="fork()的过程"></a>fork()的过程</h2><p>进程调用<code>fork</code>，当控制转移到<strong>内核</strong>中的fork代码后，<strong>内核</strong>做</p><ul><li>分配<strong>新的</strong>内存块和内核数据结构给子进程</li><li>将父进程部分数据结构内容<strong>拷贝</strong>至子进程</li><li>添加子进程到<strong>系统进程列表</strong>当中</li><li><code>fork</code>返回，开始调度器调度</li></ul><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-09_18-54-41.png"></p><p>当一个进程调用fork之后，就有一对二进制<strong>代码相同</strong>的父子进程。而且它们都运行到相同的地方。但每个进程都可以<strong>独立</strong>地继续运行代码,并按代码分流至不同的代码段</p><p>但这两个进程谁先执行<strong>完全</strong>由调度器决定，而谁先结束，则由实际执行情况和调度器决定</p><h2 id="拷贝的过程-与-写时拷贝"><a href="#拷贝的过程-与-写时拷贝" class="headerlink" title="拷贝的过程 与 写时拷贝"></a>拷贝的过程 与 写时拷贝</h2><p><code>fork</code>时，子进程会将父进程虚拟内存的内容都复制一份在自己的虚拟内存中,但通过页表，二者映射到了同一块物理内存的区域，这样在二者都<strong>没有写入行为</strong>时，减少了物理内存中<strong>冗余</strong>的拷贝行为，有效提高了运行效率</p><p>但当父子进程中有一方发生写入行为时，就会触发<code>写时拷贝</code>，此时物理内存中发生拷贝行为，但只拷贝进程映射的<code>数据段</code>，而由于<strong>不发生进程替换时</strong>父子进程的代码段一定相同，物理内存中,<code>代码段</code>映射部分并不发生拷贝</p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-09_19-38-58.png"></p><h1 id="进程退出"><a href="#进程退出" class="headerlink" title="进程退出"></a>进程退出</h1><h2 id="进程退出的场景"><a href="#进程退出的场景" class="headerlink" title="进程退出的场景"></a>进程退出的场景</h2><ul><li>代码运行完毕，结果正确</li><li>代码运行完毕，结果不正确</li><li>代码异常终止</li></ul><h2 id="进程常见退出方法"><a href="#进程常见退出方法" class="headerlink" title="进程常见退出方法"></a>进程常见退出方法</h2><ul><li><code>main</code>函数返回</li><li><code>exit</code>退出</li><li><code>_exit</code>退出</li></ul><p><strong>异常退出</strong>: <code>ctrl</code> + <code>c</code></p><h2 id="查看退出码"><a href="#查看退出码" class="headerlink" title="查看退出码"></a>查看退出码</h2><p>在终端使用命令<code>echo $?</code>可以查看退出码</p><p><code>注</code>尽管子进程返回的是<code>int</code>,父进程只取退出码的最低<code>8位</code>,所以以下三种情况</p><ul><li><code>main</code>函数返回<code>-1</code></li><li><code>exit(-1)</code></li><li><code>_exit(-1)</code></li></ul><p>在终端输<code>echo $?</code>可得退出码<code>255</code></p><h2 id="exit-和-eixt-辨析"><a href="#exit-和-eixt-辨析" class="headerlink" title="exit 和 _eixt 辨析"></a><code>exit</code> 和 <code>_eixt</code> 辨析</h2><p><code>main</code>函数返回就不惜说了，来辨析一下头文件<code>&lt;stdlib.h&gt;</code>提供的<code>exit</code>和<code>_exit</code>函数</p><h3 id="exit"><a href="#exit" class="headerlink" title="_exit()"></a><code>_exit()</code></h3><p><code>_exit</code>会<strong>直接终止</strong>进程并返回状态码,而<strong>不会</strong>执行用户定义的清理函数，<strong>也不会</strong>清理缓冲区</p><h3 id="exit-1"><a href="#exit-1" class="headerlink" title="exit()"></a><code>exit()</code></h3><p><code>exit</code>实际上最后也会调用<code>_exit</code>,但它会先执行一系列善后工作,顺序如下:</p><ol><li>执行用户通过 atexit或on_exit定义的<strong>清理函数</strong>。</li><li>关闭所有打开的流，所有的<strong>缓存数据</strong>均被写入</li><li>调用<code>_exit</code></li></ol><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-09_22-10-26.png"></p><p><code>return</code>退出： 执行<code>return n</code>等同于执行<code>exit(n)</code></p><h1 id="进程等待"><a href="#进程等待" class="headerlink" title="进程等待"></a>进程等待</h1><h2 id="进程等待的必要性"><a href="#进程等待的必要性" class="headerlink" title="进程等待的必要性"></a>进程等待的必要性</h2><ul><li>子进程退出后需要父进程来<strong>回收</strong>僵尸进程,防止产生其引发内存泄漏等问题</li><li>僵尸进程难以处理,<code>kill -9</code>也清理不掉</li><li>父进程通过进程等待的方式，<strong>回收</strong>子进程资源，获取子进程<strong>退出信息</strong></li></ul><h2 id="进程等待的方法"><a href="#进程等待的方法" class="headerlink" title="进程等待的方法"></a>进程等待的方法</h2><h3 id="wait方法"><a href="#wait方法" class="headerlink" title="wait方法"></a><code>wait</code>方法</h3><blockquote><p>#include&lt;sys&#x2F;types.h&gt;<br>#include&lt;sys&#x2F;wait.h&gt;</p><p>pid_t wait(int*status);</p><p><code>参数</code>：显然<code>status</code>是输出型参数,获取子进程的<code>退出状态</code>,若不关心，可传参<code>NULL</code></p><p><code>返回值</code>: 若<strong>成功</strong>，则返回被等待进程的<code>pid</code>,若<strong>失败</strong>，则返回<code>-1</code></p></blockquote><h3 id="waitpid方法"><a href="#waitpid方法" class="headerlink" title="waitpid方法"></a><code>waitpid</code>方法</h3><blockquote><p>返回值：<br>   当正常返回的时候waitpid返回收集到的子进程的进程ID；<br>   如果设置了选项WNOHANG,而调用中waitpid发现没有已退出的子进程可收集,则返回0；<br>   如果调用中出错,则返回-1,这时errno会被设置成相应的值以指示错误所在；</p><p>参数：<br>   <code>pid</code>：<br>       <code>pid == -1</code>,等待任一个子进程。与wait等效。<br>       <code>pid &gt; 0</code>.等待其进程ID与pid相等的子进程。<br>   <code>status</code>:<br>       输出型参数传参<code>&amp;status</code>: 将子进程的<code>状态码</code>存入<code>status</code><br>       以下两个宏函数用于处理<code>状态码</code>:<br>       <code>WIFEXITED(status)</code>: 若为<strong>正常终止</strong>子进程返回的状态，则为真。（查看进程是否是<strong>正常退出</strong>）<br>       <code>WEXITSTATUS(status)</code>: 若WIFEXITED非零，提取子进程<code>退出码</code>。（查看进程的<code>退出码</code>）<br>   <code>options</code>:<br>       <code>WNOHANG</code>: 若pid指定的子进程没有结束，则waitpid()函数返回0，不予以等待。若正常结束，则返回该子进程的ID。<br>       <code>0</code>: 阻塞等待指定<code>pid</code>的进程</p></blockquote><h4 id="阻塞等待"><a href="#阻塞等待" class="headerlink" title="阻塞等待"></a>阻塞等待</h4><p><code>option</code> &#x3D;&#x3D; <code>0</code>时<code>waitpid</code>采用阻塞等待，父进程会阻塞等待到子进程退出</p><p><em>示例代码</em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    <span class="type">pid_t</span> id = fork();</span><br><span class="line">    <span class="keyword">if</span>(id == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child running [%d]s\n&quot;</span>,i);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child exited\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        waitpid(id,&amp;status,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(WIFEXITED(status))</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;father wait success, exit code: %d\n&quot;</span>,WEXITSTATUS(status));</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child failed to exit\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="非阻塞轮询"><a href="#非阻塞轮询" class="headerlink" title="非阻塞轮询"></a>非阻塞轮询</h4><p><code>option</code> &#x3D;&#x3D; <code>WNOHANG</code>时,<code>waitpid</code>采用非阻塞等待,若等不到子进程退出，就会继续执行后面的代码，所以一般加上<code>while</code>等循环用于轮询，二者共同构成<code>非阻塞轮询</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//非阻塞轮询</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    <span class="type">pid_t</span> id = fork();</span><br><span class="line">    <span class="keyword">if</span>(id == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sleep(<span class="number">5</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child exited\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)<span class="comment">//轮询</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">pid_t</span> rid = waitpid(id,&amp;status,WNOHANG);</span><br><span class="line">            <span class="keyword">if</span>(rid &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(WIFEXITED(status))</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;father wait success, exit code: %d\n&quot;</span>,WEXITSTATUS(status));</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;child failed to exit\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(rid == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;等待子进程中...\n&quot;</span>);</span><br><span class="line">                sleep(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span><span class="comment">//rid&lt;0</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;wait failed\n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> fork Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>环境变量</title>
      <link href="/2024/07/06/evn/"/>
      <url>/2024/07/06/evn/</url>
      
        <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><ul><li>环境变量(environment variables)一般是指在操作系统中用来指定操作系统运行环境的一些<strong>参数</strong></li><li>环境变量通常具有某些特殊用途，还有在系统当中通常具有<strong>全局特性</strong></li></ul><p><strong>构成</strong>：环境变量是一系列<code>字符串</code>的统称,所以一个环境变量由<code>变量名</code>和<code>值</code>构成</p><p>这么说还是太抽象了，我们接下来会举几个具体样例，体会<code>环境变量</code>在获取系统全局的变量，系统指令路径等方面的作用</p><h2 id="常见环境变量"><a href="#常见环境变量" class="headerlink" title="常见环境变量"></a>常见环境变量</h2><table><thead><tr><th>变量名</th><th>功能</th></tr></thead><tbody><tr><td><code>PATH</code></td><td>指定命令的搜索路径</td></tr><tr><td><code>HOME</code></td><td>指定用户的主工作目录(即用户登陆到Linux系统中时,默认的目录)</td></tr><tr><td><code>USER</code></td><td>当前用户名</td></tr><tr><td><code>SHELL</code></td><td>当前Shell,它的值通常是<code>/bin/bash</code></td></tr><tr><td><code>PWD</code></td><td>当前工作目录</td></tr></tbody></table><h1 id="操作系统变量"><a href="#操作系统变量" class="headerlink" title="操作系统变量"></a>操作系统变量</h1><h2 id="查看环境变量"><a href="#查看环境变量" class="headerlink" title="查看环境变量"></a>查看环境变量</h2><p><code>echo $NAME</code> <em>NAME为变量名</em></p><p>以<code>PATH</code>为例,查看<code>PATH</code>的值的指令为</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $PATH</span><br></pre></td></tr></table></figure><p><a href="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-08_12-46-35.png">https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-08_12-46-35.png</a></p><p>可以看到<code>PATH</code>的内容为多个文件路径，互相以<code>:</code>分隔</p><p>而若要查看当前的全部环境变量,可以使用<code>env</code>指令,将当前所有环境变量打印在终端上</p><p>也可以通过<code>管道</code>和<code>grep</code>将<code>env</code>的输出内容过滤</p><p><em>查看PATH</em></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">env | grep PATH</span><br></pre></td></tr></table></figure><p>同时还有个<code>set</code> 指令可以显示本地定义的shell变量和环境变量环境变量的组织方式 </p><h2 id="获取进程的环境变量"><a href="#获取进程的环境变量" class="headerlink" title="获取进程的环境变量"></a>获取进程的环境变量</h2><ul><li>在程序中，可以使用<code>getenv()</code>接口获取对应<code>环境变量名</code>的对应环境变量值</li></ul><p><em><code>getenv</code>在<code>&lt;stdlib.h&gt;</code>中</em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PATH: %s\n&quot;</span>,getenv(<span class="string">&quot;PATH&quot;</span>));<span class="comment">//打印PATH的值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="环境变量的组织方式"><a href="#环境变量的组织方式" class="headerlink" title="环境变量的组织方式"></a>环境变量的组织方式</h2><p>每个<code>进程</code>都有自己的<code>环境表</code>,所谓<code>环境表</code>就是一个<strong>字符</strong><code>指针数组</code>,每个不为<code>NULL</code>的指针指向<code>环境字符串</code></p><p><a href="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-08_20-52-19.png">https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-08_20-52-19.png</a></p><ul><li>因此也可以使用<code>main</code>函数传参来打印所有环境变量的内容<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[],con <span class="type">char</span>* env[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span>* str;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(str =env[i++]) <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,str);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="导入环境变量"><a href="#导入环境变量" class="headerlink" title="导入环境变量"></a>导入环境变量</h2><p>头文件<code>unistd.h&gt;</code>提供了一个全局变量<code>environ</code>,因此可以用<code>extern</code>导入环境变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> **environ;<span class="comment">//导入换进变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* str;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(str =environ[i++]) <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,str);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="添加新的环境变量"><a href="#添加新的环境变量" class="headerlink" title="添加新的环境变量"></a>添加新的环境变量</h2><p>使用<code>export</code>命令可以添加新的环境变量</p><p>使用方法:<code>export``=``(变量值)</code></p><p>例如添加一个值为<code>supdriver666</code>,名为<code>MY_VALUE</code>的环境变量,最后查看该变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export MY_VALUE=supdriver666</span><br><span class="line"></span><br><span class="line">env | grep MY_VALUE</span><br></pre></td></tr></table></figure><h2 id="程序内设置换进变量"><a href="#程序内设置换进变量" class="headerlink" title="程序内设置换进变量"></a>程序内设置换进变量</h2><p>使用<code>&lt;stdlib.h&gt;</code>提供的<code>putenv()</code>接口可以设置环境变量，用法与<code>export</code>指令相同</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    putenv(<span class="string">&quot;MY_VALUE=666&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;MY_VALUE = %s&quot;</span>,getenv(<span class="string">&quot;MY_VALUE&quot;</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除环境变量"><a href="#删除环境变量" class="headerlink" title="删除环境变量"></a>删除环境变量</h2><p>使用<code>unset</code>可以删除环境变量</p><p><em>删除上文的<code>MY_VALUE</code></em></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">unset MY_VALUE</span><br><span class="line"></span><br><span class="line">env | grep MY_VALUE</span><br></pre></td></tr></table></figure><p>可以看到没有输出了 </p><h2 id="添加本地shell变量-和-查看本地变量与环境变量"><a href="#添加本地shell变量-和-查看本地变量与环境变量" class="headerlink" title="添加本地shell变量 和 查看本地变量与环境变量"></a>添加本地shell变量 和 查看本地变量与环境变量</h2><p>添加本地变量: 直接输入<code>(变量名)``=``(值)</code>  &#x2F;&#x2F;<em>不加空格</em>&#x2F;</p><p>查看变量: 使用<code>set</code>命令查看本地变量与环境变量，但是内容非常多，建议搭配<code>grep</code>等使用</p><p><em>例</em></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">my_value=2024</span><br><span class="line"></span><br><span class="line">set</span><br><span class="line"></span><br><span class="line">set | grep my_value</span><br></pre></td></tr></table></figure><h2 id="本地变量与环境变量"><a href="#本地变量与环境变量" class="headerlink" title="本地变量与环境变量"></a>本地变量与环境变量</h2><p>二者最大的差别是<code>环境变量</code>可以被子进程<strong>继承</strong>,而<code>本地变量</code>只在本BASH内部有效，<strong>不会</strong>被继承</p>]]></content>
      
      
      
        <tags>
            
            <tag> 环境变量 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识进程</title>
      <link href="/2024/07/04/progress/"/>
      <url>/2024/07/04/progress/</url>
      
        <content type="html"><![CDATA[<hr><p>操作系统平台:Linux<br>服务器系统: CentOS 7</p><hr><h1 id="概念抽象"><a href="#概念抽象" class="headerlink" title="概念抽象"></a>概念抽象</h1><h2 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h2><p><code>程序</code> &#x3D; <code>代码</code> + <code>数据</code></p><p>程序是储存在硬盘上的可执行文件</p><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>将<code>程序</code>加载到<code>内存</code>后，就在<code>内存</code>中程序的就是进程。也就是说一个正在运行的程序就能叫做进程</p><p><em>结构关系如下</em></p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-06_13-55-08.png"></p><p>如图，操作系统为了<strong>管理</strong>内存中的进程,使用了<code>PCB</code>结构体来描述进程,通过管理<code>PCB</code>来管理进程,依然是<em>先描述再组织</em></p><p><code>PCB</code>:进程控制块的数据结构(process control block)</p><p>所以实际上:<code>进程</code>&#x3D;<code>PCB</code>+<code>代码和数据</code></p><p>对于<code>代码和数据</code>没什么好说的，接下来主要讨论<code>PCB</code></p><h2 id="task-struct"><a href="#task-struct" class="headerlink" title="task_struct"></a>task_struct</h2><p><code>Linux</code>平台下的<code>PCB</code>叫做<code>task_struct</code></p><blockquote><p><code>task_struct</code>内容分类:</p></blockquote><ul><li><strong>标示符</strong>: 描述本进程的唯一标示符，用来区别其他进程。</li><li><strong>状态</strong>: 任务状态，退出代码，退出信号等。</li><li><strong>优先级</strong>: 相对于其他进程的优先级。</li><li>程序计数器: 程序中即将被执行的下一条指令的地址。</li><li>内存指针: 包括程序代码和进程相关数据的指针，还有和其他进程共享的内存块的指针</li><li>上下文数据: 进程执行时处理器的寄存器中的数据。</li><li>I／O状态信息: 包括显示的I&#x2F;O请求,分配给进程的I／O设备和被进程使用的文件列表。</li><li>记账信息: 可能包括处理器时间总和，使用的时钟数总和，时间限制，记账号等。</li><li>其他信息</li></ul><p><em>加粗部分会详细介绍</em></p><h1 id="查看进程"><a href="#查看进程" class="headerlink" title="查看进程"></a>查看进程</h1><p>进程的信息可以通过&#x2F;proc 系统文件夹查看,其中文件夹的名字就是进程的<code>PID</code></p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-06_21-53-59.png"></p><p>大多数进程信息同样可以使用top和ps这些用户级工具来获取</p><blockquote><p>以我自己编写的一个程序为例</p></blockquote><p><em>Makefile</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mycmd:mycmd.c</span><br><span class="line">gcc -o $@ $^</span><br><span class="line"></span><br><span class="line">.PHONY:clean</span><br><span class="line">clean:</span><br><span class="line">rm -rf mycmd</span><br></pre></td></tr></table></figure><p><strong>注</strong>： 后面的程序都是这三个头文件，仅修改<code>main()</code>函数体即可<br><em>mycmd.c</em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>) sleep(<span class="number">1</span>);<span class="comment">//死循环使该进程常驻内存</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后编译并运行程序<br><em>命令行</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">make</span><br><span class="line">./mycmd</span><br><span class="line">ps aux | grep mycmd | grep -v grep</span><br></pre></td></tr></table></figure><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-06_22-56-05.png"></p><h2 id="进程标示符-PID-PPID"><a href="#进程标示符-PID-PPID" class="headerlink" title="进程标示符(PID PPID)"></a>进程标示符(PID PPID)</h2><p>可以通过系统接口获取进程标示符</p><ul><li>进程id (pid)    使用<code>getpid()</code></li><li>父进程id (ppid) 使用<code>getppid()</code></li></ul><p><em>来修改一下代码</em><br><em>mycmd.c</em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;pid: %d\n&quot;</span>,getpid());<span class="comment">//打印pid (该进程id)</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;ppid: %d\n&quot;</span>,getppid());<span class="comment">//打印ppid (父进程id)</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>命令行</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">make clean</span><br><span class="line">make</span><br><span class="line">./mycmd</span><br></pre></td></tr></table></figure><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-06_23-28-35.png"></p><h2 id="利用fork-创建子进程"><a href="#利用fork-创建子进程" class="headerlink" title="利用fork()创建子进程"></a>利用<code>fork()</code>创建子进程</h2><p><em>mycmd.c</em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">pid_t</span> id = fork();</span><br><span class="line">  <span class="keyword">if</span>(id == <span class="number">0</span>)<span class="comment">//子进程</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child pid: %d\n&quot;</span>,getpid());<span class="comment">//打印pid (该进程id)</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child ppid: %d\n&quot;</span>,getppid());<span class="comment">//打印ppid (父进程id)</span></span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span><span class="comment">//父进程</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;father pid: %d\n&quot;</span>,getpid());<span class="comment">//打印pid (该进程id)</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;father ppid: %d\n&quot;</span>,getppid());<span class="comment">//打印ppid (父进程id)</span></span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-07_10-56-48.png"></p><p>如图，<code>fork()</code>创建了子进程，且子进程的<code>PPID</code>和父进程<code>PID</code>相同</p><h3 id="fork-的返回值"><a href="#fork-的返回值" class="headerlink" title="fork()的返回值"></a>fork()的返回值</h3><p>父子进程中<code>fork()</code>函数的返回值(此处用变量<code>id</code>储存)是不同的:</p><p><strong>父进程</strong>里<code>id</code>的值为子进程的<code>PID</code>,其值<code>&gt;0</code>;<strong>子进程</strong>里<code>id</code>值固定为<code>0</code></p><ul><li><code>id &gt; 0</code> 父进程</li><li><code>id == 0</code> 子进程</li><li><code>id &lt; 0</code> fork()失败</li></ul><h3 id="父子进程分流"><a href="#父子进程分流" class="headerlink" title="父子进程分流"></a>父子进程分流</h3><p>利用<code>fork()</code>返回值不同的特性可以做到分流操作，利用<code>if...else...</code>让父子进程执行不同的代码</p><p><a href="https://www.supdriver.top/2024/07/07/fork/">戳我去fork的详细介绍</a></p><h1 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h1><p><em>状态在kernel源代码里定义</em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> task_state_array[] = &#123;</span><br><span class="line"><span class="string">&quot;R (running)&quot;</span>, <span class="comment">/* 0 */</span></span><br><span class="line"><span class="string">&quot;S (sleeping)&quot;</span>, <span class="comment">/* 1 */</span></span><br><span class="line"><span class="string">&quot;D (disk sleep)&quot;</span>, <span class="comment">/* 2 */</span></span><br><span class="line"><span class="string">&quot;T (stopped)&quot;</span>, <span class="comment">/* 4 */</span></span><br><span class="line"><span class="string">&quot;t (tracing stop)&quot;</span>, <span class="comment">/* 8 */</span></span><br><span class="line"><span class="string">&quot;X (dead)&quot;</span>, <span class="comment">/* 16 */</span></span><br><span class="line"><span class="string">&quot;Z (zombie)&quot;</span>, <span class="comment">/* 32 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="R-运行状态-running"><a href="#R-运行状态-running" class="headerlink" title="R 运行状态(running)"></a>R 运行状态(running)</h2><p>R状态并不一定正在运行，而是<code>正在运行</code>和<code>处于运行队列</code>中的一种</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-07_13-14-49.png"></p><h2 id="S-睡眠状态-sleeping"><a href="#S-睡眠状态-sleeping" class="headerlink" title="S 睡眠状态(sleeping)"></a>S 睡眠状态(sleeping)</h2><p>S 意味着进程在<strong>等待</strong>运行完成</p><p>(<em>这里的睡眠有时也可叫做可中断睡眠 interruptible sleep</em>)</p><p><em>下面展示两种S状态的进程</em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  sleep(<span class="number">50</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-07_13-45-14.png"></p><p>直接使用<code>sleep()</code>系列的函数直接使进程休眠</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Enter the num: &quot;</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-07_13-47-33.png"></p><p>像<code>scanf()</code>这种需要等待外设(键盘)的接口，在<strong>阻塞等待</strong>资源的过程中会使进程进入<code>S</code>状态</p><h2 id="D-磁盘休眠状态（Disk-sleep）"><a href="#D-磁盘休眠状态（Disk-sleep）" class="headerlink" title="D 磁盘休眠状态（Disk sleep）"></a>D 磁盘休眠状态（Disk sleep）</h2><p>有时候也叫不可中断睡眠状态（uninterruptible sleep），在这个状态的进程通常会等待<code>IO</code>的结束。</p><h2 id="T-停止状态（stopped）"><a href="#T-停止状态（stopped）" class="headerlink" title="T 停止状态（stopped）"></a>T 停止状态（stopped）</h2><p>可以通过(<em>kill等命令</em>)发送 <code>SIGSTOP</code> 信号给进程来停止（T）进程。这个被暂停的进程可以通过发送 <code>SIGCONT </code>信号让进程继续运行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>) sleep(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行前先<strong>复制</strong>ssh渠道，其中一个窗口用于执行进程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">make clean</span><br><span class="line">make</span><br><span class="line">./mycmd</span><br></pre></td></tr></table></figure><p>另一个进程用于输入命令</p><p>先查看该进程的<code>PID</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps ajx | head -1 &amp;&amp; ps ajx | grep mycmd | grep -v grep</span><br></pre></td></tr></table></figure><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-07_15-04-51.png"></p><p>如图，这次的<code>PID</code>是<code>20275</code></p><p>然后用<code>kill</code>发送<code>SIGSTOP</code>,对应参数为<code>-19</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kill -19 20275</span><br><span class="line">ps ajx | head -1 &amp;&amp; ps ajx | grep mycmd | grep -v grep</span><br></pre></td></tr></table></figure><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-07_15-06-38.png"></p><p>可以看到它已经由<code>S</code>状态改为<code>T</code>状态了</p><p>接下来发送<code>SIGCONT</code>,对应参数<code>-18</code>,使进程恢复</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kill -18 20275</span><br><span class="line">ps ajx | head -1 &amp;&amp; ps ajx | grep mycmd | grep -v grep</span><br></pre></td></tr></table></figure><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-07_15-08-45.png"></p><p>可以看到已经由<code>T</code>变为原本的<code>S</code>状态了</p><h2 id="X-死亡状态（dead）"><a href="#X-死亡状态（dead）" class="headerlink" title="X 死亡状态（dead）"></a>X 死亡状态（dead）</h2><p>这个状态只是一个返回状态，你不会在任务列表里看到这个状态。</p><h2 id="Z-僵尸进程-zombie"><a href="#Z-僵尸进程-zombie" class="headerlink" title="Z 僵尸进程(zombie)"></a>Z 僵尸进程(zombie)</h2><p>这个详细讨论下</p><h3 id="产生"><a href="#产生" class="headerlink" title="产生"></a>产生</h3><p>当该进程退出后，父进程尚未使用<code>wait()</code>之类的接口获取该进程的<code>退出码</code>,且父进程<strong>没有结束</strong>时，该进程会变成僵尸进程</p><p><em>父进程比子进程先退出时，子进程的父进程会改变为PID为1的进程，由新进程托管</em></p><p><em>下面创建一个例子</em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">pid_t</span> id = fork();</span><br><span class="line">  <span class="keyword">if</span>(id == <span class="number">0</span>)<span class="comment">//子进程</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child exit\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span><span class="comment">//父进程</span></span><br><span class="line">  &#123;</span><br><span class="line">    sleep(<span class="number">30</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;father exit\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行程序后的<code>30秒</code>内查看进程状态，可以看到子进程进入了<code>Z</code>状态</p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-07_16-27-27.png"></p><h3 id="行为"><a href="#行为" class="headerlink" title="行为"></a>行为</h3><p>僵尸进程会以终止状态保持在进程表中，等待父进程读取退出状态代码</p><h3 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h3><ul><li>父进程一直<strong>未获取</strong>子进程的退出码,僵尸状态就会一直保持</li><li>保持<code>Z</code>状态的进程的<code>PCB</code>仍然要一直维护，占用资源</li><li>未退出<code>Z</code>状态的子进程可能造成内存泄漏</li></ul><h2 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h2><p>当父进程比子进程<strong>先</strong>退出后,这个子进程便成了<code>孤儿进程</code></p><p>既然原本的父进程没了，谁来托管子进程呢？答案是<code>PID</code>为<code>1</code>的那个进程</p><p><em>例子如下</em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">pid_t</span> id = fork();</span><br><span class="line">  <span class="keyword">if</span>(id == <span class="number">0</span>)<span class="comment">//子进程</span></span><br><span class="line">  &#123;</span><br><span class="line">    sleep(<span class="number">30</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child exit\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span><span class="comment">//父进程</span></span><br><span class="line">  &#123;</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;father exit\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-07_19-05-32.png"></p><h1 id="进程优先级"><a href="#进程优先级" class="headerlink" title="进程优先级"></a>进程优先级</h1><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><ul><li>cpu资源分配的先后顺序，就是指进程的优先权（priority）。</li><li>优先权高的进程有优先执行权利。配置进程优先权对多任务环境的linux很有用，可以改善系统性能。</li><li>还可以把进程运行到指定的CPU上，这样一来，把不重要的进程安排到某个CPU，可以大大改善系统整体性能</li></ul><h2 id="查看优先级"><a href="#查看优先级" class="headerlink" title="查看优先级"></a>查看优先级</h2><p><em>首先写一个常驻进程</em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)sleep(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后使用<code>ps -la</code>查看进程信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./mycmd</span><br><span class="line">ps -la</span><br></pre></td></tr></table></figure><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-07_19-59-12.png"></p><p>其中的<code>PRI</code>和<code>NI</code>与进程优先级有关,<code>PRI</code>就是进程的优先级，跟排队摇号一样，此值<code>越小</code>，被执行的优先级越高,而<code>NI</code>就是nice值，用于修正原<code>PRI</code>值</p><h3 id="PRI值的计算"><a href="#PRI值的计算" class="headerlink" title="PRI值的计算"></a>PRI值的计算</h3><p>首先在看到的<code>PRI</code>值之外，还有个隐藏的基准值，本文用<code>PRI0</code>指代，这个<code>PRI0</code>是固定的，当<code>NI</code>值为<code>0</code>时，<code>PRI == PRI0</code>,而<br>无论怎么修改多少次<code>NI</code>,<code>PRI</code>的值减去<code>NI</code>值都相等，所以大可以推断在本系统(Linux)中,<code>PRI</code>值有如下计算公式</p><p><code>PRI = PRI0 + NI</code></p><h3 id="修改NI值"><a href="#修改NI值" class="headerlink" title="修改NI值"></a>修改NI值</h3><p>因为修改<code>NI</code>值要管理员权限，所以要么<code>root</code>用户用<code>top</code>，要么信任用户用<code>sudo top</code>打开界面，然后按<code>r</code>,输入待修改进程的<code>PID</code>,按下回车后再输入新的<code>NI</code>值(有效范围<code>-20~19</code>)</p><p><em>此处可以用<code>ps -la</code>查看进程的PID,或调用<code>getpid()</code></em></p><p><em>再写一个例子</em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;mypid: %d\n&quot;</span>,getpid());</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>sudo top</code>然后按<code>r</code></p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-07_21-14-38.png"></p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-07_21-15-50.png"></p><p><code>ps -la</code>可以看到被修改后的进程优先级</p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-07_21-17-02.png"></p><h1 id="其它概念"><a href="#其它概念" class="headerlink" title="其它概念"></a>其它概念</h1><ul><li>竞争性: 系统进程数目众多，而CPU资源只有少量，甚至1个，所以进程之间是具有竞争属性的。为了高效完成任务，更合理竞争相关资源，便具有了优先级</li><li>独立性: 多进程运行，需要独享各种资源，多进程运行期间<strong>互不干扰</strong></li><li>并行: 多个进程在<strong>多个CPU</strong>下分别，同时进行运行，这称之为并行</li><li>并发: 多个进程在<strong>一个CPU</strong>下采用进程切换的方式，在一段时间之内，让多个进程都得以推进，称之为并发</li></ul><p><em>下一章</em><a href="https://www.supdriver.top/2024/07/06/evn/">环境变量</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 进程 Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C/C++ static关键字的使用</title>
      <link href="/2024/06/30/usestatic/"/>
      <url>/2024/06/30/usestatic/</url>
      
        <content type="html"><![CDATA[<p>因为<code>static</code>的用法又多又杂，值得单出一篇博客用以汇总</p><h1 id="C-C-通用用法"><a href="#C-C-通用用法" class="headerlink" title="C&#x2F;C++ 通用用法"></a>C&#x2F;C++ 通用用法</h1><h2 id="局部变量-全局属性"><a href="#局部变量-全局属性" class="headerlink" title="局部变量-&gt;全局属性"></a>局部变量-&gt;全局属性</h2><p>当对原本声明在函数栈帧里的<code>变量</code>使用<code>static</code>修饰时,该<code>变量</code>的存储空间会改变到<code>静态区</code>，不会随着函数栈帧的销毁而销毁。</p><p>初始化：初次调用声明语句时会执行声明操作，而之后再执行到该语句处时会自动跳过。</p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-03_10-51-24.png"></p><p>作用范围：与不加<code>static</code>时的作用范围相同，还是局部可用</p><p>销毁：和全局变量一样在<code>main</code>函数的栈帧销毁时一并销毁</p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-03_11-09-04.png"></p><h2 id="全局变量-限制访问"><a href="#全局变量-限制访问" class="headerlink" title="全局变量-&gt;限制访问"></a>全局变量-&gt;限制访问</h2><p>原本同级文件夹下的源文件可以用<code>extern</code>关键字互相获取全局变量,但如果用<code>static</code>修饰本地全局变量，那么这个全局变量只能在本文件调用，而其它文件看不到它</p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-03_11-56-27.png"></p><h2 id="全局函数-限制访问"><a href="#全局函数-限制访问" class="headerlink" title="全局函数-&gt;限制访问"></a>全局函数-&gt;限制访问</h2><p>原本同级文件夹下的源文件可以用<code>extern</code>关键字声明函数，然后去其它源文件的全局函数中寻找<code>实现方式</code>,但如果用<code>static</code>修饰本地全局函数，那么这个全局函数的实现只能在本文件调用，而其它文件看不到它</p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-03_12-02-16.png"></p><h1 id="C-类和对象"><a href="#C-类和对象" class="headerlink" title="C++类和对象"></a>C++类和对象</h1><h2 id="成员变量-静态成员-全局变量"><a href="#成员变量-静态成员-全局变量" class="headerlink" title="成员变量-&gt;静态成员 (全局变量)"></a>成员变量-&gt;静态成员 (全局变量)</h2><p>原本声明的成员变量在实例化后，属于由<code>类</code>实例化出来的<code>对象</code>，生命周期与所属对象相同，但在加了<code>static</code>后，该变量属于该类域中的全局变量，不再属于某个<strong>具体</strong>的<code>对象</code></p><p><strong>初始化</strong>: 因为已经不属于某一个对象，初始化也不能在类的接口中完成了，因此在类中声明<code>static</code>成员变量后，<strong>必须</strong>在全局区初始化<code>类域</code>中的成员变量。  #<em>在main函数等非全局域中无法初始化</em></p><p>常见应用：引用计数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">A</span>()</span><br><span class="line">&#123;</span><br><span class="line">cnt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> cnt;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> A::cnt = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h2 id="成员函数-静态成员函数-不含this指针"><a href="#成员函数-静态成员函数-不含this指针" class="headerlink" title="成员函数-&gt;静态成员函数 (不含this指针)"></a>成员函数-&gt;静态成员函数 (不含this指针)</h2><p>一般声明在类中的成员函数的参数列表隐藏<code>this</code>指针，要调用函数时得用类实例化出的<code>对象</code>来调用，由这个对象提供<code>this</code>指针</p><p>而使用<code>static</code>修饰后的静态成员函数不含<code>this</code>指针，该函数属于整个类域，调用时使用类域调用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">A</span>()</span><br><span class="line">&#123;</span><br><span class="line">cnt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">getCNT</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> cnt;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> A::cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a,b,c;</span><br><span class="line">    cout&lt;&lt;A::<span class="built_in">getCNT</span>();<span class="comment">//此时输出3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>归并排序</title>
      <link href="/2024/06/28/mergesort/"/>
      <url>/2024/06/28/mergesort/</url>
      
        <content type="html"><![CDATA[<hr><p>时间复杂度: O(nlogn)<br>空间复杂度: O(n)<br>稳定性： 稳定<br>实现语言: C&#x2F;C++</p><hr><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>这里采用的是<strong>分治</strong>的思想，但与<code>快速排序</code>相反的是，归并排序采用的是先分治再合并。</p><p>已知在有额外空间的情况下，合并两个<strong>有序</strong>数组得到一个新的较长有序数组是很高效的。 所以能不能把一个任意数组分成由左右两个有序数组组成然后合并成有序数组呢？</p><p>显然不能，大部分情况并不能分成两个有序数组，但如果在此之前用同样的方法（这里采用递归）事先排序左右两部分呢？大部分情况依然不能，因此这个递归会一直递推下去，最终待排序区间<strong>不断缩小</strong>,到只剩一个或零个元素，此时就可以将其看为有序数组了,也就是说递归在这里停止，可以一路合并有序数组一路回归上去了</p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-02_21-29-34.png"></p><h2 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h2><p>这里使用左右指针<strong>控制待排序区间</strong>（迭代器也行）,并采用递归的方式形象地完成分治操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> _MergeSort(vector&lt;<span class="type">int</span>&gt;&amp; arr,<span class="type">int</span> left,<span class="type">int</span> right,vector&lt;<span class="type">int</span>&gt;&amp;tmp)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//分治</span></span><br><span class="line">    <span class="keyword">if</span>(left &gt;= right) <span class="keyword">return</span>;<span class="comment">//递归出口</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">    _MergeSort(arr,left,mid,tmp);<span class="comment">//排序左半边</span></span><br><span class="line">    _MergeSort(arr,mid+<span class="number">1</span>,right,tmp);<span class="comment">//排序右半边</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//合并数组</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">tmp</span><span class="params">(arr.size())</span></span>;<span class="comment">//用tmp开辟额外空间用于合并数组</span></span><br><span class="line">    _MergeSort(arr,<span class="number">0</span>,arr.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="合并有序数组"><a href="#合并有序数组" class="headerlink" title="合并有序数组"></a>合并有序数组</h2><p>因为合并两个有序数组<strong>难以原地</strong>完成，所以要借助<code>tmp</code>数组提供额外空间。</p><p>具体做法就是用两个指针分别从两个数组中挑最小值，然后用第三个指针从左向右填到<code>tmp</code>中，最后再拷贝至原数组</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> _MergeSort(vector&lt;<span class="type">int</span>&gt;&amp; arr,<span class="type">int</span> left,<span class="type">int</span> right,vector&lt;<span class="type">int</span>&gt;&amp;tmp)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//分治</span></span><br><span class="line">    <span class="keyword">if</span>(left &gt;= right) <span class="keyword">return</span>;<span class="comment">//递归出口</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">    _MergeSort(arr,left,mid,tmp);<span class="comment">//排序左半边</span></span><br><span class="line">    _MergeSort(arr,mid+<span class="number">1</span>,right,tmp);<span class="comment">//排序右半边</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//合并数组</span></span><br><span class="line">    <span class="type">int</span> cur1 = left;</span><br><span class="line"><span class="type">int</span> cur2 = mid + <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> cur = left;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (cur1 &lt;= mid &amp;&amp; cur2 &lt;= right)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[cur1] &lt; arr[cur2])</span><br><span class="line">&#123;</span><br><span class="line">tmp[cur++] = arr[cur1++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">tmp[cur++] = arr[cur2++];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (cur1 &lt;= left)</span><br><span class="line">tmp[cur++] = arr[cur1++];</span><br><span class="line"><span class="keyword">while</span> (cur2 &lt;= right)</span><br><span class="line">tmp[cur++] = arr[cur2++];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = left; i &lt;= right; i++)</span><br><span class="line">arr[i] = tmp[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">tmp</span><span class="params">(arr.size())</span></span>;<span class="comment">//用tmp开辟额外空间用于合并数组</span></span><br><span class="line">    _MergeSort(arr,<span class="number">0</span>,arr.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是C++版的完整代码,下面再提供<code>C</code>语言版的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> _MergeSort(<span class="type">int</span>* arr, <span class="type">int</span> sz, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span>* tmp)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (left &gt;= right) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">_MergeSort(arr,sz ,left, mid, tmp);</span><br><span class="line">_MergeSort(arr, sz, mid + <span class="number">1</span>,right, tmp);</span><br><span class="line"><span class="type">int</span> cur1 = left, cur2 = mid + <span class="number">1</span>, cur = left;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (cur1 &lt;= mid &amp;&amp; cur2 &lt;= right)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[cur1] &lt; arr[cur2])</span><br><span class="line">tmp[cur++] = arr[cur1++];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">tmp[cur++] = arr[cur2++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (cur1 &lt;= mid)</span><br><span class="line">tmp[cur++] = arr[cur1++];</span><br><span class="line"><span class="keyword">while</span> (cur2 &lt;= right)</span><br><span class="line">tmp[cur++] = arr[cur2++];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = left; i &lt;= right; i++)</span><br><span class="line">arr[i] = tmp[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MergeSort</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> sz)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span>* tmp = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * sz);</span><br><span class="line">_MergeSort(arr, sz, <span class="number">0</span>, sz - <span class="number">1</span>, tmp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>归并排序的原理乍一看很吓人，好像很高深的样子，但其实多上手练练，多试着独立敲代码就能掌握其精髓了，之后手撕归并排序不要太简单</p>]]></content>
      
      
      
        <tags>
            
            <tag> 排序 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>=Linux=一步步自己写一个shell程序</title>
      <link href="/2024/06/04/myshell/"/>
      <url>/2024/06/04/myshell/</url>
      
        <content type="html"><![CDATA[<hr><p>系统：阿里云服务器Linux CentOs 7</p><p>编辑器: vim </p><p>编译器: gcc (支持C99)</p><hr><h1 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h1><p>本次写的程序较为简单，所以只使用一个源文件</p><p>所以在shell中<code>touch</code>一个<code>makefile</code>和一个<code>myshell.c</code></p><blockquote><p>shell</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">touch makefile</span><br><span class="line">touch myshell.c</span><br></pre></td></tr></table></figure><p>然后编辑<code>makefile</code>文件</p><blockquote><p>makefile</p></blockquote><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1 myshell:myshell.c                         </span><br><span class="line">  gcc -o <span class="variable">$@</span> <span class="variable">$^</span> -std=c99</span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>:clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">   rm -f myshell</span><br></pre></td></tr></table></figure><h1 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h1><p>本程序因函数较杂，会<code>include</code>较多头文件</p><blockquote><p>myshell.c</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br></pre></td></tr></table></figure><h1 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h1><p>为了统一修改部分参数，以及使参数更易读，这里使用部分宏定义</p><blockquote><p>myshell.c</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LEFT <span class="string">&quot;[&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RIGHT <span class="string">&quot;]&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LABEL <span class="string">&quot;# &quot;</span><span class="comment">//注意有个空格</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LINE_SIZE 1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ARGC_SIZE 32</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DLIM <span class="string">&quot; \t&quot;</span> <span class="comment">//可能有多个分隔符</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXIT_CODE 446 <span class="comment">//特殊的退出码，表示程序未正常退出，具体数字目前没有约定</span></span></span><br></pre></td></tr></table></figure><h1 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h1><p>我们需要用全局的变量来存储<code>命令行</code>(command line)和<code>参数包</code></p><blockquote><p>myshell.c</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> cline[LINE_SIZE];</span><br><span class="line"><span class="type">char</span>* arg[ARGC_SIZE];</span><br><span class="line"><span class="type">int</span> last_code = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h1 id="用Interact函数实现交互功能"><a href="#用Interact函数实现交互功能" class="headerlink" title="用Interact函数实现交互功能"></a>用<code>Interact</code>函数实现交互功能</h1><h2 id="打印命令行头部"><a href="#打印命令行头部" class="headerlink" title="打印命令行头部"></a>打印命令行头部</h2><p>为了打印命令行头部，我们需要知道三样东西：用户，主机，工作路径，这里包装了三个函数来分别调用<code>getenv</code>函数</p><blockquote><p>myshell.c</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* <span class="title function_">getusername</span><span class="params">()</span><span class="comment">//获取用户名</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> getenv(<span class="string">&quot;USER&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* <span class="title function_">gethostname</span><span class="params">()</span><span class="comment">//获取主机名</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> getenv(<span class="string">&quot;HOSTNAME&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* <span class="title function_">getpwd</span><span class="params">()</span><span class="comment">//获取工作路径</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> getenv(<span class="string">&quot;PWD&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>因此打印的代码为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(LEFT <span class="string">&quot;%s@%s %s&quot;</span> RIGHT LABLE,getusername(),gethostname(),getpwd());</span><br></pre></td></tr></table></figure><h2 id="获取命令行"><a href="#获取命令行" class="headerlink" title="获取命令行"></a>获取命令行</h2><p>使用Linux的终端时，我们会打<code>命令+空格+参数...</code>,因此我们的<code>myshell</code>程序也要支持连空格一起读入,读入一整行命令</p><p>所以<code>scanf</code>并不适合用来读入命令，这次我们使用<code>fgets</code>函数，这个函数可以从<code>文件流</code>中整行读入，而正好在终端输入的字符都储存在<code>标准输入流</code>,即<code>stdin</code>中,因此可以用一行代码获取<code>命令行</code></p><p>为安全考虑，这里使用一个临时变量<code>s</code>来接受<code>fgets</code>的返回值并用<code>assert</code>判空,但在<code>release</code>版本中<code>assert</code>不被编译，导致变量<code>s</code>未被调用，而报警告（甚至报错），所以还要再加一句<code>(void) s</code>,只为了调用一下<code>s</code>,没有更多用处</p><p>之后便完成了文件流的读取</p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-06-04_16-25-34.png"></p><p>但此时获得的命令行在<code>\0</code>前以<code>\n</code>结尾，所以要把<code>\n</code>替换为<code>\0</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *s = fgets(cline,size,<span class="built_in">stdin</span>);</span><br><span class="line">assert(s);<span class="comment">//s为空时报错</span></span><br><span class="line">(<span class="type">void</span>) s;<span class="comment">//防止因未调用s而报警告</span></span><br><span class="line"></span><br><span class="line">cline[<span class="built_in">strlen</span>(cline) - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br></pre></td></tr></table></figure><h2 id="整个函数体"><a href="#整个函数体" class="headerlink" title="整个函数体"></a>整个函数体</h2><blockquote><p>myshell.c</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Interact</span><span class="params">(<span class="type">char</span>* cline,<span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(LEFT <span class="string">&quot;%s@%s %s&quot;</span> RIGHT LABLE,getusername(),gethostname(),getpwd());<span class="comment">//打印头部</span></span><br><span class="line">    fgets(cline,size,<span class="built_in">stdin</span>);<span class="comment">//获取命令行</span></span><br><span class="line">    assert(s);<span class="comment">//s为空时报错</span></span><br><span class="line">    (<span class="type">void</span>) s;<span class="comment">//防止因未调用s而报警告</span></span><br><span class="line">    cline[<span class="built_in">strlen</span>(cline) - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;echo: %s\n&quot;</span>);<span class="comment">//写一段测一段的测试代码，输出获取的命令行,测完可删</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>先在<code>main</code>函数里调用一次<code>Interact</code>函数测试一下</p><p>我的测试结果如下</p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-06-04_16-42-55.png"></p><p>可以看到达到了预期效果，但是<code>工作路径</code>太长了，还是学一学Linux的展示方式吧，我们来把<code>getpwd</code>函数重写一下</p><h2 id="重写getpwd"><a href="#重写getpwd" class="headerlink" title="重写getpwd()"></a>重写<code>getpwd()</code></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* <span class="title function_">getpwd</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* pwd = getenv(<span class="string">&quot;PWD&quot;</span>);</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">strlen</span>(pwd);</span><br><span class="line">    <span class="keyword">while</span>(n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(pwd[n] == <span class="string">&#x27;/&#x27;</span>) <span class="keyword">break</span>;</span><br><span class="line">        n--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (pwd+n+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样打印出的工作路径仅为当前文件夹，可以缩短很多长度</p><h1 id="分割命令行"><a href="#分割命令行" class="headerlink" title="分割命令行"></a>分割命令行</h1><p>现在的<code>cline</code>中的命令行还是完整的一串，需要分割出命令和参数包，因此我们也封装一个函数<code>Splitcline</code></p><p>这里使用的是<code>string.h</code>中的<code>strtok</code>函数，可以用特定的单个或多个字符将字符串分割</p><blockquote><p>myshell.c</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Splitcline</span><span class="params">(<span class="type">char</span>*cline,<span class="type">char</span>** argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">memset</span>(argv,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="type">char</span>*) * ARGV_SIZE);</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    argv[<span class="number">0</span>] = strtok(cline,DLIM);</span><br><span class="line">    <span class="keyword">if</span>(argv[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">while</span>(argv[i++] == strtok(<span class="literal">NULL</span>,DLIM));</span><br><span class="line"></span><br><span class="line">    *argv_n = i<span class="number">-1</span>;<span class="comment">//输出型参数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>再写一段测试代码</p><blockquote><p>myshell.c</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Interact(cline,<span class="keyword">sizeof</span>(cline));</span><br><span class="line"></span><br><span class="line">    Splitcline(cline,argv);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;argv[i];i++)<span class="comment">//逐行打印输出argv的内容</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,argv[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="执行外部命令"><a href="#执行外部命令" class="headerlink" title="执行外部命令"></a>执行外部命令</h1><p>通过<code>fork</code>函数创建子进程，然后用<code>execvp</code>替换子进程，通过环境变量<code>PATH</code>找到外部命令并替换到子进程执行，同时父进程<code>myshell</code>调用<code>waitpid</code>函数等待子进程结束，保证<code>myshell</code>程序正常运行</p><blockquote><p>myshell.c</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ExternalCommand</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> id = fork();</span><br><span class="line">    <span class="keyword">if</span>(id &lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(id == <span class="number">0</span>)<span class="comment">//child</span></span><br><span class="line">    &#123;</span><br><span class="line">        execvp(argv[<span class="number">0</span>],argv+<span class="number">1</span>);<span class="comment">//+1之后才是参数列表</span></span><br><span class="line">        <span class="built_in">exit</span>(EXIT_CODE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> status = <span class="number">0</span>;</span><br><span class="line">        <span class="type">pid_t</span> rid = waitpid(id,&amp;status,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(rid == id)</span><br><span class="line">        &#123;</span><br><span class="line">            last_code = WEXITSTATUS(status);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="执行内建命令"><a href="#执行内建命令" class="headerlink" title="执行内建命令"></a>执行内建命令</h1><p><code>shell</code>中并不是所有的命令都由子进程完成的，比如用<code>cd</code>命令改变工作路径，就不能让子进程去执行(<del>否则只是改了子进程的路径</del>),因此我们还需要加一个内建命令接口</p><blockquote><p>myshell.c</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">BuildCommand</span><span class="params">(<span class="type">char</span>* _argv[],<span class="type">int</span> _argv_n)</span><span class="comment">//处理内建命令</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(_argv_n == <span class="number">2</span> &amp;&amp; <span class="built_in">strcmp</span>(_argv[<span class="number">0</span>],<span class="string">&quot;cd&quot;</span>)== <span class="number">0</span>)<span class="comment">//特殊处理的命令1</span></span><br><span class="line">  &#123;</span><br><span class="line">    chdir(argv[<span class="number">1</span>]);</span><br><span class="line">    getpwd();</span><br><span class="line">    <span class="built_in">sprintf</span>(getenv(<span class="string">&quot;PWD&quot;</span>),<span class="string">&quot;%s&quot;</span>,pwd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//完成执行返回1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//还可以继续else uf 加特殊处理的命令2,3,4,,,n</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//未执行内建命令。返回0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="完成框架"><a href="#完成框架" class="headerlink" title="完成框架"></a>完成框架</h1><p>至此，把<code>main</code>函数组织好后，一个简单的<code>shell</code>代码框架就搭好了，可以根据需要继续扩展<code>内建命令</code>的内容，比如导出环境变量，实现<code>echo</code>指令等（略写）。</p><blockquote><p>myshell.c</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">int</span> quit = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">while</span>(!quit)</span><br><span class="line">   &#123;</span><br><span class="line">     Interact(cline,<span class="keyword">sizeof</span>(cline));</span><br><span class="line">     <span class="type">int</span> argv_n;</span><br><span class="line">     Splitcline(cline,argv,&amp;argv_n);</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">if</span>(argv_n == <span class="number">0</span> )<span class="keyword">continue</span>;</span><br><span class="line">     </span><br><span class="line">     <span class="type">int</span> flag = BuildCommand(argv,argv_n);</span><br><span class="line">     <span class="keyword">if</span>(!flag) ExeternalCommand();</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;                            </span><br><span class="line">&#125;          </span><br></pre></td></tr></table></figure><h1 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h1><p>这里的命令行处理并没有考虑<code>输入/输出重定向</code>,所以仍有较大的需要完善的地方</p><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><p><a href="https://github.com/sis-shen/Linux_Code">点我去往github仓库</a>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆排序</title>
      <link href="/2024/05/21/heap-sort/"/>
      <url>/2024/05/21/heap-sort/</url>
      
        <content type="html"><![CDATA[<h1 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h1><ul><li>知道什么是大堆&#x2F;小堆</li><li>掌握如何将数组与完全二叉树的映射关系</li><li>掌握<code>向上调整法</code>和<code>向下调整法</code></li></ul><h2 id="大堆-小堆"><a href="#大堆-小堆" class="headerlink" title="大堆&#x2F;小堆"></a>大堆&#x2F;小堆</h2><p>大堆的特性:每一个节点的值都比左右孩子都大,<code>根</code>的值是整个大堆中<strong>最大的</strong><br>小堆的特性:每一个节点的值都比左右孩子都小,<code>根</code>的值是整个大堆中<strong>最小的</strong></p><p><strong>后面以大堆为例</strong></p><h2 id="数组映射成完全二叉树"><a href="#数组映射成完全二叉树" class="headerlink" title="数组映射成完全二叉树"></a>数组映射成完全二叉树</h2><p>任何一个数组可以看成一个<code>完全二叉树</code>,下标0为二叉树的根</p><p>而非常方便的是，已知一个节点的下标，可以利用数学关系求出根或孩子的下标</p><blockquote><p>下标关系如下（变量均为下标）</p></blockquote><ul><li><code>parent = (child-1)/2</code></li><li><code>left_child = parent*2+1</code></li><li><code>right_child = parent*2+2</code></li></ul><h2 id="建堆方法"><a href="#建堆方法" class="headerlink" title="建堆方法"></a>建堆方法</h2><h3 id="向上调整法"><a href="#向上调整法" class="headerlink" title="向上调整法"></a>向上调整法</h3><p>在已有一个大堆的<strong>前提下</strong>,把一个新的数据插入到堆的最后一个节点(此时破坏大堆的结构),再<strong>一路</strong>向上调整,可以重新建堆</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">adjust_up</span><span class="params">(vector&lt;T&gt;&amp; arr, <span class="type">int</span> child)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> parent = (child - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">while</span> (parent != child)<span class="comment">//parent == child == 0时</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[parent] &lt; arr[child])<span class="comment">//不满足大堆</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">swap</span>(arr[parent], arr[child]);<span class="comment">//交换</span></span><br><span class="line">child = parent;<span class="comment">//继续向上调整,迭代child和parent</span></span><br><span class="line">parent = (child - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span><span class="comment">//完成建堆，退出循环</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="向下调整法"><a href="#向下调整法" class="headerlink" title="向下调整法"></a>向下调整法</h3><p>在已有一个大堆的<strong>前提下</strong>,把根的值改变(此时破坏大堆的结构),再<strong>一路</strong>向下调整，可以重新建堆</p><p>上一句也可以等价于,左子树和右子树都是大堆的前提下，将根<strong>一路</strong>向下调整，可以重新建堆</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">adjust_down</span><span class="params">(vector&lt;T&gt;&amp; arr,<span class="type">int</span> sz , <span class="type">int</span> parent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> child = parent * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (child + <span class="number">1</span> &lt; sz &amp;&amp; arr[child + <span class="number">1</span>] &gt; arr[child]) child++;<span class="comment">//取较大的孩子</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (child &lt; sz)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[parent] &lt; arr[child])</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">swap</span>(arr[parent], arr[child]);</span><br><span class="line">parent = child;</span><br><span class="line"><span class="type">int</span> child = parent * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (child &gt;= sz) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (child + <span class="number">1</span> &lt; sz &amp;&amp; arr[child + <span class="number">1</span>] &gt; arr[child]) child++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="主要思路"><a href="#主要思路" class="headerlink" title="主要思路"></a>主要思路</h1><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-05-21_12-40-09.png"></p><h2 id="建堆"><a href="#建堆" class="headerlink" title="建堆"></a>建堆</h2><p>用<code>向上调整法</code>和<code>向下调整法</code>都能建堆,不过<code>向上调整法</code>建堆思路更简单，也更容易代码实现，只需要把第一个元素当成现成的大堆，然后逐个插入并向上调整。<strong>也就是说只需要写一个循环</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//向上调整法建堆</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; sz; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">adjust_up</span>(arr, i);<span class="comment">//逐个插入并向上调整建堆</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-05-21_19-45-09.png"></p><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>此时的排序有个特点，那就是我们要<strong>倒着排</strong></p><p>尽管此时数组的第一个元素为<code>最大值</code>,似乎只需要把它放在那，整一个<code>降序</code>排列，再把剩下的元素建个堆，确定第二大的数…<strong>但是</strong>，此时有个很大的问题，当把剩下的元素看作堆时，会发现前面建堆留下来的关系全被打乱了(原本父子关系,兄弟关系乱套了),也就是说要<code>完全重新建堆</code>,极大地浪费了第一次建堆所建立的关系</p><p>所以我们要尽可能<code>保留</code>原来的堆,既然把下标<code>0</code>处的节点除外会极大地影响堆的关系，那就改成把<code>最后一个叶子节点</code>除外,这样对原来的堆几乎没有改变。</p><p>但建堆选出的<code>最大的</code>的值在根处,所以把<code>根</code>和<code>最后一个叶子节点</code>交换，<strong>交换后</strong>,此时<strong>待排序</strong>的数中的<code>最大值</code>以完成排序（即倒着排）,把<code>最后一个叶子节点</code>从堆中除外,再从<code>根</code>开始一路向下调整即可重新<code>建堆</code>,如此循环</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = sz<span class="number">-1</span>; i &gt;= <span class="number">1</span>; i--)<span class="comment">//利用i的减小将已排序的元素逐个除外</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">swap</span>(arr[<span class="number">0</span>], arr[i]);<span class="comment">//选出最大的元素放在末尾</span></span><br><span class="line"><span class="built_in">adjust_down</span>(arr,i,<span class="number">0</span>);<span class="comment">//向下调整建堆,待排序的（待建堆的）数的个数为i,逐个减小</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-05-21_19-45-22.png"></p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-05-21_19-47-20.png"></p><p>正因为实际上排序时是<strong>倒着排</strong>的,所以当我们要排序时：</p><ul><li>升序-&gt;<code>大堆</code></li><li>降序-&gt;<code>小堆</code></li></ul><h1 id="全部代码"><a href="#全部代码" class="headerlink" title="全部代码"></a>全部代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">adjust_up</span><span class="params">(vector&lt;T&gt;&amp; arr, <span class="type">int</span> child)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> parent = (child - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">while</span> (parent != child)<span class="comment">//parent == child == 0时</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[parent] &lt; arr[child])<span class="comment">//不满足大堆</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">swap</span>(arr[parent], arr[child]);<span class="comment">//交换</span></span><br><span class="line">child = parent;<span class="comment">//继续向上调整,迭代child和parent</span></span><br><span class="line">parent = (child - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span><span class="comment">//完成建堆，退出循环</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">adjust_down</span><span class="params">(vector&lt;T&gt;&amp; arr,<span class="type">int</span> sz , <span class="type">int</span> parent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> child = parent * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (child + <span class="number">1</span> &lt; sz &amp;&amp; arr[child + <span class="number">1</span>] &gt; arr[child]) child++;<span class="comment">//取较大的孩子</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (child &lt; sz)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[parent] &lt; arr[child])</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">swap</span>(arr[parent], arr[child]);</span><br><span class="line">parent = child;</span><br><span class="line"><span class="type">int</span> child = parent * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (child &gt;= sz) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (child + <span class="number">1</span> &lt; sz &amp;&amp; arr[child + <span class="number">1</span>] &gt; arr[child]) child++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heap_sort</span><span class="params">(vector&lt;T&gt;&amp; arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> sz = arr.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//建堆</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; sz; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">adjust_up</span>(arr, i);<span class="comment">//逐个插入并向上调整建堆</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = sz<span class="number">-1</span>; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">swap</span>(arr[<span class="number">0</span>], arr[i]);<span class="comment">//选出最大的元素放在末尾</span></span><br><span class="line"><span class="built_in">adjust_down</span>(arr,i,<span class="number">0</span>);<span class="comment">//向下调整建堆</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 七大排序 堆排序 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++文件操作</title>
      <link href="/2024/05/14/cpp-file-op/"/>
      <url>/2024/05/14/cpp-file-op/</url>
      
        <content type="html"><![CDATA[<p><em>注:追求代码简洁,有一致的C++风格，可参阅本篇博客，若追求更高的读写效率，建议参阅C语言篇</em> <a href="">但文章还没写</a></p><p>本篇文章主要研究头文件<code>fstream</code>中的<strong>函数</strong>和<strong>类</strong></p><p>目前C++文件操作主要有两种流派,一种是声明<code>fstream</code>对象,另一种是分开声明<code>ifstream</code>和<code>ofstream</code></p><p><strong>注意，本文代码为了简洁，都是在展开std命名空间的前提下书写</strong></p><h1 id="fstream的使用"><a href="#fstream的使用" class="headerlink" title="fstream的使用"></a>fstream的使用</h1><p>先写一段示例代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">fstream <span class="title">f</span><span class="params">(<span class="string">&quot;file.txt&quot;</span>, ios::out)</span></span>;<span class="comment">//调用构造函数以out模式打开文件file.txt 注:out模式下file.txt 会自动创建</span></span><br><span class="line">string str = <span class="string">&quot;This is a sentence&quot;</span>;<span class="comment">//在内存中准备一段字符串</span></span><br><span class="line">f &lt;&lt; str;<span class="comment">//将字符串从内存写入文件</span></span><br><span class="line">f.<span class="built_in">close</span>();<span class="comment">//关闭文件流</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//f对象可以复用</span></span><br><span class="line">f.<span class="built_in">open</span>(<span class="string">&quot;file.txt&quot;</span>, ios::in);<span class="comment">//以in模式打开file.txt</span></span><br><span class="line">string content;<span class="comment">//声明变量</span></span><br><span class="line">f &gt;&gt; content;<span class="comment">//从文件流读取数据写入变量(内存)</span></span><br><span class="line">cout &lt;&lt; content;<span class="comment">//打印出来看一眼</span></span><br><span class="line">    f.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><em>输出结果</em><br><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-05-14_18-49-56.png"></p><p>这一小段代码完成了文件的两种模式的打开和读写，已经体现了<code>fstream</code>的基本功能,接下来分别详细介绍<code>成员函数</code>和<code>操作符重载</code></p><h2 id="fstreanm-open"><a href="#fstreanm-open" class="headerlink" title="fstreanm::open()"></a>fstreanm::open()</h2><p>函数声明:<code>void open(const char* filename, ios_base::openmode mode)</code></p><p>特别的,<strong>C++11</strong>增加了一个函数重载，第一个形参变为<code>const string&amp; filename</code></p><p>实际上，也可以通过<code>fstream</code>类的构造函数来打开文件，参数与<code>open()</code>函数相同</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">fstream <span class="title">f</span><span class="params">(<span class="string">&quot;filename&quot;</span>,ios::out)</span></span>;</span><br></pre></td></tr></table></figure><p>接下来分别介绍两个形参</p><h3 id="filename"><a href="#filename" class="headerlink" title="filename"></a>filename</h3><p><strong>一般</strong>第一个形参是文件名，可以传<code>字符串</code>&#x2F;<code>char*</code>指针，C++11还支持传<code>string</code>对象</p><p>文件名没什么好说的，就是有后缀的文件要<strong>注意后缀</strong>,以及文件名要写对，勤检查</p><p><strong>但实际上</strong>,第一个形参是<code>文件路径</code>,且支持<code>相对路径</code>,<del>绝对路径我测不出来</del></p><p><em>代码示例如下</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f.<span class="built_in">open</span>(<span class="string">&quot;this,txt&quot;</span>,ios::in);<span class="comment">///打开当前文件夹的文件,this.txt是文件名</span></span><br><span class="line">f.<span class="built_in">open</span>(<span class="string">&quot;../father.txt&quot;</span>,ios::in);<span class="comment">//打开父级文件夹的文件,father.txt是文件名</span></span><br><span class="line">f.<span class="built_in">open</span>(<span class="string">&quot;./dir/child.txt&quot;</span>,ios::in);<span class="comment">//打开子级文件夹的文件(dir是文件夹名称)child.txt是文件名</span></span><br></pre></td></tr></table></figure><h3 id="mode"><a href="#mode" class="headerlink" title="mode"></a>mode</h3><p><strong>用前须知</strong>:这些<code>mode</code>都存在于<code>ios_base</code>的类域中,但由于<code>ios</code>继承自<code>ios_base</code>,混用二者皆可，本文为了简洁，指定类域时，使用<code>ios</code>，如<code>f.open(&quot;file.txt&quot;,ios::out)</code></p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-05-16_19-22-46.png"></p><p><em>上图是继承关系图，箭头指向父类</em></p><p>这里依然统一使用<code>fstream</code>类声明一个<code>f</code>对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fstream f;</span><br></pre></td></tr></table></figure><p>打开模式比较多，下面先放一张表</p><table><thead><tr><th>mode</th><th>stands for</th><th>描述</th></tr></thead><tbody><tr><td>out</td><td>output</td><td>打开文件用于<code>写入</code>,即<code>内存-&gt;文件</code>,且会<strong>完全覆盖</strong>原文件,内置的流缓存(<code>internal stream buffer</code>)支持输出操作(类似<code>cout</code>)</td></tr><tr><td>in</td><td>input</td><td>打开文件用于读取,即<code>文件-&gt;内存</code>,内置的流缓存支持输入操作(<code>类似cin</code>)</td></tr><tr><td>app</td><td>append</td><td>所有的输出操作都<strong>追加在文件末尾</strong>,向已有内容追加文本</td></tr><tr><td>trunc</td><td>truncate</td><td>在打文件<strong>前</strong>,<strong>清除所有内容</strong></td></tr><tr><td>binary</td><td>binary</td><td>所有操作都以<code>二进制</code>的形式，而不是文本</td></tr><tr><td>ate</td><td>at end</td><td>输出操作在文件末尾开始</td></tr></tbody></table><p><em>注</em>,这些<code>mode</code>能用<code>|</code>操作符连接,<strong>同时</strong>使用这些<code>mode</code></p><p><strong>但是</strong></p><p>-使用<code>trunc | app</code>会打开失败<br>-使用<code>trunc</code>而未使用<code>|</code>连接<code>out</code>,也会失败</p><p>接下来逐一介绍这些<code>mode</code></p><h4 id="out-和-in"><a href="#out-和-in" class="headerlink" title="out 和 in"></a>out 和 in</h4><p><code>out</code>是最常用的模式之一,用于<code>覆盖</code>写入文件,而且当文件不存在时，会按文件名<strong>新建</strong>一个文件并执行写入操作(哪怕是空文件)</p><p><code>in</code>也是最常用的模式之一，用于<code>只读</code>地读取文件，且当文件不存在时，会<strong>抛异常</strong>(<em>这里挖个坑</em>)</p><ul><li>使用<code>out</code>时，<code>f</code>对象支持<code>&lt;&lt;</code>流插入操作符</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">str</span><span class="params">(<span class="string">&quot;123456&quot;</span>)</span></span>;</span><br><span class="line">f&lt;&lt;str&lt;&lt;endl;<span class="comment">//和输出内容到终端(cout)是一样的</span></span><br></pre></td></tr></table></figure><ul><li>使用<code>in</code>时,<code>f</code>对象支持<code>&gt;&gt;</code>流提取和作为<code>getline</code>函数的参数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">string s1,s2;</span><br><span class="line">f&gt;&gt;s1&gt;&gt;s2;<span class="comment">//和从终端提取内容(cin)是一样的</span></span><br><span class="line"></span><br><span class="line">string line;</span><br><span class="line"><span class="built_in">getline</span>(f,line);<span class="comment">//从文件流中提取一行,存入line对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">getline</span>(f,line))<span class="comment">//逐行提取至文件末尾</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用<code>in | out</code>时，<code>f</code>同时支持以上操作</li></ul><p>但是<code>写入</code>操作又和单一个<code>out</code>不一样，<code>单out</code>是完全覆盖，不考虑原文件内容,而<code>in | out</code>时，是<strong>不完全</strong>覆盖：从头开始覆盖，新写入的内容没有原文件长时，剩下的原文件<strong>依然保留</strong></p><blockquote><p><em>示例代码</em></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">fstream f;</span><br><span class="line">f.<span class="built_in">open</span>(<span class="string">&quot;ff.txt&quot;</span>, ios::out);</span><br><span class="line">f &lt;&lt; <span class="string">&quot;LongWord&quot;</span>;<span class="comment">//准备一个有内容的原文件</span></span><br><span class="line">f.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">f.<span class="built_in">open</span>(<span class="string">&quot;ff.txt&quot;</span>, ios::in | ios::out);</span><br><span class="line">f &lt;&lt; <span class="string">&quot;1234&quot;</span>;<span class="comment">//写入1234</span></span><br><span class="line">f.<span class="built_in">close</span>();</span><br><span class="line"><span class="comment">//最后ff.txt的内容为&quot;1234Word&quot;,不完全覆盖</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>但是，同时进行流插入和流提取时，文件的操作结果会比较诡异，所以并不建议对<strong>同一个文件流</strong>同时进行读写操作。</p><p>在一段<code>f.open()</code>和<code>f.close()</code>之间依然还是只进行读取<strong>或</strong>写入中的<strong>一种</strong>，而不要混合操作</p><p><strong>缺省参数</strong>：其实<code>mode</code>形参是有缺省参数的，正是<code>ios_base::in | ios_base::out</code>,也就是说在明确只使用<code>out</code>或<code>in</code>的情况下，且执行覆盖写入操作时，单写一个<code>f.open(文件名)</code>即可</p><h4 id="其它mode"><a href="#其它mode" class="headerlink" title="其它mode"></a>其它mode</h4><h5 id="app"><a href="#app" class="headerlink" title="app"></a>app</h5><p>正如表格里描述的，使用<code>app</code>时，写入时不会覆盖远内容，而是<code>追加</code>到文件末尾。其中与<code>out</code>一样，当文件不存在时，会自动创建并写入内容。(即使没内容，也会创建空文件)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">fstream f;</span><br><span class="line"></span><br><span class="line">f.<span class="built_in">open</span>(<span class="string">&quot;file.txt&quot;</span>,ios::out);</span><br><span class="line">f &lt;&lt; <span class="string">&quot;111&quot;</span>;<span class="comment">//准备一个内容为111的文件</span></span><br><span class="line">f.<span class="built_in">close</span>();</span><br><span class="line">f.<span class="built_in">open</span>(<span class="string">&quot;file.txt&quot;</span>, ios::app);</span><br><span class="line">f &lt;&lt; <span class="string">&quot;222&quot;</span>;<span class="comment">//111后面追加222</span></span><br><span class="line">f.<span class="built_in">close</span>();</span><br><span class="line"><span class="comment">//文件内容为111222</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="trunc"><a href="#trunc" class="headerlink" title="trunc"></a>trunc</h5><p>因为不加<code>out</code>会打开失败，所以<code>trunc</code>算是个<code>out</code>的修正,在以<code>out</code>模式打开前，清空原文件的内容</p><p>乍一看，因为<code>单out</code>是<code>完全覆盖写入</code>,似乎<code>trunc</code>没什么用</p><p>但是使用<code>ios::out | ios::in | ios::trunc</code>时是不完全覆盖写入，所以提前清空内容还是很有意义的。<del>(那为啥不用单out呢)</del></p><h5 id="ate"><a href="#ate" class="headerlink" title="ate"></a>ate</h5><p>全称<code>at end</code>,单用<code>ate</code>也会打开失败,当然，<code>ios::ate | ios::out</code>没有意义，因为还是完全覆盖写入,<code>ate</code>在<code>ios::in | ios::out | ios::in</code>更加有用，可以从文件末尾追加内容</p><h5 id="binary"><a href="#binary" class="headerlink" title="binary"></a>binary</h5><p>虽然表格里是那么说了，有没有用<code>binary</code>我是真测不出差别(<del>真要用的话，另寻高就把</del>)</p><p>但是单用<code>binary</code>依然会打开失败,需要再连个<code>out</code>或<code>in</code></p><hr><h1 id="ifstream-和-ofstream"><a href="#ifstream-和-ofstream" class="headerlink" title="ifstream 和 ofstream"></a>ifstream 和 ofstream</h1><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-05-17_11-18-29.png"></p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-05-17_11-18-48.png"></p><p>上图分别为二者的继承关系,实际上二者用起来和<code>fstream</code>是基本一样的，只不过在打开文件时，一个始终自带<code>ios::in</code>,另一个始终自带<code>ios::out</code></p><h1 id="读取文件流的一些方法"><a href="#读取文件流的一些方法" class="headerlink" title="读取文件流的一些方法"></a>读取文件流的一些方法</h1><h2 id="操作符"><a href="#操作符" class="headerlink" title="&gt;&gt;操作符"></a><code>&gt;&gt;</code>操作符</h2><p>这是最容易理解的方式，和从终端读取<code>数据</code>到变量里是一样的,只要类型匹配，不一定要存到字符串里</p><h2 id="getline-函数"><a href="#getline-函数" class="headerlink" title="getline()函数"></a><code>getline()</code>函数</h2><p>用<code>getline</code>可以读取一行(即读到<code>\n</code>或文件末尾<code>EOF</code>)</p><p>但<code>getline</code>主要有两种，存在于不同的头文件中，且参数不同</p><h3 id="中的getline"><a href="#中的getline" class="headerlink" title="&lt;string&gt;中的getline"></a>&lt;string&gt;中的getline</h3><p><code>istream&amp; getline (istream&amp; is, string&amp; str);</code></p><p>函数声明如上，第一个参数是文件流(<code>fstream</code>类或<code>istream</code>类都可以),第二个参数就是个<code>string</code>对象</p><p>下面是一个逐行提取的例子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//提前准备一个待提取文件</span></span><br><span class="line">fstream f;</span><br><span class="line">f.<span class="built_in">open</span>(<span class="string">&quot;ff.txt&quot;</span>, ios::out);</span><br><span class="line">f &lt;&lt; <span class="string">&quot;line 1&quot;</span> &lt;&lt; endl &lt;&lt; <span class="string">&quot;line 2&quot;</span> &lt;&lt; endl;</span><br><span class="line">f.<span class="built_in">close</span>();</span><br><span class="line"><span class="comment">//================</span></span><br><span class="line">f.<span class="built_in">open</span>(<span class="string">&quot;ff.txt&quot;</span>);</span><br><span class="line">string str;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">getline</span>(f, str))<span class="comment">//当f为空时，循环停止</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; str &lt;&lt; endl;<span class="comment">//打印每行,str内不含换行符</span></span><br><span class="line">&#125;</span><br><span class="line">f.<span class="built_in">close</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="成员函数中的getline"><a href="#成员函数中的getline" class="headerlink" title="成员函数中的getline"></a>成员函数中的getline</h3><p><code>std::istream::getline</code></p><p>根据继承关系,<code>fstream</code>继承了来自<code>istream</code>的<code>getline</code>成员函数,也就是说它们的对象都能调用这一成员函数</p><p><code>istream&amp; getline (char* s, streamsize n );</code></p><p>函数声明如上，可以看到，第一个参数是<code>char*</code>，要传给它一个<code>字符数组</code>,第二个则是读入字符数的最大值,当实际读入的字符数<strong>小于</strong><code>n</code>时，会自动在结尾加一个<code>\0</code></p><p><del>讲真这个函数更像是来自C语言的函数</del></p><p>示例代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">fstream f;</span><br><span class="line">f.<span class="built_in">open</span>(<span class="string">&quot;ff.txt&quot;</span>, ios::out);</span><br><span class="line">f &lt;&lt; <span class="string">&quot;line 1&quot;</span> &lt;&lt; endl &lt;&lt; <span class="string">&quot;line 2&quot;</span> &lt;&lt; endl;</span><br><span class="line">f.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">f.<span class="built_in">open</span>(<span class="string">&quot;ff.txt&quot;</span>);</span><br><span class="line"><span class="type">char</span> str[<span class="number">256</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">f.<span class="built_in">getline</span>(str, <span class="number">256</span>);<span class="comment">//str里存了line 1\0</span></span><br><span class="line">f.<span class="built_in">close</span>();</span><br><span class="line">cout &lt;&lt; str;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="get-函数"><a href="#get-函数" class="headerlink" title="get() 函数"></a>get() 函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">istream&amp; <span class="title">get</span> <span class="params">(<span class="type">char</span>&amp; c)</span></span>;</span><br></pre></td></tr></table></figure><p>如上是两种常用的函数重载,均为继承来的<code>成员函数</code>,逐字符提取的话就能提取到<code>\n``\r</code>之类的转义字符</p><p>代码示例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//提前准备一个待提取文件</span></span><br><span class="line">fstream f;</span><br><span class="line">f.<span class="built_in">open</span>(<span class="string">&quot;ff.txt&quot;</span>, ios::out);</span><br><span class="line">f &lt;&lt; <span class="string">&quot;line 1&quot;</span> &lt;&lt; endl &lt;&lt; <span class="string">&quot;line 2&quot;</span> &lt;&lt; endl;</span><br><span class="line">f.<span class="built_in">close</span>();</span><br><span class="line"><span class="comment">//================</span></span><br><span class="line"><span class="comment">//方法1</span></span><br><span class="line">f.<span class="built_in">open</span>(<span class="string">&quot;ff.txt&quot;</span>);</span><br><span class="line"><span class="type">char</span> ch;</span><br><span class="line"><span class="keyword">while</span> (f.<span class="built_in">get</span>(ch))<span class="comment">//获取字符</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; ch;<span class="comment">//打印字符</span></span><br><span class="line">&#125;</span><br><span class="line">f.<span class="built_in">close</span>();</span><br><span class="line"><span class="comment">//方法2</span></span><br><span class="line">f.<span class="built_in">open</span>(<span class="string">&quot;ff.txt&quot;</span>);</span><br><span class="line"><span class="keyword">while</span> ((ch = f.<span class="built_in">get</span>()) != EOF)<span class="comment">//因为优先级的问题，必须加括号</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; ch;<span class="comment">//打印字符</span></span><br><span class="line">&#125;</span><br><span class="line">f.<span class="built_in">close</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>以上就是C++文件操作的大部分常用内容了。挖一挖确实也不少内容了,值得总结。</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ 文件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通过设计list类深入理解iterator迭代器</title>
      <link href="/2024/04/26/create-mylist/"/>
      <url>/2024/04/26/create-mylist/</url>
      
        <content type="html"><![CDATA[<p>前置博客:<strong><a href="https://www.supdriver.top/2023/12/07/cpp-class/" title="点击跳转">从构建一个Date类入门C++类与对象</a></strong><br>设计模式介绍:<em>TODO</em></p><p><code>Iterator</code>迭代器实际上也是一种设计模式，它提供了一种方法<strong>顺序访问</strong>一个聚合对象中<strong>各个元素</strong></p><blockquote><p>下面先迅速地搓一个<code>list</code>类</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="comment">//先用模板创建一个节点类</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span></span><br><span class="line">&#123;</span><br><span class="line">T _val;</span><br><span class="line">ListNode&lt;T&gt;* _next;</span><br><span class="line">ListNode&lt;T&gt;* _prev;</span><br><span class="line"></span><br><span class="line"><span class="comment">//提供全缺省的默认构造函数</span></span><br><span class="line"><span class="built_in">ListNode</span>(<span class="type">const</span> T&amp; val = <span class="built_in">T</span>()) :_val(val), _next(<span class="literal">nullptr</span>), _prev(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用ListNode构造list类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">list</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">typedef</span> ListNode&lt;T&gt; Node;<span class="comment">//用typedef简化代码</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">list</span>()<span class="comment">//默认构造函数</span></span><br><span class="line">&#123;</span><br><span class="line">_head = <span class="keyword">new</span> Node;</span><br><span class="line"><span class="comment">//维护两个指针</span></span><br><span class="line">_head-&gt;_next = _head;</span><br><span class="line">_head-&gt;_prev = _head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_front</span><span class="params">(<span class="type">const</span> T&amp; val)</span><span class="comment">//头插</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Node* newnode = <span class="keyword">new</span> <span class="built_in">Node</span>(val);</span><br><span class="line">Node* next = _head-&gt;_next;<span class="comment">//额外的指针，简化代码</span></span><br><span class="line"></span><br><span class="line">_head-&gt;_next = newnode;</span><br><span class="line">newnode-&gt;_prev = _head;</span><br><span class="line">newnode-&gt;_next = next;</span><br><span class="line">next-&gt;_prev = newnode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop_front</span><span class="params">()</span><span class="comment">//尾插</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">empty</span>()) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">Node* cur = _head-&gt;_next;</span><br><span class="line"></span><br><span class="line">_head-&gt;_next = cur-&gt;_next;</span><br><span class="line">cur-&gt;_next-&gt;_prev = _head;</span><br><span class="line"><span class="keyword">delete</span> cur;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="comment">//判空</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _head-&gt;_next == _head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//剩余代码自行补全</span></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Node* _head;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="list的迭代器"><a href="#list的迭代器" class="headerlink" title="list的迭代器"></a>list的迭代器</h1><p>不同于<code>vector</code>底层的数据在内存中<strong>连续</strong>存储,可以用<code>原生指针</code>充当迭代器,例如<code>typedef T* iterator</code></p><p><code>list</code>的底层是链表,在内存中<strong>分散</strong>*存储，是<strong>不能</strong>用<code>原生指针</code>来<strong>连续</strong>访问的,所以为了解决这一复杂问题，<br>需要自己写一个<code>iterator</code>类</p><h2 id="普通迭代器"><a href="#普通迭代器" class="headerlink" title="普通迭代器"></a>普通迭代器</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="comment">//迭代器也得用模板</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__list_iterator</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">typedef</span> __list_iterator&lt;T&gt; Self;<span class="comment">//简化代码</span></span><br><span class="line"><span class="keyword">typedef</span> ListNode&lt;T&gt; Node;</span><br><span class="line">Node* _node;</span><br><span class="line"></span><br><span class="line">__list_iterator(Node* node) :_node(node) &#123;&#125;</span><br><span class="line"></span><br><span class="line">Self&amp; <span class="keyword">operator</span>++()<span class="comment">//重载operator++</span></span><br><span class="line">&#123;</span><br><span class="line">_node = _node-&gt;_next;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> Self&amp; it) <span class="type">const</span> <span class="comment">//重载!==,比较操作符记得加const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> _node != it._node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">T&amp; <span class="keyword">operator</span>*()<span class="comment">//重载 *</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> _node-&gt;_val;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><em><code>list</code>类中添加如下代码</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">typedef</span> __list_iterator&lt;T&gt; iterator;</span><br><span class="line"></span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">iterator</span>(_head-&gt;_next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">iterator <span class="title">end</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">iterator</span>(_head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过如上修改,<code>list</code>已经支持<code>普通迭代器</code>,并且非<code>const</code>修饰的<code>list</code>已经支持<code>范围for</code>了</p><blockquote><p>测试代码如下</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">list&lt;<span class="type">int</span>&gt; lst;</span><br><span class="line">lst.<span class="built_in">push_front</span>(<span class="number">5</span>);</span><br><span class="line">lst.<span class="built_in">push_front</span>(<span class="number">4</span>);</span><br><span class="line">lst.<span class="built_in">push_front</span>(<span class="number">3</span>);</span><br><span class="line">lst.<span class="built_in">push_front</span>(<span class="number">2</span>);</span><br><span class="line">lst.<span class="built_in">push_front</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> e : lst)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; e &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="const迭代器"><a href="#const迭代器" class="headerlink" title="const迭代器"></a>const迭代器</h2><p><code>const list</code>要能提供<code>const_iterator</code>，因此我们还要写一个<code>const_iterator</code>类…吗？</p><p>其实<strong>并不用</strong>，要利用好C++中的<code>模板语法</code>来大大提高代码的复用性,尤其像<code>iterator</code>和<code>const_iterator</code>这种差别不大的类,没必要每个都单独写一段代码</p><p>为此我们的<code>__list_iterator</code>只需要能用<code>模板</code>解决好二者的差异即可。而目前最大的问题是什么？是<code>operator*()</code>的返回值问题,一个是返回<code>T&amp;</code>,另一个是<code>const T&amp;</code>,其他的成员函数则基本没差别,所以不妨扩充一下<code>模板参数</code>,添加一个<code>Ref</code>类。</p><blockquote><p>有变化的代码如下</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> <span class="title class_">Ref</span>&gt;<span class="comment">//增加一个Ref参数</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__list_iterator</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">typedef</span> __list_iterator&lt;T,Ref&gt; Self;<span class="comment">//Self这里的原类也要加</span></span><br><span class="line"><span class="keyword">typedef</span> ListNode&lt;T&gt; Node;</span><br><span class="line">Node* _node;</span><br><span class="line"></span><br><span class="line">__list_iterator(Node* node) :_node(node) &#123;&#125;</span><br><span class="line"></span><br><span class="line">Ref <span class="keyword">operator</span>*()<span class="comment">//直接返回Ref类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> _node-&gt;_val;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><em><code>list</code>类也有相应变化</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">typedef</span> __list_iterator&lt;T,T&amp;&gt; iterator;<span class="comment">//普通迭代器</span></span><br><span class="line"><span class="keyword">typedef</span> __list_iterator&lt;T,<span class="type">const</span> T&amp;&gt; const_iterator;<span class="comment">//const迭代器</span></span><br><span class="line"></span><br><span class="line">    <span class="function">const_iterator <span class="title">begin</span><span class="params">()</span> <span class="type">const</span> <span class="comment">//针对const指针的</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">const_iterator</span>(_head-&gt;_next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">const_iterator <span class="title">end</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">const_iterator</span>(_head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样通过增加一个<code>Ref</code>模板参数,完成了对<code>iterator</code>和<code>const_iterator</code>的代码级统一(<em>当然模板实例化出来是不一样的</em>)</p><p>但别忘了迭代器还要提供<code>-&gt;</code>操作符的重载,而<code>operator-&gt;()</code>函数要返回不同的指针，所以我们如法炮制，再增加一个<code>Ptr</code>模板参数</p><blockquote><p>有变化的代码如下</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> <span class="title class_">Ref</span>,<span class="keyword">class</span> <span class="title class_">Ptr</span>&gt;<span class="comment">//增加一个Ptr参数</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__list_iterator</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">typedef</span> __list_iterator&lt;T,Ref,Ptr&gt; Self;<span class="comment">//Self相应更改</span></span><br><span class="line"></span><br><span class="line">Ptr <span class="keyword">operator</span>-&gt;()<span class="comment">//重载-&gt;</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> &amp;(_node-&gt;_val);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><em><code>list</code>类也有相应变化</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">typedef</span> __list_iterator&lt;T,T&amp;,T*&gt; iterator;<span class="comment">//普通迭代器</span></span><br><span class="line"><span class="keyword">typedef</span> __list_iterator&lt;T,<span class="type">const</span> T&amp;,<span class="type">const</span> T*&gt; const_iterator;<span class="comment">//const迭代器</span></span><br></pre></td></tr></table></figure><p>至此，<code>list</code>和<code>__list_iterator</code>的基本功能已基本完成，本篇的重点<code>__list_iterator</code>主要解决了两点问题</p><p>-为了应对<code>list</code>的迭代器的复杂性，单独为其构建一个<code>__list_iterator</code>类，并提供一系列的操作符重载<br>-为了提高代码的<strong>复用性</strong>,仅用一个<code>__list_iterator</code>类来<code>typedef</code>普通迭代器和<code>const</code>迭代器,我们增加了模板参数,最终模板变为<code>template&lt;class T, class Ref, class Ptr&gt;</code></p><h2 id="用普通迭代器构造const迭代器"><a href="#用普通迭代器构造const迭代器" class="headerlink" title="用普通迭代器构造const迭代器"></a>用普通迭代器构造const迭代器</h2><p>有时候我们需要用普通迭代器构造<code>const</code>迭代器,于是可以给<code>__list_iterator</code>提供一个比较有意思的<code>构造函数</code>,<br>可以实现时而充当拷贝构造，时而充当满足上述的构造</p><blockquote><p>代码如下</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> __list_iterator&lt;T,Ref,Ptr&gt; Self;<span class="comment">//再展示一遍Self的代码，便于下文对比</span></span><br><span class="line"><span class="keyword">typedef</span> __list_iterator&lt;T,T&amp;,T*&gt; iterator;<span class="comment">//指定普通迭代器，并用typedef简化代码</span></span><br><span class="line"></span><br><span class="line">__list_iterator(iterator it) :_node(it._node) &#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>-当模板参数为<code>&lt;T,T&amp;,T*&gt;</code>时，<code>Self</code>和<code>iterator</code>相同，上段代码中的构造函数相当于<code>拷贝构造</code></p><p>-当模板参数为<code>&lt;T,const T&amp;,const T*&gt;</code>时，<code>Self</code>和<code>iterator</code>不同,<code>Slef</code>是<code>const</code>迭代器,<code>iterator</code><strong>始终</strong>是普通迭代器，这个构造函数便能用普通迭代器构造<code>const</code>迭代器</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>通过构造一个<code>list</code>类，我们使用到了更复杂的迭代器，使用了带<code>3个模板参数</code>的<code>__list_iterator</code>类定义普通迭代器和<code>const</code>迭代器，学习了如何利用模板参数提高代码的复用性，如何提供额外的<code>构造函数</code>使<code>__list_iterator</code>支持用普通迭代器构造<code>const</code>迭代器</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ 类和对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vim基础指令集</title>
      <link href="/2023/12/11/vim-cmd/"/>
      <url>/2023/12/11/vim-cmd/</url>
      
        <content type="html"><![CDATA[<p><code>Vim</code>是一款文本编辑器,下面介绍在vim界面中的常用指令</p><p><strong>三种模式</strong>:<code>命令模式(Command Mode)</code> <code>插入模式（Insert Mode</code> <code>命令行模式（Command-Line Mode）</code>（这里称命令行模式为<code>底行模式</code>）</p><p>三者关系如下图</p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2023-12-11_10-39-04.png"></p><h1 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h1><p><code>vim</code>界面中多摁几次<code>ESC</code>就能退出其它模式回到<code>命令模式</code>，在这个模式下可以使用一系列vim<a href="https://linux.cn/article-8144-1.html">快捷键</a></p><h1 id="底行模式"><a href="#底行模式" class="headerlink" title="底行模式"></a>底行模式</h1><p><code>tips</code>:不管目前是什么模式,先狂按<code>ESC</code>,回到<code>命令模式</code>,然后输入<code>:</code>进入<code>底行模式</code>,准备开始输命令</p><p><code>命令组成</code><br><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2023-12-11_12-48-54.png"></p><ul><li>保存<code>:w</code>-&gt;强制保存<code>!w</code></li><li>退出<code>:q</code>-&gt;强制退出<code>:!q</code></li><li>保存并退出<code>:wq</code>-.强制保存并退出<code>:!wq</code></li><li>对比<code>:vs </code>+<code>(源文件路径)</code></li></ul><h1 id="插入模式"><a href="#插入模式" class="headerlink" title="插入模式"></a>插入模式</h1><p>在<code>命令模式</code>下按键盘<code>i</code>进入<code>插入模式</code>，执行正常的文本编辑功能</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从构建一个Date类入门C++类与对象</title>
      <link href="/2023/12/07/cpp-class/"/>
      <url>/2023/12/07/cpp-class/</url>
      
        <content type="html"><![CDATA[<h1 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">(<span class="type">int</span> year = <span class="number">1</span>,<span class="type">int</span> month = <span class="number">1</span>,<span class="type">int</span> day = <span class="number">1</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _year = year;</span><br><span class="line">        _month = month;</span><br><span class="line">        _day = day;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; _year &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; _month &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; _day &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _year;</span><br><span class="line">    <span class="type">int</span> _month;</span><br><span class="line">    <span class="type">int</span> _day;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="抽象数据类型-类"><a href="#抽象数据类型-类" class="headerlink" title="抽象数据类型(类)"></a>抽象数据类型(类)</h2><p>通过如上代码，我们就在源代码中通过<code>class</code>声明了一个抽象数据类型<code>Date</code>,简称<code>类</code>，那么封装一个类有什么好处呢？<br>好处是类把相关的操作分为<strong>两类</strong>:</p><ul><li>类的<strong>设计者</strong>:负责考虑类的具体实现，提供类的接口，成员变量等</li><li>类的<strong>使用者</strong>:只关心类<strong>提供</strong>了哪些功能，而不关心具体实现，从而简化思路</li></ul><p>以上面的<code>Date</code>类为例</p><blockquote><p>对设计者</p></blockquote><ul><li>要考虑实现<code>Date</code>,就需要声明<strong>成员变量</strong><code>_year</code> <code>_month</code> <code>_day</code>,以及声明及实现<strong>成员函数</strong><code>Init</code>和<code>Print</code></li></ul><blockquote><p>对使用者</p></blockquote><ul><li>只需知道可以调用<code>Date</code>的<strong>成员函数</strong><code>Init</code>和<code>Print</code>,以及知道它们的用处即可</li></ul><h2 id="实例化-–-将类真正投入使用"><a href="#实例化-–-将类真正投入使用" class="headerlink" title="实例化 – 将类真正投入使用"></a>实例化 – 将类真正投入使用</h2><p>类也可以用于声明变量，例如<code>Date d</code>就声明了一个变量<code>d</code>,但由于是由<code>类</code>声明的,我们将这一过程称为<code>实例化</code>,其中<code>Date</code>这样的抽象数据类型称为<code>类</code>，像<code>d</code>这样的变量称为<code>对象</code></p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-04-16_11-19-21.png"></p><p>实例化后的对象拥有<strong>私有</strong>的<code>成员变量</code>和整个类<strong>公有</strong>的<code>成员函数</code>,接下来对<code>对象</code>的操作都是对<code>成员变量</code>和<code>成员函数</code>的操作</p><h2 id="访问成员函数-变量"><a href="#访问成员函数-变量" class="headerlink" title="访问成员函数&#x2F;变量"></a>访问成员函数&#x2F;变量</h2><h3 id="在类的内部"><a href="#在类的内部" class="headerlink" title="在类的内部"></a>在<code>类的内部</code></h3><p>对于类的成员函数，除了显式声明的<code>函数参数</code>外,还有<strong>隐式</strong>传入的<code>this</code>指针，这是个<strong>默认<code>非const</code>修饰</strong>的,指向调用该成员函数的<strong>对象的指针</strong>,编译器可以通过这个指针访问该对象的<code>成员变量</code>和<code>成员函数</code>。</p><p>而我们作为类的<strong>设计者</strong>，既然语法都<strong>隐式</strong>地传入<code>this</code>指针了，自然也可以<strong>隐式</strong>地调用<code>成员</code>,即<strong>直接写</strong>变量名&#x2F;函数名调用</p><p><em>当然，手动显式调用this指针也是可以的</em></p><blockquote><p>以<code>Date</code>为例</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该函数声明在Date类中，成员变量见文章开头</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestPrint</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _year = <span class="number">2024</span>;<span class="comment">//隐式调用this访问成员变量</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;_month = <span class="number">4</span>;<span class="comment">//显式调用this</span></span><br><span class="line">    _day = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">Print</span>();<span class="comment">//隐式调用this来调用成员函数Print()</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">Print</span>();<span class="comment">//显式调用this，效果与上一句相同</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但由于<code>const</code>修饰的<code>对象</code>传出的是<code>const</code>修饰的<code>this</code>指针，普通的<code>this</code>形参无法接收。<br>那么如何让<code>成员函数</code>传入<code>const</code>修饰的<code>this</code>指针,来使<code>const</code>修饰的<code>对象</code>有成员函数可调用呢？</p><p>语法规定，在函数的参数列表(<em>圆括号后面</em>)紧跟一个<code>const</code>可使函数传入<code>const</code>修饰的<code>this</code>指针</p><p><em>这种函数称为常量成员函数</em></p><blockquote><p><em>举个例子</em></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="comment">//该函数声明在类中</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">constPrint</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在类的外部"><a href="#在类的外部" class="headerlink" title="在类的外部"></a>在<code>类的外部</code></h3><p>和C语言的结构体一样，访问对象内的成员有两种方式</p><ul><li><em>对象名</em> + <code>.</code> + 成员名 ： 用<code>.</code>操作符访问对应成员</li><li><em>对象的指针</em> + <code>-&gt;</code> + 成员名 : 用<code>-&gt;</code>操作符访问指针<strong>指向对象</strong>的对应成员</li></ul><blockquote><p>以<code>Date</code>实例化一个<code>d</code>为例</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// class Date</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     ....</span></span><br><span class="line"><span class="comment">// &#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Date d;</span><br><span class="line">    Date* pd = &amp;d;</span><br><span class="line">    d.<span class="built_in">Init</span>(<span class="number">2024</span>,<span class="number">4</span>,<span class="number">1</span>);<span class="comment">// . 操作符调用Init成员函数来初始化对象</span></span><br><span class="line">    pd-&gt;<span class="built_in">Print</span>();<span class="comment">//-&gt;操作符调用Print成员函数来打印内容</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Date d;</span><br><span class="line">    d._year = <span class="number">2024</span>;<span class="comment">//试图访问成员变量_year,但是访问权限冲突</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test1输出</span></span><br><span class="line"><span class="number">2024</span>:<span class="number">4</span>:<span class="number">1</span></span><br><span class="line"><span class="comment">//test2输出</span></span><br><span class="line">报错，无输出，因为访问权限冲突</span><br></pre></td></tr></table></figure><p>代码如上，<code>test1</code>运行的很好，但<code>test2</code>报错了，原因在于<code>test2</code>作为<strong>非成员函数</strong>访问了访问限定符<code>private</code>控制的成员<code>_year</code>,权限冲突，就会报错。</p><p>由此，C++类和对象还有一个重要概念需要强调–<strong>访问控制</strong></p><h2 id="访问权限控制与封装"><a href="#访问权限控制与封装" class="headerlink" title="访问权限控制与封装"></a>访问权限控制与封装</h2><p>使用类和对象编程的一大优点就是类可以<code>封装</code>代码，让使用者只能使用公有的接口和成员变量，而对内部的具体实现不可见，来提高类的<code>易用性</code>和<code>安全性</code></p><p>所以C++语法提供了三种<code>访问说明符</code>(<em>access specifiers</em>)</p><ul><li>public: 该说明符之后的成员在整个程序内可被访问</li><li>private: 之后的成员仅可被该类的的类域里（<em>如成员函数</em>）访问</li><li>protected: 一般同<code>private</code>,主要特点体现在类的继承，这里<strong>不作讨论</strong></li></ul><h3 id="作用范围"><a href="#作用范围" class="headerlink" title="作用范围"></a>作用范围</h3><p>某一<code>访问说明符</code>的作用范围开始于它的<code>冒号</code>,终止于下一个<code>访问说明符</code>或<code>类的结尾</code>,而<code>类的开始</code>到第一个<code>访问说明符</code>前的访问权限取决于<strong>声明</strong>类的<code>关键字</code>,分类如下</p><ul><li><code>class</code>默认为<code>private</code>权限</li><li><code>struct</code>默认为<code>public</code>权限</li></ul><blockquote><p>图例如下</p></blockquote><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-04-18_14-15-40.png"></p><p>实际上<code>class</code>和<code>struct</code>除了默认权限不一样，基本<strong>没有差别</strong>。</p><p>所以为了防止误读，<strong>提高可读性</strong>,<strong>不建议</strong>在<code>默认区</code>写代码,而是保证每段语句前都有合适的<code>访问限定符</code></p><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>作为类的设计者，一个类按<code>访问权限</code>可以分为两个区</p><ul><li><code>public</code>: 将提供给<code>使用者</code>的<code>接口（函数）</code>和<code>成员变量</code>声明在此，用于外部调用接口和修改非私有的成员函数</li><li><code>private</code>: 用于存放<strong>受保护</strong>的<code>成员变量</code>和<code>成员函数</code>,防止外部使用者<em>意外</em>或<em>恶意</em>调用或修改,造成类的内部结构被破坏等<strong>安全问题</strong>,所以特别重要的成员变量，和不希望被外部调用的函数声明在这里</li></ul><blockquote><p>例如在声明<code>Date</code>类时，我们将<code>Init</code>和<code>Print</code>接口提供给使用者，用<code>public</code>控制；<code>_year</code>等成员变量不希望被外部随意修改，就用<code>private</code>控制</p></blockquote><h1 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h1><p>学完以上内容，不过是会写个高级点的<code>结构体</code>而已，要写一个完整的类，还需要学习更多的语法知识</p><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>像本篇的<code>Date</code>类那样显式地调用<code>Init</code>函数来初始化是非常挫的，既然语言本身的<code>内置类型</code>可以在声明的时候初始化，那么类的设计者设计出来的类也应当提供<code>初始化的接口</code>,而支持这一功能的接口便是<code>构造函数</code></p><p>按语法规定，<code>构造函数</code>的函数名必须是<code>类名</code>,<strong>没有返回值</strong>，<code>const</code>修饰的成员变量必须位于<code>初始化列表</code>,其它则可省略。<em>关于初始化列表，稍后详细解释</em></p><blockquote><p>以<code>Date</code>类为例</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//一个普通的构造函数</span></span><br><span class="line">    <span class="built_in">Date</span>(<span class="type">int</span> year,<span class="type">int</span> month,<span class="type">int</span> day)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//进入括号时成员变量已经声明，且未初始化</span></span><br><span class="line">        _year = year;<span class="comment">//这是一个赋值操作，而不是初始化</span></span><br><span class="line">        _month = month;</span><br><span class="line">        _day = day;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _year;</span><br><span class="line">    <span class="type">int</span> _month;</span><br><span class="line">    <span class="type">int</span> _day;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Date <span class="title">d</span><span class="params">(<span class="number">2024</span>,<span class="number">4</span>,<span class="number">1</span>)</span></span>;<span class="comment">//使用构造函数声明了一个d对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以上的构造函数基本能用了,但还有两个问题</p><ul><li>构造函数没有初始化成员变量，而是采用赋值操作,无法初始化<code>const</code>修饰的成员变量</li><li>使用<code>Date d</code>是会报错的，因为没有提供<code>默认构造函数</code></li></ul><p>对于<strong>第一个问题</strong>，就要引入<code>初始化列表</code>这一概念，让初始化函数直接拥有<code>初始化成员变量</code>的功能</p><p>初始化列表位于构造函数的参数列表之后，花括号之前，以<code>:</code>开头，用<code>,</code>分隔成员变量</p><blockquote><p>以<code>Date</code>为例</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Date</span>(<span class="type">int</span> year,<span class="type">int</span> month,<span class="type">int</span> day):_year(year) , _month(month) , _day(day) &#123;&#125;</span><br><span class="line"><span class="comment">//或者换个书写格式（二者完全等价）</span></span><br><span class="line"><span class="built_in">Date</span>(<span class="type">int</span> year,<span class="type">int</span> month,<span class="type">int</span> day):_year(year) </span><br><span class="line">, _month(month) </span><br><span class="line">, _day(day) </span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure><p>通过这样<code>初始化列表</code>,便能在声明对象时，<strong>直接</strong>初始化成员变量</p><p>对于<strong>问题二</strong>，我们开启另一个个小专题</p><h3 id="构造函数的重载和缺省参数"><a href="#构造函数的重载和缺省参数" class="headerlink" title="构造函数的重载和缺省参数"></a>构造函数的重载和缺省参数</h3><p>没错，构造函数和函数一样，也是能<code>重载</code>和给参数传<code>缺省值</code>的</p><p><em>也就是说我们能写好几个构造函数</em></p><p>下面特别说明几个<strong>特殊</strong>的构造函数</p><h4 id="默认构造函数"><a href="#默认构造函数" class="headerlink" title="默认构造函数"></a>默认构造函数</h4><p>原则上对于每一个类，都应该提供<strong>有且仅有一个</strong>默认构造函数（*多个<code>默认构造函数</code>会报错!*）</p><p>而要<strong>声明</strong>默认构造函数，只需声明<code>无参数</code>构造函数，或者<code>全缺省参数</code>构造函数即可</p><blockquote><p>以<code>Date</code>为例</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Date</span>():_year(<span class="number">2024</span>),_month(<span class="number">4</span>),_day(<span class="number">1</span>)&#123;&#125;</span><br><span class="line"><span class="comment">//====分割线=======</span></span><br><span class="line"><span class="comment">//或者全缺省，两个函数不能同时声明</span></span><br><span class="line"><span class="built_in">Date</span>(<span class="type">int</span> year = <span class="number">2024</span>,<span class="type">int</span> month = <span class="number">4</span>,<span class="type">int</span> day = <span class="number">1</span>): _year(year),_month(month),_day(day)&#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以上就是两种默认构造函数的声明形式</p><h4 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h4><p>有时候我们会希望用<strong>现有的</strong>的对象去初始化一个<strong>新</strong>对象,此时对应的构造函数就称为<code>拷贝构造（函数）</code></p><p><code>拷贝构造</code>的声明方式为<code>构造函数</code>+参数类型为<code>类本身的引用传参</code>,不加<code>&amp;</code>的话就会死递归报错,有无<code>const</code>皆可，但由于是实现<code>拷贝功能</code>，一般是加<code>const</code>的</p><blockquote><p>以<code>Date</code>为例</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Date</span>(<span class="type">const</span> Date&amp; d):_year(d._year),_month(d._month),_day(d._day)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用示例</span></span><br><span class="line"><span class="function">Date <span class="title">d</span><span class="params">(<span class="number">2024</span>,<span class="number">4</span>,<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="function">Date <span class="title">copy1</span><span class="params">(d)</span></span>;<span class="comment">//调用方式一</span></span><br><span class="line">Date copy2 = d;<span class="comment">//调用方式二,此时不会调用operator=()</span></span><br><span class="line"></span><br><span class="line">copy1 = copy2;<span class="comment">//这种并不会调用拷贝构造,而是调用operator=()</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="使用模板的类的函数缺省值"><a href="#使用模板的类的函数缺省值" class="headerlink" title="使用模板的类的函数缺省值"></a>使用模板的类的函数缺省值</h4><p>有时我们在使用类模板来设计类时，需要给<code>模版类</code>类型的形参提供一个缺省值，有些人可能会写个<code>0</code>,但是其实是<strong>错的</strong>，正确的做法是传一个<code>临时变量</code></p><p>但此时要求<code>模板参数中的类</code>有可用的<code>默认构造函数</code>和<code>拷贝构造</code>用于调用</p><blockquote><p>以链表节点<code>Node</code>为例</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">value_type</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    value_type _val;</span><br><span class="line">    Node&lt;value_type&gt;* _next;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">const</span> value_type&amp; val = <span class="built_in">value_type</span>()):_val(val),_next(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以用本文的Date实例化为例</span></span><br><span class="line">Node&lt;Date&gt; node;</span><br><span class="line"><span class="comment">//通过输出会发现node中的val已经调用了默认构造函数</span></span><br><span class="line">node.val.<span class="built_in">TestPrint</span>();</span><br></pre></td></tr></table></figure><h2 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h2><p>对于声明在<code>栈区</code>或<code>静态区</code>的成员函数，程序完全可以自动销毁，<br>但如果<code>成员变量</code>有指向在<code>堆区</code>声明的某段<code>内存块</code>,在该如果只是仍由程序自动<br>销毁这个指针，那么那段<code>内存块</code>就会一直处于<strong>未释放</strong>的状态，也就是造成内存泄漏，<br>也就是说此时编译器自动生成的<code>析构函数</code>已经不能满足需求,编译器并不知道如何处理声明在<code>堆区</code>上的数据,<br>这部分操作应由类的设计者来规划</p><p>所以我们应当<strong>显式</strong>地声明一个合理的<code>析构函数</code></p><p><code>析构函数</code>的函数名也是由语法规定的，为<code>~</code>+<code>类名</code>,并且<strong>不能</strong>声明形参</p><blockquote><p>以一个<code>指针类</code>为例</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Ptr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Ptr</span>()<span class="comment">//构造函数</span></span><br><span class="line">    &#123; </span><br><span class="line">        _ptr = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">1</span>); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Ptr</span>()<span class="comment">//析构函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> _ptr;<span class="comment">//手动delte堆区上的数据</span></span><br><span class="line">        _ptr = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span>* _ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类的重载操作符"><a href="#类的重载操作符" class="headerlink" title="类的重载操作符"></a>类的重载操作符</h2><p>C++语法提供了重载操作符的函数，而由于<code>this</code>指针的存在，在类的<code>内部声明</code>重载操作符函数会稍有不同</p><p>-对于一元操作符，<code>[]</code>,<code>-&gt;</code>之类的重载，不再需要<code>显式传参</code><br>-对于二元操作符，<code>+</code>,<code>&gt;</code>之类只需要传<code>右操作数</code></p><blockquote><p>以<code>Date</code>类为例</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在类的内部,重构一个 ==</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Date&amp; date) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> _year == date._year</span><br><span class="line">            &amp;&amp; _month == date._month</span><br><span class="line">            &amp;&amp; _day == date._day;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>至此，C++类和对象已基本入门，再进阶的<code>迭代器</code>,<code>继承</code>,<code>虚继承</code>等将单独出博客。</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ 类和对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>指针详解</title>
      <link href="/2023/11/23/pointer/"/>
      <url>/2023/11/23/pointer/</url>
      
        <content type="html"><![CDATA[<p><em>这篇质量不太行:（</em></p><h1 id="内存和地址"><a href="#内存和地址" class="headerlink" title="内存和地址"></a>内存和地址</h1><p>在了解指针之前，先讲讲内存是如何管理的</p><p>首先因为内存很大（一般有几个G）,所以为了高效管理，有了<code>内存单元</code>的概念。而这个单元的大小，正好是一个字节。</p><p>因为一个<code>比特位</code>就是一个二进制位，太小了，超过一个字节，在处理<code>char</code>这样一个字节长的变量很麻烦。</p><p>定下长度后，就可以给内存单元编号，而每个内存单元获得的独一无二的编号，便是它的<strong>地址</strong>,以声明了一个变量a为例,示意图如下</p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-23_09-59-30.png"></p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-23_10-21-48.png"></p><h2 id="变量的地址"><a href="#变量的地址" class="headerlink" title="变量的地址"></a>变量的地址</h2><p>上图中<code>a</code>占4个字节，每个字节都有自己的地址，但要找到<code>a</code>其实只需要找到第一个地址就行了，实际上在<code>C语言</code>中也是如此,<code>a</code>的地址就是<code>首字节地址</code>,即图中的<code>0x000000AF88DFF6A4</code></p><h2 id="关于几个名词"><a href="#关于几个名词" class="headerlink" title="关于几个名词"></a>关于几个名词</h2><p>在<code>C语言</code>中称<code>地址</code>为<code>指针</code>,<strong>储存</strong>地址的变量叫<code>指针变量</code>,平时也<strong>简称</strong><code>指针</code>,此时强调的是<code>指针变量</code>里储存的地址，而不是这个变量。</p><h2 id="指针变量的组成"><a href="#指针变量的组成" class="headerlink" title="指针变量的组成"></a>指针变量的组成</h2><p>指针变量也要<strong>拆成两部分</strong>来看</p><p>一个是变量的<code>值</code>,在同一个程序中，所有指针变量的值的<code>长度</code>都是一样的，都指向了某<strong>一</strong>个内存中的<code>字节</code>, 至于具体多长，取决于环境:<code>32位程序是4个字节</code>,<code>64位程序是8个字节</code></p><p>另一个是变量的<code>类型</code>,类型决定编译器从<code>值</code>所指向的字节，向后总共读<strong>几个</strong>字节，以及用<strong>什么方式</strong>读取内存里的内容。以下图的代码为例</p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-23_11-36-47.png"></p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-23_11-29-53.png"></p><p>可以看到三种指针指向了<strong>同一个</strong>字节，即它们的值是相等的，但<code>指针类型</code>不同，解引用之后得到的<code>值</code>也不同,</p><p><code>char</code>比<code>int</code>短，所以<code>*p_char</code>只能取到<code>00</code>,</p><p>而虽然<code>float</code>和<code>int</code>一样长，但对内存的<strong>读法不同</strong>，所以<code>*p_float</code>和<code>*p_int</code>依然不同</p><h1 id="指针-变量-的使用"><a href="#指针-变量-的使用" class="headerlink" title="指针(变量)的使用"></a>指针(变量)的使用</h1><h2 id="声明指针变量"><a href="#声明指针变量" class="headerlink" title="声明指针变量"></a>声明指针变量</h2><p>指针变量也是变量，在没有结合性问题时，和一般变量的声明方式差不多。</p><p>变量的声明:<code>变量类型</code> + <code>变量名</code></p><p>指针的声明:<code>指向的变量类型</code> + <code>*</code> + <code>变量名</code></p><p>以下以声明一个字符指针为例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* pointer = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-24_10-02-19.png"></p><p><em>变量的声明逻辑如上图</em></p><h3 id="进阶：二级指针-N级指针"><a href="#进阶：二级指针-N级指针" class="headerlink" title="进阶：二级指针-&gt;N级指针"></a>进阶：二级指针-&gt;N级指针</h3><p>我们可以用同样的逻辑声明更高级的指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* *ppstr = <span class="literal">NULL</span>;<span class="comment">//ppstr是一个二级指针</span></span><br><span class="line"><span class="type">char</span>** *ppstr = <span class="literal">NULL</span>;<span class="comment">//pppstr是一个三级指针</span></span><br></pre></td></tr></table></figure><p>在声明中,前面的<code>char*</code>声明了<code>ppstr</code><strong>指向</strong>的变量类型,后面的<code>*</code>与<code>变量名</code>结合，声明<code>ppstr</code>是一个指针.</p><p>此处，称指向<code>一级指针</code>的指针为<code>二级指针</code>,同理有<code>三级指针</code>,至<code>N级指针</code>.</p><h2 id="指针的解引用"><a href="#指针的解引用" class="headerlink" title="指针的解引用"></a>指针的解引用</h2><p>指针最常见的用处就是通过变量里<strong>储存的地址</strong>，通过直接修改目标变量的<strong>内存</strong>来修改变量的值 ， 当然还有强制转换指针类型来读取目标变量的<strong>一部分</strong>内存 之类的骚操作</p><h3 id="函数的传址调用"><a href="#函数的传址调用" class="headerlink" title="函数的传址调用"></a>函数的传址调用</h3><p>在遇到指针前，使用函数时，由于实参传到函数里都变成了<strong>形参</strong>,无法通过形参（<em>包括修改形参的值</em>）来改变实参的值，因为形参终究只是实参的一份<strong>临时拷贝</strong>.</p><p>而有了指针之后，函数的实参，形参关系不变，但我们有了<strong>更高端</strong>的形参,也就是<code>指针</code>, 尽管<code>函数内的指针</code>依旧是<code>函数外的指针</code>的<strong>临时拷贝</strong>,但我们已经能通过其储存的<strong>值</strong>访问<code>函数外变量</code>的内存了,同时包括<code>读取</code>和<code>修改</code>, 这种通过传入指针来修改外部变量的函数调用，便称为<code>函数的传址调用</code></p><p><em>以如下代码为例</em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Swap_int</span><span class="params">(<span class="type">int</span>*a,<span class="type">int</span>*b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//给我两个整型的地址，我就能 真·交换它们的值</span></span><br><span class="line">    <span class="type">int</span> tmp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="提问-如何修改函数外的指针的值"><a href="#提问-如何修改函数外的指针的值" class="headerlink" title="提问?如何修改函数外的指针的值?"></a>提问?如何修改函数外的指针的值?</h4><p>依然还是把这一<strong>指针的地址</strong>传进去，而函数的形参写成<strong>更高一级</strong>的指针</p><p><em>如下代码，例如我想在函数里把外部的指针置空</em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Reset</span><span class="params">(<span class="type">char</span>* *pstr)</span> </span><br><span class="line">&#123;</span><br><span class="line">    *pstr = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span>* str;</span><br><span class="line">    Reset(&amp;str)<span class="comment">//对一级指针取地址，传入二级指针</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="有关指针的危险操作"><a href="#有关指针的危险操作" class="headerlink" title="有关指针的危险操作"></a>有关指针的危险操作</h1><h2 id="野指针的解引用"><a href="#野指针的解引用" class="headerlink" title="野指针的解引用"></a>野指针的解引用</h2><p>有些指针因为错误操作，指向了不能访问的内存，一旦解引用，就有可能使程序崩溃</p><p><em>情形如下</em></p><h3 id="使用了-未初始化-赋值-的指针"><a href="#使用了-未初始化-赋值-的指针" class="headerlink" title="使用了 未初始化&#x2F;赋值 的指针"></a>使用了 未初始化&#x2F;赋值 的指针</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* pa;<span class="comment">//未初始化，pa的值为随机值</span></span><br><span class="line">*pa = <span class="number">0</span> ;<span class="comment">//野指针的解引用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//正确的用法</span></span><br><span class="line"><span class="type">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* pa;</span><br><span class="line">pa = arr;<span class="comment">//立即初始化</span></span><br><span class="line"><span class="type">int</span>* pb = <span class="literal">NULL</span>;<span class="comment">//初始化</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>所以声明指针时最好初始化,如果不知道初始化成什么，就用<code>NULL</code>空指针初始化</p><h3 id="指向了-已回收的-内存空间"><a href="#指向了-已回收的-内存空间" class="headerlink" title="指向了 已回收的 内存空间"></a>指向了 已回收的 内存空间</h3><p>有的函数<strong>错误</strong>*地返回了内部临时变量的地址， 在<strong>外面</strong>使用返回的指针，因为此时函数的栈帧已经<strong>销毁</strong>，会发生野指针的解引用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">fun</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span>* pa = &amp;a;</span><br><span class="line">    <span class="keyword">return</span> pa;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//情形一</span></span><br><span class="line">    <span class="type">char</span>* pa = fun();</span><br><span class="line">    *pa = <span class="number">1</span>;<span class="comment">//此时变量a已经销毁，发生野指针的解引用，即非法访问</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//情形二</span></span><br><span class="line">    <span class="type">char</span>* str = (<span class="type">char</span>*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>) *<span class="number">10</span>) <span class="comment">//在堆区开辟10个字节的空间</span></span><br><span class="line">    <span class="built_in">free</span>(str);<span class="comment">//然后释放掉</span></span><br><span class="line">    str[<span class="number">0</span>] = <span class="string">&#x27;A&#x27;</span>;<span class="comment">//试图访问已free的内存，并写入，发生非法访问</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="空指针的解引用"><a href="#空指针的解引用" class="headerlink" title="空指针的解引用"></a>空指针的解引用</h2><p>空指针<code>NULL</code>,<code>值</code>为<code>0</code>,一旦解引用就会报错，所以在解引用陌生指针时一定要注意判空</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//情形一</span></span><br><span class="line"><span class="type">char</span>* <span class="title function_">func</span><span class="params">(<span class="type">char</span>* str)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(str == <span class="literal">NULL</span>)<span class="comment">//防止使用者错误传入空指针</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//情形二</span></span><br><span class="line"><span class="type">char</span>* <span class="title function_">InitArray</span><span class="params">(<span class="type">char</span>** pstr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(pstr == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    *pstr = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>) * <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">if</span>(*ptr == <span class="literal">NULL</span>)<span class="comment">//malloc一旦失败就会返回NULL,所以调用后一定要判空</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>=C入门=深入研究 字符串与字符数组</title>
      <link href="/2023/11/08/str-arr/"/>
      <url>/2023/11/08/str-arr/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是字符串"><a href="#什么是字符串" class="headerlink" title="什么是字符串"></a>什么是字符串</h1><h2 id="初见字符串"><a href="#初见字符串" class="headerlink" title="初见字符串"></a>初见字符串</h2><p>我们最先遇到的字符串,一般是<code>hello_world</code>程序中用到的<code>&quot;hello world&quot;</code>,也就是<strong>两个双引号括起来的一串字符</strong>,输出时的占位符是<code>%s</code>,可以直接拿去传值，代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,<span class="string">&quot;hello world&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="声明字符串变量"><a href="#声明字符串变量" class="headerlink" title="声明字符串变量"></a>声明字符串变量</h2><p>有时我们想要先把字符串存起来，再进行操作，那么就使用<strong>字符数组</strong>，并在<strong>初始化</strong>的时候把字符串传给它,这样在<strong>创建数组</strong>时会编译器会自动分配内存给它，代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[] = <span class="string">&quot;abcdef&quot;</span>;</span><br></pre></td></tr></table></figure><p>此时我们也可以开启VS的<strong>调试</strong>，并打开<strong>内存</strong>和<strong>监视</strong>窗口观察字符串是如何在内存中储存的,如下图</p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-09_10-06-06.jpg"></p><p>通过观察可以发现，C语⾔字符串的字符串有个<code>规定</code>(特点)，就是以字符<code>\0</code>结尾，无论是初始化数组时，还是在分配内存时，都有<code>\0</code>的位置。</p><h3 id="strlen-函数"><a href="#strlen-函数" class="headerlink" title="strlen()函数"></a>strlen()函数</h3><p>依据以<code>\0</code>为字符串结尾的规则，<code>strlen</code>函数就可以计算字符串的长度，它会从字符串的第一个字符向后扫描，直到遇到<code>\0</code>结束,且<code>\0</code>不进入计数，最后返回字符串的长度,代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span> <span class="comment">//需要引对应的头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> len = <span class="built_in">strlen</span>(<span class="string">&quot;abcdef&quot;</span>);<span class="comment">//len的值为6</span></span><br><span class="line"><span class="type">int</span> sz = <span class="keyword">sizeof</span>(<span class="string">&quot;abcdef&quot;</span>);<span class="comment">//sz的大小为7(\0被计入总数)</span></span><br></pre></td></tr></table></figure><h3 id="验证字符串的结尾"><a href="#验证字符串的结尾" class="headerlink" title="验证字符串的结尾"></a>验证字符串的结尾</h3><h4 id="正向验证"><a href="#正向验证" class="headerlink" title="正向验证"></a>正向验证</h4><p>我们做在字符数组里插入一个<code>\0</code>,来看看函数<code>printf</code>和<code>strlen</code>找到的结尾在哪里,如下图</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[] = &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;\0&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;f&#x27;</span>,<span class="string">&#x27;\0&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-09_11-01-35.jpg"></p><p>可以看到字符数组似乎被“截断”了，<code>printf</code>只输出了<code>\0</code>前面的内容, <code>strlen</code>算出来的长度也只有<code>3</code>,可见插入的<code>\0</code>被作为了<strong>字符串</strong>的结尾，字符串提前中指,而没到达<strong>字符数组</strong>的结尾</p><h4 id="反向验证"><a href="#反向验证" class="headerlink" title="反向验证"></a>反向验证</h4><p>我们来<strong>反向</strong>验证一下，<code>\0</code>是字符串结尾的标志,如下图，我们声明一个<strong>没有</strong><code>\0</code>结尾的字符数组，看看函数<code>printf</code>和<code>strlen</code>还找不找得到我们“认为”的结尾</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[] = &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;f&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-09_14-02-07.jpg"></p><p>可以看到函数对字符串的判断出现了严重<strong>失误</strong>，所以<strong>字符数组</strong>里没有<code>\0</code>标记结尾是非常严重的问题，不光是找不到字符串的结尾，而且会<strong>越界访问</strong>！危险操作，写代码的时候一定要注意</p><hr><h2 id="从字符串到字符数组"><a href="#从字符串到字符数组" class="headerlink" title="从字符串到字符数组"></a>从字符串到字符数组</h2><p>虽然上面已经用到了字符数组，但主要还是为了方便讨论<strong>字符串</strong>,接下来着重研究字符数组。</p><h3 id="先整清楚几个概念"><a href="#先整清楚几个概念" class="headerlink" title="先整清楚几个概念"></a>先整清楚几个概念</h3><p><code>什么是数组</code>：数组是⼀组相同类型元素的集合,会在内存中开辟一段连续的空间，将元素储存在那段内存中</p><p><code>什么是数组元素</code>：存放在数组的值被称为数组的元素，数组在创建的时候可以指定数组的⼤⼩和数组的元素类型。</p><p>所以<code>字符数组</code>是一组<code>字符</code>的集合，字符数组里的<code>元素</code>都是<code>字符</code>!,访问到的字符数组里的<strong>元素</strong>都是<strong>字符</strong>，像<code>&#39;a&#39;</code>,<code>&#39;b&#39;</code>,<code>&#39;c&#39;</code>这种的单个的字符,别和<code>字符串</code>混为一谈！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="type">int</span> sz = <span class="keyword">sizeof</span>(str);<span class="comment">//这里str代表了整个数组,所以包括\0</span></span><br><span class="line">,sz的值为<span class="number">4</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="字符数组的声明"><a href="#字符数组的声明" class="headerlink" title="字符数组的声明"></a>字符数组的声明</h3><p>字符数组的声明和其他类型的数组差不多，有<strong>初始化</strong>，<strong>不完全初始化</strong>，<strong>声明长度</strong>，<strong>不声明长度</strong></p><p><em>正确的声明代码如下</em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str1[] = <span class="string">&quot;abc&quot;</span>;<span class="comment">//初始化,不声明长度</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> str2[] = &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;\0&#x27;</span>&#125;;<span class="comment">//这也是初始化，且不声明长度</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> str3[<span class="number">10</span>] = &#123; <span class="number">0</span> &#125;;<span class="comment">//初始化，用值0(等价于`\0`)填充</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> str4[<span class="number">10</span>] = <span class="string">&quot;abc&quot;</span>;<span class="comment">//不完全初始化，存入字符串&quot;abc&quot;,后面都用&#x27;\0&#x27;填充</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> str5[<span class="number">10</span>] = &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>&#125;;<span class="comment">//不完全初始化,从下标为0开始，依次往后填充字符 a,b,c,\0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><em>错误的声明代码</em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str1[<span class="number">3</span>] = <span class="string">&quot;abc&quot;</span>;<span class="comment">//数组声明短了，放不下结尾的\0,编译过不了</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> str2[<span class="number">3</span>] = &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>&#125;;<span class="comment">//同上,放不下</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> str3[] = &#123; <span class="number">0</span> &#125;;<span class="comment">//能声明，但是字符数组长度为1，这个数组大概率是用不了的/会被拿去错误使用的</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="来看看这些声明方式在内存中的表现"><a href="#来看看这些声明方式在内存中的表现" class="headerlink" title="来看看这些声明方式在内存中的表现"></a>来看看这些声明方式在内存中的表现</h3><h4 id="不初始化的声明-极度不推荐"><a href="#不初始化的声明-极度不推荐" class="headerlink" title="不初始化的声明(极度不推荐)"></a>不初始化的声明(极度不推荐)</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[];<span class="comment">//这个不加长度，直接编译失败（如下图）</span></span><br></pre></td></tr></table></figure><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-10_11-39-10.jpg"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">10</span>];<span class="comment">//语法没有问题，来看看此时数组里存了什么</span></span><br></pre></td></tr></table></figure><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-10_11-46-49.jpg"><br>可以看到全都存了<code>-52</code>,对应的中文字符是<code>烫</code>，这样<strong>不好</strong>，请在声明字符数组的时候<strong>初始化数组</strong></p><h4 id="不声明长度的数组声明"><a href="#不声明长度的数组声明" class="headerlink" title="不声明长度的数组声明"></a>不声明长度的数组声明</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str1[] = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> str2[] = &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;\0&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-09_14-59-34.jpg"></p><p>如上图，不声明长度时，编译器自动给字符数组分配内存，既不给多，也不给少，初始化给的<code>字符串</code>或者<code>&#123;...&#125;</code>多长，创建的数组就多长。</p><p><strong>注意红框</strong>，再强调一遍，字符串以<code>\0</code>结尾,看到双引号括起来的字符串，要记得最后隐藏了一个<code>\0</code>,用字符数组储存的时候一定要留足空间</p><h4 id="声明长度的数组声明"><a href="#声明长度的数组声明" class="headerlink" title="声明长度的数组声明"></a>声明长度的数组声明</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str3[<span class="number">10</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> str4[<span class="number">10</span>] = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> str5[<span class="number">10</span>] = &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-09_15-25-54.jpg"></p><p>可以看到，在声明的长度<strong>足够长</strong>时，你初始化的时候给它多少字符，它就从<code>下标0</code>处开始<strong>按顺序</strong>存进去多少,剩下的部分<strong>自动</strong>用<code>&#39;\0&#39;</code>填充,</p><p>所以实际上上面代码中的<code>str5</code>因为长度<code>10</code>&gt;初始化给的<code>4</code>个字符，后面六个元素用<code>\0</code>填充了，所以<code>str5</code>里存了有<strong>结尾</strong>的完整字符串</p><h4 id="错误声明"><a href="#错误声明" class="headerlink" title="错误声明"></a>错误声明</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str1[<span class="number">3</span>] = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="type">char</span> str2[<span class="number">3</span>] = &#123; <span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span> &#125;;</span><br></pre></td></tr></table></figure><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-10_07-44-57.jpg"></p><p>可以看到上面两种错误的声明方式，甚至直接<strong>编译失败</strong>,所以声明字符数组的时候一定要<strong>留足空间</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str3[] = &#123; <span class="number">0</span> &#125;;</span><br></pre></td></tr></table></figure><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-10_07-51-55.jpg"></p><p>如上图，可以看到这样写还是编译成功了，但是在监视查看<strong>数组长度</strong>的时候，发现长度为<code>1</code>,里面存了一个<code>\0</code>,这么<strong>短</strong>的数组能用吗？只能<strong>用一点点</strong>，甚至还不如直接声明一个<code>char</code>类型的字符变量</p><h2 id="当字符数组加上const"><a href="#当字符数组加上const" class="headerlink" title="当字符数组加上const"></a>当字符数组加上const</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> str[<span class="number">5</span>] = <span class="string">&quot;abc&quot;</span>;</span><br></pre></td></tr></table></figure><h3 id="一些性质"><a href="#一些性质" class="headerlink" title="一些性质"></a>一些性质</h3><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-10_18-55-52.jpg"></p><p>可以看到，声明时加了<code>const</code>之后，字符数组<code>str</code>在声明时的<strong>初始化</strong>之后便不可更改了，只能<strong>访问</strong>其元素,而<strong>不能通过访问元素来改变数组内容</strong></p><p>那么<code>scanf</code>还能写入内容吗？答案是<strong>可以</strong>!<em>(如下图)</em></p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-10_19-10-43.jpg"></p><p>那它能拿来初始化别的数组吗？很遗憾，<strong>不能</strong><br><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-10_19-05-15.jpg"></p><h3 id="对应的指针类型"><a href="#对应的指针类型" class="headerlink" title="对应的指针类型"></a>对应的指针类型</h3><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-10_19-15-32.jpg"></p><p>可以看到，这里得用<code>const char*</code>来储存字符数组的地址，而使用<code>char*</code>就会报错</p><p>那么用<code>双引号括起来的字符串</code>，是否也有地址，能用指针储存它的地址呢？</p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-10_19-21-10.jpg"></p><p>如图，可以看到,字符串<code>&quot;abc&quot;</code>是属于<code>const char</code>类型的数组，对应的指针是<code>const char*</code>,不能通过访问元素来改变内部的值，也不能用<code>char*</code>来储存地址</p><h4 id="在内存中的表现"><a href="#在内存中的表现" class="headerlink" title="在内存中的表现"></a>在内存中的表现</h4><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/const_str.gif"></p><p>可以看到哪怕是字符串<code>&quot;abc&quot;</code>,也是在内存中开辟了一段空间，并把字符<strong>储存在内存中</strong>了的</p><p>但是，<strong>不要</strong>试图用<code>scanf</code>去改变字符串的值<br><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/const_strrrr.gif"></p><hr><h2 id="如何向字符数组里添加内容"><a href="#如何向字符数组里添加内容" class="headerlink" title="如何向字符数组里添加内容"></a>如何向字符数组里添加内容</h2><p>添加的方法多种多样，搞不好可能还会出错，所以把字符数组<strong>学明白</strong>很重要！</p><p>以下使用的数组样例声明如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">10</span>] = &#123; <span class="number">0</span> &#125;;</span><br></pre></td></tr></table></figure><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>在初始化的时候就把值传进去，有哪些初始化方式<strong>上面</strong>已经介绍过了，这里不多赘述</p><h3 id="访问数组元素"><a href="#访问数组元素" class="headerlink" title="访问数组元素"></a>访问数组元素</h3><p>通过<code>[]</code>可以访问数组元素，并对没有<code>const</code>修饰的数组，修改其元素,例如:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str[<span class="number">0</span>] = <span class="string">&#x27;A&#x27;</span>;<span class="comment">//将数组的第一个元素改成字符A</span></span><br></pre></td></tr></table></figure><p>我们也可以通过循环的方式，将数组的所有元素填充为某个字符</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> place_holder = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span> ; i++)<span class="comment">//这里使用左闭右开区间，10为数组的大小</span></span><br><span class="line">&#123;</span><br><span class="line">    str[i] = place_holder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用scanf函数"><a href="#使用scanf函数" class="headerlink" title="使用scanf函数"></a>使用<code>scanf</code>函数</h3><p>由上面的探究已知：对于已声明的字符数组，<strong>无论</strong>有没有<code>const</code>修饰，都可已用<code>scanf</code>修改内容,那么<code>scanf</code>怎么用，又具体怎么工作的，我们接着往下探究</p><h4 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">10</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str);<span class="comment">//占位符是 %s ,右边的参数是 str ,也就是数组名</span></span><br><span class="line"><span class="comment">//或者 scanf(&quot;%s&quot;,&amp;str)</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>！这边的数组名<code>str</code>储存的是<strong>数组首元素的地址</strong>，而<code>&amp;str</code>储存的是<code>整个数组的地址</code>，值是一样的，两者皆可用于传参，但<strong>指针类型不一样</strong>，要做好区分</p><h4 id="scanf都做了什么"><a href="#scanf都做了什么" class="headerlink" title="scanf都做了什么"></a><code>scanf</code>都做了什么</h4><p>先来看看它分别对用<code>&#123; 0 &#125;</code><strong>初始化</strong>和<strong>不初始化</strong>的数组做了什么</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str1[<span class="number">10</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str1);</span><br><span class="line"><span class="type">char</span> str2[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str2);</span><br></pre></td></tr></table></figure><p><em>两个数组的输入均为abc</em><br><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-11_19-09-50.jpg"></p><p>可以看到，对<code>str1</code>,字符非常正常地填充进去了，因为整个数组原本是用<code>\0</code>填充的,看不出什么端倪</p><p>而对于<code>str2</code>,观察发现，除了输入进去的字符<code>a</code>,<code>b</code>,<code>c</code>,它还自动在结尾补了一个<code>\0</code>,使<code>str2</code>里储存了一个完整的字符串。<strong>但是</strong>，剩下的部分还是用<strong>值</strong><code>-52</code>填充，即未初始化的状态，所以依然<strong>不提倡</strong>声明的时候没有初始化</p><p>然后是在字符数组内已有内容的情况下，再次使用<code>scanf</code>的情况</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str1[<span class="number">5</span>] = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="type">char</span> str2[<span class="number">5</span>] = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s %s&quot;</span>,str1,str2);</span><br></pre></td></tr></table></figure><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-12_09-33-02.jpg"></p><p>如图，<code>scanf</code>做的是把输入的字符串<code>覆盖</code>式存入字符数组，比原来长，就完全覆盖，比原来短，就部分覆盖，未覆盖的部分无改动</p><h4 id="关于scanf的危险操作"><a href="#关于scanf的危险操作" class="headerlink" title="关于scanf的危险操作"></a>关于<code>scanf</code>的危险操作</h4><p>由于<code>scanf</code>无法预测<strong>字符数组</strong>能否存下输入的<strong>字符串</strong>，如果<strong>字符数组</strong>声明的长度不够，就可能出现<strong>越界访问</strong>,随之而来的便是奇奇怪怪的<code>bug</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">4</span>] = &#123; <span class="number">0</span> &#125;;<span class="comment">//先声明一个长度为4的数组</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str);<span class="comment">//这次输入abcdef试试</span></span><br></pre></td></tr></table></figure><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-12_09-47-00.jpg"></p><p>可以看到，确实<strong>越界访问</strong>了，所以声明字符数组的时候，建议比预计最大输入，在多些长度，防止越界访问。</p>]]></content>
      
      
      
        <tags>
            
            <tag> C语言 字符串 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>=C语言实践= 手把手教你做高端cmd简单扫雷</title>
      <link href="/2023/10/30/mine-clearance/"/>
      <url>/2023/10/30/mine-clearance/</url>
      
        <content type="html"><![CDATA[<h1 id="直接开始吧！"><a href="#直接开始吧！" class="headerlink" title="直接开始吧！"></a>直接开始吧！</h1><h2 id="多文件项目"><a href="#多文件项目" class="headerlink" title="多文件项目"></a>多文件项目</h2><p>扫雷项目内容较多，需要调用的<strong>函数</strong>也较多，采用多文件的方式，可以使代码<strong>条理清晰</strong>，并且<strong>易于管理和维护</strong>。文件如下</p><p><code>game.h</code>用于宏定义，函数声明，引入头文件等</p><p><code>game.c</code>用于<strong>函数的具体实现</strong></p><p><code>front.c</code>用于实现程序的<strong>主干部分</strong></p><p><code>other.c</code>用于实现其他杂项函数，这里我用于实现<code>menu()</code>函数，<del>主要内容太花了</del></p><p><strong>注</strong>  <code>.c</code>结尾的源文件均需加一句<code>#include &quot;game.h&quot;</code></p><h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><p>本次用到的头文件有<code>stdio.h</code> <code>stdlib.h</code> <code>time.h</code> <code>windows.h</code><br>和自己建的<code>game.h</code></p><p><strong>均在</strong>文件<code>game.h</code>中<code>#include</code></p><h2 id="define宏定义"><a href="#define宏定义" class="headerlink" title="define宏定义"></a>define宏定义</h2><p>为了便于<strong>阅读和维护</strong>代码,在<code>game.h</code>中的宏定义如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//显示行列</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ROW 9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COL 9</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//实际数组大小</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ROWS ROW+2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COLS COL + 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//地雷信息</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Bomb <span class="string">&#x27;*&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Blank <span class="string">&#x27; &#x27;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//难度</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EZ_RANK 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HD_RANK 15</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//显示区</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UN <span class="string">&#x27;&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Flag <span class="string">&#x27;!&#x27;</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="为什么实际数组要大一圈？"><a href="#为什么实际数组要大一圈？" class="headerlink" title="为什么实际数组要大一圈？"></a>为什么实际数组要大一圈？</h3><p>如图，采用九宫格式访问时，大出来的一圈能有效<strong>防止越界访问</strong></p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-02_11-23-51.jpg"></p><h2 id="构建main函数"><a href="#构建main函数" class="headerlink" title="构建main函数"></a>构建main函数</h2><p>内容不多，主要是与菜单配合食用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//用time()获取时间戳，传给srand设置(随机值生成器的)种子</span></span><br><span class="line">srand((<span class="type">unsigned</span> <span class="type">int</span>)time(<span class="literal">NULL</span>));</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)<span class="comment">//循环游玩</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> input = <span class="number">0</span>;</span><br><span class="line">Menu();<span class="comment">//打印菜单</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入:&gt;&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;input);<span class="comment">//获取指令</span></span><br><span class="line"><span class="keyword">switch</span> (input)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">Sleep(<span class="number">250</span>);</span><br><span class="line">game();<span class="comment">//开始游戏,游戏具体在game()函数中实现</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;游戏结束\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//结束程序</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;输入错误,请重试\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="打印菜单"><a href="#打印菜单" class="headerlink" title="打印菜单"></a>打印菜单</h2><p>还在做静态菜单?<del>弱爆了！</del>来试试<strong>动态出现</strong>的菜单！</p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/menu.gif"></p><p>原理很<strong>简单</strong>，就是<code>打印空白数组</code>-&gt;<code>向内逐个替换两侧元素</code>-&gt;<code>清屏</code>-&gt;<code>再打印</code>-&gt;<code>再替换</code>-&gt;<code>...</code></p><p><em>接下来的代码写在<code>other.c</code>中</em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//动态打印菜单</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Menu</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> cover[]  =  <span class="string">&quot;=======================&quot;</span>;</span><br><span class="line"><span class="type">char</span> option1[] = <span class="string">&quot;======  play (1) ======&quot;</span>;</span><br><span class="line"><span class="type">char</span> option2[] = <span class="string">&quot;======  exit (2) ======&quot;</span>; </span><br><span class="line"><span class="type">char</span> empty_c[] = <span class="string">&quot;                       &quot;</span>;</span><br><span class="line"><span class="type">char</span> empty_1[] = <span class="string">&quot;                       &quot;</span>;</span><br><span class="line"><span class="type">char</span> empty_2[] = <span class="string">&quot;                       &quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> right = <span class="number">22</span>;</span><br><span class="line"><span class="keyword">while</span> (left &lt; right)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">//内容替换</span></span><br><span class="line">empty_c[left] = cover[left];</span><br><span class="line">empty_c[right] = cover[right];</span><br><span class="line">empty_1[left] = option1[left];</span><br><span class="line">empty_1[right] = option1[right];</span><br><span class="line">empty_2[left] = option2[left];</span><br><span class="line">empty_2[right] = option2[right];</span><br><span class="line"></span><br><span class="line">Sleep(<span class="number">50</span>);</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);<span class="comment">//清屏</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n%s\n%s\n%s\n&quot;</span>,empty_c,empty_1,empty_2,empty_c);<span class="comment">//打印菜单</span></span><br><span class="line"></span><br><span class="line">left++;</span><br><span class="line">right--;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (left == right)<span class="comment">//打印最终菜单</span></span><br><span class="line">&#123;</span><br><span class="line">Sleep(<span class="number">50</span>);</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">empty_c[left] = cover[left];</span><br><span class="line">empty_1[left] = option1[left];</span><br><span class="line">empty_2[left] = option2[left];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n%s\n%s\n%s\n&quot;</span>, empty_c, empty_1, empty_2, empty_c);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现game-函数"><a href="#实现game-函数" class="headerlink" title="实现game()函数"></a>实现game()函数</h2><p><em>游戏的主要逻辑在game()中实现</em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">game</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> mine[ROWS][COLS] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="type">char</span> show[ROWS][COLS] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="type">char</span> check[ROWS][COLS] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化棋盘，其实就是用第二个形参填充二维数组</span></span><br><span class="line">InitBoard(mine, Blank);</span><br><span class="line">InitBoard(show, UN);</span><br><span class="line"></span><br><span class="line">InitCheck(check);<span class="comment">//初始化check数组，逻辑与上面的初始化不同</span></span><br><span class="line"></span><br><span class="line">SetMine(mine,EZ_RANK);<span class="comment">//设置地雷</span></span><br><span class="line">SetNum(mine);<span class="comment">//设置雷周围的数字</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//DisplayBoard(mine); //用于开发时检查棋盘布局</span></span><br><span class="line"><span class="comment">//DisplayBoard(show); //同上，不使用时注释掉</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//以上是前期准备</span></span><br><span class="line">OPMine(mine,show, check);<span class="comment">//开始排雷</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;敲击enter以继续\n&quot;</span>);</span><br><span class="line">getchar();</span><br><span class="line">getchar();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="为什么用三个二维数组？"><a href="#为什么用三个二维数组？" class="headerlink" title="为什么用三个二维数组？"></a>为什么用三个二维数组？</h3><p>扫雷需要实现的功能较多，显然一个二维数组是不足以满足需求的，所以这里采用<strong>三个</strong>数组相叠加的方式，各自实现功能，并整合到一起。</p><p>数组<code>mine</code>用于存放<code>雷</code>和雷周围的<code>计数数字</code></p><p>数组<code>show</code>用于储存给<code>用户</code>看到的内容，可以是<code>Unkown</code>,<code>空白</code>，<code>数字</code>，<code>旗帜</code></p><p>数组<code>check</code>用于记录棋盘的哪些地块被检查过了，防止后面用<strong>递归</strong>打开成片的空白区时，出现无限递归。</p><p><strong>规定</strong>：检查过的坐标储存<code>字符1</code>,没检查过的坐标储存<code>字符0</code>,大出来的<strong>一圈</strong>默认储存<code>字符1</code></p><h2 id="实现游戏用的函数"><a href="#实现游戏用的函数" class="headerlink" title="实现游戏用的函数"></a>实现游戏用的函数</h2><h3 id="先看看有哪些要声明在game-h里的"><a href="#先看看有哪些要声明在game-h里的" class="headerlink" title="先看看有哪些要声明在game.h里的"></a>先看看有哪些要声明在<code>game.h</code>里的</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Menu</span><span class="params">()</span>;<span class="comment">//这个在上文实现过了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//一下函数将在下文实现</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化棋盘</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitBoard</span><span class="params">(<span class="type">char</span> board[ROWS][COLS], <span class="type">char</span> sign)</span>;</span><br><span class="line"><span class="comment">//展示棋盘</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DisplayBoard</span><span class="params">(<span class="type">char</span> board[ROWS][COLS])</span>;</span><br><span class="line"><span class="comment">//初始化check棋盘</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitCheck</span><span class="params">(<span class="type">char</span> check[ROWS][COLS])</span>;</span><br><span class="line"><span class="comment">//设置地雷/数字</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SetMine</span><span class="params">(<span class="type">char</span> board[ROWS][COLS],<span class="type">int</span> rank)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">SetNum</span><span class="params">(<span class="type">char</span> board[ROWS][COLS])</span>;</span><br><span class="line"><span class="comment">//玩家排雷用的函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OPMine</span><span class="params">(<span class="type">char</span> mine[ROWS][COLS],<span class="type">char</span> show[ROWS][COLS],<span class="type">char</span> check[ROWS][COLS])</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><em>好，有了目标，接下来就去一个一个实现</em></p><p><strong>注</strong>：以下代码均写在<code>game.c</code>文件里</p><h3 id="InitBoard"><a href="#InitBoard" class="headerlink" title="InitBoard()"></a>InitBoard()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InitBoard</span><span class="params">(<span class="type">char</span> board[ROWS][COLS],<span class="type">char</span> sign)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ROWS; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; COLS; j++)</span><br><span class="line">&#123;</span><br><span class="line">board[i][j] = sign;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里初始化的方式比较简单粗暴，就是用形参<code>sign</code>填充整个二维数组</p><h3 id="DisplayBoard-函数"><a href="#DisplayBoard-函数" class="headerlink" title="DisplayBoard()函数"></a>DisplayBoard()函数</h3><p>这里采用的展示方式是带横纵坐标的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">DisplayBoard</span><span class="params">(<span class="type">char</span> board[ROWS][COLS])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//打印一排列坐标</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt;= COL; k++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="comment">//打印一排横分割线</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt;= COL; k++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;--&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= ROW; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d|&quot;</span>, i);<span class="comment">//这句话打印横排坐标和竖分割线</span></span><br><span class="line"><span class="comment">//打印一排棋盘内容</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= COL; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, board[i][j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="InitCheck-函数"><a href="#InitCheck-函数" class="headerlink" title="InitCheck()函数"></a>InitCheck()函数</h3><p>这里复用了<code>InitBoard()</code>函数，是在其基础上增加了内容</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InitCheck</span><span class="params">(<span class="type">char</span> check[ROWS][COLS])</span></span><br><span class="line">&#123;</span><br><span class="line">InitBoard(check, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将边缘大出来的一圈改为&#x27;1&#x27;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; COLS; k++)</span><br><span class="line">&#123;</span><br><span class="line">check[<span class="number">0</span>][k] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">check[ROWS - <span class="number">1</span>][k] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; ROWS <span class="number">-1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">check[i][<span class="number">0</span>] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">check[i][COLS - <span class="number">1</span>] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="SetMine-函数"><a href="#SetMine-函数" class="headerlink" title="SetMine()函数"></a>SetMine()函数</h3><p>这里要使用<code>rand()</code>函数搭配<code>%</code>运算，来随机生成雷的坐标</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SetMine</span><span class="params">(<span class="type">char</span> board[ROWS][COLS],<span class="type">int</span> rank)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> y = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> count = <span class="number">0</span>;count &lt; rank;)</span><br><span class="line">&#123;</span><br><span class="line">x = rand() % ROW + <span class="number">1</span>;<span class="comment">//x的范围是1~ROW</span></span><br><span class="line">y = rand() % COL + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (board[x][y] == Blank)</span><br><span class="line">&#123;</span><br><span class="line">count++;</span><br><span class="line">board[x][y] = Bomb;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="SetNum-函数"><a href="#SetNum-函数" class="headerlink" title="SetNum()函数"></a>SetNum()函数</h3><p>这里遍历一遍数组并采用<code>九宫格式</code>计数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该函数用于九宫格式计数，并在下个函数中被调用</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">CountMine</span><span class="params">(<span class="type">char</span> board[ROWS][COLS], <span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = x - <span class="number">1</span>; i &lt;= x + <span class="number">1</span>; i++)<span class="comment">//上中下三行</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = y - <span class="number">1</span>; j &lt;= y + <span class="number">1</span>; j++)<span class="comment">//左中右三列</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i != x || j != y)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (board[i][j] == Bomb)</span><br><span class="line">&#123;</span><br><span class="line">sum++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SetNum</span><span class="params">(<span class="type">char</span> board[ROWS][COLS])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//遍历二维数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= ROW; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= COLS; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (board[i][j] == Blank)<span class="comment">//仅操作非雷的格子</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (CountMine(board, i, j))</span><br><span class="line">&#123;</span><br><span class="line">board[i][j] = <span class="string">&#x27;0&#x27;</span> + CountMine(board, i, j);<span class="comment">//将返回的数字转化成字符</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="OPMine-函数–核心函数"><a href="#OPMine-函数–核心函数" class="headerlink" title="OPMine()函数–核心函数"></a>OPMine()函数–核心函数</h3><p>该函数为游戏的<code>核心函数</code>，有内置菜单，且多次调用其它函数，其中<code>函数</code>的具体实现见<code>四级标题</code>处</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">OPMine</span><span class="params">(<span class="type">char</span> mine[ROWS][COLS],<span class="type">char</span> show[ROWS][COLS],<span class="type">char</span> check[ROWS][COLS])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> x = <span class="number">0</span>;<span class="comment">//横纵坐标</span></span><br><span class="line"><span class="type">int</span> y = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> flag = <span class="number">1</span>;<span class="comment">//用于菜单选项</span></span><br><span class="line"><span class="type">int</span> cont = <span class="number">1</span>;<span class="comment">//cont为0时游戏结束</span></span><br><span class="line"><span class="keyword">while</span> (cont)</span><br><span class="line">&#123;</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">DisplayBoard(show);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;排雷(1)\n插旗/拔旗(2)\n请输入:&gt;&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;flag);</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (flag)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//排雷</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;坐标格式,例&gt;2(空格)2\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入坐标:&gt;&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line"><span class="keyword">if</span> (show[x][y] == Flag)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;此处为旗帜，不可排雷\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (show[x][y] != UN)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;不可重复排查\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体排雷操作</span></span><br><span class="line">cont = FindMine(mine,show,check, x, y);</span><br><span class="line"><span class="keyword">if</span> (cont)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//检查是否赢得游戏</span></span><br><span class="line">cont = CheckWin(mine,show);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//插旗</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;坐标格式,例&gt;2(空格)2\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入坐标:&gt;&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">SetFlag(show, x, y);<span class="comment">//插旗函数</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">&#123;</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n输入错误(恼\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="SetFlag-函数"><a href="#SetFlag-函数" class="headerlink" title="SetFlag()函数"></a>SetFlag()函数</h4><p>先捏软柿子，插旗函数比较简单</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SetFlag</span><span class="params">(<span class="type">char</span> show[ROWS][COLS], <span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (show[x][y] == UN)<span class="comment">//插旗</span></span><br><span class="line">&#123;</span><br><span class="line">show[x][y] = Flag;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (show[x][y] == Flag)<span class="comment">//拔旗</span></span><br><span class="line">&#123;</span><br><span class="line">show[x][y] = UN;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;报错\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="ExpandBlank-函数"><a href="#ExpandBlank-函数" class="headerlink" title="ExpandBlank()函数"></a>ExpandBlank()函数</h4><p>这个函数用于打开成片的<code>空白区</code>,因为要从连着的空白连续开下去，所以要用到<code>函数递归</code>,此时<code>二维数组check</code>用于防止死递归</p><p><strong>注</strong>：这个函数一定要写在下一个函数(FindMine)前</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ExpandBlank</span><span class="params">(<span class="type">char</span> mine[ROWS][COLS], <span class="type">char</span> show[ROWS][COLS], <span class="type">char</span> check[ROWS][COLS],<span class="type">int</span> x,<span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">show[x][y] = mine[x][y];<span class="comment">//将用户看到的格子改成mine中的格子,包括空白和数字格子</span></span><br><span class="line">check[x][y] = <span class="string">&#x27;1&#x27;</span>;<span class="comment">//探测过的格子放`1`</span></span><br><span class="line"><span class="keyword">if</span> (mine[x][y] == Blank)<span class="comment">//仅空白格子会触发递归，数字格子不会</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//九宫格式探测</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = x - <span class="number">1</span>; i &lt;= x + <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = y - <span class="number">1</span>; j &lt;= y + <span class="number">1</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (check[i][j] == <span class="string">&#x27;0&#x27;</span> &amp;&amp; mine[i][j] != Bomb &amp;&amp; show[i][j] != Flag)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//含雷的格子不会执行ExpandBlank函数，就不会把雷放出来给用户看，但数字格子会</span></span><br><span class="line">ExpandBlank(mine, show, check, i, j);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="FindMine-函数"><a href="#FindMine-函数" class="headerlink" title="FindMine()函数"></a>FindMine()函数</h4><p>排雷用的函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">FindMine</span><span class="params">(<span class="type">char</span> mine[ROWS][COLS], <span class="type">char</span> show[ROW][COLS],<span class="type">char</span> check[ROWS][COLS], <span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (mine[x][y] == Bomb)</span><br><span class="line">&#123;</span><br><span class="line">DisplayBoard(mine);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;炸死，游戏结束:)\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//返回0来结束游戏</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (mine[x][y] != Blank)</span><br><span class="line">&#123;</span><br><span class="line">show[x][y] = mine[x][y];</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//返回1来继续游戏</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//这里有对上一个函数的调用</span></span><br><span class="line">ExpandBlank(mine, show, check,x,y);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="CheckWin-函数"><a href="#CheckWin-函数" class="headerlink" title="CheckWin()函数"></a>CheckWin()函数</h4><p>用于检查玩家是否完全排雷，赢得游戏</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">CheckWin</span><span class="params">(<span class="type">char</span> mine[ROWS][COLS], <span class="type">char</span> show[ROWS][COLS])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;<span class="comment">//统计没排雷的格子数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= ROW; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= COL; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (show[i][j] == UN || show[i][j] == Flag)</span><br><span class="line">&#123;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (count == EZ_RANK)<span class="comment">//统计数==雷数</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;恭喜排雷成功!\n&quot;</span>);</span><br><span class="line">DisplayBoard(mine);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//返回0，停止游戏</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>至此游戏所需的代码全部完成，已经可以编译出来玩耍啦。</p><p>该实践项目主要练习了<code>二维数组</code>,<code>函数</code>,<code>函数递归</code>,<code>宏定义</code>等内容，代码量在入门学习中算较大的，本人在初次编写的时候也写出了不少bug，debug的过程是相当<del>快乐</del></p><p>建议多多画示意图，<strong>耐下性子</strong>写代码和debug,哪怕是实现这样的小游戏项目，也是颇有意义的</p>]]></content>
      
      
      
        <tags>
            
            <tag> C语言 实践项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>玩转N组输入和多组输入</title>
      <link href="/2023/10/18/mutiInput/"/>
      <url>/2023/10/18/mutiInput/</url>
      
        <content type="html"><![CDATA[<h1 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h1><p>当我们在写IO型OJ时，<code>多组输入</code>便是我们绕过不开的话题了，但<strong>不用担心</strong>，可能初见多组输入会觉得难以理解，但用多了之后就会发现，<code>多组输入</code> 花样并不多，混熟了就<strong>很简单了</strong></p><h2 id="先看看一组输入输出如何完成的"><a href="#先看看一组输入输出如何完成的" class="headerlink" title="先看看一组输入输出如何完成的"></a>先看看一组输入输出如何完成的</h2><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-10-19_17-06-13.jpg"></p><p><em>如图</em>：一组输入时，用<code>scanf</code>获取一组输入，并在主体部分完成数据的处理，产生结果，最后用<code>printf</code>输出产生的一组结果。</p><p><em>以下用实现加法的程序做演示</em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a,b;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;a,&amp;b);<span class="comment">//获取一组输入</span></span><br><span class="line">    <span class="type">int</span> sum = a + b;<span class="comment">//产生结果</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,sum);<span class="comment">//输出结果</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="然后升级到N组输入"><a href="#然后升级到N组输入" class="headerlink" title="然后升级到N组输入"></a>然后升级到N组输入</h1><p>有的OJ题在一个测试文件中会先输入一个<code>n</code>,告诉你接下来有<code>n</code>组输入，你就要产生<code>n</code>组输出,也就是说要将<code>一组输入输出</code><strong>重复性地</strong>完成<code>n次</code>。难道我们要把代码重复<code>n次</code>吗？显然不现实。</p><p>所以是时候使用<strong>循环</strong>了，具体用法如下</p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-10-20_07-34-35.jpg"></p><p>如图，先用一个<code>scanf</code>获取循环次数<code>n</code>,然后创建一个循环，将<code>一组输入输出</code>放入循环体，一次一次循环处理即可</p><h2 id="变量的重置"><a href="#变量的重置" class="headerlink" title="变量的重置"></a>变量的重置</h2><p>为防止前后两次循环产生干扰，有两种处理<code>变量</code>的方式</p><p>1.(推荐)除了输入的变量，<strong>其它所有变量</strong>在循环体内声明，这些变量会在一次循环后<em>销毁</em>，下一次循环开始时<strong>自动</strong><em>重新声明</em>，从而完成<strong>变量的自动重置</strong></p><p><em>以下面这个一次求和3个数的程序为例</em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);<span class="comment">//获取循环次数n</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;n;i++)<span class="comment">//创建循环</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//以下完成一组输入输出</span></span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;<span class="comment">//声明一个局部变量，下次循环时会自动重声明</span></span><br><span class="line">        <span class="type">int</span> num = <span class="number">0</span>;<span class="comment">//储存输入的数字</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j =<span class="number">0</span>;j&lt;<span class="number">3</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;num);</span><br><span class="line">            sum+=num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,sum);<span class="comment">//完成输出</span></span><br><span class="line">        <span class="comment">//本次循环走完后变量sum被销毁，然后进入下一次循环,完成重置</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2.在循环外部声明变量，然后在<strong>循环末尾</strong>手动重置变量</p><p><em>以下面这个一次求和3个数的程序为例</em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;<span class="comment">//声明在循环外部</span></span><br><span class="line">    <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);<span class="comment">//获取循环次数n</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;n;i++)<span class="comment">//创建循环</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//以下完成一组输入输出</span></span><br><span class="line">        <span class="type">int</span> num = <span class="number">0</span>;<span class="comment">//储存输入的数字</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j =<span class="number">0</span>;j&lt;<span class="number">3</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;num);</span><br><span class="line">            sum+=num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,sum);<span class="comment">//完成输出</span></span><br><span class="line">        sum = <span class="number">0</span>;<span class="comment">//重置sum</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="要不要用数组储存输入，或储存结果再一次性输出？"><a href="#要不要用数组储存输入，或储存结果再一次性输出？" class="headerlink" title="要不要用数组储存输入，或储存结果再一次性输出？"></a>要不要用数组储存输入，或储存结果再一次性输出？</h2><p>答案是：<strong>可以，但没必要</strong>。</p><p>只需要像上图那么写即可，因为输入是一次性喂进去的 。存数组再输出，和每产生一个结果就输出一次，最终呈现出来是一样的（如下图）</p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/%E5%A4%9A%E7%BB%84%E8%BE%93%E5%87%BA.gif"></p><h1 id="现在，勇士，来挑战多组输入吧"><a href="#现在，勇士，来挑战多组输入吧" class="headerlink" title="现在，勇士，来挑战多组输入吧"></a>现在，勇士，来挑战多组输入吧</h1><h2 id="scanf的返回值"><a href="#scanf的返回值" class="headerlink" title="scanf的返回值"></a>scanf的返回值</h2><p>多组输入时，究竟会输入多少组数据，也不告诉你了，<strong>但是</strong>，此时<code>scanf</code>的返回值就派上用场了。和我们在终端手打输入不同,OJ的输入是喂一个文件进去，所以当<strong>输入结束时</strong>，<code>scanf</code>的返回值是<code>EOF</code><em>(意为文件结尾end of file)</em>,而当成功输入数据时，则会返回输入数据的个数(文档截图如下)</p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-10-20_20-46-54.jpg"></p><h2 id="结合循环"><a href="#结合循环" class="headerlink" title="结合循环"></a>结合循环</h2><p>那么就把<code>scanf</code>放入<code>while</code>循环吧,每次试图获取下一组输入时，检测是否返回值为<code>EOF</code>,若是，则跳出循环，结束程序；若否，则继续循环</p><p><em>以下面这个一次求和3个数的程序为例</em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;<span class="comment">//先声明至少一个待输入的变量</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n) != EOF)<span class="comment">//创建循环，每次循环开始时scanf一次，并检测是否返回EOF</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//开始构建循坏体</span></span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        sum+=n;</span><br><span class="line">        <span class="comment">//完成剩下的两次输入</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>; i &lt; <span class="number">3</span> - <span class="number">1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">            sum+=n</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,sum);<span class="comment">//完成一次输出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//scanf返回EOF后跳出循环</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="基本架构"><a href="#基本架构" class="headerlink" title="基本架构"></a>基本架构</h2><p>以后再要写<code>多组输入</code>，基本就像上面那个程序一样</p><p>1.先声明至少一个待输入的变量</p><p>2.创建循环，每次循环开始时scanf一次，并检测是否返回EOF</p><p>3.开始构建循坏体(包括完成剩下的输入,完成一组输出)<strong>别忘了回车！！！</strong></p><p>4.直至scanf返回EOF后跳出循环</p><h1 id="想模拟一下多组输入看看？"><a href="#想模拟一下多组输入看看？" class="headerlink" title="想模拟一下多组输入看看？"></a>想模拟一下多组输入看看？</h1><p>像下图一样每组数据间加个<code>空格</code>就行，什么？题目的样例输入有<code>回车</code>？不用管它，放心大胆地<code>换成空格</code>就行。自己<code>测试</code>程序，只需要<strong>输出</strong>一样就行，至于怎么输入，<strong>没必要</strong>和题目一模一样</p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/mutiInpuut.gif"></p><h1 id="注意！！！不要试图在终端停止程序"><a href="#注意！！！不要试图在终端停止程序" class="headerlink" title="注意！！！不要试图在终端停止程序"></a>注意！！！不要试图在终端停止程序</h1><p>因为和OJ不同，在本地运行程序时，不是文件输入，而是终端输入,没法让<code>scanf</code>返回<code>EOF</code>,<del>炫迈，根本停不来</del></p><p>你要是想立即<code>中断</code>程序，那就按<code>ctrl+c</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> C语言 多组输入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>=C语言= 整型变量与过大的整数</title>
      <link href="/2023/10/14/BiiigInt/"/>
      <url>/2023/10/14/BiiigInt/</url>
      
        <content type="html"><![CDATA[<h2 id="整型家族"><a href="#整型家族" class="headerlink" title="整型家族"></a>整型家族</h2><p>在使用C语言写程序时，会储存各种长度的整型,而在整型家族中，长度的比较如下</p><p><code>char &lt; short &lt;= int &lt;= long &lt;long long </code></p><h2 id="整型是如何储存在内存中的"><a href="#整型是如何储存在内存中的" class="headerlink" title="整型是如何储存在内存中的"></a>整型是如何储存在内存中的</h2><p><em>以<code>char</code>为例</em><br><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-10-14_15-33-30.jpg" alt="char"></p><p><code>char</code>的长度为1个<code>字节</code>，8个<code>比特位</code>,其中<strong>最高位</strong>是<strong>符号位</strong>,<code>0</code>表示正数，<code>1</code>表示负数，剩下的位数用于储存变量的<strong>绝对值</strong></p><hr><p>而当使用无符号整型(带前缀<code>unsigned</code>)时，只需把符号位也用于存值即可</p><h2 id="能够储存的最大正整数"><a href="#能够储存的最大正整数" class="headerlink" title="能够储存的最大正整数"></a>能够储存的最大正整数</h2><p><code>int</code>长度为4<code>字节</code>,能够储存的最大值为<code>2的31次方-1</code>,即<strong>2,147,483,647</strong></p><p><code>unsigned int</code>能够储存的最大值为<strong>4294967295</strong></p><p><code>unsigned long long</code>长度为8<code>字节</code>,能够储存的最大值为<code>2的64次方-1</code>,即<strong>18,446,744,073,709,551,615</strong></p><hr><h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><p>虽然<code>unsigned long long</code>已经很大了，但当遇到<code>指数</code>,<code>阶乘</code>之类的运算时仍然可能<strong>存不下!</strong>(光<code>21!</code>就比<code>unsigned long long</code>长了)</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>过大的整数，可能出现在<strong>程序的过程</strong>中，也可能出现在<strong>输出</strong>中，对于过程，可以尝试<strong>改变实现思路</strong>，让过程中不出现过大的整数；对于输出，可以尝试<strong>改变输出的类型</strong>，采用输出<strong>字符或字符串</strong></p><h1 id="以下皆为例题"><a href="#以下皆为例题" class="headerlink" title="以下皆为例题"></a>以下皆为例题</h1><h2 id="1-求n-的结尾有多少个0"><a href="#1-求n-的结尾有多少个0" class="headerlink" title="1.求n!的结尾有多少个0"></a>1.求n!的结尾有多少个0</h2><p>最直白的思路就是把<code>n!</code>算出来，然后用<code>%10</code>再<code>/=10</code>的方法统计末尾的<code>0</code>,想法很简单，“实现”起来也不难，<strong>但不幸的是</strong>，<code>21!</code>就已经储存不了了，所以不能暴力求解</p><p>所以要<strong>改变思路</strong>，先从末尾0是怎么来的下手。末尾的n个0来自因式分解后10的n次方，而采用质因数分解的方法，可以发现<code>0</code>来自分解后<code>2的n次方</code>和<code>5的n次方</code>,而一个数分解后<code>2的n次方</code>必定比<code>5的n次方</code> 多，所以只需统计<code>5的n次方</code>。<strong>注意</strong>：就别再倒回去，想着先算出阶乘再求<code>5的n次方</code>了。</p><p><strong>这里采用逐步计数的方法</strong>：结果中的<code>5的n次方</code>来自各个因数中<code>5的N次方</code>的累乘,所以只需要历遍每个因数，并统计其中<code>因数5</code>的次数。这样过程中就不会有过大的数字了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码实现</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">count_num0</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> copy = i<span class="comment">//防止改变循环变量</span></span><br><span class="line">        <span class="keyword">while</span>(copy%<span class="number">5</span> == <span class="number">0</span>)<span class="comment">//统计因数5的出现次数</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(copy%<span class="number">5</span> == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            copy/=<span class="number">5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="快速输出1-2-……-10-n"><a href="#快速输出1-2-……-10-n" class="headerlink" title="快速输出1+2+……+10^n"></a>快速输出1+2+……+10^n</h2><p><em>如下图</em>：当我们试图算一算答案时，发现<code>n</code>到了<code>10</code>时就已经算不出答案了</p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/gao_si.png" alt="计算结果"></p><p>所以要<strong>改变输出答案答案的方式</strong>,观察一下<code>n</code>在<code>1~9</code>时的输出</p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-10-19_07-26-54.jpg" alt="输出"></p><p>这时我们发现<strong>答案颇有规律</strong>：每个输出都是<strong>两段</strong><code>先一个5，然后n-1个0</code>！</p><p>这样我们只需<strong>从最高位往最低位</strong>逐位打印即可,代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">printChar</span><span class="params">(<span class="type">int</span> n)</span><span class="comment">//版本一，逐位打印字符(串)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;5&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//再重复一段</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;5&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printNum</span><span class="params">(<span class="type">int</span> n)</span><span class="comment">//版本二，逐位打印整型</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//再重复一段</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何在VS里使用scanf</title>
      <link href="/2023/10/05/useScanf/"/>
      <url>/2023/10/05/useScanf/</url>
      
        <content type="html"><![CDATA[<h1 id="VS里怎么连scanf都用不了？"><a href="#VS里怎么连scanf都用不了？" class="headerlink" title="VS里怎么连scanf都用不了？"></a>VS里怎么连scanf都用不了？</h1><p>不少刚接触<a href="https://visualstudio.microsoft.com/zh-hans/free-developer-offers/">Visual Studio</a>的可能发现使用scanf会报错(如下)</p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/VS_scanf.jpg" alt="报错图片"></p><p>vs告诉你说<code>scanf</code>不安全，然后你会发现vs给你提供了<code>scanf_s</code>去代替<code>scanf</code>,<strong>但是</strong>,只有vs能编译<code>scanf_s</code>,<strong>可移植性</strong>太差了，所以我们要用回<code>scanf</code>,所以要怎么不让它报错呢？<strong>可以在源文件开头添加一行宏定义(如下)</strong></p><p><code>#define  _CRT_SECURE_NO_WARNINGS 1</code></p><p>这样就能<strong>关闭报错</strong>了,但请先<strong>别急着走</strong>,每次都要复制粘贴一句宏定义太麻烦了，想<strong>一劳永逸</strong>的请往下看。</p><h1 id="修改newc-file-cpp来自动添加宏定义"><a href="#修改newc-file-cpp来自动添加宏定义" class="headerlink" title="修改newc++file.cpp来自动添加宏定义"></a>修改newc++file.cpp来自动添加宏定义</h1><p><strong>先来看怎么做：</strong>首先搜索找到电脑中叫做<code>newc++file.cpp</code>的文件。（这里推荐使用<a href="https://www.voidtools.com/zh-cn/downloads/">everything</a>）</p><hr><p><em>后半段路径应与图片一致，注意不是快捷方式</em></p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/newcppfile.jpg" alt="c++文件的位置"></p><hr><p><strong>注意</strong>：由于权限原因，<strong>无法</strong>直接修改此文件</p><p>所以先将这个文件复制粘贴到别处，例如桌面，下文用<code>副本</code>代称。</p><p>用记事本类软件(记事本就行)打开<code>副本</code>,在第一行输入上文提到的宏定义代码<code>#define  _CRT_SECURE_NO_WARNINGS 1</code>,然后<code>ctrl+s</code>保存。</p><p><strong>关闭编辑窗口</strong>，将该<code>副本</code>移动到原始文件所在文件夹，弹出如下窗口，然后选择<strong>替换文件</strong></p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-10-08_12-28-18.jpg"></p><p>接着弹出下一个提示，点<strong>接续</strong></p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-10-08_12-28-33.jpg"></p><p>等待它替换完成，然后<strong>大功告成！</strong>。之后新建的每一个<code>.c</code>或<code>.cpp</code> 文件都会自带那段宏定义，于是<code>scanf</code>从此任君使用。<del>当然平时删代码的时候记得别把那段宏定义删了</del></p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>VS所新建的<code>.c</code>和<code>.cpp</code>文件都源自于对上文<code>newc++file.cpp</code>文件的拷贝，通过修改它就能改变<code>VS新建文件</code>的初始内容</p>]]></content>
      
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>=回顾-前端=从简陋的html到单网页再到全栈开发</title>
      <link href="/2023/09/23/vueTheRoad/"/>
      <url>/2023/09/23/vueTheRoad/</url>
      
        <content type="html"><![CDATA[<p><a href="https://picbed.supdriver.top/html/prj_basis++/index.html">👉点我去作业一</a></p><p><a href="https://picbed.supdriver.top/html/adc_v2/index.html">👉点我去作业二</a></p><p><a href="http://localhost:5173/">👉点我去作业三</a>(抱歉，还没部署到服务器里，这个只能在我自己的电脑里用)</p><p><a href="https://picbed.supdriver.top/video/never.mp4">👉点我去作业四</a></p><p><del>其实这依然是个博客</del></p><hr><h1 id="粗糙的作业一"><a href="#粗糙的作业一" class="headerlink" title="粗糙的作业一"></a>粗糙的作业一</h1><p>当时只学过html,css,js的快速入门，对盒子<code>&lt;div&gt;</code>的玩法还不太熟，还只会用浮动盒子<code>float</code>和绝对定位,结局就是写两句html就得清除浮动<del>233</del>,甚至<code>&lt;lenged&gt;</code>也不认识，结果手动用css给实现了。总之就挺简陋的</p><h1 id="精致-并不-作业二"><a href="#精致-并不-作业二" class="headerlink" title="精致(并不)作业二"></a>精致<del>(并不)</del>作业二</h1><p>用vscode写作业二的时候，写一半发现鼠标悬停在<code>tag</code>时，它会给出去往<a href="https://developer.mozilla.org/zh-CN/"><em>MDN</em></a>对应参考页的连接,然后就开始一边写一边阅读MDN,结果一发不可收拾，开始读的时间比写的时间还长。最后成功学到神器<del>bushi</del><code>flex</code><strong>弹性盒子模型。</strong>。</p><p>但还没完，除了参阅文档，我还多次在B站首页和MC百度百科首页打开<code>F12</code>,查看，学习他们是如何布局盒子的，别说，学成品也挺有用的，对盒子的排版，嵌套的想法成熟多了</p><p>结合二者，照着图片做一个网页便没什么问题了。那个作业二我甚至直接弃掉了初版（已经把顶部做好了）version2基本完全采用<code>flex盒子</code>。比较遗憾的是，虽然每个菜单按钮都加了超链接，但是对应的网页并没有做出来（创作力有限）。但至少是个合格的花瓶，嘿嘿</p><h1 id="速成作业三"><a href="#速成作业三" class="headerlink" title="速成作业三"></a>速成作业三</h1><p>因为作业三没部署到服务器上，只能文字描述了（悲）</p><p>作业三我选的是用<code>vue</code>搭建个人博客，我先是自学了几天vue,结果发现光学vue就做不了个人博客，于是在B站上找了个时长6小时的全栈开发，用<code>js</code>写的服务端，数据库用<code>sqlite</code>,前端框架是<code>vue</code>.</p><p>好家伙，5天爆肝项目（包括但不限于<em>抄代码</em>,<em>找bug</em>,<em>找bug</em>,<em>找bug</em>），成功把博客的基本功能写完了。除了<code>Naive UI</code>的代码是复制<strong>组件库</strong>里的，剩下的代码基本都是我<strong>手打</strong>的，可以说忙得不亦乐乎，而且当时我并不太懂<code>js语法</code>，体验可以说是相当刺激了。</p><p>但<strong>回报不小</strong>，就算不能说入门吧，到时候自己加功能，照葫芦画瓢，自己写<code>js</code>的能力还是有了滴。而且这也是我首次<strong>接触数据库</strong>,混个脸熟，嘿嘿。而且<strong>最重要</strong>的一点，我成功增加了一个<strong>高自由度的个人博客</strong>，<del>讲真hexo的各自魔改我不太玩的懂</del>。</p><h2 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h2><p>作业三部曲之后，我大概就不太去碰前端了，至少一周爆肝一个全栈开发项目这种疯狂的行为不会再有了，权当是一次挑战罢，一次冒险，一次对边界的探索罢。重心很明确，对前端顶多写写像这篇博客一样的感悟，技术博客主要还是在后端语言，算法，数据结构之类</p>]]></content>
      
      
      
        <tags>
            
            <tag> 回顾 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>=算法=双指针的种种应用(更新中)</title>
      <link href="/2023/09/12/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
      <url>/2023/09/12/%E5%8F%8C%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<p><em>注：本文写于C语言学习早期，双指针的用法较为基础且不全面。本文章将涉及C语言数组至数据结构的链表</em></p><h2 id="Q-为什么要用双指针"><a href="#Q-为什么要用双指针" class="headerlink" title="Q:为什么要用双指针?"></a>Q:为什么要用双指针?</h2><p>A:因为<br>通过使用双指针可以使算法的<strong>时间复杂度降低</strong>(或者降低遍历次数),有时也能<strong>降低空间复杂度</strong></p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>根据双指针的用法，可分为<strong>前后双指针</strong>,<strong>头尾双指针</strong>,<strong>快慢双指针</strong>…..</p><hr><h1 id="以下为各种双指针的应用及介绍"><a href="#以下为各种双指针的应用及介绍" class="headerlink" title="以下为各种双指针的应用及介绍"></a>以下为各种双指针的应用及介绍</h1><h2 id="前后双指针"><a href="#前后双指针" class="headerlink" title="前后双指针"></a>前后双指针</h2><h4 id="应用一-删除排序数组中的重复项"><a href="#应用一-删除排序数组中的重复项" class="headerlink" title="应用一 删除排序数组中的重复项"></a>应用一 删除排序数组中的重复项</h4><p><strong>要求</strong>:原地删除,并返回新数组的长度，不需要考虑数组中超出新长度后面的元素。</p><p><strong>思路</strong>:通过创建一前一后两个指针，<strong>前指针</strong>指向<strong>上一个元素</strong>，<strong>后指针</strong>向后历遍,一旦<strong>找到</strong>不同的元素,前指针指向<strong>下一个位置，并视为空位</strong>，通过<strong>后指针</strong>找到目标元素,并存入前指针目前所指向的<strong>空位</strong>。然后<strong>后指针</strong>接着遍历，直至遍历整个数组.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码实现</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span>&#123;</span><br><span class="line">    <span class="type">int</span>* left = nums;</span><br><span class="line">    <span class="type">int</span>*right = nums+<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//遍历数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;numsSize<span class="number">-1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(*left != *right)</span><br><span class="line">        &#123;</span><br><span class="line">            left++;</span><br><span class="line">            *left = *right;</span><br><span class="line">            right++;</span><br><span class="line">            ret++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>分析</strong>:这个函数只遍历的一遍数组，没有复制数组,所以<strong>时间复杂度</strong>为<code>O(n)</code>,<strong>空间复杂度</strong>为<code>O(1)</code>;</p><hr><h2 id="头尾双指针"><a href="#头尾双指针" class="headerlink" title="头尾双指针"></a>头尾双指针</h2><h4 id="应用一-翻转数组-字符串"><a href="#应用一-翻转数组-字符串" class="headerlink" title="应用一 翻转数组&#x2F;字符串"></a>应用一 翻转数组&#x2F;字符串</h4><p>关于翻转，首先想到的应该是创建一个<strong>等长的空数组</strong>，再同时顺序遍历<strong>原数组</strong>和逆序遍历<strong>空数组</strong>，逐位储存到空数组，然后再同时顺序遍历两个数组，将<strong>已逆序</strong>的数组拷贝至原数组</p><p><strong>缺点</strong>：需要<strong>多次</strong>遍历，且<strong>空间复杂度</strong>为O(n)</p><p><strong>使用双指针优化</strong>：整个数组的翻转可逐步拆解为：第一个和最后一个互换、第二个和倒数第二个互换、、、第N个数和倒数第N个数互换，直至中间。此处便可使用<strong>双指针</strong>，头尾指针各自一边<strong>交换</strong>所指向的内容，一边<strong>向中间靠近</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码实现-这里是翻转字符串</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">reverseString</span><span class="params">(<span class="type">char</span>* s, <span class="type">int</span> sSize)</span>&#123;</span><br><span class="line">    <span class="type">int</span> *left = s;<span class="comment">//头指针</span></span><br><span class="line">    <span class="type">int</span> *right = s + sSize<span class="number">-1</span>;<span class="comment">//尾指针</span></span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)<span class="comment">//尚未到达中间时</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> tmp = *left;</span><br><span class="line">        *left = *right;</span><br><span class="line">        *right = tmp;</span><br><span class="line">        left++;</span><br><span class="line">        right--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="快慢双指针"><a href="#快慢双指针" class="headerlink" title="快慢双指针"></a>快慢双指针</h2><h4 id="应用一-删除链表倒数第K个节点"><a href="#应用一-删除链表倒数第K个节点" class="headerlink" title="应用一 删除链表倒数第K个节点"></a>应用一 删除链表倒数第K个节点</h4><p><strong>一般解法</strong>：先遍历一遍链表获得链表总数N,再二次遍历到N-K处的节点，并执行删除</p><p><strong>如何优化</strong>：使用快慢双指针，仅需遍历一次，就能用慢指针定位目标节点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码实现</span></span><br><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">removeNthFromEnd</span><span class="params">(<span class="keyword">struct</span> ListNode* head, <span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="comment">//创建哨兵位解决头删问题</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">dummy</span> =</span> (<span class="keyword">struct</span> ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> ListNode));</span><br><span class="line">    dummy-&gt;val = <span class="number">0</span>;</span><br><span class="line">    dummy-&gt;next = head;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">slow</span> =</span> dummy;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">fast</span> =</span> dummy;</span><br><span class="line">    <span class="keyword">while</span> (<span class="type">int</span> i = <span class="number">0</span>;i&lt;n+<span class="number">1</span>;n++)<span class="comment">//移动fast</span></span><br><span class="line">    &#123;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(fast != <span class="literal">NULL</span>)<span class="comment">//同时遍历</span></span><br><span class="line">    &#123;</span><br><span class="line">        fast= fast-&gt;next;</span><br><span class="line">        slow= slow-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//此时slow指向目标节点的前一个节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">tmp</span> =</span> slow-&gt;next;</span><br><span class="line">    slow-&gt;next = slow-&gt;next-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(tmp);</span><br><span class="line">    <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="应用二-找出并返回链表中间的节点"><a href="#应用二-找出并返回链表中间的节点" class="headerlink" title="应用二 找出并返回链表中间的节点"></a>应用二 找出并返回链表中间的节点</h4><p><strong>注</strong>:偶数个节点时删除<strong>前一个</strong>中间节点</p><p><strong>一般解法</strong>：依然是先遍历一遍链表，然后定位中间的节点,二次遍历</p><p><strong>如何优化</strong>：使用<strong>慢指针</strong>(一步走一个节点)和<strong>快指针</strong>(一步走两个节点)，二者同时遍历，直至<strong>快指针</strong>指向<code>NULL</code>或快指针指向<code>尾节点</code></p><p>当遍历结束时，慢指针指向目标中间节点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码实现</span></span><br><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">middleNode</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">slow</span> =</span> head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">fast</span> =</span> head;</span><br><span class="line">    <span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next-&gt;next; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="应用三-循环链表问题"><a href="#应用三-循环链表问题" class="headerlink" title="应用三 循环链表问题"></a>应用三 循环链表问题</h2>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>=算法=按位异或^的种种玩法</title>
      <link href="/2023/09/04/%E7%AE%97%E6%B3%95_%E6%8C%89%E4%BD%8D%E5%BC%82%E6%88%96/"/>
      <url>/2023/09/04/%E7%AE%97%E6%B3%95_%E6%8C%89%E4%BD%8D%E5%BC%82%E6%88%96/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是按位异或"><a href="#什么是按位异或" class="headerlink" title="什么是按位异或^"></a>什么是按位异或<code>^</code></h2><p>首先将不同数制的数写成<strong>二进制</strong>,例如<code>9-&gt;0b1001</code>.<br>然后最末位对齐，依次<strong>按位异或</strong>.<br>规则:<code>0 ^ 0= 0 ; 1 ^ 1 = 0; 1 ^ 0 = 1</code><br>推论:任意整数<code>x</code>,都有<code>0^x = x</code>  ;   <code>x ^ x = 0</code>\</p><hr><p><strong>来看看应用</strong></p><h2 id="寻找一个单身狗数"><a href="#寻找一个单身狗数" class="headerlink" title="寻找一个单身狗数"></a>寻找一个单身狗数</h2><p>像<code>[1,3,2,2,3]</code>这样除了某一个数<code>1</code>,剩下的数字都是成对的,也就是说遍历一次数组，把所有的元素<strong>按位异或</strong>在一起，结果便是落单的那个<code>1</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码实现</span></span><br><span class="line"><span class="type">int</span> arr[] = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span> sz = <span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);<span class="comment">//求数组大小</span></span><br><span class="line"><span class="type">int</span> ret  = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i =<span class="number">0</span>;i&lt;sz;i++)</span><br><span class="line">&#123;</span><br><span class="line">    ret^=arr[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret; <span class="comment">//此时ret即为落单的那个数</span></span><br></pre></td></tr></table></figure><p><strong><em>变形</em></strong></p><h2 id="消失的数"><a href="#消失的数" class="headerlink" title="消失的数"></a>消失的数</h2><p>已知一个由0~n(缺失一个数)填充的数组，例<code>[0,6,4,2,3,1]</code>,例中的数组少了一个<code>5</code>,而我们已知数组包含0~6中的5个数，就可以将数组元素与0~6<strong>按位异或</strong>到一起，将问题<em>消失的数</em>转化为问题<em>寻找单身狗</em>,消失的数变成剩下的那个单身狗</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码实现</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">missingNumber</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;numsSize;i++&gt;)</span><br><span class="line">    &#123;</span><br><span class="line">        ret^=nums[i];<span class="comment">//历遍nums的所有元素</span></span><br><span class="line">        ret^=i;<span class="comment">//历遍0~numsSize-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    ret^=numsSize;<span class="comment">//补上numsSize;</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>进阶</em></strong></p><h2 id="找到两个单身狗"><a href="#找到两个单身狗" class="headerlink" title="找到两个单身狗"></a>找到两个单身狗</h2><p>数组再升级，单身狗变成了<strong>两个</strong>，导致不能粗暴地把所有元素按位异或来求出两个数,但我们仍可以将问题简化：能否将两个单身狗分到两个数组，使之转化为两个独立的<em>求单个单身狗问题</em>。于是难点来到了如何<strong>分组</strong></p><h3 id="方案之一便是运用按位异或和右移运算符"><a href="#方案之一便是运用按位异或和右移运算符" class="headerlink" title="方案之一便是运用按位异或和右移运算符"></a>方案之一便是运用<strong>按位异或</strong>和<strong>右移运算符</strong></h3><p>因为两个不同的数，在二进制上作比较，就至少有一位是不同的，以那一位为<code>0</code>或<code>1</code>分成两组，便可将两个单身狗分开.而若要查找具体是哪一位，将列表中<strong>所有元素</strong>（就包括了两数）<strong>按位异或</strong>后再用<strong>右移运算符</strong>逐位检验是否为<code>1</code>,之后便可轻松分组，并直接<strong>按位异或</strong>得出结果</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码实现</span></span><br><span class="line"><span class="type">int</span>* <span class="title function_">singleNumber</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> ret[<span class="number">2</span>])</span>&#123;</span><br><span class="line">    <span class="type">int</span> ret1 = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> ret2 = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">0</span>;<span class="comment">//用于记录&quot;1&quot;在哪一位</span></span><br><span class="line">    <span class="type">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;numsSize;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp^=nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>((tmp&gt;&gt;n) !=<span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        n++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;nums;i++&gt;)<span class="comment">//再次历遍</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((nums[i]&gt;&gt;n ==<span class="number">1</span>))<span class="comment">//分组1</span></span><br><span class="line">        &#123;</span><br><span class="line">            ret1^=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>  <span class="comment">//分组2</span></span><br><span class="line">        &#123;</span><br><span class="line">            ret2^=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ret[<span class="number">0</span>] = ret1;</span><br><span class="line">    ret[<span class="number">1</span>] = ret2;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>思考:3个，4个….N个单身狗时呢？</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>=C语言=动态内存分配遇上函数-经典错误纠错</title>
      <link href="/2023/08/28/mistake1/"/>
      <url>/2023/08/28/mistake1/</url>
      
        <content type="html"><![CDATA[<h3 id="直接完整代码"><a href="#直接完整代码" class="headerlink" title="直接完整代码"></a>直接完整代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">GetMemory</span><span class="params">(<span class="type">char</span>* p)</span>   <span class="comment">//申请内存</span></span><br><span class="line">&#123;</span><br><span class="line">p = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="number">100</span>);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Test</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span>* str = <span class="literal">NULL</span>;</span><br><span class="line">GetMemory(str);</span><br><span class="line"><span class="built_in">strcpy</span>(str, <span class="string">&quot;hello world&quot;</span>); <span class="comment">//复制字符串</span></span><br><span class="line"><span class="built_in">printf</span>(str);  <span class="comment">//输出字符串</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">Test();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>推测这段代码的的目的是通过<code>GetMemory</code>函数申请内存，然后把返回的地址存入指针变量<code>str</code>,再把字符串<code>&quot;hello world&quot;</code>复制到<code>str</code>所指向的内存中，最后<code>printf</code>输出</p><h4 id="逐步纠错"><a href="#逐步纠错" class="headerlink" title="逐步纠错"></a>逐步纠错</h4><h5 id="GetMemory"><a href="#GetMemory" class="headerlink" title="GetMemory"></a><code>GetMemory</code></h5><ol><li>首先是传参错误。若在函数内修改外部的一级指针，不能直接将外部一级指针作为<strong>实参</strong>传入：因为函数会将<strong>实参</strong>赋给<strong>形参</strong>，程序运行到大括号外面后，<strong>形参</strong>被销毁，<strong>实参</strong>没有变化。所以应该使用<code>char** p</code>二级指针作为<strong>形参</strong>,储存地址时使用<code>*p</code>\</li><li>其次是内存泄漏。开辟的内存的地址并没有传递给实参，形参又最后销毁了，同时没有释放内存，函数运行完后申请的内存无法找到，导致最终无法释放，造成内存泄漏</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//更合适的代码</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GetMenmory</span><span class="params">(<span class="type">char</span>** p)</span></span><br><span class="line">&#123;</span><br><span class="line">    *p = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="Test"><a href="#Test" class="headerlink" title="Test"></a><code>Test</code></h5><ol><li>NULL的大问题。假设<code>malloc</code>返回的地址已经存入<code>str</code>,但任然缺少对空指针的判断,导致<code>strcmp</code>中传入了空指针-&gt;报错;<code>printf</code>中传入空指针-&gt;报错</li><li>没有释放内存-&gt;内存泄漏。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//更适合的代码</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Test</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span>* str = <span class="literal">NULL</span>;</span><br><span class="line">    GetMemory(str);</span><br><span class="line">    <span class="keyword">if</span>(str == MULL)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">strcpy</span>(str,<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,str);</span><br><span class="line">    <span class="built_in">free</span>(str); <span class="comment">//防止内存泄漏</span></span><br><span class="line">    str = <span class="literal">NULL</span>; <span class="comment">//清除野指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
