<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>进程间通信</title>
      <link href="/2024/08/02/progressMSG/"/>
      <url>/2024/08/02/progressMSG/</url>
      
        <content type="html"><![CDATA[<p>本篇博客更偏向于总括和导航,部分概念更细致的介绍将内嵌链接在文章中</p><p><strong>重点内容</strong></p><ul><li>初识进程间通信</li><li>管道</li><li>消息队列</li><li>共享内存</li><li>信号量</li></ul><h1 id="进程间通信的目的"><a href="#进程间通信的目的" class="headerlink" title="进程间通信的目的"></a>进程间通信的目的</h1><ul><li>数据传输： 一个进程需要将它的数据<strong>发送</strong>给另一个进程</li><li>资源共享： 多个进程之间<strong>共享</strong>同样的资源</li><li>通知事件：一个进程需要向另一个或一组进程<strong>发送消息</strong>，<strong>通知</strong>它（它们）发生了某种事件（如子进程终止时要通知父进程）</li><li>进程控制： 有些进程希望<strong>完全控制</strong>另一个进程的执行（如Debug进程），此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变</li></ul><h1 id="进程间通信的主要方式"><a href="#进程间通信的主要方式" class="headerlink" title="进程间通信的主要方式"></a>进程间通信的主要方式</h1><ul><li>管道</li><li>System V进程间通信</li><li>POSIX进程间通信</li></ul><h1 id="进程间通信的分类"><a href="#进程间通信的分类" class="headerlink" title="进程间通信的分类"></a>进程间通信的分类</h1><h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><ul><li>匿名管道</li><li>命名管道</li></ul><h2 id="System-V-IPC"><a href="#System-V-IPC" class="headerlink" title="System V IPC"></a>System V IPC</h2><ul><li>System V 消息队列</li><li>SysTem V 共享内存</li><li>System V 信号量</li></ul><h2 id="POSIX-IPC"><a href="#POSIX-IPC" class="headerlink" title="POSIX IPC"></a>POSIX IPC</h2><ul><li>消息队列</li><li>共享内存</li><li>信号量</li><li>互斥量</li><li>条件变量</li><li>读写锁</li></ul><h1 id="管道-1"><a href="#管道-1" class="headerlink" title="管道"></a>管道</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>进程间通信--匿名管道与命名管道</title>
      <link href="/2024/08/02/pipe/"/>
      <url>/2024/08/02/pipe/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是管道文件"><a href="#什么是管道文件" class="headerlink" title="什么是管道文件"></a>什么是管道文件</h1><h1 id="匿名管道"><a href="#匿名管道" class="headerlink" title="匿名管道"></a>匿名管道</h1><h2 id="小小项目–进程池"><a href="#小小项目–进程池" class="headerlink" title="小小项目–进程池"></a>小小项目–进程池</h2><p>详见<a href="https://www.supdriver.top/2024/08/02/processPool/">此博客🔗</a></p><h1 id="命名管道"><a href="#命名管道" class="headerlink" title="命名管道"></a>命名管道</h1>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Linux】简易进程池</title>
      <link href="/2024/08/02/processPool/"/>
      <url>/2024/08/02/processPool/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【数据结构】一步到胃，键值对版二叉搜索树</title>
      <link href="/2024/07/27/BSTree/"/>
      <url>/2024/07/27/BSTree/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是二叉搜索树"><a href="#什么是二叉搜索树" class="headerlink" title="什么是二叉搜索树"></a>什么是二叉搜索树</h1><p>二叉搜索树的<code>定义</code>是一颗二叉树的所有节点满足:<code>根的左右孩子存在时，满足 左孩子 &lt; 根 &lt; 右孩子</code></p><p><code>递归定义</code>则是:</p><ol><li><code>左子树的根</code> &lt; <code>根</code> &lt; <code>右子树的根</code></li><li><code>左子树是二叉搜索树</code>,<code>右子树是二叉搜索树</code></li></ol><h2 id="写一个验证二叉搜索树的函数"><a href="#写一个验证二叉搜索树的函数" class="headerlink" title="写一个验证二叉搜索树的函数"></a>写一个验证二叉搜索树的函数</h2><p><a href="https://leetcode.cn/problems/validate-binary-search-tree/">Leetecode题目链接🔗</a></p><h1 id="封装一个二叉树类"><a href="#封装一个二叉树类" class="headerlink" title="封装一个二叉树类"></a>封装一个二叉树类</h1><h2 id="文件布置"><a href="#文件布置" class="headerlink" title="文件布置"></a>文件布置</h2><ul><li><code>BSTree.h</code>用于声明和实现<code>BSTree</code>类</li><li><code>test.cpp</code>用于测试</li></ul><h3 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h3><p><code>BSTree.h</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>test.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;BSTree.h&quot;</span></span></span><br></pre></td></tr></table></figure><h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> key_value</span><br></pre></td></tr></table></figure><p>这里使用<code>key_value</code>作为命名空间，表示这是键值表示的搜索二叉树</p><h2 id="定义节点"><a href="#定义节点" class="headerlink" title="定义节点"></a>定义节点</h2><p>二叉树的节点用于储存<code>键值对</code>和<code>左右指针</code>，并提供<code>默认构造函数</code>,使用<code>初始化列表</code>初始化成员变量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">K</span>,<span class="keyword">class</span> <span class="title class_">V</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BSTNode</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BSTNode</span>(<span class="type">const</span> K&amp; key = <span class="built_in">K</span>(), <span class="type">const</span> V&amp; value = <span class="built_in">V</span>())</span><br><span class="line">        :_left(<span class="literal">nullptr</span>)</span><br><span class="line">        , _right(<span class="literal">nullptr</span>)</span><br><span class="line">        , _key(key)</span><br><span class="line">        , _value(value)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    BSTNode&lt;K, V&gt;* _left;<span class="comment">//指向左子树</span></span><br><span class="line">    BSTNode&lt;K, V&gt;* _right;<span class="comment">//指向右子树</span></span><br><span class="line">    K _key;<span class="comment">//储存键</span></span><br><span class="line">    V _value;<span class="comment">//储存值</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="封装二叉搜索树"><a href="#封装二叉搜索树" class="headerlink" title="封装二叉搜索树"></a>封装二叉搜索树</h2><p><code>Binary Search Tree</code>,这里用简称<code>BSTree</code>封装</p><h3 id="基本架构"><a href="#基本架构" class="headerlink" title="基本架构"></a>基本架构</h3><p>鉴于该类的接口基本依赖于成员变量，所以先组织好成员变量</p><p>作为一颗<code>二叉树类</code>,成员变量仅需一个<code>指向根的指</code>针即可</p><p>再次之前先用<code>typedef</code>定义一个<code>节点类</code>出来用于简化代码</p><p>最后提供一个<code>默认构造函数</code>将<code>_root</code>初始化为<code>nullptr</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">K</span>,<span class="keyword">class</span> <span class="title class_">V</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BSTree</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">typedef</span> BSTNode&lt;K, V&gt; Node;<span class="comment">//使用typedef简化代码</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">BSTree</span>() :_root(<span class="literal">nullptr</span>) &#123;&#125;<span class="comment">//提供默认构造函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Node* _root;<span class="comment">//指向根节点的指针作为成员变量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="insert函数"><a href="#insert函数" class="headerlink" title="insert函数"></a><code>insert</code>函数</h3><p>准备好后第一个接口就是<code>insert</code>,用于构建搜索二叉树</p><p>这里需要考虑的情况有</p><ul><li>空树时的插入</li><li>插入的<code>key</code>已存在</li><li>一般情况下成功的插入</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> K&amp; key, <span class="type">const</span> V&amp; value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (_root == <span class="literal">nullptr</span>)<span class="comment">//空树</span></span><br><span class="line">    &#123;</span><br><span class="line">        _root = <span class="keyword">new</span> <span class="built_in">Node</span>(key, value);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node* cur = _root;</span><br><span class="line">    Node* parent = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (key &lt; cur-&gt;_key)<span class="comment">//key比当前节点小，往左子树走</span></span><br><span class="line">        &#123;</span><br><span class="line">            parent = cur;</span><br><span class="line">            cur = cur-&gt;_left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; cur-&gt;_key)<span class="comment">//往右子树走</span></span><br><span class="line">        &#123;</span><br><span class="line">            parent = cur;</span><br><span class="line">            cur = cur-&gt;_right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//key已存在，插入失败</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//此时cur为nullptr, parent为cur的结点</span></span><br><span class="line">    <span class="keyword">if</span> (key &lt; parent-&gt;_key)parent-&gt;_left = <span class="keyword">new</span> <span class="built_in">Node</span>(key, value);</span><br><span class="line">    <span class="keyword">else</span> parent-&gt;_right = <span class="keyword">new</span> <span class="built_in">Node</span>(key, value);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//成功插入</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="in-order函数"><a href="#in-order函数" class="headerlink" title="in_order函数"></a><code>in_order</code>函数</h3><p>使用此函数<code>前序遍历打印</code>二叉树来验证其满足<code>搜索树</code>的性质</p><p>这里使用递归打印,所以要借助<code>_in_order</code>子函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">in_order</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _in_order(_root);<span class="comment">//传入根结点</span></span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">void</span> _in_order(Node* root)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        _in_order(root-&gt;_left);<span class="comment">//先访问左结点</span></span><br><span class="line">        std::cout &lt;&lt; root-&gt;_value &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; std::endl;<span class="comment">//再访问根结点</span></span><br><span class="line">        _in_order(root-&gt;_right);<span class="comment">//最后访问右结点</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>然后写一段测试代码测试性质</p><blockquote><p>test.cpp</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;BSTree.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">arr</span><span class="params">(&#123; <span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">7</span> &#125;)</span></span>;<span class="comment">//准备待插入的键值对</span></span><br><span class="line">key_value::BSTree&lt;<span class="type">int</span>, <span class="type">int</span>&gt; bst;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); ++i)</span><br><span class="line">&#123;</span><br><span class="line">bst.<span class="built_in">insert</span>(arr[i],arr[i]);<span class="comment">//这里使键值相同，方便观察</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bst.<span class="built_in">in_order</span>();<span class="comment">//测试</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="find函数"><a href="#find函数" class="headerlink" title="find函数"></a><code>find</code>函数</h3><p>可以用<code>find</code>函数查找对应<code>key</code>的结点。</p><p>同时观察可知，控制<code>cur</code>和<code>parent</code>的移动的代码段和前面的函数很像，所以给<code>find</code>函数分出来一个<code>_find</code>子函数，并使它返回<code>pair&lt;Node*,Node*&gt;</code>，将这两个指针返回利于其它函数对<code>_find</code>的回调</p><p>同时为了简化代码，继续用<code>typedef</code>封装类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> std::pair&lt; Node*, Node* &gt; PNN;<span class="comment">//简化代码</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">const</span> K&amp; key)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _find(key).first != <span class="literal">nullptr</span>;<span class="comment">//检查是否找到</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"></span><br><span class="line">    PNN _find(<span class="type">const</span> K&amp; key)<span class="comment">//返回PNN用于简化其它接口</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (_root == <span class="literal">nullptr</span>) <span class="keyword">return</span> &#123;<span class="literal">nullptr</span>,<span class="literal">nullptr</span>&#125;;</span><br><span class="line">        Node* cur = _root;</span><br><span class="line">        Node* parent = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (key &lt; cur-&gt;_key)<span class="comment">//key比当前节点小，往左子树走</span></span><br><span class="line">            &#123;</span><br><span class="line">                parent = cur;</span><br><span class="line">                cur = cur-&gt;_left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; cur-&gt;_key)<span class="comment">//往右子树走</span></span><br><span class="line">            &#123;</span><br><span class="line">                parent = cur;</span><br><span class="line">                cur = cur-&gt;_right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//找到key</span></span><br><span class="line">                <span class="keyword">return</span> &#123; cur,parent &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//没找到key,cur为nullptr</span></span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="literal">nullptr</span>,parent &#125;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="重写insert函数"><a href="#重写insert函数" class="headerlink" title="重写insert函数"></a>重写<code>insert</code>函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> K&amp; key, <span class="type">const</span> V&amp; value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (_root == <span class="literal">nullptr</span>)<span class="comment">//空树</span></span><br><span class="line">    &#123;</span><br><span class="line">        _root = <span class="keyword">new</span> <span class="built_in">Node</span>(key, value);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//====修改的部分====</span></span><br><span class="line">    PNN pnn = _find(key);</span><br><span class="line"></span><br><span class="line">    Node* cur = pnn.first;</span><br><span class="line">    Node* parent = pnn.second;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cur != <span class="literal">nullptr</span>)<span class="comment">//该key已存在，插入失败</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//================</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//此时cur为nullptr, parent为cur的结点</span></span><br><span class="line">    <span class="keyword">if</span> (key &lt; parent-&gt;_key)parent-&gt;_left = <span class="keyword">new</span> <span class="built_in">Node</span>(key, value);</span><br><span class="line">    <span class="keyword">else</span> parent-&gt;_right = <span class="keyword">new</span> <span class="built_in">Node</span>(key, value);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//成功插入</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="erase函数"><a href="#erase函数" class="headerlink" title="erase函数"></a><code>erase</code>函数</h3><p>这里也可以复用<code>_find</code>来方便地删除结点</p><p>这里要考虑的情况有:</p><ul><li>树为空</li><li>删除最后一个结点</li><li>删除根节点</li><li>左子树为空（包括叶子结点）</li><li>右子树为空</li><li>删除一般的结点</li></ul><p>当树有<code>&gt;=2</code>个结点，且要删除<code>非叶子</code>结点时，要考虑<code>结点替换</code>，否则二叉树会断掉，这里一般两种策略，取左子树的最右结点（最大结点），或取右子树的最左结点（最小结点）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">erase</span><span class="params">(<span class="type">const</span> K&amp; key)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (_root == <span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//空树无法删除</span></span><br><span class="line">        <span class="keyword">if</span> (_root-&gt;_key == key &amp;&amp; _root-&gt;_left == <span class="literal">nullptr</span> &amp;&amp; _root-&gt;_right == <span class="literal">nullptr</span>)<span class="comment">//删除最后一个结点</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> _root;</span><br><span class="line">            _root = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        PNN pnn = _find(key);</span><br><span class="line">        Node* cur = pnn.first;</span><br><span class="line">        Node* parent = pnn.second;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//没找到该结点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//下面的cur必不为空</span></span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;_left == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur == _root)<span class="comment">//为根节点时要替换根节点</span></span><br><span class="line">            &#123;</span><br><span class="line">                Node* right = _root-&gt;_right;</span><br><span class="line">                <span class="keyword">delete</span> _root;</span><br><span class="line">                _root = right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//没有左子树，则直接移除结点,右子树替代原结点</span></span><br><span class="line">            <span class="keyword">if</span> (cur == parent-&gt;_left) parent-&gt;_left = cur-&gt;_right;</span><br><span class="line">            <span class="keyword">else</span> parent-&gt;_right = cur-&gt;_right;</span><br><span class="line">            <span class="keyword">delete</span> cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cur-&gt;_right == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur == _root)</span><br><span class="line">            &#123;</span><br><span class="line">                Node* left = _root-&gt;_left;</span><br><span class="line">                <span class="keyword">delete</span> _root;</span><br><span class="line">                _root = left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//直接过继左子树</span></span><br><span class="line">            <span class="keyword">if</span> (cur == parent-&gt;_left)parent-&gt;_left = cur-&gt;_left;</span><br><span class="line">            <span class="keyword">else</span> parent-&gt;_right = cur-&gt;_left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//找到左子树的最右结点</span></span><br><span class="line">            Node* _cur = cur-&gt;_left;</span><br><span class="line">            Node* _parent = cur;</span><br><span class="line">            <span class="keyword">while</span> (_cur-&gt;_right != <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                _parent = _cur;</span><br><span class="line">                _cur = _cur-&gt;_right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//移走结点</span></span><br><span class="line">            <span class="keyword">if</span> (_cur == _parent-&gt;_left) _parent-&gt;_left = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">else</span> _parent-&gt;_right = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="comment">//获取cur的左右结点,必须再移走结点后，否则可能出现指向自己的结点</span></span><br><span class="line">            _cur-&gt;_left = cur-&gt;_left;</span><br><span class="line">            _cur-&gt;_right = cur-&gt;_right;</span><br><span class="line">            <span class="comment">//代替cur的位置</span></span><br><span class="line">            <span class="keyword">if</span> (cur == _root)<span class="comment">//删除根结点时</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">delete</span> _root;</span><br><span class="line">                _root = _cur;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span><span class="comment">//删除普通结点时</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (cur == parent-&gt;_left) parent-&gt;_left = _cur;</span><br><span class="line">                <span class="keyword">else</span> parent-&gt;_right = _cur;</span><br><span class="line">                <span class="keyword">delete</span> cur;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="拷贝构造"><a href="#拷贝构造" class="headerlink" title="拷贝构造"></a>拷贝构造</h3><p>利用二叉树的性质，可以再构建个<code>copy</code>子函数来递归拷贝</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BSTree</span>(<span class="type">const</span> BSTree&lt;K&gt;&amp; t)</span><br><span class="line">    &#123;</span><br><span class="line">        _root = <span class="built_in">Copy</span>(t._root);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">copy</span><span class="params">(Node* root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;<span class="comment">//递归出口</span></span><br><span class="line">        Node* pnode = <span class="keyword">new</span> <span class="built_in">Node</span>(root-&gt;_key, root-&gt;_value);<span class="comment">//复制结点</span></span><br><span class="line">        pnode-&gt;_left = <span class="built_in">copy</span>(root-&gt;_left);</span><br><span class="line">        pnode-&gt;_right = <span class="built_in">copy</span>(root-&gt;_right);</span><br><span class="line">        <span class="keyword">return</span> pnode;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><p>这里也用<code>destroy</code>子函数来递归地后序遍历依次删除各个结点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">BSTree</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">destroy</span>(_root);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">destroy</span><span class="params">(Node* root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">destroy</span>(root-&gt;_left);</span><br><span class="line">        <span class="built_in">destroy</span>(root-&gt;_right);</span><br><span class="line">        <span class="keyword">delete</span> root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>至此，一个基本的二叉搜索树已封装完成</p><p>实现的功能有</p><ul><li>构建二叉搜索树</li><li>拷贝复制二叉树</li><li>按<code>key</code>值查找</li><li>按<code>key</code>值删除</li></ul><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> key_value</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">K</span>,<span class="keyword">class</span> <span class="title class_">V</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BSTNode</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">BSTNode</span>(<span class="type">const</span> K&amp; key = <span class="built_in">K</span>(), <span class="type">const</span> V&amp; value = <span class="built_in">V</span>())</span><br><span class="line">:_left(<span class="literal">nullptr</span>)</span><br><span class="line">, _right(<span class="literal">nullptr</span>)</span><br><span class="line">, _key(key)</span><br><span class="line">, _value(value)</span><br><span class="line">&#123;&#125;</span><br><span class="line">BSTNode&lt;K, V&gt;* _left;<span class="comment">//指向左子树</span></span><br><span class="line">BSTNode&lt;K, V&gt;* _right;<span class="comment">//指向右子树</span></span><br><span class="line">K _key;<span class="comment">//储存键</span></span><br><span class="line">V _value;<span class="comment">//储存值</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">K</span>,<span class="keyword">class</span> <span class="title class_">V</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BSTree</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">typedef</span> BSTNode&lt;K, V&gt; Node;<span class="comment">//使用typedef简化代码</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">BSTree</span>() :_root(<span class="literal">nullptr</span>) &#123;&#125;<span class="comment">//提供默认构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">BSTree</span>(<span class="type">const</span> BSTree&lt;K, V&gt;&amp; bst)</span><br><span class="line">&#123;</span><br><span class="line">_root = <span class="built_in">copy</span>(bst._root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">BSTree</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">destroy</span>(_root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> K&amp; key, <span class="type">const</span> V&amp; value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (_root == <span class="literal">nullptr</span>)<span class="comment">//空树</span></span><br><span class="line">&#123;</span><br><span class="line">_root = <span class="keyword">new</span> <span class="built_in">Node</span>(key, value);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//====修改的部分====</span></span><br><span class="line">PNN pnn = _find(key);</span><br><span class="line"></span><br><span class="line">Node* cur = pnn.first;</span><br><span class="line">Node* parent = pnn.second;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cur != <span class="literal">nullptr</span>)<span class="comment">//该key已存在，插入失败</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//此时cur为nullptr, parent为cur的结点</span></span><br><span class="line"><span class="keyword">if</span> (key &lt; parent-&gt;_key)parent-&gt;_left = <span class="keyword">new</span> <span class="built_in">Node</span>(key, value);</span><br><span class="line"><span class="keyword">else</span> parent-&gt;_right = <span class="keyword">new</span> <span class="built_in">Node</span>(key, value);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//成功插入</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">in_order</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">_in_order(_root);<span class="comment">//传入根结点</span></span><br><span class="line">std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="type">void</span> _in_order(Node* root)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">_in_order(root-&gt;_left);<span class="comment">//先访问左结点</span></span><br><span class="line">std::cout &lt;&lt; root-&gt;_value &lt;&lt; <span class="string">&quot; &quot;</span>;<span class="comment">//再访问根结点</span></span><br><span class="line">_in_order(root-&gt;_right);<span class="comment">//最后访问右结点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt; Node*, Node* &gt; PNN;<span class="comment">//简化代码</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">const</span> K&amp; key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _find(key).first != <span class="literal">nullptr</span>;<span class="comment">//检查是否找到</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"></span><br><span class="line">PNN _find(<span class="type">const</span> K&amp; key)<span class="comment">//返回PNN用于简化其它接口</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (_root == <span class="literal">nullptr</span>) <span class="keyword">return</span> &#123;<span class="literal">nullptr</span>,<span class="literal">nullptr</span>&#125;;</span><br><span class="line">Node* cur = _root;</span><br><span class="line">Node* parent = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">while</span> (cur)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (key &lt; cur-&gt;_key)<span class="comment">//key比当前节点小，往左子树走</span></span><br><span class="line">&#123;</span><br><span class="line">parent = cur;</span><br><span class="line">cur = cur-&gt;_left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (key &gt; cur-&gt;_key)<span class="comment">//往右子树走</span></span><br><span class="line">&#123;</span><br><span class="line">parent = cur;</span><br><span class="line">cur = cur-&gt;_right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//找到key</span></span><br><span class="line"><span class="keyword">return</span> &#123; cur,parent &#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//没找到key,cur为nullptr</span></span><br><span class="line"><span class="keyword">return</span> &#123; <span class="literal">nullptr</span>,parent &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">erase</span><span class="params">(<span class="type">const</span> K&amp; key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (_root == <span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//空树无法删除</span></span><br><span class="line"><span class="keyword">if</span> (_root-&gt;_key == key &amp;&amp; _root-&gt;_left == <span class="literal">nullptr</span> &amp;&amp; _root-&gt;_right == <span class="literal">nullptr</span>)<span class="comment">//删除最后一个结点</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> _root;</span><br><span class="line">_root = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line">PNN pnn = _find(key);</span><br><span class="line">Node* cur = pnn.first;</span><br><span class="line">Node* parent = pnn.second;</span><br><span class="line"><span class="keyword">if</span> (cur == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//没找到该结点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//下面的cur必不为空</span></span><br><span class="line"><span class="keyword">if</span>(cur-&gt;_left == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (cur == _root)<span class="comment">//为根节点时要替换根节点</span></span><br><span class="line">&#123;</span><br><span class="line">Node* right = _root-&gt;_right;</span><br><span class="line"><span class="keyword">delete</span> _root;</span><br><span class="line">_root = right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//没有左子树，则直接移除结点,右子树替代原结点</span></span><br><span class="line"><span class="keyword">if</span> (cur == parent-&gt;_left) parent-&gt;_left = cur-&gt;_right;</span><br><span class="line"><span class="keyword">else</span> parent-&gt;_right = cur-&gt;_right;</span><br><span class="line"><span class="keyword">delete</span> cur;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (cur-&gt;_right == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (cur == _root)</span><br><span class="line">&#123;</span><br><span class="line">Node* left = _root-&gt;_left;</span><br><span class="line"><span class="keyword">delete</span> _root;</span><br><span class="line">_root = left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//直接过继左子树</span></span><br><span class="line"><span class="keyword">if</span> (cur == parent-&gt;_left)parent-&gt;_left = cur-&gt;_left;</span><br><span class="line"><span class="keyword">else</span> parent-&gt;_right = cur-&gt;_left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//找到左子树的最右结点</span></span><br><span class="line">Node* _cur = cur-&gt;_left;</span><br><span class="line">Node* _parent = cur;</span><br><span class="line"><span class="keyword">while</span> (_cur-&gt;_right != <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">_parent = _cur;</span><br><span class="line">_cur = _cur-&gt;_right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//移走结点</span></span><br><span class="line"><span class="keyword">if</span> (_cur == _parent-&gt;_left) _parent-&gt;_left = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">else</span> _parent-&gt;_right = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="comment">//获取cur的左右结点,必须再移走结点后，否则可能出现指向自己的结点</span></span><br><span class="line">_cur-&gt;_left = cur-&gt;_left;</span><br><span class="line">_cur-&gt;_right = cur-&gt;_right;</span><br><span class="line"><span class="comment">//代替cur的位置</span></span><br><span class="line"><span class="keyword">if</span> (cur == _root)<span class="comment">//删除根结点时</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> _root;</span><br><span class="line">_root = _cur;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span><span class="comment">//删除普通结点时</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (cur == parent-&gt;_left) parent-&gt;_left = _cur;</span><br><span class="line"><span class="keyword">else</span> parent-&gt;_right = _cur;</span><br><span class="line"><span class="keyword">delete</span> cur;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="function">Node* <span class="title">copy</span><span class="params">(Node* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;<span class="comment">//递归出口</span></span><br><span class="line">Node* pnode = <span class="keyword">new</span> <span class="built_in">Node</span>(root-&gt;_key, root-&gt;_value);<span class="comment">//复制结点</span></span><br><span class="line">pnode-&gt;_left = <span class="built_in">copy</span>(root-&gt;_left);</span><br><span class="line">pnode-&gt;_right = <span class="built_in">copy</span>(root-&gt;_right);</span><br><span class="line"><span class="keyword">return</span> pnode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">destroy</span><span class="params">(Node* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">destroy</span>(root-&gt;_left);</span><br><span class="line"><span class="built_in">destroy</span>(root-&gt;_right);</span><br><span class="line"><span class="keyword">delete</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Node* _root;<span class="comment">//指向根节点的指针作为成员变量</span></span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 二叉树 搜索树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件缓冲区</title>
      <link href="/2024/07/26/c-file-cache/"/>
      <url>/2024/07/26/c-file-cache/</url>
      
        <content type="html"><![CDATA[<p>前置博客 <a href="https://www.supdriver.top/2024/07/10/basicIO/">基础IO</a></p><h1 id="为什么有缓冲"><a href="#为什么有缓冲" class="headerlink" title="为什么有缓冲"></a>为什么有缓冲</h1><p>因为<code>磁盘的读写</code>与<code>内存的读写</code>操作速度相比，磁盘的读写是相差数量级的慢，所以为了提高内存<strong>多次</strong>，<strong>频繁</strong>读写磁盘文件的效率，<code>缓冲区</code>被投入使用。尤其是内存内容<strong>写入</strong>磁盘时，常常先写入<code>内存级缓冲区</code>，再在特定规则下一次性将<code>缓冲区</code>的内容写入磁盘</p><p>**本文以<code>C语言</code>提供的用户级缓冲区为例介绍缓冲区</p><h1 id="缓冲区的刷新规则"><a href="#缓冲区的刷新规则" class="headerlink" title="缓冲区的刷新规则"></a>缓冲区的刷新规则</h1><p>首先当一个进程<strong>正常退出</strong>时，会先刷新缓冲区再关闭文件,此时必定有一次刷新</p><p>而当进程<strong>运行时</strong>缓冲区的刷新策略主要有以下三种</p><ul><li><code>无缓冲</code> 内容直接写入文件</li><li><code>行缓冲</code> 输入一般内容不刷新，遇到<code>\n</code>时刷新一次缓冲区</li><li><code>全缓冲</code> 缓冲区有容量限制，<strong>满了</strong>之后就刷新</li></ul><h1 id="认识一下C语言的缓冲区"><a href="#认识一下C语言的缓冲区" class="headerlink" title="认识一下C语言的缓冲区"></a>认识一下C语言的缓冲区</h1><p><em>这里的系统环境是Linux</em></p><h2 id="刷新规则"><a href="#刷新规则" class="headerlink" title="刷新规则"></a>刷新规则</h2><p>运行如下代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    FILE* pfile = fopen(<span class="string">&quot;file.txt&quot;</span>,<span class="string">&quot;w&quot;</span>);<span class="comment">//打开空文件</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>,<span class="string">&quot;stdout&quot;</span>);<span class="comment">//向标准输出输出</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;strerr&quot;</span>);<span class="comment">//向标准错误输出输出</span></span><br><span class="line">    <span class="built_in">fprintf</span>(pfile,<span class="string">&quot;file&quot;</span>);<span class="comment">//向文件输出</span></span><br><span class="line">    _exit(<span class="number">0</span>);<span class="comment">//不刷新缓冲区，直接退出</span></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>终端和文件的内容为:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stderr</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到只有<code>标准错误输出</code>有实际的输出,而<code>标准输出</code>和<code>文件输出</code>都没有输出</p><p>目前可以得出：</p><ul><li><code>标准错误输出</code>是<code>无缓冲</code>的刷新规则</li></ul><p>因此我们再运行如下代码，再输出内容后面加上<code>\n</code>换行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    FILE* pfile = fopen(<span class="string">&quot;file.txt&quot;</span>,<span class="string">&quot;w&quot;</span>);<span class="comment">//打开空文件</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>,<span class="string">&quot;stdout\n&quot;</span>);<span class="comment">//向标准输出输出</span></span><br><span class="line">    <span class="built_in">fprintf</span>(pfile,<span class="string">&quot;file\n&quot;</span>);<span class="comment">//向文件输出</span></span><br><span class="line">    _exit(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>终端输出内容为</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stdout</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>而文件依然为空</strong></p><p>由此可得:</p><ul><li><code>标准输出</code>遵循<code>行缓冲</code>的刷新规则</li><li><code>文件输出</code>遵循<code>全缓冲</code>的刷新规则</li></ul><h2 id="缓冲区在fork中的行为"><a href="#缓冲区在fork中的行为" class="headerlink" title="缓冲区在fork中的行为"></a>缓冲区在fork中的行为</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello1 &quot;</span>);<span class="comment">//父进程向标准输出打印一句话</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>,<span class="string">&quot;hello2 &quot;</span>);<span class="comment">//父进程向标准输出打印一句话</span></span><br><span class="line"></span><br><span class="line">    fork();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上段代码的输出内容为</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello1 hello2 hello1 hello2 </span><br></pre></td></tr></table></figure><p>可见<code>fork</code>前的缓冲区内容被打印了两次（父子进程各一次），所以<code>fork</code>也会复制<code>缓冲区</code>的内容</p><p>实际上<code>缓冲区</code>属于进程的一部分，且<code>fork</code>时遵循<code>写时拷贝</code></p><h1 id="模拟一下C语言的文件接口（包括缓冲区）"><a href="#模拟一下C语言的文件接口（包括缓冲区）" class="headerlink" title="模拟一下C语言的文件接口（包括缓冲区）"></a>模拟一下C语言的文件接口（包括缓冲区）</h1><h2 id="主要目标"><a href="#主要目标" class="headerlink" title="主要目标"></a>主要目标</h2><p>采用<code>Mystdio.h</code>声明，<code>Mystdio.c</code>实现的方式，封装<code>read</code>,<code>write</code>,<code>close</code>系统调用接口。并提供用户级缓冲区和缓冲区的刷新等功能</p><h2 id="声明结构体和接口"><a href="#声明结构体和接口" class="headerlink" title="声明结构体和接口"></a>声明结构体和接口</h2><p>我们先把主要的接口和主要的内容做出来看看封装效果</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MYSTDIO_H__ <span class="comment">//利用预编译防止头文件被重复编译</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MYSTDIO_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//声明文件结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">IO_FILE</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> fileno;</span><br><span class="line">&#125;_FILE;</span><br><span class="line"></span><br><span class="line">_FILE * _fopen(<span class="type">const</span> <span class="type">char</span> *filename,<span class="type">const</span> <span class="type">char</span> *flag);</span><br><span class="line"><span class="type">int</span> _fwrite(_FILE* fp,<span class="type">const</span> <span class="type">char</span>*s, <span class="type">int</span> len);</span><br><span class="line"><span class="type">void</span> _fclose(_FILE* fp);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br></pre></td></tr></table></figure><h2 id="部分实现接口"><a href="#部分实现接口" class="headerlink" title="部分实现接口"></a>部分实现接口</h2><p>实现的部分由<code>Mystdio.c</code>完成</p><h3 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h3><p>这里的头文件要能够提供使用系统调用接口,以及调用堆区的接口,所以 头文件如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Mystdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="fopen函数"><a href="#fopen函数" class="headerlink" title="_fopen函数"></a>_fopen函数</h3><p>我们先模拟实现<code>fopen</code>函数的主要功能，主要实现<code>&quot;w&quot;``&quot;a&quot;``&quot;r&quot;</code>的打开模式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FILE_MODE 0666 <span class="comment">//设置默认的文件权限</span></span></span><br><span class="line"></span><br><span class="line">_FILE * _fopen(<span class="type">const</span> <span class="type">char</span> *filename,<span class="type">const</span> <span class="type">char</span> *flag)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> f = <span class="number">0</span>;<span class="comment">//准备空位图</span></span><br><span class="line">    <span class="type">int</span> fd = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(flag,<span class="string">&quot;w&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        f = (O_CREAT|O_WRONLY|O_TRUNC);</span><br><span class="line">        fd = open(filename,f,FILE_MODE);<span class="comment">//打开文件</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strcmp</span>(flag,<span class="string">&quot;a&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        f = (O_CREAT|O_WRONLY|O_APPEND);</span><br><span class="line">        fd = open(filename,f,FILE_MODE);<span class="comment">//打开文件</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strcmp</span>(flag,<span class="string">&quot;w&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        f = O_RDONLY;</span><br><span class="line">        fd = open(filename,f);<span class="comment">//打开文件</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">NULL</span>;<span class="comment">//非法的打开模式</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;<span class="comment">//打开失败</span></span><br><span class="line">    </span><br><span class="line">    _FILE *fp = (_FILE*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(_FILE));<span class="comment">//创建_FILE结构体</span></span><br><span class="line">    fp-&gt;fileno = fp;<span class="comment">//设置_FILE结构体</span></span><br><span class="line">    <span class="keyword">return</span> fp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux文件系统</title>
      <link href="/2024/07/26/filesys/"/>
      <url>/2024/07/26/filesys/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言文件操作</title>
      <link href="/2024/07/15/cfileop/"/>
      <url>/2024/07/15/cfileop/</url>
      
        <content type="html"><![CDATA[<h1 id="用户级文件操作"><a href="#用户级文件操作" class="headerlink" title="用户级文件操作"></a>用户级文件操作</h1><p><code>C语言</code>的文件操作也是用户级的文件操作，通过<code>FILE</code>对象来<strong>管理</strong>每一个<code>被打开的文件</code>，以及提供了<strong>用户级</strong>文件缓冲区，因此还涉及到冲刷缓冲区等问题</p><h2 id="FILE-类"><a href="#FILE-类" class="headerlink" title="FILE 类"></a><code>FILE</code> 类</h2><p><code>FILE</code>类描述了一个文件流。里面存储了<strong>文件控制</strong>所需的信息:</p><ul><li>指向自身缓冲区的的<code>指针</code></li><li>位置指示器</li><li>状态指示器</li></ul><p>所以<code>C语言</code>中对文件的管理就是对<code>FILE</code>对象的管理</p><h1 id="基础操作-针对一般文件"><a href="#基础操作-针对一般文件" class="headerlink" title="基础操作 - 针对一般文件"></a>基础操作 - 针对一般文件</h1><h2 id="基础示例"><a href="#基础示例" class="headerlink" title="基础示例"></a>基础示例</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">FILE* pfile = fopen(<span class="string">&quot;file.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);<span class="comment">//&quot;w&quot;模式打开文件file.txt</span></span><br><span class="line"><span class="type">int</span> code = <span class="number">1</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* msg = <span class="string">&quot;this is a msg&quot;</span>;</span><br><span class="line"><span class="built_in">fprintf</span>(pfile, <span class="string">&quot;get msg : %s code:%d&quot;</span>, msg, code);<span class="comment">//格式化输出字符串</span></span><br><span class="line">fclose(pfile);<span class="comment">//冲刷缓冲区并关闭文件</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码创建了一个<code>file.txt</code>文件，输入<code>格式化字符串</code>(就和使用printf打印一样)。然后用<code>flcose</code>关闭文件流</p><h2 id="fopen-打开文件"><a href="#fopen-打开文件" class="headerlink" title="fopen 打开文件"></a>fopen 打开文件</h2><p><code>fopen</code>能够打开以各种<code>模式</code>磁盘上的文件</p><p><code>FILE* fopen( const char * filename, const char * mode );</code></p><p><strong>返回值</strong>:</p><ul><li>成功时，返回一个不为空的<code>FILE*</code>指针，用于控制该文件</li><li>失败时，返回<code>NULL</code>空指针并设置了全局变量<code>errno</code></li></ul><h3 id="常见模式"><a href="#常见模式" class="headerlink" title="常见模式"></a>常见模式</h3><p>| 模式 | 简述 |<br>| &#x3D;&#x3D;&#x3D; | &#x3D;&#x3D;&#x3D; |<br>| <code>&quot;w&quot;</code> | 创建一个<strong>新的空文件</strong>用于输出操作。如果已存在<code>同名文件</code>,清除原文件并当作新文件处理 |<br>| <code>&quot;r&quot;</code> | 只读模式打开文件。且该文件必须存在 |<br>| <code>&quot;a&quot;</code> | 打开已有文件时，仅用于在文件末尾<code>追加</code>新的内容。并且重定位函数<code>(fseek,fsetpos,reweind)</code>会被忽略，即使成功调用，也没有效果；当文件不存在时，会创建一个新的空文件 |<br>| “<code>r+</code>“ | 读写模式打开已有文件，<strong>不会清除</strong>原文件内容,并且读写时均从文件开头开始。打开后第一次操作为写入时，从文件头部开始逐字符覆盖原文件。<strong>注</strong>读写模式同时只能<code>读</code>或<code>写</code>的一种，第一次取决于先进行哪种操作，可以用<code>fseek</code>函数转换读写模式 |<br>| “<code>w+</code>“ | 读写模式打开新文件，若存在，则清除原文件内容;读写模式的切换和<code>&quot;r+&quot;</code>模式相同，唯一的区别就是打开时是否清除原文件内容 |<br>| “<code>a+</code>“ | 从文件末尾打开读写模式，<strong>不会清除原文件内容</strong>，若打开后第一次操作为写，则从文件末尾开始；若第一次操作为读，则从头开始；读写模式的切换同上 |</p><h3 id="二进制模式"><a href="#二进制模式" class="headerlink" title="二进制模式"></a>二进制模式</h3><p>如果要以二进制模式打开文件，只需要在上面的模式末尾加上字符<code>b</code></p><p>若有<code>+</code>,则<code>b</code>既可以放在末尾也可以放在中间</p><ul><li><code>r+b</code> <code>w+b</code> <code>a+b</code></li><li><code>rb+</code> <code>wb+</code> <code>ab+</code></li></ul><h3 id="强制新建文件"><a href="#强制新建文件" class="headerlink" title="强制新建文件"></a>强制新建文件</h3><p>新的C语言标准,<code>C2011</code>(不是C++11),添加了一种新的说明符<code>w</code>,可以被添加在任意<code>&quot;w&quot;</code>后面</p><ul><li><code>&quot;wx&quot;</code> <code>&quot;wbx&quot;</code> <code>&quot;w+x&quot;</code>  <code>&quot;w+bx&quot;</code>&#x2F;<code>&quot;wb+x&quot;</code></li></ul><p>当文件<strong>存在</strong>时,<code>w</code>会<strong>强制</strong><code>fopen</code>函数失败,返回一个<code>NULL</code>空指针</p><h2 id="freopen-重定向文件流"><a href="#freopen-重定向文件流" class="headerlink" title="freopen 重定向文件流"></a>freopen 重定向文件流</h2><p><code>FILE* freopen ( const char *filename, const char *mode, FILE * pFile );</code></p><ul><li>如果传入了新的文件名(与<code>pFile</code>控制的文件相比),该函数会<strong>关闭</strong><code>pFile</code>原本指向的文件流，并取消关联。然后<strong>不论</strong>是否成功关闭，<code>freopen</code>会用和<code>fopen</code>同样的方式打开该文件</li><li>如果文件名还是原文件，则只会改变打开模式</li></ul><p><strong>返回值</strong>:</p><ul><li>成功时，返回<code>pFile</code>内储存的地址</li><li>失败时，返回<code>NULL</code></li></ul><h3 id="特别的"><a href="#特别的" class="headerlink" title="特别的"></a>特别的</h3><p><code>freopen</code>用于进程的输入输出重定向会特别有用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">freopen (<span class="string">&quot;outfile.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,<span class="built_in">stdout</span>);<span class="comment">//标准输出重定向到文件</span></span><br><span class="line"></span><br><span class="line">freopen (<span class="string">&quot;readfile.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,<span class="built_in">stdin</span>);<span class="comment">//标准输入重定向到文件</span></span><br><span class="line"></span><br><span class="line">freopen (<span class="string">&quot;errdfile.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,<span class="built_in">stderr</span>);<span class="comment">//标准错误输出重定向到文件</span></span><br></pre></td></tr></table></figure><h2 id="重定位-文件流位置指示器-stream-position-indicator"><a href="#重定位-文件流位置指示器-stream-position-indicator" class="headerlink" title="重定位 文件流位置指示器(stream position indicator)"></a>重定位 文件流位置指示器(stream position indicator)</h2><h3 id="文件的抽象内存结构"><a href="#文件的抽象内存结构" class="headerlink" title="文件的抽象内存结构"></a>文件的抽象内存结构</h3><p>首先我们要明确一下文件的内存结构，如下图</p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-20_21-23-32.png"></p><p>这里及下文用图中的<code>ptr</code>代指标题的中的 <code>文件流位置指示器</code>,这个<code>ptr</code>决定了每一次对文件的<code>读/写</code>操作的<strong>起点</strong>,同时每一次<code>读/写</code>操作都会使<code>ptr</code>自动往后走，因此要显示控制<code>ptr</code>，就得使用<code>fseek,fsetpos</code>等接口</p><h2 id="fseek-重定位"><a href="#fseek-重定位" class="headerlink" title="fseek 重定位"></a>fseek 重定位</h2><p><code>int fseek ( FILE *pFile, long int offset, int origin );</code></p><p><code>fseek</code>能过直接重定位<code>ptr</code>所指的</p><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ul><li><code>pFile</code>：用于控制文件的<code>FILE*</code>类型指针</li><li><code>offset</code>：则是<strong>偏移量</strong>，长整型，表示偏移多少字节</li><li><code>origin</code>：该形参标注了<strong>偏移量</strong>相对于哪个位置计算<strong>实际位置</strong></li></ul><p><code>origin</code>有三个宏可以选<br>| 宏 | 实际位置 |<br>| <code>SEEK_SET</code> | 偏移量从<code>文件头</code>开始算 |<br>| <code>SEEK_CUR</code> | 偏移量从<code>当前文件指针ptr(上文介绍的)所在位置</code>开始算 |<br>| <code>SEEK_END</code> | 偏移量从<code>文件尾</code>开始算 |</p><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><ul><li>成功时,返回<code>0</code></li><li>失败时，返回<code>非零值</code>，同时，<strong>这条语句失效</strong>,上文说的<code>ptr</code>没有改变</li></ul><h2 id="fgetpos-和-fsetpos-设置-ptr"><a href="#fgetpos-和-fsetpos-设置-ptr" class="headerlink" title="fgetpos 和 fsetpos 设置 ptr"></a>fgetpos 和 fsetpos 设置 ptr</h2><p>可以用<code>fgetpos</code>获取<code>ptr</code>的当前位置，并使用<code>输出型参数</code>输出一个<code>fpos_t</code>类型的变量，而<code>fsetpos</code>可以用<code>fpos_t</code>类型的形参设置<code>ptr</code>的当前位置</p><p>就好比<code>ptr</code>是当前坐标，每次<code>fgetpos</code>得到一个传送点信息，而<code>fsetpos</code>就可以用这个传送点信息传送<code>ptr</code>过去</p><p><em>示例如下</em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//准备一个文件</span></span><br><span class="line">FILE* pfile = fopen(<span class="string">&quot;file.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);<span class="comment">//&quot;w&quot;模式打开文件file.txt</span></span><br><span class="line"><span class="type">int</span> code = <span class="number">1</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* msg = <span class="string">&quot;this is a msg&quot;</span>;</span><br><span class="line"><span class="built_in">fprintf</span>(pfile, <span class="string">&quot;get msg : %s code:%d&quot;</span>, msg, code);</span><br><span class="line">fclose(pfile);</span><br><span class="line"><span class="comment">//===========</span></span><br><span class="line"></span><br><span class="line"><span class="type">fpos_t</span> pos1,pos2;</span><br><span class="line">pfile = fopen(<span class="string">&quot;file.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"></span><br><span class="line">fgetpos(pfile, &amp;pos1);</span><br><span class="line">fgetc(pfile);</span><br><span class="line">fgetpos(pfile, &amp;pos2);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">fsetpos(pfile, &amp;pos2);<span class="comment">//循环令ptr指向第二个字符</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;第2个字符为: %c\n&quot;</span>, fgetc(pfile));</span><br><span class="line">&#125;                                                     </span><br><span class="line">fsetpos(pfile, &amp;pos1);<span class="comment">//令ptr指向第一个字符</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;第1个字符为: %c\n&quot;</span>, fgetc(pfile));</span><br><span class="line"></span><br><span class="line">fclose(pfile);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">第2个字符为: e</span><br><span class="line">第2个字符为: e</span><br><span class="line">第2个字符为: e</span><br><span class="line">第1个字符为: g</span><br></pre></td></tr></table></figure><h2 id="fclose-关闭文件流"><a href="#fclose-关闭文件流" class="headerlink" title="fclose 关闭文件流"></a>fclose 关闭文件流</h2><p>可以用<code>fclose</code>显式地关闭文件流</p><p>用法为<code>fclose(pFile);</code></p><p>进程正常退出时，也会自动关闭文件流</p><h2 id="fprintf-格式化输出字符串"><a href="#fprintf-格式化输出字符串" class="headerlink" title="fprintf 格式化输出字符串"></a>fprintf 格式化输出字符串</h2><p><code>fprintf</code>能格式化输出字符串到指定文件流，除了要<strong>指定</strong>文件流，格式化字符串的方式和<code>printf</code>一样</p><ul><li>且<code>fprintf(stdout,format,...)</code>和<code>printf(format,...)</code>效果一样</li></ul><h2 id="fputs-输出字符串"><a href="#fputs-输出字符串" class="headerlink" title="fputs 输出字符串"></a>fputs 输出字符串</h2><p><code>int fputs ( const char * str, FILE * stream );</code></p><p><code>fputs</code>能将<code>C语言</code>的字符串输入到指定文件流中</p><h2 id="fwrite-输出内存数据块"><a href="#fwrite-输出内存数据块" class="headerlink" title="fwrite 输出内存数据块"></a>fwrite 输出内存数据块</h2><p><code>size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);</code></p><ul><li><code>ptr</code>是指向<code>内存数据块</code>的指针</li><li><code>size</code>是每个<code>数组元素</code>的大小</li><li><code>nmemb</code>是元素数量</li><li><code>stream</code>是文件流</li></ul><p>fwrite可以向指定文件流输入特定大小的内存数据块</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">FILE* pfile = fopen(<span class="string">&quot;file.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);<span class="comment">//&quot;w&quot;模式打开文件file.txt</span></span><br><span class="line"><span class="type">char</span> msg[] = <span class="string">&quot;this is a msg&quot;</span>;</span><br><span class="line">fwrite(msg, <span class="keyword">sizeof</span>(<span class="type">char</span>), <span class="built_in">strlen</span>(msg), pfile);</span><br><span class="line"></span><br><span class="line">fclose(pfile);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="fscanf-格式化输入"><a href="#fscanf-格式化输入" class="headerlink" title="fscanf 格式化输入"></a>fscanf 格式化输入</h2><p><code>fscanf</code>能像<code>scanf</code>读取标准输入流一样,读取指定文件流</p><ul><li>且<code>scanf(stdin,format,...)</code>和<code>printf(format,...)</code>效果一样</li></ul><h2 id="fegts-获取一行"><a href="#fegts-获取一行" class="headerlink" title="fegts 获取一行"></a>fegts 获取一行</h2><p><code>char * fgets (char *str, int num, FILE *stream );</code></p><h3 id="行为"><a href="#行为" class="headerlink" title="行为"></a>行为</h3><p><code>fegts</code>会一直读取直到<code>换行符</code>或<code>EOF文件结尾</code>结束读取，但<code>换行符</code>作为<strong>非法</strong>字符不会被拷贝到形参<code>str</code>中</p><ul><li>字符串结尾的<code>\0</code>会被自动添加,且<strong>计算</strong>在读入的<strong>最大字符数</strong></li><li><code>fgets</code>和<code>gets</code>有很大差别，它需要<strong>指定</strong>最大的读入字符数</li></ul><h3 id="形参"><a href="#形参" class="headerlink" title="形参"></a>形参</h3><ul><li><code>str</code>为传入的字符数组作为缓冲区</li><li><code>num</code>为拷贝的最大字符数，<strong>包括</strong>自动添加的结尾<code>\0</code></li><li><code>stream</code>为指定的文件流</li></ul><h3 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h3><ul><li>成功时，返回<code>str</code>的值</li><li>失败时，返回<code>NULL</code></li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//准备一个文件</span></span><br><span class="line">FILE* pfile = fopen(<span class="string">&quot;file.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);<span class="comment">//&quot;w&quot;模式打开文件file.txt</span></span><br><span class="line"><span class="type">int</span> code = <span class="number">1</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* msg = <span class="string">&quot;this is a msg&quot;</span>;</span><br><span class="line"><span class="built_in">fprintf</span>(pfile, <span class="string">&quot;get msg : %s code:%d&quot;</span>, msg, code);</span><br><span class="line">fclose(pfile);</span><br><span class="line"><span class="comment">//=====</span></span><br><span class="line"></span><br><span class="line">pfile = fopen(<span class="string">&quot;file.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"><span class="type">char</span> str[<span class="number">5</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">fgets(str, <span class="keyword">sizeof</span>(str), pfile);<span class="comment">//除去自动添加的\0,最多从文件里读入4个字符</span></span><br><span class="line"><span class="built_in">printf</span>(str);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;|&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get |</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>=C++= sizeof关键字详解</title>
      <link href="/2024/07/10/cppsizeof/"/>
      <url>/2024/07/10/cppsizeof/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>sizeof</code>作为C&#x2F;C++关键字,基本用法是求<code>字节大小</code>，但仅仅这一项用法在细节上就有很多说法了</p><h2 id="求内置类型变量的大小"><a href="#求内置类型变量的大小" class="headerlink" title="求内置类型变量的大小"></a>求内置类型变量的大小</h2><p>有两种写法，以<code>int a = 0</code>的变量<code>a</code>为例</p><ul><li><code>sizeof a</code></li><li><code>sizeof(a)</code></li></ul><p>都可以求变量<code>a</code>的大小，但<strong>注意</strong>，该变量的大小仅与<code>变量类型</code>有关，而与值无关</p><h2 id="求内置类型的大小"><a href="#求内置类型的大小" class="headerlink" title="求内置类型的大小"></a>求内置类型的大小</h2><p>求类型大小时必须<strong>加上括号</strong></p><p>例如<code>sizeof(int)</code></p><h2 id="求数组的大小"><a href="#求数组的大小" class="headerlink" title="求数组的大小"></a>求数组的大小</h2><ul><li>当数组声明在<code>全局</code>或<code>sizeof</code>处于数组声明语句的<code>局部作用范围</code>时,能够用<code>sizeof(&lt;数组名&gt;)</code>求数组大小</li><li>当数组名经过<strong>函数传参</strong>或<code>加减常量运算</code>后，退化为<code>指针变量</code>,类型大小在<code>32位机器</code>中为<code>4</code>,<code>64位机器</code>中为<code>8</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> g_arr[<span class="number">10</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> st_arr[])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(st_arr) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//此处退化为指针变量，输出4或8</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> arr[<span class="number">10</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(g_arr) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//输出40</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(arr) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//输出40</span></span><br><span class="line">func(arr);<span class="comment">//输出4/8</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="求类-对象的大小"><a href="#求类-对象的大小" class="headerlink" title="求类&#x2F;对象的大小"></a>求类&#x2F;对象的大小</h2><h3 id="一般情况的内存对齐"><a href="#一般情况的内存对齐" class="headerlink" title="一般情况的内存对齐"></a>一般情况的内存对齐</h3><p>为了访问效率问题，类的大小遵循<code>内存对齐</code>规则，计算理论大小时需考虑<code>成员变量的大小</code>和<code>内存对齐</code>,而不考虑普通成员函数,这里不详细讨论</p><h2 id="含有虚函数"><a href="#含有虚函数" class="headerlink" title="含有虚函数"></a>含有虚函数</h2><p>C++的编译器一旦发现一个类型中<strong>有虚函数</strong>，就会为该类型生成<code>虚函数表</code>，每一个实例化出的<code>对象</code>都含有一个<code>指向虚函数表的指针</code>。所以<code>sizeof</code>求出来的值还要考虑<code>该指针</code>以及<code>内存对齐</code>等因素</p><h3 id="没有成员变量的特殊情况"><a href="#没有成员变量的特殊情况" class="headerlink" title="没有成员变量的特殊情况"></a>没有成员变量的特殊情况</h3><h4 id="没有成员函数"><a href="#没有成员函数" class="headerlink" title="没有成员函数"></a>没有成员函数</h4><p>这样的类型可以称为<code>空类型</code>,因为这样的类型实例化后不含任何信息,本来求<code>sizeof</code>应该是<code>O</code>，但考虑实际使用时，我们需将类<strong>实例化</strong>为对象，它必须在内存中占有一定的空间，否则无法使用或管理这些实例。至于分配内存，由编译器决定。但出于节省不必要的内存占用原则，理应分配最小内存单元，即<code>1字节</code>。正好在<code>VisualStudio</code>中，每个空类型的实例占用<code>1字节</code>的空间。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//空类型</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">sizeof</span>(A);<span class="comment">//visual studio 中值为1</span></span><br></pre></td></tr></table></figure><h4 id="只有普通的成员函数"><a href="#只有普通的成员函数" class="headerlink" title="只有普通的成员函数"></a>只有普通的成员函数</h4><p>和上一条一样也是<code>1字节</code>。因为考虑实例化时，调用这些普通成员函数只需知道<code>函数地址</code>即可，而这些函数地址只与用户自定义的<code>类</code>有关，而与实例化出来的<code>对象</code>无关，所以不会在<code>对象</code>中存储相关信息，不会改变其大小。</p><h4 id="含有虚函数-1"><a href="#含有虚函数-1" class="headerlink" title="含有虚函数"></a>含有虚函数</h4><p>实例化出的<code>对象</code>含有了指向虚函数的<code>指针</code>,所以<code>sizeof</code>求出来的大小为一个<code>指针</code>的大小，<code>32位机器</code>求得<code>4</code>字节,<code>64位机器</code>求得<code>8</code>字节</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>基础IO</title>
      <link href="/2024/07/10/basicIO/"/>
      <url>/2024/07/10/basicIO/</url>
      
        <content type="html"><![CDATA[<h1 id="共识原理"><a href="#共识原理" class="headerlink" title="共识原理"></a>共识原理</h1><ul><li>文件 &#x3D; 内容 + 属性</li><li>被打开的文件需要加载到内存中</li><li><strong>内存中</strong>的文件需要被操作系统<strong>管理</strong></li></ul><h1 id="用户级文件接口"><a href="#用户级文件接口" class="headerlink" title="用户级文件接口"></a>用户级文件接口</h1><p><a href="https://www.supdriver.top/2024/05/14/cpp-file-op/">详见C++文件操作</a></p><p><a href="https://www.supdriver.top/2024/07/15/cfileop/">详见C语言文件操作</a></p><h1 id="Linux系统调用接口"><a href="#Linux系统调用接口" class="headerlink" title="Linux系统调用接口"></a>Linux系统调用接口</h1><h2 id="fd-文件描述符-与访问文件的本质"><a href="#fd-文件描述符-与访问文件的本质" class="headerlink" title="fd 文件描述符 与访问文件的本质"></a>fd 文件描述符 与访问文件的本质</h2><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-24_17-10-26.png"></p><p><code>fd</code>(<em>file descriptor</em>),即文件描述符,下文的系统调用接口经常以<code>fd</code>命名变量，<code>fd</code>是整形变量，作为数组下标，用于管理<strong>打开的文件</strong></p><p>可以看到,一个进程通过<code>struct files _struct</code>里的指针数组，管理多个同时打开的文件</p><p>且每个进程启动时，会默认打开三个文件,且默认<code>fd</code>固定</p><ol><li>stdout</li></ol><h2 id="read"><a href="#read" class="headerlink" title="read"></a>read</h2><p><strong>所需头文件</strong><br><code>#include &lt;unistd.h&gt;</code><br><strong>声明</strong><br><code>ssize_t read(int fd, void *buf, size_t count);</code></p><p><strong>参数</strong></p><ul><li><code>fd</code>即为目标文件的文件描述符</li><li><code>buf</code>为要从文件读取字节到的内存地址</li><li><code>count</code>为最大读取字节数</li></ul><p><strong>返回值</strong></p><ul><li>若成功，返回读取文件的字节数,类型为<code>ssize_t</code>,是层层封装的<code>long int</code></li><li>若失败，返回<code>-1</code>,并设置<code>errno</code>的值</li></ul><h2 id="write"><a href="#write" class="headerlink" title="write"></a>write</h2><p><strong>所需头文件</strong><br><code>#include &lt;unistd.h&gt;</code><br><strong>声明</strong><br><code>ssize_t write(int fd, const void *buf, size_t count);</code></p><p><strong>参数</strong></p><ul><li><code>fd</code> 为目标文件的文件描述符</li><li><code>buf</code>为要写入文件的<code>源内存地址</code>,输入字节数量取决于<code>count</code>形参</li><li><code>count</code>为要输入的字节数量,若要输入为字符串，且要输入字符串的全部内容，建议使用<code>strlen(buf)</code>，防止输入<code>\0</code>,因为对于<strong>文件</strong>来说，<code>\0</code>是<strong>非法字符</strong></li></ul><p><strong>返回值</strong></p><ul><li>若成功，返回写入文件的字节数,类型为<code>ssize_t</code>,是层层封装的<code>long int</code></li><li>若失败，返回<code>-1</code>,并设置<code>errno</code>的值</li></ul><p><strong>特别的</strong><br><code>read</code>函数从文件中读取的是<code>字节</code>内容，不把读取的内容看作字符串，因此，<strong>不会自动</strong>添加<code>\0</code>在写入<code>buf</code>内容的结尾</p><p><em>用法见后文对<code>open</code>的介绍</em></p><h2 id="open"><a href="#open" class="headerlink" title="open"></a>open</h2><p><strong>所需头文件</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br></pre></td></tr></table></figure><p><strong>声明</strong><br><code>int open(const char *pathname, int flags);</code><br><code>int open(const char *pathname, int flags，mode_t mode);</code></p><p><strong>参数</strong>:</p><ul><li><code>pathname</code>为文件路径，若只有文件名，则默认在当前工作路径搜索</li><li><code>flag</code>则是一个<code>位图</code>,而<strong>不应</strong>看作整型参数，传参时可用<code>|</code>位运算传递多个参数到位图中,例如<code>O_CREAT | O_WRONLY</code></li><li><code>mode</code>则是在<strong>创建</strong>文件时,传入权限信息,这里使用<code>八进制表示法</code>，例如传入<code>0666</code><br><strong>返回值</strong>:</li><li>若成功，返回打开文件的<code>fd</code>值</li><li>若失败，则返回<code>-1</code></li></ul><h3 id="写入操作"><a href="#写入操作" class="headerlink" title="写入操作"></a>写入操作</h3><p>相关的<code>flags</code></p><ul><li><code>O_WRONLY</code> 仅写入</li><li><code>O_CREAT</code> 如果文件不存在，就创建，<strong>注</strong>新文件的权限由<code>open</code>函数传入的<code>mode</code>参数决定</li><li><code>O_TRUNC</code> 如果文件已存在且是<code>常规文件</code>,并且打开的模式组合<strong>支持写入操作</strong>(<code>O_RDWR</code>或<code>O_WRONLY</code>),该文件内容将会被清除。但如果该文件是<code>FIFO</code>(命名管道)文件或<code>终端设备文件</code>，则<code>O_TRUNC</code>将会被<strong>忽略</strong></li><li><code>O_EXCL</code> 保证此次<code>open</code>操作打开新文件。<strong>必须</strong>和<code>O_CREAT</code>联合使用，否则打开<strong>失败</strong>。若<code>pathname</code>存在，即该路径的文件存在时，也会打开<strong>失败</strong></li></ul><h4 id="打开已有文件并写入"><a href="#打开已有文件并写入" class="headerlink" title="打开已有文件并写入"></a>打开已有文件并写入</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//前提是log.txt已存在</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;log.txt&quot;</span>,O_WRONLY,<span class="number">0666</span>);<span class="comment">//只写模式打开文件</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span> msg[] = <span class="string">&quot;this is a msg&quot;</span>;<span class="comment">//准备字符串</span></span><br><span class="line">    write(fd,msg,<span class="built_in">strlen</span>(msg));<span class="comment">//写入</span></span><br><span class="line">    close(fd);<span class="comment">//关闭文件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当原本<code>log.txt</code>为空文件时</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this is a msg</span><br></pre></td></tr></table></figure><p>当原<code>log.txt</code>不为空且内容长度大于程序输入的<code>msg</code>时，发生<code>部分覆写</code></p><p>例如原内容为<code>0000111100001111</code>时，执行后为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this is a msg111</span><br></pre></td></tr></table></figure><p>可以看到有一部分没有被覆盖</p><h4 id="打开空文件-或-创建空文件"><a href="#打开空文件-或-创建空文件" class="headerlink" title="打开空文件 或 创建空文件"></a>打开空文件 或 创建空文件</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//唯一的区别是这里的参数</span></span><br><span class="line">    <span class="comment">//O_CREAT可以创建空文件</span></span><br><span class="line">    <span class="comment">//O_TRUNC保证打开已有文件时，清空原文内容</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;log.txt&quot;</span>,O_CREAT|O_WRONLY|O_TRUNC,<span class="number">0666</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span> msg[] = <span class="string">&quot;this is a msg&quot;</span>;</span><br><span class="line">    write(fd,msg,<span class="built_in">strlen</span>(msg));</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="追加写入"><a href="#追加写入" class="headerlink" title="追加写入"></a>追加写入</h4><p>追加写入只需把<code>O_TRUNC</code>改成<code>O_APPEND</code>即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;log.txt&quot;</span>,O_CREAT|O_WRONLY|O_APPEND,<span class="number">0666</span>);<span class="comment">//追加模式打开文化</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span> msg[] = <span class="string">&quot;this is a msg&quot;</span>;</span><br><span class="line">    write(fd,msg,<span class="built_in">strlen</span>(msg));</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们事先删除<code>log.txt</code>文件，然后运行两次编译出的程序,可以获得如下内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this is a msgthis is a msg</span><br></pre></td></tr></table></figure><p>可以看到内容追加了两次</p><h3 id="读取操作"><a href="#读取操作" class="headerlink" title="读取操作"></a>读取操作</h3><p>相关的<code>flags</code></p><ul><li><code>O_RDONLY</code>只读模式打开文件</li><li><code>O_RDWR</code> 读写模式打开文件</li></ul><h4 id="只读模式读取内容"><a href="#只读模式读取内容" class="headerlink" title="只读模式读取内容"></a>只读模式读取内容</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;log.txt&quot;</span>,O_RDONLY);</span><br><span class="line">    <span class="type">char</span>* buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">ssize_t</span> n = read(fd,buf,<span class="keyword">sizeof</span>(buf)<span class="number">-1</span>);<span class="comment">//这里要储存字符串，所以要留一位给\0</span></span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">0</span>) perror(<span class="string">&quot;read&quot;</span>);<span class="comment">//打开失败，输出错误信息</span></span><br><span class="line">    <span class="keyword">else</span> buf[n] = <span class="string">&#x27;\0&#x27;</span>;<span class="comment">//添加结尾</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,buf);<span class="comment">//打印读取到的内容</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现准备内容为<code>123456</code>的<code>log.txt</code>文件</p><p>然后运行<code>./mycmd</code></p><p>得到输出和文件内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">456</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zzz456</span><br></pre></td></tr></table></figure><p>关于<code>read</code>没读取到前面新写入的<code>zzz</code>,是因为<code>wtrite</code>和<code>read</code>操作都是从文件的<code>同一处继续</code>操作的，并不会发生回退</p><h2 id="close"><a href="#close" class="headerlink" title="close"></a>close</h2><p><code>int close(int fd);</code></p><p>用于冲刷缓冲区，并<strong>关闭</strong>一个文件描述符</p><h2 id="dup2-文件重定向"><a href="#dup2-文件重定向" class="headerlink" title="dup2 文件重定向"></a>dup2 文件重定向</h2><p><code>int dup2(int oldfd, int newfd);</code></p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-24_19-55-30.png"></p><p>如图所示，<code>dup2</code>能将<code>oldfd</code>对应的数组元素<code>覆盖</code>到<code>newfd</code>对应的数组元素处，完成对<code>newfd</code>对应文件的重定向</p><p>图中就是完成了对<code>标准输出</code>的重定向,像<code>printf</code>之类的函数会直接输出内容到文件中,而不是显示器</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;log.txt&quot;</span>,O_RDWR|O_CREAT|O_TRUNC,<span class="number">0666</span>);<span class="comment">//打开一个新的空文件</span></span><br><span class="line">    dup2(fd,<span class="number">1</span>);<span class="comment">//标准输出重定向</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;output1\n&quot;</span>);<span class="comment">//输出</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;output2\n&quot;</span>);<span class="comment">//输出</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行代码后，可以看到<code>终端</code><strong>没有输出</strong></p><p>而打开<code>log.txt</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">output1</span><br><span class="line">output2</span><br></pre></td></tr></table></figure><h1 id="子进程-与-父进程的文件关系"><a href="#子进程-与-父进程的文件关系" class="headerlink" title="子进程 与 父进程的文件关系"></a>子进程 与 父进程的文件关系</h1><h2 id="子进程对父进程的拷贝"><a href="#子进程对父进程的拷贝" class="headerlink" title="子进程对父进程的拷贝"></a>子进程对父进程的拷贝</h2><p>先运行一段代码测试 子进程是否<strong>继承</strong>父进程的打开文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;log.txt&quot;</span>,O_RDWR|O_CREAT|O_TRUNC|O_APPEND);<span class="comment">//追加模式打开一个新文件</span></span><br><span class="line">    dup2(fd,<span class="number">1</span>);<span class="comment">//在fork前就打开文件</span></span><br><span class="line"></span><br><span class="line">    <span class="type">pid_t</span> id = fork();<span class="comment">//创建子进程</span></span><br><span class="line">    <span class="keyword">if</span>(id == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child output\n&quot;</span>);<span class="comment">//子进程输出到文件</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        waitpid(id,<span class="number">0</span>,<span class="number">0</span>);<span class="comment">//阻塞等待子进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent output\n&quot;</span>);<span class="comment">//父进程输出</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码中，我们在<code>fork</code><strong>之前</strong>完成了对标准输出的<strong>重定向</strong>,然后<code>fork</code>之后令父进程和子进程进行不同的标准输出</p><p>运行结果为父进程和子进程的<code>标准输出</code>都<strong>重定向</strong>到了文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">child output</span><br><span class="line">parent output</span><br></pre></td></tr></table></figure><h2 id="子进程和父进程的-独立性"><a href="#子进程和父进程的-独立性" class="headerlink" title="子进程和父进程的 独立性"></a>子进程和父进程的 独立性</h2><p>接下来一段代码测试 父进程 和 子进程 的打开文件是否独立</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;log.txt&quot;</span>,O_RDWR|O_CREAT|O_TRUNC|O_APPEND);<span class="comment">//追加模式打开一个新文件</span></span><br><span class="line"></span><br><span class="line">    <span class="type">pid_t</span> id = fork();<span class="comment">//创建子进程</span></span><br><span class="line">    <span class="keyword">if</span>(id == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        dup2(fd,<span class="number">1</span>);<span class="comment">//只有子进程重定向了标准输出</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child output\n&quot;</span>);<span class="comment">//子进程输出到文件</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        waitpid(id,<span class="number">0</span>,<span class="number">0</span>);<span class="comment">//阻塞等待子进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent output\n&quot;</span>);<span class="comment">//父进程输出</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们在<code>fork</code>之前都不进行重定向，<code>fork</code>后仅对子进程进行了标准输出重定向，而父进程不作任何重定向</p><p>在运行后发现子进程的输出重定向不会影响父进程,二者有<code>独立性</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parent output</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">child output</span><br></pre></td></tr></table></figure><h1 id="进程替换"><a href="#进程替换" class="headerlink" title="进程替换"></a>进程替换</h1><p>先在同级文件夹准备一个待替换的程序</p><blockquote><p>execute.c</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;exe output\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后运行<code>gcc -o execute execute.c</code>编译获得一个程序</p><p>然后准备主程序</p><blockquote><p>mycmd.c</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;log.txt&quot;</span>,O_RDWR|O_CREAT|O_TRUNC|O_APPEND);<span class="comment">//追加模式打开一个新文件</span></span><br><span class="line"></span><br><span class="line">    <span class="type">pid_t</span> id = fork();<span class="comment">//创建子进程</span></span><br><span class="line">    <span class="keyword">if</span>(id == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        dup2(fd,<span class="number">1</span>);<span class="comment">//只有子进程重定向了标准输出</span></span><br><span class="line">        execvp(<span class="string">&quot;./execute&quot;</span>,<span class="literal">NULL</span>);<span class="comment">//进程替换</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        waitpid(id,<span class="number">0</span>,<span class="number">0</span>);<span class="comment">//阻塞等待子进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent wait success\n&quot;</span>);<span class="comment">//父进程输出</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们使子进程<strong>先</strong>标准输出重定向， <strong>再</strong>进行进程替换，发现替换后的进程，也是标准输出重定向的状态</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exe output</span><br></pre></td></tr></table></figure><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>进程替换<strong>不会</strong>改变原进程的文件打开状态和重定向关系</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识动静态库(修改中)</title>
      <link href="/2024/07/08/libs/"/>
      <url>/2024/07/08/libs/</url>
      
        <content type="html"><![CDATA[<h1 id="动态库"><a href="#动态库" class="headerlink" title="动态库"></a>动态库</h1><h1 id="静态库"><a href="#静态库" class="headerlink" title="静态库"></a>静态库</h1>]]></content>
      
      
      
        <tags>
            
            <tag> 动态库 静态库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>fork子进程,进程退出与等待</title>
      <link href="/2024/07/07/fork/"/>
      <url>/2024/07/07/fork/</url>
      
        <content type="html"><![CDATA[<h1 id="认识fork"><a href="#认识fork" class="headerlink" title="认识fork()"></a>认识<code>fork()</code></h1><p>头文件<code>&lt;unistd.h&gt;</code>提供的<code>fork()</code>函数用于从已有的<code>原进程</code>创建一个新的<code>子进程</code>，而原进程在关系式称为<code>父进程</code></p><h2 id="fork-的返回值"><a href="#fork-的返回值" class="headerlink" title="fork()的返回值"></a>fork()的返回值</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> id = fork();</span><br></pre></td></tr></table></figure><p>父子进程中<code>fork()</code>函数的返回值(此处用变量<code>id</code>储存)是不同的:</p><p><strong>父进程</strong>里<code>id</code>的值为子进程的<code>PID</code>,其值<code>&gt;0</code>;<strong>子进程</strong>里<code>id</code>值固定为<code>0</code></p><ul><li><code>id &gt; 0</code> 父进程</li><li><code>id == 0</code> 子进程</li><li><code>id &lt; 0</code> fork()失败</li></ul><h2 id="分流"><a href="#分流" class="headerlink" title="分流"></a>分流</h2><p><a href="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-09_13-00-38.png">https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-09_13-00-38.png</a></p><p>利用父子进程中<code>fork()</code>返回值的不同，可以用<code>if...else...</code>进行分流，让父子进程执行不同的代码</p><h2 id="fork-的过程"><a href="#fork-的过程" class="headerlink" title="fork()的过程"></a>fork()的过程</h2><p>进程调用<code>fork</code>，当控制转移到<strong>内核</strong>中的fork代码后，<strong>内核</strong>做</p><ul><li>分配<strong>新的</strong>内存块和内核数据结构给子进程</li><li>将父进程部分数据结构内容<strong>拷贝</strong>至子进程</li><li>添加子进程到<strong>系统进程列表</strong>当中</li><li><code>fork</code>返回，开始调度器调度</li></ul><p><a href="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-09_18-54-41.png">https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-09_18-54-41.png</a></p><p>当一个进程调用fork之后，就有一对二进制<strong>代码相同</strong>的父子进程。而且它们都运行到相同的地方。但每个进程都可以<strong>独立</strong>地继续运行代码,并按代码分流至不同的代码段</p><p>但这两个进程谁先执行<strong>完全</strong>由调度器决定，而谁先结束，则由实际执行情况和调度器决定</p><h2 id="拷贝的过程-与-写时拷贝"><a href="#拷贝的过程-与-写时拷贝" class="headerlink" title="拷贝的过程 与 写时拷贝"></a>拷贝的过程 与 写时拷贝</h2><p><code>fork</code>时，子进程会将父进程虚拟内存的内容都复制一份在自己的虚拟内存中,但通过页表，二者映射到了同一块物理内存的区域，这样在二者都<strong>没有写入行为</strong>时，减少了物理内存中<strong>冗余</strong>的拷贝行为，有效提高了运行效率</p><p>但当父子进程中有一方发生写入行为时，就会触发<code>写时拷贝</code>，此时物理内存中发生拷贝行为，但只拷贝进程映射的<code>数据段</code>，而由于<strong>不发生进程替换时</strong>父子进程的代码段一定相同，物理内存中,<code>代码段</code>映射部分并不发生拷贝</p><p><a href="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-09_19-38-58.png">https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-09_19-38-58.png</a></p><h1 id="进程退出"><a href="#进程退出" class="headerlink" title="进程退出"></a>进程退出</h1><h2 id="进程退出的场景"><a href="#进程退出的场景" class="headerlink" title="进程退出的场景"></a>进程退出的场景</h2><ul><li>代码运行完毕，结果正确</li><li>代码运行完毕，结果不正确</li><li>代码异常终止</li></ul><h2 id="进程常见退出方法"><a href="#进程常见退出方法" class="headerlink" title="进程常见退出方法"></a>进程常见退出方法</h2><ul><li><code>main</code>函数返回</li><li><code>exit</code>退出</li><li><code>_exit</code>退出</li></ul><p><strong>异常退出</strong>: <code>ctrl</code> + <code>c</code></p><h2 id="查看退出码"><a href="#查看退出码" class="headerlink" title="查看退出码"></a>查看退出码</h2><p>在终端使用命令<code>echo $?</code>可以查看退出码</p><p><code>注</code>尽管子进程返回的是<code>int</code>,父进程只取退出码的最低<code>8位</code>,所以以下三种情况</p><ul><li><code>main</code>函数返回<code>-1</code></li><li><code>exit(-1)</code></li><li><code>_exit(-1)</code></li></ul><p>在终端输<code>echo $?</code>可得退出码<code>255</code></p><h2 id="exit-和-eixt-辨析"><a href="#exit-和-eixt-辨析" class="headerlink" title="exit 和 _eixt 辨析"></a><code>exit</code> 和 <code>_eixt</code> 辨析</h2><p><code>main</code>函数返回就不惜说了，来辨析一下头文件<code>&lt;stdlib.h&gt;</code>提供的<code>exit</code>和<code>_exit</code>函数</p><h3 id="exit"><a href="#exit" class="headerlink" title="_exit()"></a><code>_exit()</code></h3><p><code>_exit</code>会<strong>直接终止</strong>进程并返回状态码,而<strong>不会</strong>执行用户定义的清理函数，<strong>也不会</strong>清理缓冲区</p><h3 id="exit-1"><a href="#exit-1" class="headerlink" title="exit()"></a><code>exit()</code></h3><p><code>exit</code>实际上最后也会调用<code>_exit</code>,但它会先执行一系列善后工作,顺序如下:</p><ol><li>执行用户通过 atexit或on_exit定义的<strong>清理函数</strong>。</li><li>关闭所有打开的流，所有的<strong>缓存数据</strong>均被写入</li><li>调用<code>_exit</code></li></ol><p><a href="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-09_22-10-26.png">https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-09_22-10-26.png</a></p><p><code>return</code>退出： 执行<code>return n</code>等同于执行<code>exit(n)</code></p><h1 id="进程等待"><a href="#进程等待" class="headerlink" title="进程等待"></a>进程等待</h1><h2 id="进程等待的必要性"><a href="#进程等待的必要性" class="headerlink" title="进程等待的必要性"></a>进程等待的必要性</h2><ul><li>子进程退出后需要父进程来<strong>回收</strong>僵尸进程,防止产生其引发内存泄漏等问题</li><li>僵尸进程难以处理,<code>kill -9</code>也清理不掉</li><li>父进程通过进程等待的方式，<strong>回收</strong>子进程资源，获取子进程<strong>退出信息</strong></li></ul><h2 id="进程等待的方法"><a href="#进程等待的方法" class="headerlink" title="进程等待的方法"></a>进程等待的方法</h2><h3 id="wait方法"><a href="#wait方法" class="headerlink" title="wait方法"></a><code>wait</code>方法</h3><blockquote><p>#include&lt;sys&#x2F;types.h&gt;<br>#include&lt;sys&#x2F;wait.h&gt;</p><p>pid_t wait(int*status);</p><p><code>参数</code>：显然<code>status</code>是输出型参数,获取子进程的<code>退出状态</code>,若不关心，可传参<code>NULL</code></p><p><code>返回值</code>: 若<strong>成功</strong>，则返回被等待进程的<code>pid</code>,若<strong>失败</strong>，则返回<code>-1</code></p></blockquote><h3 id="waitpid方法"><a href="#waitpid方法" class="headerlink" title="waitpid方法"></a><code>waitpid</code>方法</h3><blockquote><p>返回值：<br>   当正常返回的时候waitpid返回收集到的子进程的进程ID；<br>   如果设置了选项WNOHANG,而调用中waitpid发现没有已退出的子进程可收集,则返回0；<br>   如果调用中出错,则返回-1,这时errno会被设置成相应的值以指示错误所在；</p><p>参数：<br>   <code>pid</code>：<br>       <code>pid == -1</code>,等待任一个子进程。与wait等效。<br>       <code>pid &gt; 0</code>.等待其进程ID与pid相等的子进程。<br>   <code>status</code>:<br>       输出型参数传参<code>&amp;status</code>: 将子进程的<code>状态码</code>存入<code>status</code><br>       以下两个宏函数用于处理<code>状态码</code>:<br>       <code>WIFEXITED(status)</code>: 若为<strong>正常终止</strong>子进程返回的状态，则为真。（查看进程是否是<strong>正常退出</strong>）<br>       <code>WEXITSTATUS(status)</code>: 若WIFEXITED非零，提取子进程<code>退出码</code>。（查看进程的<code>退出码</code>）<br>   <code>options</code>:<br>       <code>WNOHANG</code>: 若pid指定的子进程没有结束，则waitpid()函数返回0，不予以等待。若正常结束，则返回该子进程的ID。<br>       <code>0</code>: 阻塞等待指定<code>pid</code>的进程</p></blockquote><h4 id="阻塞等待"><a href="#阻塞等待" class="headerlink" title="阻塞等待"></a>阻塞等待</h4><p><code>option</code> &#x3D;&#x3D; <code>0</code>时<code>waitpid</code>采用阻塞等待，父进程会阻塞等待到子进程退出</p><p><em>示例代码</em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    <span class="type">pid_t</span> id = fork();</span><br><span class="line">    <span class="keyword">if</span>(id == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child running [%d]s\n&quot;</span>,i);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child exited\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        waitpid(id,&amp;status,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(WIFEXITED(status))</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;father wait success, exit code: %d\n&quot;</span>,WEXITSTATUS(status));</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child failed to exit\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="非阻塞轮询"><a href="#非阻塞轮询" class="headerlink" title="非阻塞轮询"></a>非阻塞轮询</h4><p><code>option</code> &#x3D;&#x3D; <code>WNOHANG</code>时,<code>waitpid</code>采用非阻塞等待,若等不到子进程退出，就会继续执行后面的代码，所以一般加上<code>while</code>等循环用于轮询，二者共同构成<code>非阻塞轮询</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//非阻塞轮询</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    <span class="type">pid_t</span> id = fork();</span><br><span class="line">    <span class="keyword">if</span>(id == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sleep(<span class="number">5</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child exited\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)<span class="comment">//轮询</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">pid_t</span> rid = waitpid(id,&amp;status,WNOHANG);</span><br><span class="line">            <span class="keyword">if</span>(rid &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(WIFEXITED(status))</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;father wait success, exit code: %d\n&quot;</span>,WEXITSTATUS(status));</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;child failed to exit\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(rid == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;等待子进程中...\n&quot;</span>);</span><br><span class="line">                sleep(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span><span class="comment">//rid&lt;0</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;wait failed\n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> fork Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>环境变量</title>
      <link href="/2024/07/06/evn/"/>
      <url>/2024/07/06/evn/</url>
      
        <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><ul><li>环境变量(environment variables)一般是指在操作系统中用来指定操作系统运行环境的一些<strong>参数</strong></li><li>环境变量通常具有某些特殊用途，还有在系统当中通常具有<strong>全局特性</strong></li></ul><p><strong>构成</strong>：环境变量是一系列<code>字符串</code>的统称,所以一个环境变量由<code>变量名</code>和<code>值</code>构成</p><p>这么说还是太抽象了，我们接下来会举几个具体样例，体会<code>环境变量</code>在获取系统全局的变量，系统指令路径等方面的作用</p><h2 id="常见环境变量"><a href="#常见环境变量" class="headerlink" title="常见环境变量"></a>常见环境变量</h2><table><thead><tr><th>变量名</th><th>功能</th></tr></thead><tbody><tr><td><code>PATH</code></td><td>指定命令的搜索路径</td></tr><tr><td><code>HOME</code></td><td>指定用户的主工作目录(即用户登陆到Linux系统中时,默认的目录)</td></tr><tr><td><code>USER</code></td><td>当前用户名</td></tr><tr><td><code>SHELL</code></td><td>当前Shell,它的值通常是<code>/bin/bash</code></td></tr><tr><td><code>PWD</code></td><td>当前工作目录</td></tr></tbody></table><h1 id="操作系统变量"><a href="#操作系统变量" class="headerlink" title="操作系统变量"></a>操作系统变量</h1><h2 id="查看环境变量"><a href="#查看环境变量" class="headerlink" title="查看环境变量"></a>查看环境变量</h2><p><code>echo $NAME</code> <em>NAME为变量名</em></p><p>以<code>PATH</code>为例,查看<code>PATH</code>的值的指令为</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $PATH</span><br></pre></td></tr></table></figure><p><a href="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-08_12-46-35.png">https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-08_12-46-35.png</a></p><p>可以看到<code>PATH</code>的内容为多个文件路径，互相以<code>:</code>分隔</p><p>而若要查看当前的全部环境变量,可以使用<code>env</code>指令,将当前所有环境变量打印在终端上</p><p>也可以通过<code>管道</code>和<code>grep</code>将<code>env</code>的输出内容过滤</p><p><em>查看PATH</em></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">env | grep PATH</span><br></pre></td></tr></table></figure><p>同时还有个<code>set</code> 指令可以显示本地定义的shell变量和环境变量环境变量的组织方式 </p><h2 id="获取进程的环境变量"><a href="#获取进程的环境变量" class="headerlink" title="获取进程的环境变量"></a>获取进程的环境变量</h2><ul><li>在程序中，可以使用<code>getenv()</code>接口获取对应<code>环境变量名</code>的对应环境变量值</li></ul><p><em><code>getenv</code>在<code>&lt;stdlib.h&gt;</code>中</em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PATH: %s\n&quot;</span>,getenv(<span class="string">&quot;PATH&quot;</span>));<span class="comment">//打印PATH的值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="环境变量的组织方式"><a href="#环境变量的组织方式" class="headerlink" title="环境变量的组织方式"></a>环境变量的组织方式</h2><p>每个<code>进程</code>都有自己的<code>环境表</code>,所谓<code>环境表</code>就是一个<strong>字符</strong><code>指针数组</code>,每个不为<code>NULL</code>的指针指向<code>环境字符串</code></p><p><a href="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-08_20-52-19.png">https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-08_20-52-19.png</a></p><ul><li>因此也可以使用<code>main</code>函数传参来打印所有环境变量的内容<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[],con <span class="type">char</span>* env[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span>* str;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(str =env[i++]) <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,str);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="导入环境变量"><a href="#导入环境变量" class="headerlink" title="导入环境变量"></a>导入环境变量</h2><p>头文件<code>unistd.h&gt;</code>提供了一个全局变量<code>environ</code>,因此可以用<code>extern</code>导入环境变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> **environ;<span class="comment">//导入换进变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* str;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(str =environ[i++]) <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,str);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="添加新的环境变量"><a href="#添加新的环境变量" class="headerlink" title="添加新的环境变量"></a>添加新的环境变量</h2><p>使用<code>export</code>命令可以添加新的环境变量</p><p>使用方法:<code>export``=``(变量值)</code></p><p>例如添加一个值为<code>supdriver666</code>,名为<code>MY_VALUE</code>的环境变量,最后查看该变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export MY_VALUE=supdriver666</span><br><span class="line"></span><br><span class="line">env | grep MY_VALUE</span><br></pre></td></tr></table></figure><h2 id="程序内设置换进变量"><a href="#程序内设置换进变量" class="headerlink" title="程序内设置换进变量"></a>程序内设置换进变量</h2><p>使用<code>&lt;stdlib.h&gt;</code>提供的<code>putenv()</code>接口可以设置环境变量，用法与<code>export</code>指令相同</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    putenv(<span class="string">&quot;MY_VALUE=666&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;MY_VALUE = %s&quot;</span>,getenv(<span class="string">&quot;MY_VALUE&quot;</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除环境变量"><a href="#删除环境变量" class="headerlink" title="删除环境变量"></a>删除环境变量</h2><p>使用<code>unset</code>可以删除环境变量</p><p><em>删除上文的<code>MY_VALUE</code></em></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">unset MY_VALUE</span><br><span class="line"></span><br><span class="line">env | grep MY_VALUE</span><br></pre></td></tr></table></figure><p>可以看到没有输出了 </p><h2 id="添加本地shell变量-和-查看本地变量与环境变量"><a href="#添加本地shell变量-和-查看本地变量与环境变量" class="headerlink" title="添加本地shell变量 和 查看本地变量与环境变量"></a>添加本地shell变量 和 查看本地变量与环境变量</h2><p>添加本地变量: 直接输入<code>(变量名)``=``(值)</code>  &#x2F;&#x2F;<em>不加空格</em>&#x2F;</p><p>查看变量: 使用<code>set</code>命令查看本地变量与环境变量，但是内容非常多，建议搭配<code>grep</code>等使用</p><p><em>例</em></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">my_value=2024</span><br><span class="line"></span><br><span class="line">set</span><br><span class="line"></span><br><span class="line">set | grep my_value</span><br></pre></td></tr></table></figure><h2 id="本地变量与环境变量"><a href="#本地变量与环境变量" class="headerlink" title="本地变量与环境变量"></a>本地变量与环境变量</h2><p>二者最大的差别是<code>环境变量</code>可以被子进程<strong>继承</strong>,而<code>本地变量</code>只在本BASH内部有效，<strong>不会</strong>被继承</p>]]></content>
      
      
      
        <tags>
            
            <tag> 环境变量 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识进程</title>
      <link href="/2024/07/04/progress/"/>
      <url>/2024/07/04/progress/</url>
      
        <content type="html"><![CDATA[<hr><p>操作系统平台:Linux<br>服务器系统: CentOS 7</p><hr><h1 id="概念抽象"><a href="#概念抽象" class="headerlink" title="概念抽象"></a>概念抽象</h1><h2 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h2><p><code>程序</code> &#x3D; <code>代码</code> + <code>数据</code></p><p>程序是储存在硬盘上的可执行文件</p><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>将<code>程序</code>加载到<code>内存</code>后，就在<code>内存</code>中程序的就是进程。也就是说一个正在运行的程序就能叫做进程</p><p><em>结构关系如下</em></p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-06_13-55-08.png"></p><p>如图，操作系统为了<strong>管理</strong>内存中的进程,使用了<code>PCB</code>结构体来描述进程,通过管理<code>PCB</code>来管理进程,依然是<em>先描述再组织</em></p><p><code>PCB</code>:进程控制块的数据结构(process control block)</p><p>所以实际上:<code>进程</code>&#x3D;<code>PCB</code>+<code>代码和数据</code></p><p>对于<code>代码和数据</code>没什么好说的，接下来主要讨论<code>PCB</code></p><h2 id="task-struct"><a href="#task-struct" class="headerlink" title="task_struct"></a>task_struct</h2><p><code>Linux</code>平台下的<code>PCB</code>叫做<code>task_struct</code></p><blockquote><p><code>task_struct</code>内容分类:</p></blockquote><ul><li><strong>标示符</strong>: 描述本进程的唯一标示符，用来区别其他进程。</li><li><strong>状态</strong>: 任务状态，退出代码，退出信号等。</li><li><strong>优先级</strong>: 相对于其他进程的优先级。</li><li>程序计数器: 程序中即将被执行的下一条指令的地址。</li><li>内存指针: 包括程序代码和进程相关数据的指针，还有和其他进程共享的内存块的指针</li><li>上下文数据: 进程执行时处理器的寄存器中的数据。</li><li>I／O状态信息: 包括显示的I&#x2F;O请求,分配给进程的I／O设备和被进程使用的文件列表。</li><li>记账信息: 可能包括处理器时间总和，使用的时钟数总和，时间限制，记账号等。</li><li>其他信息</li></ul><p><em>加粗部分会详细介绍</em></p><h1 id="查看进程"><a href="#查看进程" class="headerlink" title="查看进程"></a>查看进程</h1><p>进程的信息可以通过&#x2F;proc 系统文件夹查看,其中文件夹的名字就是进程的<code>PID</code></p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-06_21-53-59.png"></p><p>大多数进程信息同样可以使用top和ps这些用户级工具来获取</p><blockquote><p>以我自己编写的一个程序为例</p></blockquote><p><em>Makefile</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mycmd:mycmd.c</span><br><span class="line">gcc -o $@ $^</span><br><span class="line"></span><br><span class="line">.PHONY:clean</span><br><span class="line">clean:</span><br><span class="line">rm -rf mycmd</span><br></pre></td></tr></table></figure><p><strong>注</strong>： 后面的程序都是这三个头文件，仅修改<code>main()</code>函数体即可<br><em>mycmd.c</em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>) sleep(<span class="number">1</span>);<span class="comment">//死循环使该进程常驻内存</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后编译并运行程序<br><em>命令行</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">make</span><br><span class="line">./mycmd</span><br><span class="line">ps aux | grep mycmd | grep -v grep</span><br></pre></td></tr></table></figure><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-06_22-56-05.png"></p><h2 id="进程标示符-PID-PPID"><a href="#进程标示符-PID-PPID" class="headerlink" title="进程标示符(PID PPID)"></a>进程标示符(PID PPID)</h2><p>可以通过系统接口获取进程标示符</p><ul><li>进程id (pid)    使用<code>getpid()</code></li><li>父进程id (ppid) 使用<code>getppid()</code></li></ul><p><em>来修改一下代码</em><br><em>mycmd.c</em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;pid: %d\n&quot;</span>,getpid());<span class="comment">//打印pid (该进程id)</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;ppid: %d\n&quot;</span>,getppid());<span class="comment">//打印ppid (父进程id)</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>命令行</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">make clean</span><br><span class="line">make</span><br><span class="line">./mycmd</span><br></pre></td></tr></table></figure><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-06_23-28-35.png"></p><h2 id="利用fork-创建子进程"><a href="#利用fork-创建子进程" class="headerlink" title="利用fork()创建子进程"></a>利用<code>fork()</code>创建子进程</h2><p><em>mycmd.c</em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">pid_t</span> id = fork();</span><br><span class="line">  <span class="keyword">if</span>(id == <span class="number">0</span>)<span class="comment">//子进程</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child pid: %d\n&quot;</span>,getpid());<span class="comment">//打印pid (该进程id)</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child ppid: %d\n&quot;</span>,getppid());<span class="comment">//打印ppid (父进程id)</span></span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span><span class="comment">//父进程</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;father pid: %d\n&quot;</span>,getpid());<span class="comment">//打印pid (该进程id)</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;father ppid: %d\n&quot;</span>,getppid());<span class="comment">//打印ppid (父进程id)</span></span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-07_10-56-48.png"></p><p>如图，<code>fork()</code>创建了子进程，且子进程的<code>PPID</code>和父进程<code>PID</code>相同</p><h3 id="fork-的返回值"><a href="#fork-的返回值" class="headerlink" title="fork()的返回值"></a>fork()的返回值</h3><p>父子进程中<code>fork()</code>函数的返回值(此处用变量<code>id</code>储存)是不同的:</p><p><strong>父进程</strong>里<code>id</code>的值为子进程的<code>PID</code>,其值<code>&gt;0</code>;<strong>子进程</strong>里<code>id</code>值固定为<code>0</code></p><ul><li><code>id &gt; 0</code> 父进程</li><li><code>id == 0</code> 子进程</li><li><code>id &lt; 0</code> fork()失败</li></ul><h3 id="父子进程分流"><a href="#父子进程分流" class="headerlink" title="父子进程分流"></a>父子进程分流</h3><p>利用<code>fork()</code>返回值不同的特性可以做到分流操作，利用<code>if...else...</code>让父子进程执行不同的代码</p><p><a href="https://www.supdriver.top/2024/07/07/fork/">戳我去fork的详细介绍</a></p><h1 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h1><p><em>状态在kernel源代码里定义</em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> task_state_array[] = &#123;</span><br><span class="line"><span class="string">&quot;R (running)&quot;</span>, <span class="comment">/* 0 */</span></span><br><span class="line"><span class="string">&quot;S (sleeping)&quot;</span>, <span class="comment">/* 1 */</span></span><br><span class="line"><span class="string">&quot;D (disk sleep)&quot;</span>, <span class="comment">/* 2 */</span></span><br><span class="line"><span class="string">&quot;T (stopped)&quot;</span>, <span class="comment">/* 4 */</span></span><br><span class="line"><span class="string">&quot;t (tracing stop)&quot;</span>, <span class="comment">/* 8 */</span></span><br><span class="line"><span class="string">&quot;X (dead)&quot;</span>, <span class="comment">/* 16 */</span></span><br><span class="line"><span class="string">&quot;Z (zombie)&quot;</span>, <span class="comment">/* 32 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="R-运行状态-running"><a href="#R-运行状态-running" class="headerlink" title="R 运行状态(running)"></a>R 运行状态(running)</h2><p>R状态并不一定正在运行，而是<code>正在运行</code>和<code>处于运行队列</code>中的一种</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-07_13-14-49.png"></p><h2 id="S-睡眠状态-sleeping"><a href="#S-睡眠状态-sleeping" class="headerlink" title="S 睡眠状态(sleeping)"></a>S 睡眠状态(sleeping)</h2><p>S 意味着进程在<strong>等待</strong>运行完成</p><p>(<em>这里的睡眠有时也可叫做可中断睡眠 interruptible sleep</em>)</p><p><em>下面展示两种S状态的进程</em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  sleep(<span class="number">50</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-07_13-45-14.png"></p><p>直接使用<code>sleep()</code>系列的函数直接使进程休眠</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Enter the num: &quot;</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-07_13-47-33.png"></p><p>像<code>scanf()</code>这种需要等待外设(键盘)的接口，在<strong>阻塞等待</strong>资源的过程中会使进程进入<code>S</code>状态</p><h2 id="D-磁盘休眠状态（Disk-sleep）"><a href="#D-磁盘休眠状态（Disk-sleep）" class="headerlink" title="D 磁盘休眠状态（Disk sleep）"></a>D 磁盘休眠状态（Disk sleep）</h2><p>有时候也叫不可中断睡眠状态（uninterruptible sleep），在这个状态的进程通常会等待<code>IO</code>的结束。</p><h2 id="T-停止状态（stopped）"><a href="#T-停止状态（stopped）" class="headerlink" title="T 停止状态（stopped）"></a>T 停止状态（stopped）</h2><p>可以通过(<em>kill等命令</em>)发送 <code>SIGSTOP</code> 信号给进程来停止（T）进程。这个被暂停的进程可以通过发送 <code>SIGCONT </code>信号让进程继续运行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>) sleep(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行前先<strong>复制</strong>ssh渠道，其中一个窗口用于执行进程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">make clean</span><br><span class="line">make</span><br><span class="line">./mycmd</span><br></pre></td></tr></table></figure><p>另一个进程用于输入命令</p><p>先查看该进程的<code>PID</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps ajx | head -1 &amp;&amp; ps ajx | grep mycmd | grep -v grep</span><br></pre></td></tr></table></figure><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-07_15-04-51.png"></p><p>如图，这次的<code>PID</code>是<code>20275</code></p><p>然后用<code>kill</code>发送<code>SIGSTOP</code>,对应参数为<code>-19</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kill -19 20275</span><br><span class="line">ps ajx | head -1 &amp;&amp; ps ajx | grep mycmd | grep -v grep</span><br></pre></td></tr></table></figure><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-07_15-06-38.png"></p><p>可以看到它已经由<code>S</code>状态改为<code>T</code>状态了</p><p>接下来发送<code>SIGCONT</code>,对应参数<code>-18</code>,使进程恢复</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kill -18 20275</span><br><span class="line">ps ajx | head -1 &amp;&amp; ps ajx | grep mycmd | grep -v grep</span><br></pre></td></tr></table></figure><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-07_15-08-45.png"></p><p>可以看到已经由<code>T</code>变为原本的<code>S</code>状态了</p><h2 id="X-死亡状态（dead）"><a href="#X-死亡状态（dead）" class="headerlink" title="X 死亡状态（dead）"></a>X 死亡状态（dead）</h2><p>这个状态只是一个返回状态，你不会在任务列表里看到这个状态。</p><h2 id="Z-僵尸进程-zombie"><a href="#Z-僵尸进程-zombie" class="headerlink" title="Z 僵尸进程(zombie)"></a>Z 僵尸进程(zombie)</h2><p>这个详细讨论下</p><h3 id="产生"><a href="#产生" class="headerlink" title="产生"></a>产生</h3><p>当该进程退出后，父进程尚未使用<code>wait()</code>之类的接口获取该进程的<code>退出码</code>,且父进程<strong>没有结束</strong>时，该进程会变成僵尸进程</p><p><em>父进程比子进程先退出时，子进程的父进程会改变为PID为1的进程，由新进程托管</em></p><p><em>下面创建一个例子</em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">pid_t</span> id = fork();</span><br><span class="line">  <span class="keyword">if</span>(id == <span class="number">0</span>)<span class="comment">//子进程</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child exit\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span><span class="comment">//父进程</span></span><br><span class="line">  &#123;</span><br><span class="line">    sleep(<span class="number">30</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;father exit\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行程序后的<code>30秒</code>内查看进程状态，可以看到子进程进入了<code>Z</code>状态</p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-07_16-27-27.png"></p><h3 id="行为"><a href="#行为" class="headerlink" title="行为"></a>行为</h3><p>僵尸进程会以终止状态保持在进程表中，等待父进程读取退出状态代码</p><h3 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h3><ul><li>父进程一直<strong>未获取</strong>子进程的退出码,僵尸状态就会一直保持</li><li>保持<code>Z</code>状态的进程的<code>PCB</code>仍然要一直维护，占用资源</li><li>未退出<code>Z</code>状态的子进程可能造成内存泄漏</li></ul><h2 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h2><p>当父进程比子进程<strong>先</strong>退出后,这个子进程便成了<code>孤儿进程</code></p><p>既然原本的父进程没了，谁来托管子进程呢？答案是<code>PID</code>为<code>1</code>的那个进程</p><p><em>例子如下</em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">pid_t</span> id = fork();</span><br><span class="line">  <span class="keyword">if</span>(id == <span class="number">0</span>)<span class="comment">//子进程</span></span><br><span class="line">  &#123;</span><br><span class="line">    sleep(<span class="number">30</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child exit\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span><span class="comment">//父进程</span></span><br><span class="line">  &#123;</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;father exit\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-07_19-05-32.png"></p><h1 id="进程优先级"><a href="#进程优先级" class="headerlink" title="进程优先级"></a>进程优先级</h1><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><ul><li>cpu资源分配的先后顺序，就是指进程的优先权（priority）。</li><li>优先权高的进程有优先执行权利。配置进程优先权对多任务环境的linux很有用，可以改善系统性能。</li><li>还可以把进程运行到指定的CPU上，这样一来，把不重要的进程安排到某个CPU，可以大大改善系统整体性能</li></ul><h2 id="查看优先级"><a href="#查看优先级" class="headerlink" title="查看优先级"></a>查看优先级</h2><p><em>首先写一个常驻进程</em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)sleep(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后使用<code>ps -la</code>查看进程信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./mycmd</span><br><span class="line">ps -la</span><br></pre></td></tr></table></figure><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-07_19-59-12.png"></p><p>其中的<code>PRI</code>和<code>NI</code>与进程优先级有关,<code>PRI</code>就是进程的优先级，跟排队摇号一样，此值<code>越小</code>，被执行的优先级越高,而<code>NI</code>就是nice值，用于修正原<code>PRI</code>值</p><h3 id="PRI值的计算"><a href="#PRI值的计算" class="headerlink" title="PRI值的计算"></a>PRI值的计算</h3><p>首先在看到的<code>PRI</code>值之外，还有个隐藏的基准值，本文用<code>PRI0</code>指代，这个<code>PRI0</code>是固定的，当<code>NI</code>值为<code>0</code>时，<code>PRI == PRI0</code>,而<br>无论怎么修改多少次<code>NI</code>,<code>PRI</code>的值减去<code>NI</code>值都相等，所以大可以推断在本系统(Linux)中,<code>PRI</code>值有如下计算公式</p><p><code>PRI = PRI0 + NI</code></p><h3 id="修改NI值"><a href="#修改NI值" class="headerlink" title="修改NI值"></a>修改NI值</h3><p>因为修改<code>NI</code>值要管理员权限，所以要么<code>root</code>用户用<code>top</code>，要么信任用户用<code>sudo top</code>打开界面，然后按<code>r</code>,输入待修改进程的<code>PID</code>,按下回车后再输入新的<code>NI</code>值(有效范围<code>-20~19</code>)</p><p><em>此处可以用<code>ps -la</code>查看进程的PID,或调用<code>getpid()</code></em></p><p><em>再写一个例子</em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;mypid: %d\n&quot;</span>,getpid());</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>sudo top</code>然后按<code>r</code></p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-07_21-14-38.png"></p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-07_21-15-50.png"></p><p><code>ps -la</code>可以看到被修改后的进程优先级</p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-07_21-17-02.png"></p><h1 id="其它概念"><a href="#其它概念" class="headerlink" title="其它概念"></a>其它概念</h1><ul><li>竞争性: 系统进程数目众多，而CPU资源只有少量，甚至1个，所以进程之间是具有竞争属性的。为了高效完成任务，更合理竞争相关资源，便具有了优先级</li><li>独立性: 多进程运行，需要独享各种资源，多进程运行期间<strong>互不干扰</strong></li><li>并行: 多个进程在<strong>多个CPU</strong>下分别，同时进行运行，这称之为并行</li><li>并发: 多个进程在<strong>一个CPU</strong>下采用进程切换的方式，在一段时间之内，让多个进程都得以推进，称之为并发</li></ul><p><em>下一章</em><a href="https://www.supdriver.top/2024/07/06/evn/">环境变量</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 进程 Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C/C++ static关键字的使用</title>
      <link href="/2024/06/30/usestatic/"/>
      <url>/2024/06/30/usestatic/</url>
      
        <content type="html"><![CDATA[<p>因为<code>static</code>的用法又多又杂，值得单出一篇博客用以汇总</p><h1 id="C-C-通用用法"><a href="#C-C-通用用法" class="headerlink" title="C&#x2F;C++ 通用用法"></a>C&#x2F;C++ 通用用法</h1><h2 id="局部变量-全局属性"><a href="#局部变量-全局属性" class="headerlink" title="局部变量-&gt;全局属性"></a>局部变量-&gt;全局属性</h2><p>当对原本声明在函数栈帧里的<code>变量</code>使用<code>static</code>修饰时,该<code>变量</code>的存储空间会改变到<code>静态区</code>，不会随着函数栈帧的销毁而销毁。</p><p>初始化：初次调用声明语句时会执行声明操作，而之后再执行到该语句处时会自动跳过。</p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-03_10-51-24.png"></p><p>作用范围：与不加<code>static</code>时的作用范围相同，还是局部可用</p><p>销毁：和全局变量一样在<code>main</code>函数的栈帧销毁时一并销毁</p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-03_11-09-04.png"></p><h2 id="全局变量-限制访问"><a href="#全局变量-限制访问" class="headerlink" title="全局变量-&gt;限制访问"></a>全局变量-&gt;限制访问</h2><p>原本同级文件夹下的源文件可以用<code>extern</code>关键字互相获取全局变量,但如果用<code>static</code>修饰本地全局变量，那么这个全局变量只能在本文件调用，而其它文件看不到它</p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-03_11-56-27.png"></p><h2 id="全局函数-限制访问"><a href="#全局函数-限制访问" class="headerlink" title="全局函数-&gt;限制访问"></a>全局函数-&gt;限制访问</h2><p>原本同级文件夹下的源文件可以用<code>extern</code>关键字声明函数，然后去其它源文件的全局函数中寻找<code>实现方式</code>,但如果用<code>static</code>修饰本地全局函数，那么这个全局函数的实现只能在本文件调用，而其它文件看不到它</p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-03_12-02-16.png"></p><h1 id="C-类和对象"><a href="#C-类和对象" class="headerlink" title="C++类和对象"></a>C++类和对象</h1><h2 id="成员变量-静态成员-全局变量"><a href="#成员变量-静态成员-全局变量" class="headerlink" title="成员变量-&gt;静态成员 (全局变量)"></a>成员变量-&gt;静态成员 (全局变量)</h2><p>原本声明的成员变量在实例化后，属于由<code>类</code>实例化出来的<code>对象</code>，生命周期与所属对象相同，但在加了<code>static</code>后，该变量属于该类域中的全局变量，不再属于某个<strong>具体</strong>的<code>对象</code></p><p><strong>初始化</strong>: 因为已经不属于某一个对象，初始化也不能在类的接口中完成了，因此在类中声明<code>static</code>成员变量后，<strong>必须</strong>在全局区初始化<code>类域</code>中的成员变量。  #<em>在main函数等非全局域中无法初始化</em></p><p>常见应用：引用计数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">A</span>()</span><br><span class="line">&#123;</span><br><span class="line">cnt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> cnt;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> A::cnt = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h2 id="成员函数-静态成员函数-不含this指针"><a href="#成员函数-静态成员函数-不含this指针" class="headerlink" title="成员函数-&gt;静态成员函数 (不含this指针)"></a>成员函数-&gt;静态成员函数 (不含this指针)</h2><p>一般声明在类中的成员函数的参数列表隐藏<code>this</code>指针，要调用函数时得用类实例化出的<code>对象</code>来调用，由这个对象提供<code>this</code>指针</p><p>而使用<code>static</code>修饰后的静态成员函数不含<code>this</code>指针，该函数属于整个类域，调用时使用类域调用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">A</span>()</span><br><span class="line">&#123;</span><br><span class="line">cnt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">getCNT</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> cnt;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> A::cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a,b,c;</span><br><span class="line">    cout&lt;&lt;A::<span class="built_in">getCNT</span>();<span class="comment">//此时输出3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>归并排序</title>
      <link href="/2024/06/28/mergesort/"/>
      <url>/2024/06/28/mergesort/</url>
      
        <content type="html"><![CDATA[<hr><p>时间复杂度: O(nlogn)<br>空间复杂度: O(n)<br>稳定性： 稳定<br>实现语言: C&#x2F;C++</p><hr><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>这里采用的是<strong>分治</strong>的思想，但与<code>快速排序</code>相反的是，归并排序采用的是先分治再合并。</p><p>已知在有额外空间的情况下，合并两个<strong>有序</strong>数组得到一个新的较长有序数组是很高效的。 所以能不能把一个任意数组分成由左右两个有序数组组成然后合并成有序数组呢？</p><p>显然不能，大部分情况并不能分成两个有序数组，但如果在此之前用同样的方法（这里采用递归）事先排序左右两部分呢？大部分情况依然不能，因此这个递归会一直递推下去，最终待排序区间<strong>不断缩小</strong>,到只剩一个或零个元素，此时就可以将其看为有序数组了,也就是说递归在这里停止，可以一路合并有序数组一路回归上去了</p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-02_21-29-34.png"></p><h2 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h2><p>这里使用左右指针<strong>控制待排序区间</strong>（迭代器也行）,并采用递归的方式形象地完成分治操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> _MergeSort(vector&lt;<span class="type">int</span>&gt;&amp; arr,<span class="type">int</span> left,<span class="type">int</span> right,vector&lt;<span class="type">int</span>&gt;&amp;tmp)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//分治</span></span><br><span class="line">    <span class="keyword">if</span>(left &gt;= right) <span class="keyword">return</span>;<span class="comment">//递归出口</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">    _MergeSort(arr,left,mid,tmp);<span class="comment">//排序左半边</span></span><br><span class="line">    _MergeSort(arr,mid+<span class="number">1</span>,right,tmp);<span class="comment">//排序右半边</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//合并数组</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">tmp</span><span class="params">(arr.size())</span></span>;<span class="comment">//用tmp开辟额外空间用于合并数组</span></span><br><span class="line">    _MergeSort(arr,<span class="number">0</span>,arr.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="合并有序数组"><a href="#合并有序数组" class="headerlink" title="合并有序数组"></a>合并有序数组</h2><p>因为合并两个有序数组<strong>难以原地</strong>完成，所以要借助<code>tmp</code>数组提供额外空间。</p><p>具体做法就是用两个指针分别从两个数组中挑最小值，然后用第三个指针从左向右填到<code>tmp</code>中，最后再拷贝至原数组</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> _MergeSort(vector&lt;<span class="type">int</span>&gt;&amp; arr,<span class="type">int</span> left,<span class="type">int</span> right,vector&lt;<span class="type">int</span>&gt;&amp;tmp)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//分治</span></span><br><span class="line">    <span class="keyword">if</span>(left &gt;= right) <span class="keyword">return</span>;<span class="comment">//递归出口</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">    _MergeSort(arr,left,mid,tmp);<span class="comment">//排序左半边</span></span><br><span class="line">    _MergeSort(arr,mid+<span class="number">1</span>,right,tmp);<span class="comment">//排序右半边</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//合并数组</span></span><br><span class="line">    <span class="type">int</span> cur1 = left;</span><br><span class="line"><span class="type">int</span> cur2 = mid + <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> cur = left;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (cur1 &lt;= mid &amp;&amp; cur2 &lt;= right)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[cur1] &lt; arr[cur2])</span><br><span class="line">&#123;</span><br><span class="line">tmp[cur++] = arr[cur1++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">tmp[cur++] = arr[cur2++];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (cur1 &lt;= left)</span><br><span class="line">tmp[cur++] = arr[cur1++];</span><br><span class="line"><span class="keyword">while</span> (cur2 &lt;= right)</span><br><span class="line">tmp[cur++] = arr[cur2++];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = left; i &lt;= right; i++)</span><br><span class="line">arr[i] = tmp[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">tmp</span><span class="params">(arr.size())</span></span>;<span class="comment">//用tmp开辟额外空间用于合并数组</span></span><br><span class="line">    _MergeSort(arr,<span class="number">0</span>,arr.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是C++版的完整代码,下面再提供<code>C</code>语言版的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> _MergeSort(<span class="type">int</span>* arr, <span class="type">int</span> sz, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span>* tmp)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (left &gt;= right) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">_MergeSort(arr,sz ,left, mid, tmp);</span><br><span class="line">_MergeSort(arr, sz, mid + <span class="number">1</span>,right, tmp);</span><br><span class="line"><span class="type">int</span> cur1 = left, cur2 = mid + <span class="number">1</span>, cur = left;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (cur1 &lt;= mid &amp;&amp; cur2 &lt;= right)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[cur1] &lt; arr[cur2])</span><br><span class="line">tmp[cur++] = arr[cur1++];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">tmp[cur++] = arr[cur2++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (cur1 &lt;= mid)</span><br><span class="line">tmp[cur++] = arr[cur1++];</span><br><span class="line"><span class="keyword">while</span> (cur2 &lt;= right)</span><br><span class="line">tmp[cur++] = arr[cur2++];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = left; i &lt;= right; i++)</span><br><span class="line">arr[i] = tmp[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MergeSort</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> sz)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span>* tmp = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * sz);</span><br><span class="line">_MergeSort(arr, sz, <span class="number">0</span>, sz - <span class="number">1</span>, tmp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>归并排序的原理乍一看很吓人，好像很高深的样子，但其实多上手练练，多试着独立敲代码就能掌握其精髓了，之后手撕归并排序不要太简单</p>]]></content>
      
      
      
        <tags>
            
            <tag> 排序 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>=Linux=一步步自己写一个shell程序</title>
      <link href="/2024/06/04/myshell/"/>
      <url>/2024/06/04/myshell/</url>
      
        <content type="html"><![CDATA[<hr><p>系统：阿里云服务器Linux CentOs 7</p><p>编辑器: vim </p><p>编译器: gcc (支持C99)</p><hr><h1 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h1><p>本次写的程序较为简单，所以只使用一个源文件</p><p>所以在shell中<code>touch</code>一个<code>makefile</code>和一个<code>myshell.c</code></p><blockquote><p>shell</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">touch makefile</span><br><span class="line">touch myshell.c</span><br></pre></td></tr></table></figure><p>然后编辑<code>makefile</code>文件</p><blockquote><p>makefile</p></blockquote><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1 myshell:myshell.c                         </span><br><span class="line">  gcc -o <span class="variable">$@</span> <span class="variable">$^</span> -std=c99</span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>:clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">   rm -f myshell</span><br></pre></td></tr></table></figure><h1 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h1><p>本程序因函数较杂，会<code>include</code>较多头文件</p><blockquote><p>myshell.c</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br></pre></td></tr></table></figure><h1 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h1><p>为了统一修改部分参数，以及使参数更易读，这里使用部分宏定义</p><blockquote><p>myshell.c</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LEFT <span class="string">&quot;[&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RIGHT <span class="string">&quot;]&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LABEL <span class="string">&quot;# &quot;</span><span class="comment">//注意有个空格</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LINE_SIZE 1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ARGC_SIZE 32</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DLIM <span class="string">&quot; \t&quot;</span> <span class="comment">//可能有多个分隔符</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXIT_CODE 446 <span class="comment">//特殊的退出码，表示程序未正常退出，具体数字目前没有约定</span></span></span><br></pre></td></tr></table></figure><h1 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h1><p>我们需要用全局的变量来存储<code>命令行</code>(command line)和<code>参数包</code></p><blockquote><p>myshell.c</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> cline[LINE_SIZE];</span><br><span class="line"><span class="type">char</span>* arg[ARGC_SIZE];</span><br><span class="line"><span class="type">int</span> last_code = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h1 id="用Interact函数实现交互功能"><a href="#用Interact函数实现交互功能" class="headerlink" title="用Interact函数实现交互功能"></a>用<code>Interact</code>函数实现交互功能</h1><h2 id="打印命令行头部"><a href="#打印命令行头部" class="headerlink" title="打印命令行头部"></a>打印命令行头部</h2><p>为了打印命令行头部，我们需要知道三样东西：用户，主机，工作路径，这里包装了三个函数来分别调用<code>getenv</code>函数</p><blockquote><p>myshell.c</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* <span class="title function_">getusername</span><span class="params">()</span><span class="comment">//获取用户名</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> getenv(<span class="string">&quot;USER&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* <span class="title function_">gethostname</span><span class="params">()</span><span class="comment">//获取主机名</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> getenv(<span class="string">&quot;HOSTNAME&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* <span class="title function_">getpwd</span><span class="params">()</span><span class="comment">//获取工作路径</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> getenv(<span class="string">&quot;PWD&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>因此打印的代码为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(LEFT <span class="string">&quot;%s@%s %s&quot;</span> RIGHT LABLE,getusername(),gethostname(),getpwd());</span><br></pre></td></tr></table></figure><h2 id="获取命令行"><a href="#获取命令行" class="headerlink" title="获取命令行"></a>获取命令行</h2><p>使用Linux的终端时，我们会打<code>命令+空格+参数...</code>,因此我们的<code>myshell</code>程序也要支持连空格一起读入,读入一整行命令</p><p>所以<code>scanf</code>并不适合用来读入命令，这次我们使用<code>fgets</code>函数，这个函数可以从<code>文件流</code>中整行读入，而正好在终端输入的字符都储存在<code>标准输入流</code>,即<code>stdin</code>中,因此可以用一行代码获取<code>命令行</code></p><p>为安全考虑，这里使用一个临时变量<code>s</code>来接受<code>fgets</code>的返回值并用<code>assert</code>判空,但在<code>release</code>版本中<code>assert</code>不被编译，导致变量<code>s</code>未被调用，而报警告（甚至报错），所以还要再加一句<code>(void) s</code>,只为了调用一下<code>s</code>,没有更多用处</p><p>之后便完成了文件流的读取</p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-06-04_16-25-34.png"></p><p>但此时获得的命令行在<code>\0</code>前以<code>\n</code>结尾，所以要把<code>\n</code>替换为<code>\0</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *s = fgets(cline,size,<span class="built_in">stdin</span>);</span><br><span class="line">assert(s);<span class="comment">//s为空时报错</span></span><br><span class="line">(<span class="type">void</span>) s;<span class="comment">//防止因未调用s而报警告</span></span><br><span class="line"></span><br><span class="line">cline[<span class="built_in">strlen</span>(cline) - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br></pre></td></tr></table></figure><h2 id="整个函数体"><a href="#整个函数体" class="headerlink" title="整个函数体"></a>整个函数体</h2><blockquote><p>myshell.c</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Interact</span><span class="params">(<span class="type">char</span>* cline,<span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(LEFT <span class="string">&quot;%s@%s %s&quot;</span> RIGHT LABLE,getusername(),gethostname(),getpwd());<span class="comment">//打印头部</span></span><br><span class="line">    fgets(cline,size,<span class="built_in">stdin</span>);<span class="comment">//获取命令行</span></span><br><span class="line">    assert(s);<span class="comment">//s为空时报错</span></span><br><span class="line">    (<span class="type">void</span>) s;<span class="comment">//防止因未调用s而报警告</span></span><br><span class="line">    cline[<span class="built_in">strlen</span>(cline) - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;echo: %s\n&quot;</span>);<span class="comment">//写一段测一段的测试代码，输出获取的命令行,测完可删</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>先在<code>main</code>函数里调用一次<code>Interact</code>函数测试一下</p><p>我的测试结果如下</p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-06-04_16-42-55.png"></p><p>可以看到达到了预期效果，但是<code>工作路径</code>太长了，还是学一学Linux的展示方式吧，我们来把<code>getpwd</code>函数重写一下</p><h2 id="重写getpwd"><a href="#重写getpwd" class="headerlink" title="重写getpwd()"></a>重写<code>getpwd()</code></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* <span class="title function_">getpwd</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* pwd = getenv(<span class="string">&quot;PWD&quot;</span>);</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">strlen</span>(pwd);</span><br><span class="line">    <span class="keyword">while</span>(n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(pwd[n] == <span class="string">&#x27;/&#x27;</span>) <span class="keyword">break</span>;</span><br><span class="line">        n--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (pwd+n+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样打印出的工作路径仅为当前文件夹，可以缩短很多长度</p><h1 id="分割命令行"><a href="#分割命令行" class="headerlink" title="分割命令行"></a>分割命令行</h1><p>现在的<code>cline</code>中的命令行还是完整的一串，需要分割出命令和参数包，因此我们也封装一个函数<code>Splitcline</code></p><p>这里使用的是<code>string.h</code>中的<code>strtok</code>函数，可以用特定的单个或多个字符将字符串分割</p><blockquote><p>myshell.c</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Splitcline</span><span class="params">(<span class="type">char</span>*cline,<span class="type">char</span>** argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">memset</span>(argv,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="type">char</span>*) * ARGV_SIZE);</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    argv[<span class="number">0</span>] = strtok(cline,DLIM);</span><br><span class="line">    <span class="keyword">if</span>(argv[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">while</span>(argv[i++] == strtok(<span class="literal">NULL</span>,DLIM));</span><br><span class="line"></span><br><span class="line">    *argv_n = i<span class="number">-1</span>;<span class="comment">//输出型参数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>再写一段测试代码</p><blockquote><p>myshell.c</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Interact(cline,<span class="keyword">sizeof</span>(cline));</span><br><span class="line"></span><br><span class="line">    Splitcline(cline,argv);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;argv[i];i++)<span class="comment">//逐行打印输出argv的内容</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,argv[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="执行外部命令"><a href="#执行外部命令" class="headerlink" title="执行外部命令"></a>执行外部命令</h1><p>通过<code>fork</code>函数创建子进程，然后用<code>execvp</code>替换子进程，通过环境变量<code>PATH</code>找到外部命令并替换到子进程执行，同时父进程<code>myshell</code>调用<code>waitpid</code>函数等待子进程结束，保证<code>myshell</code>程序正常运行</p><blockquote><p>myshell.c</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ExternalCommand</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> id = fork();</span><br><span class="line">    <span class="keyword">if</span>(id &lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(id == <span class="number">0</span>)<span class="comment">//child</span></span><br><span class="line">    &#123;</span><br><span class="line">        execvp(argv[<span class="number">0</span>],argv+<span class="number">1</span>);<span class="comment">//+1之后才是参数列表</span></span><br><span class="line">        <span class="built_in">exit</span>(EXIT_CODE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> status = <span class="number">0</span>;</span><br><span class="line">        <span class="type">pid_t</span> rid = waitpid(id,&amp;status,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(rid == id)</span><br><span class="line">        &#123;</span><br><span class="line">            last_code = WEXITSTATUS(status);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="执行内建命令"><a href="#执行内建命令" class="headerlink" title="执行内建命令"></a>执行内建命令</h1><p><code>shell</code>中并不是所有的命令都由子进程完成的，比如用<code>cd</code>命令改变工作路径，就不能让子进程去执行(<del>否则只是改了子进程的路径</del>),因此我们还需要加一个内建命令接口</p><blockquote><p>myshell.c</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">BuildCommand</span><span class="params">(<span class="type">char</span>* _argv[],<span class="type">int</span> _argv_n)</span><span class="comment">//处理内建命令</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(_argv_n == <span class="number">2</span> &amp;&amp; <span class="built_in">strcmp</span>(_argv[<span class="number">0</span>],<span class="string">&quot;cd&quot;</span>)== <span class="number">0</span>)<span class="comment">//特殊处理的命令1</span></span><br><span class="line">  &#123;</span><br><span class="line">    chdir(argv[<span class="number">1</span>]);</span><br><span class="line">    getpwd();</span><br><span class="line">    <span class="built_in">sprintf</span>(getenv(<span class="string">&quot;PWD&quot;</span>),<span class="string">&quot;%s&quot;</span>,pwd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//完成执行返回1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//还可以继续else uf 加特殊处理的命令2,3,4,,,n</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//未执行内建命令。返回0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="完成框架"><a href="#完成框架" class="headerlink" title="完成框架"></a>完成框架</h1><p>至此，把<code>main</code>函数组织好后，一个简单的<code>shell</code>代码框架就搭好了，可以根据需要继续扩展<code>内建命令</code>的内容，比如导出环境变量，实现<code>echo</code>指令等（略写）。</p><blockquote><p>myshell.c</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">int</span> quit = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">while</span>(!quit)</span><br><span class="line">   &#123;</span><br><span class="line">     Interact(cline,<span class="keyword">sizeof</span>(cline));</span><br><span class="line">     <span class="type">int</span> argv_n;</span><br><span class="line">     Splitcline(cline,argv,&amp;argv_n);</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">if</span>(argv_n == <span class="number">0</span> )<span class="keyword">continue</span>;</span><br><span class="line">     </span><br><span class="line">     <span class="type">int</span> flag = BuildCommand(argv,argv_n);</span><br><span class="line">     <span class="keyword">if</span>(!flag) ExeternalCommand();</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;                            </span><br><span class="line">&#125;          </span><br></pre></td></tr></table></figure><h1 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h1><p>这里的命令行处理并没有考虑<code>输入/输出重定向</code>,所以仍有较大的需要完善的地方</p><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><p><a href="https://github.com/sis-shen/Linux_Code">点我去往github仓库</a>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆排序</title>
      <link href="/2024/05/21/heap-sort/"/>
      <url>/2024/05/21/heap-sort/</url>
      
        <content type="html"><![CDATA[<h1 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h1><ul><li>知道什么是大堆&#x2F;小堆</li><li>掌握如何将数组与完全二叉树的映射关系</li><li>掌握<code>向上调整法</code>和<code>向下调整法</code></li></ul><h2 id="大堆-小堆"><a href="#大堆-小堆" class="headerlink" title="大堆&#x2F;小堆"></a>大堆&#x2F;小堆</h2><p>大堆的特性:每一个节点的值都比左右孩子都大,<code>根</code>的值是整个大堆中<strong>最大的</strong><br>小堆的特性:每一个节点的值都比左右孩子都小,<code>根</code>的值是整个大堆中<strong>最小的</strong></p><p><strong>后面以大堆为例</strong></p><h2 id="数组映射成完全二叉树"><a href="#数组映射成完全二叉树" class="headerlink" title="数组映射成完全二叉树"></a>数组映射成完全二叉树</h2><p>任何一个数组可以看成一个<code>完全二叉树</code>,下标0为二叉树的根</p><p>而非常方便的是，已知一个节点的下标，可以利用数学关系求出根或孩子的下标</p><blockquote><p>下标关系如下（变量均为下标）</p></blockquote><ul><li><code>parent = (child-1)/2</code></li><li><code>left_child = parent*2+1</code></li><li><code>right_child = parent*2+2</code></li></ul><h2 id="建堆方法"><a href="#建堆方法" class="headerlink" title="建堆方法"></a>建堆方法</h2><h3 id="向上调整法"><a href="#向上调整法" class="headerlink" title="向上调整法"></a>向上调整法</h3><p>在已有一个大堆的<strong>前提下</strong>,把一个新的数据插入到堆的最后一个节点(此时破坏大堆的结构),再<strong>一路</strong>向上调整,可以重新建堆</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">adjust_up</span><span class="params">(vector&lt;T&gt;&amp; arr, <span class="type">int</span> child)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> parent = (child - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">while</span> (parent != child)<span class="comment">//parent == child == 0时</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[parent] &lt; arr[child])<span class="comment">//不满足大堆</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">swap</span>(arr[parent], arr[child]);<span class="comment">//交换</span></span><br><span class="line">child = parent;<span class="comment">//继续向上调整,迭代child和parent</span></span><br><span class="line">parent = (child - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span><span class="comment">//完成建堆，退出循环</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="向下调整法"><a href="#向下调整法" class="headerlink" title="向下调整法"></a>向下调整法</h3><p>在已有一个大堆的<strong>前提下</strong>,把根的值改变(此时破坏大堆的结构),再<strong>一路</strong>向下调整，可以重新建堆</p><p>上一句也可以等价于,左子树和右子树都是大堆的前提下，将根<strong>一路</strong>向下调整，可以重新建堆</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">adjust_down</span><span class="params">(vector&lt;T&gt;&amp; arr,<span class="type">int</span> sz , <span class="type">int</span> parent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> child = parent * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (child + <span class="number">1</span> &lt; sz &amp;&amp; arr[child + <span class="number">1</span>] &gt; arr[child]) child++;<span class="comment">//取较大的孩子</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (child &lt; sz)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[parent] &lt; arr[child])</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">swap</span>(arr[parent], arr[child]);</span><br><span class="line">parent = child;</span><br><span class="line"><span class="type">int</span> child = parent * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (child &gt;= sz) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (child + <span class="number">1</span> &lt; sz &amp;&amp; arr[child + <span class="number">1</span>] &gt; arr[child]) child++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="主要思路"><a href="#主要思路" class="headerlink" title="主要思路"></a>主要思路</h1><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-05-21_12-40-09.png"></p><h2 id="建堆"><a href="#建堆" class="headerlink" title="建堆"></a>建堆</h2><p>用<code>向上调整法</code>和<code>向下调整法</code>都能建堆,不过<code>向上调整法</code>建堆思路更简单，也更容易代码实现，只需要把第一个元素当成现成的大堆，然后逐个插入并向上调整。<strong>也就是说只需要写一个循环</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//向上调整法建堆</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; sz; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">adjust_up</span>(arr, i);<span class="comment">//逐个插入并向上调整建堆</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-05-21_19-45-09.png"></p><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>此时的排序有个特点，那就是我们要<strong>倒着排</strong></p><p>尽管此时数组的第一个元素为<code>最大值</code>,似乎只需要把它放在那，整一个<code>降序</code>排列，再把剩下的元素建个堆，确定第二大的数…<strong>但是</strong>，此时有个很大的问题，当把剩下的元素看作堆时，会发现前面建堆留下来的关系全被打乱了(原本父子关系,兄弟关系乱套了),也就是说要<code>完全重新建堆</code>,极大地浪费了第一次建堆所建立的关系</p><p>所以我们要尽可能<code>保留</code>原来的堆,既然把下标<code>0</code>处的节点除外会极大地影响堆的关系，那就改成把<code>最后一个叶子节点</code>除外,这样对原来的堆几乎没有改变。</p><p>但建堆选出的<code>最大的</code>的值在根处,所以把<code>根</code>和<code>最后一个叶子节点</code>交换，<strong>交换后</strong>,此时<strong>待排序</strong>的数中的<code>最大值</code>以完成排序（即倒着排）,把<code>最后一个叶子节点</code>从堆中除外,再从<code>根</code>开始一路向下调整即可重新<code>建堆</code>,如此循环</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = sz<span class="number">-1</span>; i &gt;= <span class="number">1</span>; i--)<span class="comment">//利用i的减小将已排序的元素逐个除外</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">swap</span>(arr[<span class="number">0</span>], arr[i]);<span class="comment">//选出最大的元素放在末尾</span></span><br><span class="line"><span class="built_in">adjust_down</span>(arr,i,<span class="number">0</span>);<span class="comment">//向下调整建堆,待排序的（待建堆的）数的个数为i,逐个减小</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-05-21_19-45-22.png"></p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-05-21_19-47-20.png"></p><p>正因为实际上排序时是<strong>倒着排</strong>的,所以当我们要排序时：</p><ul><li>升序-&gt;<code>大堆</code></li><li>降序-&gt;<code>小堆</code></li></ul><h1 id="全部代码"><a href="#全部代码" class="headerlink" title="全部代码"></a>全部代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">adjust_up</span><span class="params">(vector&lt;T&gt;&amp; arr, <span class="type">int</span> child)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> parent = (child - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">while</span> (parent != child)<span class="comment">//parent == child == 0时</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[parent] &lt; arr[child])<span class="comment">//不满足大堆</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">swap</span>(arr[parent], arr[child]);<span class="comment">//交换</span></span><br><span class="line">child = parent;<span class="comment">//继续向上调整,迭代child和parent</span></span><br><span class="line">parent = (child - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span><span class="comment">//完成建堆，退出循环</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">adjust_down</span><span class="params">(vector&lt;T&gt;&amp; arr,<span class="type">int</span> sz , <span class="type">int</span> parent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> child = parent * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (child + <span class="number">1</span> &lt; sz &amp;&amp; arr[child + <span class="number">1</span>] &gt; arr[child]) child++;<span class="comment">//取较大的孩子</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (child &lt; sz)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[parent] &lt; arr[child])</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">swap</span>(arr[parent], arr[child]);</span><br><span class="line">parent = child;</span><br><span class="line"><span class="type">int</span> child = parent * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (child &gt;= sz) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (child + <span class="number">1</span> &lt; sz &amp;&amp; arr[child + <span class="number">1</span>] &gt; arr[child]) child++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heap_sort</span><span class="params">(vector&lt;T&gt;&amp; arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> sz = arr.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//建堆</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; sz; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">adjust_up</span>(arr, i);<span class="comment">//逐个插入并向上调整建堆</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = sz<span class="number">-1</span>; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">swap</span>(arr[<span class="number">0</span>], arr[i]);<span class="comment">//选出最大的元素放在末尾</span></span><br><span class="line"><span class="built_in">adjust_down</span>(arr,i,<span class="number">0</span>);<span class="comment">//向下调整建堆</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 七大排序 堆排序 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++文件操作</title>
      <link href="/2024/05/14/cpp-file-op/"/>
      <url>/2024/05/14/cpp-file-op/</url>
      
        <content type="html"><![CDATA[<p><em>注:追求代码简洁,有一致的C++风格，可参阅本篇博客，若追求更高的读写效率，建议参阅C语言篇</em> <a href="">但文章还没写</a></p><p>本篇文章主要研究头文件<code>fstream</code>中的<strong>函数</strong>和<strong>类</strong></p><p>目前C++文件操作主要有两种流派,一种是声明<code>fstream</code>对象,另一种是分开声明<code>ifstream</code>和<code>ofstream</code></p><p><strong>注意，本文代码为了简洁，都是在展开std命名空间的前提下书写</strong></p><h1 id="fstream的使用"><a href="#fstream的使用" class="headerlink" title="fstream的使用"></a>fstream的使用</h1><p>先写一段示例代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">fstream <span class="title">f</span><span class="params">(<span class="string">&quot;file.txt&quot;</span>, ios::out)</span></span>;<span class="comment">//调用构造函数以out模式打开文件file.txt 注:out模式下file.txt 会自动创建</span></span><br><span class="line">string str = <span class="string">&quot;This is a sentence&quot;</span>;<span class="comment">//在内存中准备一段字符串</span></span><br><span class="line">f &lt;&lt; str;<span class="comment">//将字符串从内存写入文件</span></span><br><span class="line">f.<span class="built_in">close</span>();<span class="comment">//关闭文件流</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//f对象可以复用</span></span><br><span class="line">f.<span class="built_in">open</span>(<span class="string">&quot;file.txt&quot;</span>, ios::in);<span class="comment">//以in模式打开file.txt</span></span><br><span class="line">string content;<span class="comment">//声明变量</span></span><br><span class="line">f &gt;&gt; content;<span class="comment">//从文件流读取数据写入变量(内存)</span></span><br><span class="line">cout &lt;&lt; content;<span class="comment">//打印出来看一眼</span></span><br><span class="line">    f.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><em>输出结果</em><br><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-05-14_18-49-56.png"></p><p>这一小段代码完成了文件的两种模式的打开和读写，已经体现了<code>fstream</code>的基本功能,接下来分别详细介绍<code>成员函数</code>和<code>操作符重载</code></p><h2 id="fstreanm-open"><a href="#fstreanm-open" class="headerlink" title="fstreanm::open()"></a>fstreanm::open()</h2><p>函数声明:<code>void open(const char* filename, ios_base::openmode mode)</code></p><p>特别的,<strong>C++11</strong>增加了一个函数重载，第一个形参变为<code>const string&amp; filename</code></p><p>实际上，也可以通过<code>fstream</code>类的构造函数来打开文件，参数与<code>open()</code>函数相同</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">fstream <span class="title">f</span><span class="params">(<span class="string">&quot;filename&quot;</span>,ios::out)</span></span>;</span><br></pre></td></tr></table></figure><p>接下来分别介绍两个形参</p><h3 id="filename"><a href="#filename" class="headerlink" title="filename"></a>filename</h3><p><strong>一般</strong>第一个形参是文件名，可以传<code>字符串</code>&#x2F;<code>char*</code>指针，C++11还支持传<code>string</code>对象</p><p>文件名没什么好说的，就是有后缀的文件要<strong>注意后缀</strong>,以及文件名要写对，勤检查</p><p><strong>但实际上</strong>,第一个形参是<code>文件路径</code>,且支持<code>相对路径</code>,<del>绝对路径我测不出来</del></p><p><em>代码示例如下</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f.<span class="built_in">open</span>(<span class="string">&quot;this,txt&quot;</span>,ios::in);<span class="comment">///打开当前文件夹的文件,this.txt是文件名</span></span><br><span class="line">f.<span class="built_in">open</span>(<span class="string">&quot;../father.txt&quot;</span>,ios::in);<span class="comment">//打开父级文件夹的文件,father.txt是文件名</span></span><br><span class="line">f.<span class="built_in">open</span>(<span class="string">&quot;./dir/child.txt&quot;</span>,ios::in);<span class="comment">//打开子级文件夹的文件(dir是文件夹名称)child.txt是文件名</span></span><br></pre></td></tr></table></figure><h3 id="mode"><a href="#mode" class="headerlink" title="mode"></a>mode</h3><p><strong>用前须知</strong>:这些<code>mode</code>都存在于<code>ios_base</code>的类域中,但由于<code>ios</code>继承自<code>ios_base</code>,混用二者皆可，本文为了简洁，指定类域时，使用<code>ios</code>，如<code>f.open(&quot;file.txt&quot;,ios::out)</code></p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-05-16_19-22-46.png"></p><p><em>上图是继承关系图，箭头指向父类</em></p><p>这里依然统一使用<code>fstream</code>类声明一个<code>f</code>对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fstream f;</span><br></pre></td></tr></table></figure><p>打开模式比较多，下面先放一张表</p><table><thead><tr><th>mode</th><th>stands for</th><th>描述</th></tr></thead><tbody><tr><td>out</td><td>output</td><td>打开文件用于<code>写入</code>,即<code>内存-&gt;文件</code>,且会<strong>完全覆盖</strong>原文件,内置的流缓存(<code>internal stream buffer</code>)支持输出操作(类似<code>cout</code>)</td></tr><tr><td>in</td><td>input</td><td>打开文件用于读取,即<code>文件-&gt;内存</code>,内置的流缓存支持输入操作(<code>类似cin</code>)</td></tr><tr><td>app</td><td>append</td><td>所有的输出操作都<strong>追加在文件末尾</strong>,向已有内容追加文本</td></tr><tr><td>trunc</td><td>truncate</td><td>在打文件<strong>前</strong>,<strong>清除所有内容</strong></td></tr><tr><td>binary</td><td>binary</td><td>所有操作都以<code>二进制</code>的形式，而不是文本</td></tr><tr><td>ate</td><td>at end</td><td>输出操作在文件末尾开始</td></tr></tbody></table><p><em>注</em>,这些<code>mode</code>能用<code>|</code>操作符连接,<strong>同时</strong>使用这些<code>mode</code></p><p><strong>但是</strong></p><p>-使用<code>trunc | app</code>会打开失败<br>-使用<code>trunc</code>而未使用<code>|</code>连接<code>out</code>,也会失败</p><p>接下来逐一介绍这些<code>mode</code></p><h4 id="out-和-in"><a href="#out-和-in" class="headerlink" title="out 和 in"></a>out 和 in</h4><p><code>out</code>是最常用的模式之一,用于<code>覆盖</code>写入文件,而且当文件不存在时，会按文件名<strong>新建</strong>一个文件并执行写入操作(哪怕是空文件)</p><p><code>in</code>也是最常用的模式之一，用于<code>只读</code>地读取文件，且当文件不存在时，会<strong>抛异常</strong>(<em>这里挖个坑</em>)</p><ul><li>使用<code>out</code>时，<code>f</code>对象支持<code>&lt;&lt;</code>流插入操作符</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">str</span><span class="params">(<span class="string">&quot;123456&quot;</span>)</span></span>;</span><br><span class="line">f&lt;&lt;str&lt;&lt;endl;<span class="comment">//和输出内容到终端(cout)是一样的</span></span><br></pre></td></tr></table></figure><ul><li>使用<code>in</code>时,<code>f</code>对象支持<code>&gt;&gt;</code>流提取和作为<code>getline</code>函数的参数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">string s1,s2;</span><br><span class="line">f&gt;&gt;s1&gt;&gt;s2;<span class="comment">//和从终端提取内容(cin)是一样的</span></span><br><span class="line"></span><br><span class="line">string line;</span><br><span class="line"><span class="built_in">getline</span>(f,line);<span class="comment">//从文件流中提取一行,存入line对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">getline</span>(f,line))<span class="comment">//逐行提取至文件末尾</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用<code>in | out</code>时，<code>f</code>同时支持以上操作</li></ul><p>但是<code>写入</code>操作又和单一个<code>out</code>不一样，<code>单out</code>是完全覆盖，不考虑原文件内容,而<code>in | out</code>时，是<strong>不完全</strong>覆盖：从头开始覆盖，新写入的内容没有原文件长时，剩下的原文件<strong>依然保留</strong></p><blockquote><p><em>示例代码</em></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">fstream f;</span><br><span class="line">f.<span class="built_in">open</span>(<span class="string">&quot;ff.txt&quot;</span>, ios::out);</span><br><span class="line">f &lt;&lt; <span class="string">&quot;LongWord&quot;</span>;<span class="comment">//准备一个有内容的原文件</span></span><br><span class="line">f.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">f.<span class="built_in">open</span>(<span class="string">&quot;ff.txt&quot;</span>, ios::in | ios::out);</span><br><span class="line">f &lt;&lt; <span class="string">&quot;1234&quot;</span>;<span class="comment">//写入1234</span></span><br><span class="line">f.<span class="built_in">close</span>();</span><br><span class="line"><span class="comment">//最后ff.txt的内容为&quot;1234Word&quot;,不完全覆盖</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>但是，同时进行流插入和流提取时，文件的操作结果会比较诡异，所以并不建议对<strong>同一个文件流</strong>同时进行读写操作。</p><p>在一段<code>f.open()</code>和<code>f.close()</code>之间依然还是只进行读取<strong>或</strong>写入中的<strong>一种</strong>，而不要混合操作</p><p><strong>缺省参数</strong>：其实<code>mode</code>形参是有缺省参数的，正是<code>ios_base::in | ios_base::out</code>,也就是说在明确只使用<code>out</code>或<code>in</code>的情况下，且执行覆盖写入操作时，单写一个<code>f.open(文件名)</code>即可</p><h4 id="其它mode"><a href="#其它mode" class="headerlink" title="其它mode"></a>其它mode</h4><h5 id="app"><a href="#app" class="headerlink" title="app"></a>app</h5><p>正如表格里描述的，使用<code>app</code>时，写入时不会覆盖远内容，而是<code>追加</code>到文件末尾。其中与<code>out</code>一样，当文件不存在时，会自动创建并写入内容。(即使没内容，也会创建空文件)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">fstream f;</span><br><span class="line"></span><br><span class="line">f.<span class="built_in">open</span>(<span class="string">&quot;file.txt&quot;</span>,ios::out);</span><br><span class="line">f &lt;&lt; <span class="string">&quot;111&quot;</span>;<span class="comment">//准备一个内容为111的文件</span></span><br><span class="line">f.<span class="built_in">close</span>();</span><br><span class="line">f.<span class="built_in">open</span>(<span class="string">&quot;file.txt&quot;</span>, ios::app);</span><br><span class="line">f &lt;&lt; <span class="string">&quot;222&quot;</span>;<span class="comment">//111后面追加222</span></span><br><span class="line">f.<span class="built_in">close</span>();</span><br><span class="line"><span class="comment">//文件内容为111222</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="trunc"><a href="#trunc" class="headerlink" title="trunc"></a>trunc</h5><p>因为不加<code>out</code>会打开失败，所以<code>trunc</code>算是个<code>out</code>的修正,在以<code>out</code>模式打开前，清空原文件的内容</p><p>乍一看，因为<code>单out</code>是<code>完全覆盖写入</code>,似乎<code>trunc</code>没什么用</p><p>但是使用<code>ios::out | ios::in | ios::trunc</code>时是不完全覆盖写入，所以提前清空内容还是很有意义的。<del>(那为啥不用单out呢)</del></p><h5 id="ate"><a href="#ate" class="headerlink" title="ate"></a>ate</h5><p>全称<code>at end</code>,单用<code>ate</code>也会打开失败,当然，<code>ios::ate | ios::out</code>没有意义，因为还是完全覆盖写入,<code>ate</code>在<code>ios::in | ios::out | ios::in</code>更加有用，可以从文件末尾追加内容</p><h5 id="binary"><a href="#binary" class="headerlink" title="binary"></a>binary</h5><p>虽然表格里是那么说了，有没有用<code>binary</code>我是真测不出差别(<del>真要用的话，另寻高就把</del>)</p><p>但是单用<code>binary</code>依然会打开失败,需要再连个<code>out</code>或<code>in</code></p><hr><h1 id="ifstream-和-ofstream"><a href="#ifstream-和-ofstream" class="headerlink" title="ifstream 和 ofstream"></a>ifstream 和 ofstream</h1><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-05-17_11-18-29.png"></p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-05-17_11-18-48.png"></p><p>上图分别为二者的继承关系,实际上二者用起来和<code>fstream</code>是基本一样的，只不过在打开文件时，一个始终自带<code>ios::in</code>,另一个始终自带<code>ios::out</code></p><h1 id="读取文件流的一些方法"><a href="#读取文件流的一些方法" class="headerlink" title="读取文件流的一些方法"></a>读取文件流的一些方法</h1><h2 id="操作符"><a href="#操作符" class="headerlink" title="&gt;&gt;操作符"></a><code>&gt;&gt;</code>操作符</h2><p>这是最容易理解的方式，和从终端读取<code>数据</code>到变量里是一样的,只要类型匹配，不一定要存到字符串里</p><h2 id="getline-函数"><a href="#getline-函数" class="headerlink" title="getline()函数"></a><code>getline()</code>函数</h2><p>用<code>getline</code>可以读取一行(即读到<code>\n</code>或文件末尾<code>EOF</code>)</p><p>但<code>getline</code>主要有两种，存在于不同的头文件中，且参数不同</p><h3 id="中的getline"><a href="#中的getline" class="headerlink" title="&lt;string&gt;中的getline"></a>&lt;string&gt;中的getline</h3><p><code>istream&amp; getline (istream&amp; is, string&amp; str);</code></p><p>函数声明如上，第一个参数是文件流(<code>fstream</code>类或<code>istream</code>类都可以),第二个参数就是个<code>string</code>对象</p><p>下面是一个逐行提取的例子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//提前准备一个待提取文件</span></span><br><span class="line">fstream f;</span><br><span class="line">f.<span class="built_in">open</span>(<span class="string">&quot;ff.txt&quot;</span>, ios::out);</span><br><span class="line">f &lt;&lt; <span class="string">&quot;line 1&quot;</span> &lt;&lt; endl &lt;&lt; <span class="string">&quot;line 2&quot;</span> &lt;&lt; endl;</span><br><span class="line">f.<span class="built_in">close</span>();</span><br><span class="line"><span class="comment">//================</span></span><br><span class="line">f.<span class="built_in">open</span>(<span class="string">&quot;ff.txt&quot;</span>);</span><br><span class="line">string str;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">getline</span>(f, str))<span class="comment">//当f为空时，循环停止</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; str &lt;&lt; endl;<span class="comment">//打印每行,str内不含换行符</span></span><br><span class="line">&#125;</span><br><span class="line">f.<span class="built_in">close</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="成员函数中的getline"><a href="#成员函数中的getline" class="headerlink" title="成员函数中的getline"></a>成员函数中的getline</h3><p><code>std::istream::getline</code></p><p>根据继承关系,<code>fstream</code>继承了来自<code>istream</code>的<code>getline</code>成员函数,也就是说它们的对象都能调用这一成员函数</p><p><code>istream&amp; getline (char* s, streamsize n );</code></p><p>函数声明如上，可以看到，第一个参数是<code>char*</code>，要传给它一个<code>字符数组</code>,第二个则是读入字符数的最大值,当实际读入的字符数<strong>小于</strong><code>n</code>时，会自动在结尾加一个<code>\0</code></p><p><del>讲真这个函数更像是来自C语言的函数</del></p><p>示例代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">fstream f;</span><br><span class="line">f.<span class="built_in">open</span>(<span class="string">&quot;ff.txt&quot;</span>, ios::out);</span><br><span class="line">f &lt;&lt; <span class="string">&quot;line 1&quot;</span> &lt;&lt; endl &lt;&lt; <span class="string">&quot;line 2&quot;</span> &lt;&lt; endl;</span><br><span class="line">f.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">f.<span class="built_in">open</span>(<span class="string">&quot;ff.txt&quot;</span>);</span><br><span class="line"><span class="type">char</span> str[<span class="number">256</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">f.<span class="built_in">getline</span>(str, <span class="number">256</span>);<span class="comment">//str里存了line 1\0</span></span><br><span class="line">f.<span class="built_in">close</span>();</span><br><span class="line">cout &lt;&lt; str;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="get-函数"><a href="#get-函数" class="headerlink" title="get() 函数"></a>get() 函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">istream&amp; <span class="title">get</span> <span class="params">(<span class="type">char</span>&amp; c)</span></span>;</span><br></pre></td></tr></table></figure><p>如上是两种常用的函数重载,均为继承来的<code>成员函数</code>,逐字符提取的话就能提取到<code>\n``\r</code>之类的转义字符</p><p>代码示例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//提前准备一个待提取文件</span></span><br><span class="line">fstream f;</span><br><span class="line">f.<span class="built_in">open</span>(<span class="string">&quot;ff.txt&quot;</span>, ios::out);</span><br><span class="line">f &lt;&lt; <span class="string">&quot;line 1&quot;</span> &lt;&lt; endl &lt;&lt; <span class="string">&quot;line 2&quot;</span> &lt;&lt; endl;</span><br><span class="line">f.<span class="built_in">close</span>();</span><br><span class="line"><span class="comment">//================</span></span><br><span class="line"><span class="comment">//方法1</span></span><br><span class="line">f.<span class="built_in">open</span>(<span class="string">&quot;ff.txt&quot;</span>);</span><br><span class="line"><span class="type">char</span> ch;</span><br><span class="line"><span class="keyword">while</span> (f.<span class="built_in">get</span>(ch))<span class="comment">//获取字符</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; ch;<span class="comment">//打印字符</span></span><br><span class="line">&#125;</span><br><span class="line">f.<span class="built_in">close</span>();</span><br><span class="line"><span class="comment">//方法2</span></span><br><span class="line">f.<span class="built_in">open</span>(<span class="string">&quot;ff.txt&quot;</span>);</span><br><span class="line"><span class="keyword">while</span> ((ch = f.<span class="built_in">get</span>()) != EOF)<span class="comment">//因为优先级的问题，必须加括号</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; ch;<span class="comment">//打印字符</span></span><br><span class="line">&#125;</span><br><span class="line">f.<span class="built_in">close</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>以上就是C++文件操作的大部分常用内容了。挖一挖确实也不少内容了,值得总结。</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ 文件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通过设计list类深入理解iterator迭代器</title>
      <link href="/2024/04/26/create-mylist/"/>
      <url>/2024/04/26/create-mylist/</url>
      
        <content type="html"><![CDATA[<p>前置博客:<strong><a href="https://www.supdriver.top/2023/12/07/cpp-class/" title="点击跳转">从构建一个Date类入门C++类与对象</a></strong></p><blockquote><p>下面先迅速地搓一个<code>list</code>类</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="comment">//先用模板创建一个节点类</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span></span><br><span class="line">&#123;</span><br><span class="line">T _val;</span><br><span class="line">ListNode&lt;T&gt;* _next;</span><br><span class="line">ListNode&lt;T&gt;* _prev;</span><br><span class="line"></span><br><span class="line"><span class="comment">//提供全缺省的默认构造函数</span></span><br><span class="line"><span class="built_in">ListNode</span>(<span class="type">const</span> T&amp; val = <span class="built_in">T</span>()) :_val(val), _next(<span class="literal">nullptr</span>), _prev(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用ListNode构造list类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">list</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">typedef</span> ListNode&lt;T&gt; Node;<span class="comment">//用typedef简化代码</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">list</span>()<span class="comment">//默认构造函数</span></span><br><span class="line">&#123;</span><br><span class="line">_head = <span class="keyword">new</span> Node;</span><br><span class="line"><span class="comment">//维护两个指针</span></span><br><span class="line">_head-&gt;_next = _head;</span><br><span class="line">_head-&gt;_prev = _head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_front</span><span class="params">(<span class="type">const</span> T&amp; val)</span><span class="comment">//头插</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Node* newnode = <span class="keyword">new</span> <span class="built_in">Node</span>(val);</span><br><span class="line">Node* next = _head-&gt;_next;<span class="comment">//额外的指针，简化代码</span></span><br><span class="line"></span><br><span class="line">_head-&gt;_next = newnode;</span><br><span class="line">newnode-&gt;_prev = _head;</span><br><span class="line">newnode-&gt;_next = next;</span><br><span class="line">next-&gt;_prev = newnode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop_front</span><span class="params">()</span><span class="comment">//尾插</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">empty</span>()) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">Node* cur = _head-&gt;_next;</span><br><span class="line"></span><br><span class="line">_head-&gt;_next = cur-&gt;_next;</span><br><span class="line">cur-&gt;_next-&gt;_prev = _head;</span><br><span class="line"><span class="keyword">delete</span> cur;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="comment">//判空</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _head-&gt;_next == _head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//剩余代码自行补全</span></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Node* _head;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="list的迭代器"><a href="#list的迭代器" class="headerlink" title="list的迭代器"></a>list的迭代器</h1><p>不同于<code>vector</code>底层的数据在内存中<strong>连续</strong>存储,可以用<code>原生指针</code>充当迭代器,例如<code>typedef T* iterator</code></p><p><code>list</code>的底层是链表,在内存中<strong>分散</strong>*存储，是<strong>不能</strong>用<code>原生指针</code>来<strong>连续</strong>访问的,所以为了解决这一复杂问题，<br>需要自己写一个<code>iterator</code>类</p><h2 id="普通迭代器"><a href="#普通迭代器" class="headerlink" title="普通迭代器"></a>普通迭代器</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="comment">//迭代器也得用模板</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__list_iterator</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">typedef</span> __list_iterator&lt;T&gt; Self;<span class="comment">//简化代码</span></span><br><span class="line"><span class="keyword">typedef</span> ListNode&lt;T&gt; Node;</span><br><span class="line">Node* _node;</span><br><span class="line"></span><br><span class="line">__list_iterator(Node* node) :_node(node) &#123;&#125;</span><br><span class="line"></span><br><span class="line">Self&amp; <span class="keyword">operator</span>++()<span class="comment">//重载operator++</span></span><br><span class="line">&#123;</span><br><span class="line">_node = _node-&gt;_next;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> Self&amp; it) <span class="type">const</span> <span class="comment">//重载!==,比较操作符记得加const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> _node != it._node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">T&amp; <span class="keyword">operator</span>*()<span class="comment">//重载 *</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> _node-&gt;_val;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><em><code>list</code>类中添加如下代码</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">typedef</span> __list_iterator&lt;T&gt; iterator;</span><br><span class="line"></span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">iterator</span>(_head-&gt;_next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">iterator <span class="title">end</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">iterator</span>(_head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过如上修改,<code>list</code>已经支持<code>普通迭代器</code>,并且非<code>const</code>修饰的<code>list</code>已经支持<code>范围for</code>了</p><blockquote><p>测试代码如下</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">list&lt;<span class="type">int</span>&gt; lst;</span><br><span class="line">lst.<span class="built_in">push_front</span>(<span class="number">5</span>);</span><br><span class="line">lst.<span class="built_in">push_front</span>(<span class="number">4</span>);</span><br><span class="line">lst.<span class="built_in">push_front</span>(<span class="number">3</span>);</span><br><span class="line">lst.<span class="built_in">push_front</span>(<span class="number">2</span>);</span><br><span class="line">lst.<span class="built_in">push_front</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> e : lst)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; e &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="const迭代器"><a href="#const迭代器" class="headerlink" title="const迭代器"></a>const迭代器</h2><p><code>const list</code>要能提供<code>const_iterator</code>，因此我们还要写一个<code>const_iterator</code>类…吗？</p><p>其实<strong>并不用</strong>，要利用好C++中的<code>模板语法</code>来大大提高代码的复用性,尤其像<code>iterator</code>和<code>const_iterator</code>这种差别不大的类,没必要每个都单独写一段代码</p><p>为此我们的<code>__list_iterator</code>只需要能用<code>模板</code>解决好二者的差异即可。而目前最大的问题是什么？是<code>operator*()</code>的返回值问题,一个是返回<code>T&amp;</code>,另一个是<code>const T&amp;</code>,其他的成员函数则基本没差别,所以不妨扩充一下<code>模板参数</code>,添加一个<code>Ref</code>类。</p><blockquote><p>有变化的代码如下</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> <span class="title class_">Ref</span>&gt;<span class="comment">//增加一个Ref参数</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__list_iterator</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">typedef</span> __list_iterator&lt;T,Ref&gt; Self;<span class="comment">//Self这里的原类也要加</span></span><br><span class="line"><span class="keyword">typedef</span> ListNode&lt;T&gt; Node;</span><br><span class="line">Node* _node;</span><br><span class="line"></span><br><span class="line">__list_iterator(Node* node) :_node(node) &#123;&#125;</span><br><span class="line"></span><br><span class="line">Ref <span class="keyword">operator</span>*()<span class="comment">//直接返回Ref类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> _node-&gt;_val;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><em><code>list</code>类也有相应变化</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">typedef</span> __list_iterator&lt;T,T&amp;&gt; iterator;<span class="comment">//普通迭代器</span></span><br><span class="line"><span class="keyword">typedef</span> __list_iterator&lt;T,<span class="type">const</span> T&amp;&gt; const_iterator;<span class="comment">//const迭代器</span></span><br><span class="line"></span><br><span class="line">    <span class="function">const_iterator <span class="title">begin</span><span class="params">()</span> <span class="type">const</span> <span class="comment">//针对const指针的</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">const_iterator</span>(_head-&gt;_next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">const_iterator <span class="title">end</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">const_iterator</span>(_head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样通过增加一个<code>Ref</code>模板参数,完成了对<code>iterator</code>和<code>const_iterator</code>的代码级统一(<em>当然模板实例化出来是不一样的</em>)</p><p>但别忘了迭代器还要提供<code>-&gt;</code>操作符的重载,而<code>operator-&gt;()</code>函数要返回不同的指针，所以我们如法炮制，再增加一个<code>Ptr</code>模板参数</p><blockquote><p>有变化的代码如下</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> <span class="title class_">Ref</span>,<span class="keyword">class</span> <span class="title class_">Ptr</span>&gt;<span class="comment">//增加一个Ptr参数</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__list_iterator</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">typedef</span> __list_iterator&lt;T,Ref,Ptr&gt; Self;<span class="comment">//Self相应更改</span></span><br><span class="line"></span><br><span class="line">Ptr <span class="keyword">operator</span>-&gt;()<span class="comment">//重载-&gt;</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> &amp;(_node-&gt;_val);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><em><code>list</code>类也有相应变化</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">typedef</span> __list_iterator&lt;T,T&amp;,T*&gt; iterator;<span class="comment">//普通迭代器</span></span><br><span class="line"><span class="keyword">typedef</span> __list_iterator&lt;T,<span class="type">const</span> T&amp;,<span class="type">const</span> T*&gt; const_iterator;<span class="comment">//const迭代器</span></span><br></pre></td></tr></table></figure><p>至此，<code>list</code>和<code>__list_iterator</code>的基本功能已基本完成，本篇的重点<code>__list_iterator</code>主要解决了两点问题</p><p>-为了应对<code>list</code>的迭代器的复杂性，单独为其构建一个<code>__list_iterator</code>类，并提供一系列的操作符重载<br>-为了提高代码的<strong>复用性</strong>,仅用一个<code>__list_iterator</code>类来<code>typedef</code>普通迭代器和<code>const</code>迭代器,我们增加了模板参数,最终模板变为<code>template&lt;class T, class Ref, class Ptr&gt;</code></p><h2 id="用普通迭代器构造const迭代器"><a href="#用普通迭代器构造const迭代器" class="headerlink" title="用普通迭代器构造const迭代器"></a>用普通迭代器构造const迭代器</h2><p>有时候我们需要用普通迭代器构造<code>const</code>迭代器,于是可以给<code>__list_iterator</code>提供一个比较有意思的<code>构造函数</code>,<br>可以实现时而充当拷贝构造，时而充当满足上述的构造</p><blockquote><p>代码如下</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> __list_iterator&lt;T,Ref,Ptr&gt; Self;<span class="comment">//再展示一遍Self的代码，便于下文对比</span></span><br><span class="line"><span class="keyword">typedef</span> __list_iterator&lt;T,T&amp;,T*&gt; iterator;<span class="comment">//指定普通迭代器，并用typedef简化代码</span></span><br><span class="line"></span><br><span class="line">__list_iterator(iterator it) :_node(it._node) &#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>-当模板参数为<code>&lt;T,T&amp;,T*&gt;</code>时，<code>Self</code>和<code>iterator</code>相同，上段代码中的构造函数相当于<code>拷贝构造</code></p><p>-当模板参数为<code>&lt;T,const T&amp;,const T*&gt;</code>时，<code>Self</code>和<code>iterator</code>不同,<code>Slef</code>是<code>const</code>迭代器,<code>iterator</code><strong>始终</strong>是普通迭代器，这个构造函数便能用普通迭代器构造<code>const</code>迭代器</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>通过构造一个<code>list</code>类，我们使用到了更复杂的迭代器，使用了带<code>3个模板参数</code>的<code>__list_iterator</code>类定义普通迭代器和<code>const</code>迭代器，学习了如何利用模板参数提高代码的复用性，如何提供额外的<code>构造函数</code>使<code>__list_iterator</code>支持用普通迭代器构造<code>const</code>迭代器</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ 类和对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vim基础指令集</title>
      <link href="/2023/12/11/vim-cmd/"/>
      <url>/2023/12/11/vim-cmd/</url>
      
        <content type="html"><![CDATA[<p><code>Vim</code>是一款文本编辑器,下面介绍在vim界面中的常用指令</p><p><strong>三种模式</strong>:<code>命令模式(Command Mode)</code> <code>插入模式（Insert Mode</code> <code>命令行模式（Command-Line Mode）</code>（这里称命令行模式为<code>底行模式</code>）</p><p>三者关系如下图</p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2023-12-11_10-39-04.png"></p><h1 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h1><p><code>vim</code>界面中多摁几次<code>ESC</code>就能退出其它模式回到<code>命令模式</code>，在这个模式下可以使用一系列vim<a href="https://linux.cn/article-8144-1.html">快捷键</a></p><h1 id="底行模式"><a href="#底行模式" class="headerlink" title="底行模式"></a>底行模式</h1><p><code>tips</code>:不管目前是什么模式,先狂按<code>ESC</code>,回到<code>命令模式</code>,然后输入<code>:</code>进入<code>底行模式</code>,准备开始输命令</p><p><code>命令组成</code><br><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2023-12-11_12-48-54.png"></p><ul><li>保存<code>:w</code>-&gt;强制保存<code>!w</code></li><li>退出<code>:q</code>-&gt;强制退出<code>:!q</code></li><li>保存并退出<code>:wq</code>-.强制保存并退出<code>:!wq</code></li><li>对比<code>:vs </code>+<code>(源文件路径)</code></li></ul><h1 id="插入模式"><a href="#插入模式" class="headerlink" title="插入模式"></a>插入模式</h1><p>在<code>命令模式</code>下按键盘<code>i</code>进入<code>插入模式</code>，执行正常的文本编辑功能</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从构建一个Date类入门C++类与对象</title>
      <link href="/2023/12/07/cpp-class/"/>
      <url>/2023/12/07/cpp-class/</url>
      
        <content type="html"><![CDATA[<h1 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">(<span class="type">int</span> year = <span class="number">1</span>,<span class="type">int</span> month = <span class="number">1</span>,<span class="type">int</span> day = <span class="number">1</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _year = year;</span><br><span class="line">        _month = month;</span><br><span class="line">        _day = day;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; _year &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; _month &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; _day &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _year;</span><br><span class="line">    <span class="type">int</span> _month;</span><br><span class="line">    <span class="type">int</span> _day;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="抽象数据类型-类"><a href="#抽象数据类型-类" class="headerlink" title="抽象数据类型(类)"></a>抽象数据类型(类)</h2><p>通过如上代码，我们就在源代码中通过<code>class</code>声明了一个抽象数据类型<code>Date</code>,简称<code>类</code>，那么封装一个类有什么好处呢？<br>好处是类把相关的操作分为<strong>两类</strong>:</p><ul><li>类的<strong>设计者</strong>:负责考虑类的具体实现，提供类的接口，成员变量等</li><li>类的<strong>使用者</strong>:只关心类<strong>提供</strong>了哪些功能，而不关心具体实现，从而简化思路</li></ul><p>以上面的<code>Date</code>类为例</p><blockquote><p>对设计者</p></blockquote><ul><li>要考虑实现<code>Date</code>,就需要声明<strong>成员变量</strong><code>_year</code> <code>_month</code> <code>_day</code>,以及声明及实现<strong>成员函数</strong><code>Init</code>和<code>Print</code></li></ul><blockquote><p>对使用者</p></blockquote><ul><li>只需知道可以调用<code>Date</code>的<strong>成员函数</strong><code>Init</code>和<code>Print</code>,以及知道它们的用处即可</li></ul><h2 id="实例化-–-将类真正投入使用"><a href="#实例化-–-将类真正投入使用" class="headerlink" title="实例化 – 将类真正投入使用"></a>实例化 – 将类真正投入使用</h2><p>类也可以用于声明变量，例如<code>Date d</code>就声明了一个变量<code>d</code>,但由于是由<code>类</code>声明的,我们将这一过程称为<code>实例化</code>,其中<code>Date</code>这样的抽象数据类型称为<code>类</code>，像<code>d</code>这样的变量称为<code>对象</code></p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-04-16_11-19-21.png"></p><p>实例化后的对象拥有<strong>私有</strong>的<code>成员变量</code>和整个类<strong>公有</strong>的<code>成员函数</code>,接下来对<code>对象</code>的操作都是对<code>成员变量</code>和<code>成员函数</code>的操作</p><h2 id="访问成员函数-变量"><a href="#访问成员函数-变量" class="headerlink" title="访问成员函数&#x2F;变量"></a>访问成员函数&#x2F;变量</h2><h3 id="在类的内部"><a href="#在类的内部" class="headerlink" title="在类的内部"></a>在<code>类的内部</code></h3><p>对于类的成员函数，除了显式声明的<code>函数参数</code>外,还有<strong>隐式</strong>传入的<code>this</code>指针，这是个<strong>默认<code>非const</code>修饰</strong>的,指向调用该成员函数的<strong>对象的指针</strong>,编译器可以通过这个指针访问该对象的<code>成员变量</code>和<code>成员函数</code>。</p><p>而我们作为类的<strong>设计者</strong>，既然语法都<strong>隐式</strong>地传入<code>this</code>指针了，自然也可以<strong>隐式</strong>地调用<code>成员</code>,即<strong>直接写</strong>变量名&#x2F;函数名调用</p><p><em>当然，手动显式调用this指针也是可以的</em></p><blockquote><p>以<code>Date</code>为例</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该函数声明在Date类中，成员变量见文章开头</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestPrint</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _year = <span class="number">2024</span>;<span class="comment">//隐式调用this访问成员变量</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;_month = <span class="number">4</span>;<span class="comment">//显式调用this</span></span><br><span class="line">    _day = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">Print</span>();<span class="comment">//隐式调用this来调用成员函数Print()</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">Print</span>();<span class="comment">//显式调用this，效果与上一句相同</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但由于<code>const</code>修饰的<code>对象</code>传出的是<code>const</code>修饰的<code>this</code>指针，普通的<code>this</code>形参无法接收。<br>那么如何让<code>成员函数</code>传入<code>const</code>修饰的<code>this</code>指针,来使<code>const</code>修饰的<code>对象</code>有成员函数可调用呢？</p><p>语法规定，在函数的参数列表(<em>圆括号后面</em>)紧跟一个<code>const</code>可使函数传入<code>const</code>修饰的<code>this</code>指针</p><p><em>这种函数称为常量成员函数</em></p><blockquote><p><em>举个例子</em></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="comment">//该函数声明在类中</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">constPrint</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在类的外部"><a href="#在类的外部" class="headerlink" title="在类的外部"></a>在<code>类的外部</code></h3><p>和C语言的结构体一样，访问对象内的成员有两种方式</p><ul><li><em>对象名</em> + <code>.</code> + 成员名 ： 用<code>.</code>操作符访问对应成员</li><li><em>对象的指针</em> + <code>-&gt;</code> + 成员名 : 用<code>-&gt;</code>操作符访问指针<strong>指向对象</strong>的对应成员</li></ul><blockquote><p>以<code>Date</code>实例化一个<code>d</code>为例</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// class Date</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     ....</span></span><br><span class="line"><span class="comment">// &#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Date d;</span><br><span class="line">    Date* pd = &amp;d;</span><br><span class="line">    d.<span class="built_in">Init</span>(<span class="number">2024</span>,<span class="number">4</span>,<span class="number">1</span>);<span class="comment">// . 操作符调用Init成员函数来初始化对象</span></span><br><span class="line">    pd-&gt;<span class="built_in">Print</span>();<span class="comment">//-&gt;操作符调用Print成员函数来打印内容</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Date d;</span><br><span class="line">    d._year = <span class="number">2024</span>;<span class="comment">//试图访问成员变量_year,但是访问权限冲突</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test1输出</span></span><br><span class="line"><span class="number">2024</span>:<span class="number">4</span>:<span class="number">1</span></span><br><span class="line"><span class="comment">//test2输出</span></span><br><span class="line">报错，无输出，因为访问权限冲突</span><br></pre></td></tr></table></figure><p>代码如上，<code>test1</code>运行的很好，但<code>test2</code>报错了，原因在于<code>test2</code>作为<strong>非成员函数</strong>访问了访问限定符<code>private</code>控制的成员<code>_year</code>,权限冲突，就会报错。</p><p>由此，C++类和对象还有一个重要概念需要强调–<strong>访问控制</strong></p><h2 id="访问权限控制与封装"><a href="#访问权限控制与封装" class="headerlink" title="访问权限控制与封装"></a>访问权限控制与封装</h2><p>使用类和对象编程的一大优点就是类可以<code>封装</code>代码，让使用者只能使用公有的接口和成员变量，而对内部的具体实现不可见，来提高类的<code>易用性</code>和<code>安全性</code></p><p>所以C++语法提供了三种<code>访问说明符</code>(<em>access specifiers</em>)</p><ul><li>public: 该说明符之后的成员在整个程序内可被访问</li><li>private: 之后的成员仅可被该类的的类域里（<em>如成员函数</em>）访问</li><li>protected: 一般同<code>private</code>,主要特点体现在类的继承，这里<strong>不作讨论</strong></li></ul><h3 id="作用范围"><a href="#作用范围" class="headerlink" title="作用范围"></a>作用范围</h3><p>某一<code>访问说明符</code>的作用范围开始于它的<code>冒号</code>,终止于下一个<code>访问说明符</code>或<code>类的结尾</code>,而<code>类的开始</code>到第一个<code>访问说明符</code>前的访问权限取决于<strong>声明</strong>类的<code>关键字</code>,分类如下</p><ul><li><code>class</code>默认为<code>private</code>权限</li><li><code>struct</code>默认为<code>public</code>权限</li></ul><blockquote><p>图例如下</p></blockquote><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-04-18_14-15-40.png"></p><p>实际上<code>class</code>和<code>struct</code>除了默认权限不一样，基本<strong>没有差别</strong>。</p><p>所以为了防止误读，<strong>提高可读性</strong>,<strong>不建议</strong>在<code>默认区</code>写代码,而是保证每段语句前都有合适的<code>访问限定符</code></p><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>作为类的设计者，一个类按<code>访问权限</code>可以分为两个区</p><ul><li><code>public</code>: 将提供给<code>使用者</code>的<code>接口（函数）</code>和<code>成员变量</code>声明在此，用于外部调用接口和修改非私有的成员函数</li><li><code>private</code>: 用于存放<strong>受保护</strong>的<code>成员变量</code>和<code>成员函数</code>,防止外部使用者<em>意外</em>或<em>恶意</em>调用或修改,造成类的内部结构被破坏等<strong>安全问题</strong>,所以特别重要的成员变量，和不希望被外部调用的函数声明在这里</li></ul><blockquote><p>例如在声明<code>Date</code>类时，我们将<code>Init</code>和<code>Print</code>接口提供给使用者，用<code>public</code>控制；<code>_year</code>等成员变量不希望被外部随意修改，就用<code>private</code>控制</p></blockquote><h1 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h1><p>学完以上内容，不过是会写个高级点的<code>结构体</code>而已，要写一个完整的类，还需要学习更多的语法知识</p><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>像本篇的<code>Date</code>类那样显式地调用<code>Init</code>函数来初始化是非常挫的，既然语言本身的<code>内置类型</code>可以在声明的时候初始化，那么类的设计者设计出来的类也应当提供<code>初始化的接口</code>,而支持这一功能的接口便是<code>构造函数</code></p><p>按语法规定，<code>构造函数</code>的函数名必须是<code>类名</code>,<strong>没有返回值</strong>，<code>const</code>修饰的成员变量必须位于<code>初始化列表</code>,其它则可省略。<em>关于初始化列表，稍后详细解释</em></p><blockquote><p>以<code>Date</code>类为例</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//一个普通的构造函数</span></span><br><span class="line">    <span class="built_in">Date</span>(<span class="type">int</span> year,<span class="type">int</span> month,<span class="type">int</span> day)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//进入括号时成员变量已经声明，且未初始化</span></span><br><span class="line">        _year = year;<span class="comment">//这是一个赋值操作，而不是初始化</span></span><br><span class="line">        _month = month;</span><br><span class="line">        _day = day;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _year;</span><br><span class="line">    <span class="type">int</span> _month;</span><br><span class="line">    <span class="type">int</span> _day;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Date <span class="title">d</span><span class="params">(<span class="number">2024</span>,<span class="number">4</span>,<span class="number">1</span>)</span></span>;<span class="comment">//使用构造函数声明了一个d对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以上的构造函数基本能用了,但还有两个问题</p><ul><li>构造函数没有初始化成员变量，而是采用赋值操作,无法初始化<code>const</code>修饰的成员变量</li><li>使用<code>Date d</code>是会报错的，因为没有提供<code>默认构造函数</code></li></ul><p>对于<strong>第一个问题</strong>，就要引入<code>初始化列表</code>这一概念，让初始化函数直接拥有<code>初始化成员变量</code>的功能</p><p>初始化列表位于构造函数的参数列表之后，花括号之前，以<code>:</code>开头，用<code>,</code>分隔成员变量</p><blockquote><p>以<code>Date</code>为例</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Date</span>(<span class="type">int</span> year,<span class="type">int</span> month,<span class="type">int</span> day):_year(year) , _month(month) , _day(day) &#123;&#125;</span><br><span class="line"><span class="comment">//或者换个书写格式（二者完全等价）</span></span><br><span class="line"><span class="built_in">Date</span>(<span class="type">int</span> year,<span class="type">int</span> month,<span class="type">int</span> day):_year(year) </span><br><span class="line">, _month(month) </span><br><span class="line">, _day(day) </span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure><p>通过这样<code>初始化列表</code>,便能在声明对象时，<strong>直接</strong>初始化成员变量</p><p>对于<strong>问题二</strong>，我们开启另一个个小专题</p><h3 id="构造函数的重载和缺省参数"><a href="#构造函数的重载和缺省参数" class="headerlink" title="构造函数的重载和缺省参数"></a>构造函数的重载和缺省参数</h3><p>没错，构造函数和函数一样，也是能<code>重载</code>和给参数传<code>缺省值</code>的</p><p><em>也就是说我们能写好几个构造函数</em></p><p>下面特别说明几个<strong>特殊</strong>的构造函数</p><h4 id="默认构造函数"><a href="#默认构造函数" class="headerlink" title="默认构造函数"></a>默认构造函数</h4><p>原则上对于每一个类，都应该提供<strong>有且仅有一个</strong>默认构造函数（*多个<code>默认构造函数</code>会报错!*）</p><p>而要<strong>声明</strong>默认构造函数，只需声明<code>无参数</code>构造函数，或者<code>全缺省参数</code>构造函数即可</p><blockquote><p>以<code>Date</code>为例</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Date</span>():_year(<span class="number">2024</span>),_month(<span class="number">4</span>),_day(<span class="number">1</span>)&#123;&#125;</span><br><span class="line"><span class="comment">//====分割线=======</span></span><br><span class="line"><span class="comment">//或者全缺省，两个函数不能同时声明</span></span><br><span class="line"><span class="built_in">Date</span>(<span class="type">int</span> year = <span class="number">2024</span>,<span class="type">int</span> month = <span class="number">4</span>,<span class="type">int</span> day = <span class="number">1</span>): _year(year),_month(month),_day(day)&#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以上就是两种默认构造函数的声明形式</p><h4 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h4><p>有时候我们会希望用<strong>现有的</strong>的对象去初始化一个<strong>新</strong>对象,此时对应的构造函数就称为<code>拷贝构造（函数）</code></p><p><code>拷贝构造</code>的声明方式为<code>构造函数</code>+参数类型为<code>类本身的引用传参</code>,不加<code>&amp;</code>的话就会死递归报错,有无<code>const</code>皆可，但由于是实现<code>拷贝功能</code>，一般是加<code>const</code>的</p><blockquote><p>以<code>Date</code>为例</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Date</span>(<span class="type">const</span> Date&amp; d):_year(d._year),_month(d._month),_day(d._day)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用示例</span></span><br><span class="line"><span class="function">Date <span class="title">d</span><span class="params">(<span class="number">2024</span>,<span class="number">4</span>,<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="function">Date <span class="title">copy1</span><span class="params">(d)</span></span>;<span class="comment">//调用方式一</span></span><br><span class="line">Date copy2 = d;<span class="comment">//调用方式二,此时不会调用operator=()</span></span><br><span class="line"></span><br><span class="line">copy1 = copy2;<span class="comment">//这种并不会调用拷贝构造,而是调用operator=()</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="使用模板的类的函数缺省值"><a href="#使用模板的类的函数缺省值" class="headerlink" title="使用模板的类的函数缺省值"></a>使用模板的类的函数缺省值</h4><p>有时我们在使用类模板来设计类时，需要给<code>模版类</code>类型的形参提供一个缺省值，有些人可能会写个<code>0</code>,但是其实是<strong>错的</strong>，正确的做法是传一个<code>临时变量</code></p><p>但此时要求<code>模板参数中的类</code>有可用的<code>默认构造函数</code>和<code>拷贝构造</code>用于调用</p><blockquote><p>以链表节点<code>Node</code>为例</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">value_type</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    value_type _val;</span><br><span class="line">    Node&lt;value_type&gt;* _next;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">const</span> value_type&amp; val = <span class="built_in">value_type</span>()):_val(val),_next(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以用本文的Date实例化为例</span></span><br><span class="line">Node&lt;Date&gt; node;</span><br><span class="line"><span class="comment">//通过输出会发现node中的val已经调用了默认构造函数</span></span><br><span class="line">node.val.<span class="built_in">TestPrint</span>();</span><br></pre></td></tr></table></figure><h2 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h2><p>对于声明在<code>栈区</code>或<code>静态区</code>的成员函数，程序完全可以自动销毁，<br>但如果<code>成员变量</code>有指向在<code>堆区</code>声明的某段<code>内存块</code>,在该如果只是仍由程序自动<br>销毁这个指针，那么那段<code>内存块</code>就会一直处于<strong>未释放</strong>的状态，也就是造成内存泄漏，<br>也就是说此时编译器自动生成的<code>析构函数</code>已经不能满足需求,编译器并不知道如何处理声明在<code>堆区</code>上的数据,<br>这部分操作应由类的设计者来规划</p><p>所以我们应当<strong>显式</strong>地声明一个合理的<code>析构函数</code></p><p><code>析构函数</code>的函数名也是由语法规定的，为<code>~</code>+<code>类名</code>,并且<strong>不能</strong>声明形参</p><blockquote><p>以一个<code>指针类</code>为例</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Ptr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Ptr</span>()<span class="comment">//构造函数</span></span><br><span class="line">    &#123; </span><br><span class="line">        _ptr = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">1</span>); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Ptr</span>()<span class="comment">//析构函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> _ptr;<span class="comment">//手动delte堆区上的数据</span></span><br><span class="line">        _ptr = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span>* _ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类的重载操作符"><a href="#类的重载操作符" class="headerlink" title="类的重载操作符"></a>类的重载操作符</h2><p>C++语法提供了重载操作符的函数，而由于<code>this</code>指针的存在，在类的<code>内部声明</code>重载操作符函数会稍有不同</p><p>-对于一元操作符，<code>[]</code>,<code>-&gt;</code>之类的重载，不再需要<code>显式传参</code><br>-对于二元操作符，<code>+</code>,<code>&gt;</code>之类只需要传<code>右操作数</code></p><blockquote><p>以<code>Date</code>类为例</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在类的内部,重构一个 ==</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Date&amp; date) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> _year == date._year</span><br><span class="line">            &amp;&amp; _month == date._month</span><br><span class="line">            &amp;&amp; _day == date._day;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>至此，C++类和对象已基本入门，再进阶的<code>迭代器</code>,<code>继承</code>,<code>虚继承</code>等将单独出博客。</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ 类和对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>指针详解</title>
      <link href="/2023/11/23/pointer/"/>
      <url>/2023/11/23/pointer/</url>
      
        <content type="html"><![CDATA[<p><em>这篇质量不太行:（</em></p><h1 id="内存和地址"><a href="#内存和地址" class="headerlink" title="内存和地址"></a>内存和地址</h1><p>在了解指针之前，先讲讲内存是如何管理的</p><p>首先因为内存很大（一般有几个G）,所以为了高效管理，有了<code>内存单元</code>的概念。而这个单元的大小，正好是一个字节。</p><p>因为一个<code>比特位</code>就是一个二进制位，太小了，超过一个字节，在处理<code>char</code>这样一个字节长的变量很麻烦。</p><p>定下长度后，就可以给内存单元编号，而每个内存单元获得的独一无二的编号，便是它的<strong>地址</strong>,以声明了一个变量a为例,示意图如下</p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-23_09-59-30.png"></p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-23_10-21-48.png"></p><h2 id="变量的地址"><a href="#变量的地址" class="headerlink" title="变量的地址"></a>变量的地址</h2><p>上图中<code>a</code>占4个字节，每个字节都有自己的地址，但要找到<code>a</code>其实只需要找到第一个地址就行了，实际上在<code>C语言</code>中也是如此,<code>a</code>的地址就是<code>首字节地址</code>,即图中的<code>0x000000AF88DFF6A4</code></p><h2 id="关于几个名词"><a href="#关于几个名词" class="headerlink" title="关于几个名词"></a>关于几个名词</h2><p>在<code>C语言</code>中称<code>地址</code>为<code>指针</code>,<strong>储存</strong>地址的变量叫<code>指针变量</code>,平时也<strong>简称</strong><code>指针</code>,此时强调的是<code>指针变量</code>里储存的地址，而不是这个变量。</p><h2 id="指针变量的组成"><a href="#指针变量的组成" class="headerlink" title="指针变量的组成"></a>指针变量的组成</h2><p>指针变量也要<strong>拆成两部分</strong>来看</p><p>一个是变量的<code>值</code>,在同一个程序中，所有指针变量的值的<code>长度</code>都是一样的，都指向了某<strong>一</strong>个内存中的<code>字节</code>, 至于具体多长，取决于环境:<code>32位程序是4个字节</code>,<code>64位程序是8个字节</code></p><p>另一个是变量的<code>类型</code>,类型决定编译器从<code>值</code>所指向的字节，向后总共读<strong>几个</strong>字节，以及用<strong>什么方式</strong>读取内存里的内容。以下图的代码为例</p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-23_11-36-47.png"></p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-23_11-29-53.png"></p><p>可以看到三种指针指向了<strong>同一个</strong>字节，即它们的值是相等的，但<code>指针类型</code>不同，解引用之后得到的<code>值</code>也不同,</p><p><code>char</code>比<code>int</code>短，所以<code>*p_char</code>只能取到<code>00</code>,</p><p>而虽然<code>float</code>和<code>int</code>一样长，但对内存的<strong>读法不同</strong>，所以<code>*p_float</code>和<code>*p_int</code>依然不同</p><h1 id="指针-变量-的使用"><a href="#指针-变量-的使用" class="headerlink" title="指针(变量)的使用"></a>指针(变量)的使用</h1><h2 id="声明指针变量"><a href="#声明指针变量" class="headerlink" title="声明指针变量"></a>声明指针变量</h2><p>指针变量也是变量，在没有结合性问题时，和一般变量的声明方式差不多。</p><p>变量的声明:<code>变量类型</code> + <code>变量名</code></p><p>指针的声明:<code>指向的变量类型</code> + <code>*</code> + <code>变量名</code></p><p>以下以声明一个字符指针为例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* pointer = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-24_10-02-19.png"></p><p><em>变量的声明逻辑如上图</em></p><h3 id="进阶：二级指针-N级指针"><a href="#进阶：二级指针-N级指针" class="headerlink" title="进阶：二级指针-&gt;N级指针"></a>进阶：二级指针-&gt;N级指针</h3><p>我们可以用同样的逻辑声明更高级的指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* *ppstr = <span class="literal">NULL</span>;<span class="comment">//ppstr是一个二级指针</span></span><br><span class="line"><span class="type">char</span>** *ppstr = <span class="literal">NULL</span>;<span class="comment">//pppstr是一个三级指针</span></span><br></pre></td></tr></table></figure><p>在声明中,前面的<code>char*</code>声明了<code>ppstr</code><strong>指向</strong>的变量类型,后面的<code>*</code>与<code>变量名</code>结合，声明<code>ppstr</code>是一个指针.</p><p>此处，称指向<code>一级指针</code>的指针为<code>二级指针</code>,同理有<code>三级指针</code>,至<code>N级指针</code>.</p><h2 id="指针的解引用"><a href="#指针的解引用" class="headerlink" title="指针的解引用"></a>指针的解引用</h2><p>指针最常见的用处就是通过变量里<strong>储存的地址</strong>，通过直接修改目标变量的<strong>内存</strong>来修改变量的值 ， 当然还有强制转换指针类型来读取目标变量的<strong>一部分</strong>内存 之类的骚操作</p><h3 id="函数的传址调用"><a href="#函数的传址调用" class="headerlink" title="函数的传址调用"></a>函数的传址调用</h3><p>在遇到指针前，使用函数时，由于实参传到函数里都变成了<strong>形参</strong>,无法通过形参（<em>包括修改形参的值</em>）来改变实参的值，因为形参终究只是实参的一份<strong>临时拷贝</strong>.</p><p>而有了指针之后，函数的实参，形参关系不变，但我们有了<strong>更高端</strong>的形参,也就是<code>指针</code>, 尽管<code>函数内的指针</code>依旧是<code>函数外的指针</code>的<strong>临时拷贝</strong>,但我们已经能通过其储存的<strong>值</strong>访问<code>函数外变量</code>的内存了,同时包括<code>读取</code>和<code>修改</code>, 这种通过传入指针来修改外部变量的函数调用，便称为<code>函数的传址调用</code></p><p><em>以如下代码为例</em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Swap_int</span><span class="params">(<span class="type">int</span>*a,<span class="type">int</span>*b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//给我两个整型的地址，我就能 真·交换它们的值</span></span><br><span class="line">    <span class="type">int</span> tmp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="提问-如何修改函数外的指针的值"><a href="#提问-如何修改函数外的指针的值" class="headerlink" title="提问?如何修改函数外的指针的值?"></a>提问?如何修改函数外的指针的值?</h4><p>依然还是把这一<strong>指针的地址</strong>传进去，而函数的形参写成<strong>更高一级</strong>的指针</p><p><em>如下代码，例如我想在函数里把外部的指针置空</em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Reset</span><span class="params">(<span class="type">char</span>* *pstr)</span> </span><br><span class="line">&#123;</span><br><span class="line">    *pstr = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span>* str;</span><br><span class="line">    Reset(&amp;str)<span class="comment">//对一级指针取地址，传入二级指针</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="有关指针的危险操作"><a href="#有关指针的危险操作" class="headerlink" title="有关指针的危险操作"></a>有关指针的危险操作</h1><h2 id="野指针的解引用"><a href="#野指针的解引用" class="headerlink" title="野指针的解引用"></a>野指针的解引用</h2><p>有些指针因为错误操作，指向了不能访问的内存，一旦解引用，就有可能使程序崩溃</p><p><em>情形如下</em></p><h3 id="使用了-未初始化-赋值-的指针"><a href="#使用了-未初始化-赋值-的指针" class="headerlink" title="使用了 未初始化&#x2F;赋值 的指针"></a>使用了 未初始化&#x2F;赋值 的指针</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* pa;<span class="comment">//未初始化，pa的值为随机值</span></span><br><span class="line">*pa = <span class="number">0</span> ;<span class="comment">//野指针的解引用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//正确的用法</span></span><br><span class="line"><span class="type">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* pa;</span><br><span class="line">pa = arr;<span class="comment">//立即初始化</span></span><br><span class="line"><span class="type">int</span>* pb = <span class="literal">NULL</span>;<span class="comment">//初始化</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>所以声明指针时最好初始化,如果不知道初始化成什么，就用<code>NULL</code>空指针初始化</p><h3 id="指向了-已回收的-内存空间"><a href="#指向了-已回收的-内存空间" class="headerlink" title="指向了 已回收的 内存空间"></a>指向了 已回收的 内存空间</h3><p>有的函数<strong>错误</strong>*地返回了内部临时变量的地址， 在<strong>外面</strong>使用返回的指针，因为此时函数的栈帧已经<strong>销毁</strong>，会发生野指针的解引用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">fun</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span>* pa = &amp;a;</span><br><span class="line">    <span class="keyword">return</span> pa;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//情形一</span></span><br><span class="line">    <span class="type">char</span>* pa = fun();</span><br><span class="line">    *pa = <span class="number">1</span>;<span class="comment">//此时变量a已经销毁，发生野指针的解引用，即非法访问</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//情形二</span></span><br><span class="line">    <span class="type">char</span>* str = (<span class="type">char</span>*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>) *<span class="number">10</span>) <span class="comment">//在堆区开辟10个字节的空间</span></span><br><span class="line">    <span class="built_in">free</span>(str);<span class="comment">//然后释放掉</span></span><br><span class="line">    str[<span class="number">0</span>] = <span class="string">&#x27;A&#x27;</span>;<span class="comment">//试图访问已free的内存，并写入，发生非法访问</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="空指针的解引用"><a href="#空指针的解引用" class="headerlink" title="空指针的解引用"></a>空指针的解引用</h2><p>空指针<code>NULL</code>,<code>值</code>为<code>0</code>,一旦解引用就会报错，所以在解引用陌生指针时一定要注意判空</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//情形一</span></span><br><span class="line"><span class="type">char</span>* <span class="title function_">func</span><span class="params">(<span class="type">char</span>* str)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(str == <span class="literal">NULL</span>)<span class="comment">//防止使用者错误传入空指针</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//情形二</span></span><br><span class="line"><span class="type">char</span>* <span class="title function_">InitArray</span><span class="params">(<span class="type">char</span>** pstr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(pstr == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    *pstr = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>) * <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">if</span>(*ptr == <span class="literal">NULL</span>)<span class="comment">//malloc一旦失败就会返回NULL,所以调用后一定要判空</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>=C入门=深入研究 字符串与字符数组</title>
      <link href="/2023/11/08/str-arr/"/>
      <url>/2023/11/08/str-arr/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是字符串"><a href="#什么是字符串" class="headerlink" title="什么是字符串"></a>什么是字符串</h1><h2 id="初见字符串"><a href="#初见字符串" class="headerlink" title="初见字符串"></a>初见字符串</h2><p>我们最先遇到的字符串,一般是<code>hello_world</code>程序中用到的<code>&quot;hello world&quot;</code>,也就是<strong>两个双引号括起来的一串字符</strong>,输出时的占位符是<code>%s</code>,可以直接拿去传值，代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,<span class="string">&quot;hello world&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="声明字符串变量"><a href="#声明字符串变量" class="headerlink" title="声明字符串变量"></a>声明字符串变量</h2><p>有时我们想要先把字符串存起来，再进行操作，那么就使用<strong>字符数组</strong>，并在<strong>初始化</strong>的时候把字符串传给它,这样在<strong>创建数组</strong>时会编译器会自动分配内存给它，代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[] = <span class="string">&quot;abcdef&quot;</span>;</span><br></pre></td></tr></table></figure><p>此时我们也可以开启VS的<strong>调试</strong>，并打开<strong>内存</strong>和<strong>监视</strong>窗口观察字符串是如何在内存中储存的,如下图</p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-09_10-06-06.jpg"></p><p>通过观察可以发现，C语⾔字符串的字符串有个<code>规定</code>(特点)，就是以字符<code>\0</code>结尾，无论是初始化数组时，还是在分配内存时，都有<code>\0</code>的位置。</p><h3 id="strlen-函数"><a href="#strlen-函数" class="headerlink" title="strlen()函数"></a>strlen()函数</h3><p>依据以<code>\0</code>为字符串结尾的规则，<code>strlen</code>函数就可以计算字符串的长度，它会从字符串的第一个字符向后扫描，直到遇到<code>\0</code>结束,且<code>\0</code>不进入计数，最后返回字符串的长度,代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span> <span class="comment">//需要引对应的头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> len = <span class="built_in">strlen</span>(<span class="string">&quot;abcdef&quot;</span>);<span class="comment">//len的值为6</span></span><br><span class="line"><span class="type">int</span> sz = <span class="keyword">sizeof</span>(<span class="string">&quot;abcdef&quot;</span>);<span class="comment">//sz的大小为7(\0被计入总数)</span></span><br></pre></td></tr></table></figure><h3 id="验证字符串的结尾"><a href="#验证字符串的结尾" class="headerlink" title="验证字符串的结尾"></a>验证字符串的结尾</h3><h4 id="正向验证"><a href="#正向验证" class="headerlink" title="正向验证"></a>正向验证</h4><p>我们做在字符数组里插入一个<code>\0</code>,来看看函数<code>printf</code>和<code>strlen</code>找到的结尾在哪里,如下图</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[] = &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;\0&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;f&#x27;</span>,<span class="string">&#x27;\0&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-09_11-01-35.jpg"></p><p>可以看到字符数组似乎被“截断”了，<code>printf</code>只输出了<code>\0</code>前面的内容, <code>strlen</code>算出来的长度也只有<code>3</code>,可见插入的<code>\0</code>被作为了<strong>字符串</strong>的结尾，字符串提前中指,而没到达<strong>字符数组</strong>的结尾</p><h4 id="反向验证"><a href="#反向验证" class="headerlink" title="反向验证"></a>反向验证</h4><p>我们来<strong>反向</strong>验证一下，<code>\0</code>是字符串结尾的标志,如下图，我们声明一个<strong>没有</strong><code>\0</code>结尾的字符数组，看看函数<code>printf</code>和<code>strlen</code>还找不找得到我们“认为”的结尾</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[] = &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;f&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-09_14-02-07.jpg"></p><p>可以看到函数对字符串的判断出现了严重<strong>失误</strong>，所以<strong>字符数组</strong>里没有<code>\0</code>标记结尾是非常严重的问题，不光是找不到字符串的结尾，而且会<strong>越界访问</strong>！危险操作，写代码的时候一定要注意</p><hr><h2 id="从字符串到字符数组"><a href="#从字符串到字符数组" class="headerlink" title="从字符串到字符数组"></a>从字符串到字符数组</h2><p>虽然上面已经用到了字符数组，但主要还是为了方便讨论<strong>字符串</strong>,接下来着重研究字符数组。</p><h3 id="先整清楚几个概念"><a href="#先整清楚几个概念" class="headerlink" title="先整清楚几个概念"></a>先整清楚几个概念</h3><p><code>什么是数组</code>：数组是⼀组相同类型元素的集合,会在内存中开辟一段连续的空间，将元素储存在那段内存中</p><p><code>什么是数组元素</code>：存放在数组的值被称为数组的元素，数组在创建的时候可以指定数组的⼤⼩和数组的元素类型。</p><p>所以<code>字符数组</code>是一组<code>字符</code>的集合，字符数组里的<code>元素</code>都是<code>字符</code>!,访问到的字符数组里的<strong>元素</strong>都是<strong>字符</strong>，像<code>&#39;a&#39;</code>,<code>&#39;b&#39;</code>,<code>&#39;c&#39;</code>这种的单个的字符,别和<code>字符串</code>混为一谈！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="type">int</span> sz = <span class="keyword">sizeof</span>(str);<span class="comment">//这里str代表了整个数组,所以包括\0</span></span><br><span class="line">,sz的值为<span class="number">4</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="字符数组的声明"><a href="#字符数组的声明" class="headerlink" title="字符数组的声明"></a>字符数组的声明</h3><p>字符数组的声明和其他类型的数组差不多，有<strong>初始化</strong>，<strong>不完全初始化</strong>，<strong>声明长度</strong>，<strong>不声明长度</strong></p><p><em>正确的声明代码如下</em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str1[] = <span class="string">&quot;abc&quot;</span>;<span class="comment">//初始化,不声明长度</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> str2[] = &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;\0&#x27;</span>&#125;;<span class="comment">//这也是初始化，且不声明长度</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> str3[<span class="number">10</span>] = &#123; <span class="number">0</span> &#125;;<span class="comment">//初始化，用值0(等价于`\0`)填充</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> str4[<span class="number">10</span>] = <span class="string">&quot;abc&quot;</span>;<span class="comment">//不完全初始化，存入字符串&quot;abc&quot;,后面都用&#x27;\0&#x27;填充</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> str5[<span class="number">10</span>] = &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>&#125;;<span class="comment">//不完全初始化,从下标为0开始，依次往后填充字符 a,b,c,\0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><em>错误的声明代码</em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str1[<span class="number">3</span>] = <span class="string">&quot;abc&quot;</span>;<span class="comment">//数组声明短了，放不下结尾的\0,编译过不了</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> str2[<span class="number">3</span>] = &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>&#125;;<span class="comment">//同上,放不下</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> str3[] = &#123; <span class="number">0</span> &#125;;<span class="comment">//能声明，但是字符数组长度为1，这个数组大概率是用不了的/会被拿去错误使用的</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="来看看这些声明方式在内存中的表现"><a href="#来看看这些声明方式在内存中的表现" class="headerlink" title="来看看这些声明方式在内存中的表现"></a>来看看这些声明方式在内存中的表现</h3><h4 id="不初始化的声明-极度不推荐"><a href="#不初始化的声明-极度不推荐" class="headerlink" title="不初始化的声明(极度不推荐)"></a>不初始化的声明(极度不推荐)</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[];<span class="comment">//这个不加长度，直接编译失败（如下图）</span></span><br></pre></td></tr></table></figure><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-10_11-39-10.jpg"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">10</span>];<span class="comment">//语法没有问题，来看看此时数组里存了什么</span></span><br></pre></td></tr></table></figure><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-10_11-46-49.jpg"><br>可以看到全都存了<code>-52</code>,对应的中文字符是<code>烫</code>，这样<strong>不好</strong>，请在声明字符数组的时候<strong>初始化数组</strong></p><h4 id="不声明长度的数组声明"><a href="#不声明长度的数组声明" class="headerlink" title="不声明长度的数组声明"></a>不声明长度的数组声明</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str1[] = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> str2[] = &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;\0&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-09_14-59-34.jpg"></p><p>如上图，不声明长度时，编译器自动给字符数组分配内存，既不给多，也不给少，初始化给的<code>字符串</code>或者<code>&#123;...&#125;</code>多长，创建的数组就多长。</p><p><strong>注意红框</strong>，再强调一遍，字符串以<code>\0</code>结尾,看到双引号括起来的字符串，要记得最后隐藏了一个<code>\0</code>,用字符数组储存的时候一定要留足空间</p><h4 id="声明长度的数组声明"><a href="#声明长度的数组声明" class="headerlink" title="声明长度的数组声明"></a>声明长度的数组声明</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str3[<span class="number">10</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> str4[<span class="number">10</span>] = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> str5[<span class="number">10</span>] = &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-09_15-25-54.jpg"></p><p>可以看到，在声明的长度<strong>足够长</strong>时，你初始化的时候给它多少字符，它就从<code>下标0</code>处开始<strong>按顺序</strong>存进去多少,剩下的部分<strong>自动</strong>用<code>&#39;\0&#39;</code>填充,</p><p>所以实际上上面代码中的<code>str5</code>因为长度<code>10</code>&gt;初始化给的<code>4</code>个字符，后面六个元素用<code>\0</code>填充了，所以<code>str5</code>里存了有<strong>结尾</strong>的完整字符串</p><h4 id="错误声明"><a href="#错误声明" class="headerlink" title="错误声明"></a>错误声明</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str1[<span class="number">3</span>] = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="type">char</span> str2[<span class="number">3</span>] = &#123; <span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span> &#125;;</span><br></pre></td></tr></table></figure><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-10_07-44-57.jpg"></p><p>可以看到上面两种错误的声明方式，甚至直接<strong>编译失败</strong>,所以声明字符数组的时候一定要<strong>留足空间</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str3[] = &#123; <span class="number">0</span> &#125;;</span><br></pre></td></tr></table></figure><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-10_07-51-55.jpg"></p><p>如上图，可以看到这样写还是编译成功了，但是在监视查看<strong>数组长度</strong>的时候，发现长度为<code>1</code>,里面存了一个<code>\0</code>,这么<strong>短</strong>的数组能用吗？只能<strong>用一点点</strong>，甚至还不如直接声明一个<code>char</code>类型的字符变量</p><h2 id="当字符数组加上const"><a href="#当字符数组加上const" class="headerlink" title="当字符数组加上const"></a>当字符数组加上const</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> str[<span class="number">5</span>] = <span class="string">&quot;abc&quot;</span>;</span><br></pre></td></tr></table></figure><h3 id="一些性质"><a href="#一些性质" class="headerlink" title="一些性质"></a>一些性质</h3><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-10_18-55-52.jpg"></p><p>可以看到，声明时加了<code>const</code>之后，字符数组<code>str</code>在声明时的<strong>初始化</strong>之后便不可更改了，只能<strong>访问</strong>其元素,而<strong>不能通过访问元素来改变数组内容</strong></p><p>那么<code>scanf</code>还能写入内容吗？答案是<strong>可以</strong>!<em>(如下图)</em></p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-10_19-10-43.jpg"></p><p>那它能拿来初始化别的数组吗？很遗憾，<strong>不能</strong><br><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-10_19-05-15.jpg"></p><h3 id="对应的指针类型"><a href="#对应的指针类型" class="headerlink" title="对应的指针类型"></a>对应的指针类型</h3><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-10_19-15-32.jpg"></p><p>可以看到，这里得用<code>const char*</code>来储存字符数组的地址，而使用<code>char*</code>就会报错</p><p>那么用<code>双引号括起来的字符串</code>，是否也有地址，能用指针储存它的地址呢？</p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-10_19-21-10.jpg"></p><p>如图，可以看到,字符串<code>&quot;abc&quot;</code>是属于<code>const char</code>类型的数组，对应的指针是<code>const char*</code>,不能通过访问元素来改变内部的值，也不能用<code>char*</code>来储存地址</p><h4 id="在内存中的表现"><a href="#在内存中的表现" class="headerlink" title="在内存中的表现"></a>在内存中的表现</h4><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/const_str.gif"></p><p>可以看到哪怕是字符串<code>&quot;abc&quot;</code>,也是在内存中开辟了一段空间，并把字符<strong>储存在内存中</strong>了的</p><p>但是，<strong>不要</strong>试图用<code>scanf</code>去改变字符串的值<br><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/const_strrrr.gif"></p><hr><h2 id="如何向字符数组里添加内容"><a href="#如何向字符数组里添加内容" class="headerlink" title="如何向字符数组里添加内容"></a>如何向字符数组里添加内容</h2><p>添加的方法多种多样，搞不好可能还会出错，所以把字符数组<strong>学明白</strong>很重要！</p><p>以下使用的数组样例声明如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">10</span>] = &#123; <span class="number">0</span> &#125;;</span><br></pre></td></tr></table></figure><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>在初始化的时候就把值传进去，有哪些初始化方式<strong>上面</strong>已经介绍过了，这里不多赘述</p><h3 id="访问数组元素"><a href="#访问数组元素" class="headerlink" title="访问数组元素"></a>访问数组元素</h3><p>通过<code>[]</code>可以访问数组元素，并对没有<code>const</code>修饰的数组，修改其元素,例如:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str[<span class="number">0</span>] = <span class="string">&#x27;A&#x27;</span>;<span class="comment">//将数组的第一个元素改成字符A</span></span><br></pre></td></tr></table></figure><p>我们也可以通过循环的方式，将数组的所有元素填充为某个字符</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> place_holder = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span> ; i++)<span class="comment">//这里使用左闭右开区间，10为数组的大小</span></span><br><span class="line">&#123;</span><br><span class="line">    str[i] = place_holder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用scanf函数"><a href="#使用scanf函数" class="headerlink" title="使用scanf函数"></a>使用<code>scanf</code>函数</h3><p>由上面的探究已知：对于已声明的字符数组，<strong>无论</strong>有没有<code>const</code>修饰，都可已用<code>scanf</code>修改内容,那么<code>scanf</code>怎么用，又具体怎么工作的，我们接着往下探究</p><h4 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">10</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str);<span class="comment">//占位符是 %s ,右边的参数是 str ,也就是数组名</span></span><br><span class="line"><span class="comment">//或者 scanf(&quot;%s&quot;,&amp;str)</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>！这边的数组名<code>str</code>储存的是<strong>数组首元素的地址</strong>，而<code>&amp;str</code>储存的是<code>整个数组的地址</code>，值是一样的，两者皆可用于传参，但<strong>指针类型不一样</strong>，要做好区分</p><h4 id="scanf都做了什么"><a href="#scanf都做了什么" class="headerlink" title="scanf都做了什么"></a><code>scanf</code>都做了什么</h4><p>先来看看它分别对用<code>&#123; 0 &#125;</code><strong>初始化</strong>和<strong>不初始化</strong>的数组做了什么</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str1[<span class="number">10</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str1);</span><br><span class="line"><span class="type">char</span> str2[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str2);</span><br></pre></td></tr></table></figure><p><em>两个数组的输入均为abc</em><br><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-11_19-09-50.jpg"></p><p>可以看到，对<code>str1</code>,字符非常正常地填充进去了，因为整个数组原本是用<code>\0</code>填充的,看不出什么端倪</p><p>而对于<code>str2</code>,观察发现，除了输入进去的字符<code>a</code>,<code>b</code>,<code>c</code>,它还自动在结尾补了一个<code>\0</code>,使<code>str2</code>里储存了一个完整的字符串。<strong>但是</strong>，剩下的部分还是用<strong>值</strong><code>-52</code>填充，即未初始化的状态，所以依然<strong>不提倡</strong>声明的时候没有初始化</p><p>然后是在字符数组内已有内容的情况下，再次使用<code>scanf</code>的情况</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str1[<span class="number">5</span>] = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="type">char</span> str2[<span class="number">5</span>] = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s %s&quot;</span>,str1,str2);</span><br></pre></td></tr></table></figure><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-12_09-33-02.jpg"></p><p>如图，<code>scanf</code>做的是把输入的字符串<code>覆盖</code>式存入字符数组，比原来长，就完全覆盖，比原来短，就部分覆盖，未覆盖的部分无改动</p><h4 id="关于scanf的危险操作"><a href="#关于scanf的危险操作" class="headerlink" title="关于scanf的危险操作"></a>关于<code>scanf</code>的危险操作</h4><p>由于<code>scanf</code>无法预测<strong>字符数组</strong>能否存下输入的<strong>字符串</strong>，如果<strong>字符数组</strong>声明的长度不够，就可能出现<strong>越界访问</strong>,随之而来的便是奇奇怪怪的<code>bug</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">4</span>] = &#123; <span class="number">0</span> &#125;;<span class="comment">//先声明一个长度为4的数组</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str);<span class="comment">//这次输入abcdef试试</span></span><br></pre></td></tr></table></figure><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-12_09-47-00.jpg"></p><p>可以看到，确实<strong>越界访问</strong>了，所以声明字符数组的时候，建议比预计最大输入，在多些长度，防止越界访问。</p>]]></content>
      
      
      
        <tags>
            
            <tag> C语言 字符串 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>=C语言实践= 手把手教你做高端cmd简单扫雷</title>
      <link href="/2023/10/30/mine-clearance/"/>
      <url>/2023/10/30/mine-clearance/</url>
      
        <content type="html"><![CDATA[<h1 id="直接开始吧！"><a href="#直接开始吧！" class="headerlink" title="直接开始吧！"></a>直接开始吧！</h1><h2 id="多文件项目"><a href="#多文件项目" class="headerlink" title="多文件项目"></a>多文件项目</h2><p>扫雷项目内容较多，需要调用的<strong>函数</strong>也较多，采用多文件的方式，可以使代码<strong>条理清晰</strong>，并且<strong>易于管理和维护</strong>。文件如下</p><p><code>game.h</code>用于宏定义，函数声明，引入头文件等</p><p><code>game.c</code>用于<strong>函数的具体实现</strong></p><p><code>front.c</code>用于实现程序的<strong>主干部分</strong></p><p><code>other.c</code>用于实现其他杂项函数，这里我用于实现<code>menu()</code>函数，<del>主要内容太花了</del></p><p><strong>注</strong>  <code>.c</code>结尾的源文件均需加一句<code>#include &quot;game.h&quot;</code></p><h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><p>本次用到的头文件有<code>stdio.h</code> <code>stdlib.h</code> <code>time.h</code> <code>windows.h</code><br>和自己建的<code>game.h</code></p><p><strong>均在</strong>文件<code>game.h</code>中<code>#include</code></p><h2 id="define宏定义"><a href="#define宏定义" class="headerlink" title="define宏定义"></a>define宏定义</h2><p>为了便于<strong>阅读和维护</strong>代码,在<code>game.h</code>中的宏定义如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//显示行列</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ROW 9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COL 9</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//实际数组大小</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ROWS ROW+2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COLS COL + 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//地雷信息</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Bomb <span class="string">&#x27;*&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Blank <span class="string">&#x27; &#x27;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//难度</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EZ_RANK 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HD_RANK 15</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//显示区</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UN <span class="string">&#x27;&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Flag <span class="string">&#x27;!&#x27;</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="为什么实际数组要大一圈？"><a href="#为什么实际数组要大一圈？" class="headerlink" title="为什么实际数组要大一圈？"></a>为什么实际数组要大一圈？</h3><p>如图，采用九宫格式访问时，大出来的一圈能有效<strong>防止越界访问</strong></p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-02_11-23-51.jpg"></p><h2 id="构建main函数"><a href="#构建main函数" class="headerlink" title="构建main函数"></a>构建main函数</h2><p>内容不多，主要是与菜单配合食用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//用time()获取时间戳，传给srand设置(随机值生成器的)种子</span></span><br><span class="line">srand((<span class="type">unsigned</span> <span class="type">int</span>)time(<span class="literal">NULL</span>));</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)<span class="comment">//循环游玩</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> input = <span class="number">0</span>;</span><br><span class="line">Menu();<span class="comment">//打印菜单</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入:&gt;&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;input);<span class="comment">//获取指令</span></span><br><span class="line"><span class="keyword">switch</span> (input)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">Sleep(<span class="number">250</span>);</span><br><span class="line">game();<span class="comment">//开始游戏,游戏具体在game()函数中实现</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;游戏结束\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//结束程序</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;输入错误,请重试\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="打印菜单"><a href="#打印菜单" class="headerlink" title="打印菜单"></a>打印菜单</h2><p>还在做静态菜单?<del>弱爆了！</del>来试试<strong>动态出现</strong>的菜单！</p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/menu.gif"></p><p>原理很<strong>简单</strong>，就是<code>打印空白数组</code>-&gt;<code>向内逐个替换两侧元素</code>-&gt;<code>清屏</code>-&gt;<code>再打印</code>-&gt;<code>再替换</code>-&gt;<code>...</code></p><p><em>接下来的代码写在<code>other.c</code>中</em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//动态打印菜单</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Menu</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> cover[]  =  <span class="string">&quot;=======================&quot;</span>;</span><br><span class="line"><span class="type">char</span> option1[] = <span class="string">&quot;======  play (1) ======&quot;</span>;</span><br><span class="line"><span class="type">char</span> option2[] = <span class="string">&quot;======  exit (2) ======&quot;</span>; </span><br><span class="line"><span class="type">char</span> empty_c[] = <span class="string">&quot;                       &quot;</span>;</span><br><span class="line"><span class="type">char</span> empty_1[] = <span class="string">&quot;                       &quot;</span>;</span><br><span class="line"><span class="type">char</span> empty_2[] = <span class="string">&quot;                       &quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> right = <span class="number">22</span>;</span><br><span class="line"><span class="keyword">while</span> (left &lt; right)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">//内容替换</span></span><br><span class="line">empty_c[left] = cover[left];</span><br><span class="line">empty_c[right] = cover[right];</span><br><span class="line">empty_1[left] = option1[left];</span><br><span class="line">empty_1[right] = option1[right];</span><br><span class="line">empty_2[left] = option2[left];</span><br><span class="line">empty_2[right] = option2[right];</span><br><span class="line"></span><br><span class="line">Sleep(<span class="number">50</span>);</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);<span class="comment">//清屏</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n%s\n%s\n%s\n&quot;</span>,empty_c,empty_1,empty_2,empty_c);<span class="comment">//打印菜单</span></span><br><span class="line"></span><br><span class="line">left++;</span><br><span class="line">right--;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (left == right)<span class="comment">//打印最终菜单</span></span><br><span class="line">&#123;</span><br><span class="line">Sleep(<span class="number">50</span>);</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">empty_c[left] = cover[left];</span><br><span class="line">empty_1[left] = option1[left];</span><br><span class="line">empty_2[left] = option2[left];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n%s\n%s\n%s\n&quot;</span>, empty_c, empty_1, empty_2, empty_c);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现game-函数"><a href="#实现game-函数" class="headerlink" title="实现game()函数"></a>实现game()函数</h2><p><em>游戏的主要逻辑在game()中实现</em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">game</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> mine[ROWS][COLS] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="type">char</span> show[ROWS][COLS] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="type">char</span> check[ROWS][COLS] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化棋盘，其实就是用第二个形参填充二维数组</span></span><br><span class="line">InitBoard(mine, Blank);</span><br><span class="line">InitBoard(show, UN);</span><br><span class="line"></span><br><span class="line">InitCheck(check);<span class="comment">//初始化check数组，逻辑与上面的初始化不同</span></span><br><span class="line"></span><br><span class="line">SetMine(mine,EZ_RANK);<span class="comment">//设置地雷</span></span><br><span class="line">SetNum(mine);<span class="comment">//设置雷周围的数字</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//DisplayBoard(mine); //用于开发时检查棋盘布局</span></span><br><span class="line"><span class="comment">//DisplayBoard(show); //同上，不使用时注释掉</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//以上是前期准备</span></span><br><span class="line">OPMine(mine,show, check);<span class="comment">//开始排雷</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;敲击enter以继续\n&quot;</span>);</span><br><span class="line">getchar();</span><br><span class="line">getchar();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="为什么用三个二维数组？"><a href="#为什么用三个二维数组？" class="headerlink" title="为什么用三个二维数组？"></a>为什么用三个二维数组？</h3><p>扫雷需要实现的功能较多，显然一个二维数组是不足以满足需求的，所以这里采用<strong>三个</strong>数组相叠加的方式，各自实现功能，并整合到一起。</p><p>数组<code>mine</code>用于存放<code>雷</code>和雷周围的<code>计数数字</code></p><p>数组<code>show</code>用于储存给<code>用户</code>看到的内容，可以是<code>Unkown</code>,<code>空白</code>，<code>数字</code>，<code>旗帜</code></p><p>数组<code>check</code>用于记录棋盘的哪些地块被检查过了，防止后面用<strong>递归</strong>打开成片的空白区时，出现无限递归。</p><p><strong>规定</strong>：检查过的坐标储存<code>字符1</code>,没检查过的坐标储存<code>字符0</code>,大出来的<strong>一圈</strong>默认储存<code>字符1</code></p><h2 id="实现游戏用的函数"><a href="#实现游戏用的函数" class="headerlink" title="实现游戏用的函数"></a>实现游戏用的函数</h2><h3 id="先看看有哪些要声明在game-h里的"><a href="#先看看有哪些要声明在game-h里的" class="headerlink" title="先看看有哪些要声明在game.h里的"></a>先看看有哪些要声明在<code>game.h</code>里的</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Menu</span><span class="params">()</span>;<span class="comment">//这个在上文实现过了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//一下函数将在下文实现</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化棋盘</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitBoard</span><span class="params">(<span class="type">char</span> board[ROWS][COLS], <span class="type">char</span> sign)</span>;</span><br><span class="line"><span class="comment">//展示棋盘</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DisplayBoard</span><span class="params">(<span class="type">char</span> board[ROWS][COLS])</span>;</span><br><span class="line"><span class="comment">//初始化check棋盘</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitCheck</span><span class="params">(<span class="type">char</span> check[ROWS][COLS])</span>;</span><br><span class="line"><span class="comment">//设置地雷/数字</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SetMine</span><span class="params">(<span class="type">char</span> board[ROWS][COLS],<span class="type">int</span> rank)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">SetNum</span><span class="params">(<span class="type">char</span> board[ROWS][COLS])</span>;</span><br><span class="line"><span class="comment">//玩家排雷用的函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OPMine</span><span class="params">(<span class="type">char</span> mine[ROWS][COLS],<span class="type">char</span> show[ROWS][COLS],<span class="type">char</span> check[ROWS][COLS])</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><em>好，有了目标，接下来就去一个一个实现</em></p><p><strong>注</strong>：以下代码均写在<code>game.c</code>文件里</p><h3 id="InitBoard"><a href="#InitBoard" class="headerlink" title="InitBoard()"></a>InitBoard()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InitBoard</span><span class="params">(<span class="type">char</span> board[ROWS][COLS],<span class="type">char</span> sign)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ROWS; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; COLS; j++)</span><br><span class="line">&#123;</span><br><span class="line">board[i][j] = sign;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里初始化的方式比较简单粗暴，就是用形参<code>sign</code>填充整个二维数组</p><h3 id="DisplayBoard-函数"><a href="#DisplayBoard-函数" class="headerlink" title="DisplayBoard()函数"></a>DisplayBoard()函数</h3><p>这里采用的展示方式是带横纵坐标的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">DisplayBoard</span><span class="params">(<span class="type">char</span> board[ROWS][COLS])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//打印一排列坐标</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt;= COL; k++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="comment">//打印一排横分割线</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt;= COL; k++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;--&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= ROW; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d|&quot;</span>, i);<span class="comment">//这句话打印横排坐标和竖分割线</span></span><br><span class="line"><span class="comment">//打印一排棋盘内容</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= COL; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, board[i][j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="InitCheck-函数"><a href="#InitCheck-函数" class="headerlink" title="InitCheck()函数"></a>InitCheck()函数</h3><p>这里复用了<code>InitBoard()</code>函数，是在其基础上增加了内容</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InitCheck</span><span class="params">(<span class="type">char</span> check[ROWS][COLS])</span></span><br><span class="line">&#123;</span><br><span class="line">InitBoard(check, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将边缘大出来的一圈改为&#x27;1&#x27;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; COLS; k++)</span><br><span class="line">&#123;</span><br><span class="line">check[<span class="number">0</span>][k] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">check[ROWS - <span class="number">1</span>][k] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; ROWS <span class="number">-1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">check[i][<span class="number">0</span>] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">check[i][COLS - <span class="number">1</span>] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="SetMine-函数"><a href="#SetMine-函数" class="headerlink" title="SetMine()函数"></a>SetMine()函数</h3><p>这里要使用<code>rand()</code>函数搭配<code>%</code>运算，来随机生成雷的坐标</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SetMine</span><span class="params">(<span class="type">char</span> board[ROWS][COLS],<span class="type">int</span> rank)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> y = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> count = <span class="number">0</span>;count &lt; rank;)</span><br><span class="line">&#123;</span><br><span class="line">x = rand() % ROW + <span class="number">1</span>;<span class="comment">//x的范围是1~ROW</span></span><br><span class="line">y = rand() % COL + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (board[x][y] == Blank)</span><br><span class="line">&#123;</span><br><span class="line">count++;</span><br><span class="line">board[x][y] = Bomb;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="SetNum-函数"><a href="#SetNum-函数" class="headerlink" title="SetNum()函数"></a>SetNum()函数</h3><p>这里遍历一遍数组并采用<code>九宫格式</code>计数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该函数用于九宫格式计数，并在下个函数中被调用</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">CountMine</span><span class="params">(<span class="type">char</span> board[ROWS][COLS], <span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = x - <span class="number">1</span>; i &lt;= x + <span class="number">1</span>; i++)<span class="comment">//上中下三行</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = y - <span class="number">1</span>; j &lt;= y + <span class="number">1</span>; j++)<span class="comment">//左中右三列</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i != x || j != y)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (board[i][j] == Bomb)</span><br><span class="line">&#123;</span><br><span class="line">sum++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SetNum</span><span class="params">(<span class="type">char</span> board[ROWS][COLS])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//遍历二维数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= ROW; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= COLS; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (board[i][j] == Blank)<span class="comment">//仅操作非雷的格子</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (CountMine(board, i, j))</span><br><span class="line">&#123;</span><br><span class="line">board[i][j] = <span class="string">&#x27;0&#x27;</span> + CountMine(board, i, j);<span class="comment">//将返回的数字转化成字符</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="OPMine-函数–核心函数"><a href="#OPMine-函数–核心函数" class="headerlink" title="OPMine()函数–核心函数"></a>OPMine()函数–核心函数</h3><p>该函数为游戏的<code>核心函数</code>，有内置菜单，且多次调用其它函数，其中<code>函数</code>的具体实现见<code>四级标题</code>处</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">OPMine</span><span class="params">(<span class="type">char</span> mine[ROWS][COLS],<span class="type">char</span> show[ROWS][COLS],<span class="type">char</span> check[ROWS][COLS])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> x = <span class="number">0</span>;<span class="comment">//横纵坐标</span></span><br><span class="line"><span class="type">int</span> y = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> flag = <span class="number">1</span>;<span class="comment">//用于菜单选项</span></span><br><span class="line"><span class="type">int</span> cont = <span class="number">1</span>;<span class="comment">//cont为0时游戏结束</span></span><br><span class="line"><span class="keyword">while</span> (cont)</span><br><span class="line">&#123;</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">DisplayBoard(show);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;排雷(1)\n插旗/拔旗(2)\n请输入:&gt;&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;flag);</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (flag)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//排雷</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;坐标格式,例&gt;2(空格)2\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入坐标:&gt;&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line"><span class="keyword">if</span> (show[x][y] == Flag)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;此处为旗帜，不可排雷\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (show[x][y] != UN)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;不可重复排查\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体排雷操作</span></span><br><span class="line">cont = FindMine(mine,show,check, x, y);</span><br><span class="line"><span class="keyword">if</span> (cont)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//检查是否赢得游戏</span></span><br><span class="line">cont = CheckWin(mine,show);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//插旗</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;坐标格式,例&gt;2(空格)2\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入坐标:&gt;&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">SetFlag(show, x, y);<span class="comment">//插旗函数</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">&#123;</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n输入错误(恼\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="SetFlag-函数"><a href="#SetFlag-函数" class="headerlink" title="SetFlag()函数"></a>SetFlag()函数</h4><p>先捏软柿子，插旗函数比较简单</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SetFlag</span><span class="params">(<span class="type">char</span> show[ROWS][COLS], <span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (show[x][y] == UN)<span class="comment">//插旗</span></span><br><span class="line">&#123;</span><br><span class="line">show[x][y] = Flag;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (show[x][y] == Flag)<span class="comment">//拔旗</span></span><br><span class="line">&#123;</span><br><span class="line">show[x][y] = UN;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;报错\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="ExpandBlank-函数"><a href="#ExpandBlank-函数" class="headerlink" title="ExpandBlank()函数"></a>ExpandBlank()函数</h4><p>这个函数用于打开成片的<code>空白区</code>,因为要从连着的空白连续开下去，所以要用到<code>函数递归</code>,此时<code>二维数组check</code>用于防止死递归</p><p><strong>注</strong>：这个函数一定要写在下一个函数(FindMine)前</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ExpandBlank</span><span class="params">(<span class="type">char</span> mine[ROWS][COLS], <span class="type">char</span> show[ROWS][COLS], <span class="type">char</span> check[ROWS][COLS],<span class="type">int</span> x,<span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">show[x][y] = mine[x][y];<span class="comment">//将用户看到的格子改成mine中的格子,包括空白和数字格子</span></span><br><span class="line">check[x][y] = <span class="string">&#x27;1&#x27;</span>;<span class="comment">//探测过的格子放`1`</span></span><br><span class="line"><span class="keyword">if</span> (mine[x][y] == Blank)<span class="comment">//仅空白格子会触发递归，数字格子不会</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//九宫格式探测</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = x - <span class="number">1</span>; i &lt;= x + <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = y - <span class="number">1</span>; j &lt;= y + <span class="number">1</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (check[i][j] == <span class="string">&#x27;0&#x27;</span> &amp;&amp; mine[i][j] != Bomb &amp;&amp; show[i][j] != Flag)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//含雷的格子不会执行ExpandBlank函数，就不会把雷放出来给用户看，但数字格子会</span></span><br><span class="line">ExpandBlank(mine, show, check, i, j);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="FindMine-函数"><a href="#FindMine-函数" class="headerlink" title="FindMine()函数"></a>FindMine()函数</h4><p>排雷用的函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">FindMine</span><span class="params">(<span class="type">char</span> mine[ROWS][COLS], <span class="type">char</span> show[ROW][COLS],<span class="type">char</span> check[ROWS][COLS], <span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (mine[x][y] == Bomb)</span><br><span class="line">&#123;</span><br><span class="line">DisplayBoard(mine);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;炸死，游戏结束:)\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//返回0来结束游戏</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (mine[x][y] != Blank)</span><br><span class="line">&#123;</span><br><span class="line">show[x][y] = mine[x][y];</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//返回1来继续游戏</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//这里有对上一个函数的调用</span></span><br><span class="line">ExpandBlank(mine, show, check,x,y);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="CheckWin-函数"><a href="#CheckWin-函数" class="headerlink" title="CheckWin()函数"></a>CheckWin()函数</h4><p>用于检查玩家是否完全排雷，赢得游戏</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">CheckWin</span><span class="params">(<span class="type">char</span> mine[ROWS][COLS], <span class="type">char</span> show[ROWS][COLS])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;<span class="comment">//统计没排雷的格子数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= ROW; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= COL; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (show[i][j] == UN || show[i][j] == Flag)</span><br><span class="line">&#123;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (count == EZ_RANK)<span class="comment">//统计数==雷数</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;恭喜排雷成功!\n&quot;</span>);</span><br><span class="line">DisplayBoard(mine);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//返回0，停止游戏</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>至此游戏所需的代码全部完成，已经可以编译出来玩耍啦。</p><p>该实践项目主要练习了<code>二维数组</code>,<code>函数</code>,<code>函数递归</code>,<code>宏定义</code>等内容，代码量在入门学习中算较大的，本人在初次编写的时候也写出了不少bug，debug的过程是相当<del>快乐</del></p><p>建议多多画示意图，<strong>耐下性子</strong>写代码和debug,哪怕是实现这样的小游戏项目，也是颇有意义的</p>]]></content>
      
      
      
        <tags>
            
            <tag> C语言 实践项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>玩转N组输入和多组输入</title>
      <link href="/2023/10/18/mutiInput/"/>
      <url>/2023/10/18/mutiInput/</url>
      
        <content type="html"><![CDATA[<h1 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h1><p>当我们在写IO型OJ时，<code>多组输入</code>便是我们绕过不开的话题了，但<strong>不用担心</strong>，可能初见多组输入会觉得难以理解，但用多了之后就会发现，<code>多组输入</code> 花样并不多，混熟了就<strong>很简单了</strong></p><h2 id="先看看一组输入输出如何完成的"><a href="#先看看一组输入输出如何完成的" class="headerlink" title="先看看一组输入输出如何完成的"></a>先看看一组输入输出如何完成的</h2><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-10-19_17-06-13.jpg"></p><p><em>如图</em>：一组输入时，用<code>scanf</code>获取一组输入，并在主体部分完成数据的处理，产生结果，最后用<code>printf</code>输出产生的一组结果。</p><p><em>以下用实现加法的程序做演示</em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a,b;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;a,&amp;b);<span class="comment">//获取一组输入</span></span><br><span class="line">    <span class="type">int</span> sum = a + b;<span class="comment">//产生结果</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,sum);<span class="comment">//输出结果</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="然后升级到N组输入"><a href="#然后升级到N组输入" class="headerlink" title="然后升级到N组输入"></a>然后升级到N组输入</h1><p>有的OJ题在一个测试文件中会先输入一个<code>n</code>,告诉你接下来有<code>n</code>组输入，你就要产生<code>n</code>组输出,也就是说要将<code>一组输入输出</code><strong>重复性地</strong>完成<code>n次</code>。难道我们要把代码重复<code>n次</code>吗？显然不现实。</p><p>所以是时候使用<strong>循环</strong>了，具体用法如下</p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-10-20_07-34-35.jpg"></p><p>如图，先用一个<code>scanf</code>获取循环次数<code>n</code>,然后创建一个循环，将<code>一组输入输出</code>放入循环体，一次一次循环处理即可</p><h2 id="变量的重置"><a href="#变量的重置" class="headerlink" title="变量的重置"></a>变量的重置</h2><p>为防止前后两次循环产生干扰，有两种处理<code>变量</code>的方式</p><p>1.(推荐)除了输入的变量，<strong>其它所有变量</strong>在循环体内声明，这些变量会在一次循环后<em>销毁</em>，下一次循环开始时<strong>自动</strong><em>重新声明</em>，从而完成<strong>变量的自动重置</strong></p><p><em>以下面这个一次求和3个数的程序为例</em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);<span class="comment">//获取循环次数n</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;n;i++)<span class="comment">//创建循环</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//以下完成一组输入输出</span></span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;<span class="comment">//声明一个局部变量，下次循环时会自动重声明</span></span><br><span class="line">        <span class="type">int</span> num = <span class="number">0</span>;<span class="comment">//储存输入的数字</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j =<span class="number">0</span>;j&lt;<span class="number">3</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;num);</span><br><span class="line">            sum+=num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,sum);<span class="comment">//完成输出</span></span><br><span class="line">        <span class="comment">//本次循环走完后变量sum被销毁，然后进入下一次循环,完成重置</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2.在循环外部声明变量，然后在<strong>循环末尾</strong>手动重置变量</p><p><em>以下面这个一次求和3个数的程序为例</em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;<span class="comment">//声明在循环外部</span></span><br><span class="line">    <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);<span class="comment">//获取循环次数n</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;n;i++)<span class="comment">//创建循环</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//以下完成一组输入输出</span></span><br><span class="line">        <span class="type">int</span> num = <span class="number">0</span>;<span class="comment">//储存输入的数字</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j =<span class="number">0</span>;j&lt;<span class="number">3</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;num);</span><br><span class="line">            sum+=num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,sum);<span class="comment">//完成输出</span></span><br><span class="line">        sum = <span class="number">0</span>;<span class="comment">//重置sum</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="要不要用数组储存输入，或储存结果再一次性输出？"><a href="#要不要用数组储存输入，或储存结果再一次性输出？" class="headerlink" title="要不要用数组储存输入，或储存结果再一次性输出？"></a>要不要用数组储存输入，或储存结果再一次性输出？</h2><p>答案是：<strong>可以，但没必要</strong>。</p><p>只需要像上图那么写即可，因为输入是一次性喂进去的 。存数组再输出，和每产生一个结果就输出一次，最终呈现出来是一样的（如下图）</p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/%E5%A4%9A%E7%BB%84%E8%BE%93%E5%87%BA.gif"></p><h1 id="现在，勇士，来挑战多组输入吧"><a href="#现在，勇士，来挑战多组输入吧" class="headerlink" title="现在，勇士，来挑战多组输入吧"></a>现在，勇士，来挑战多组输入吧</h1><h2 id="scanf的返回值"><a href="#scanf的返回值" class="headerlink" title="scanf的返回值"></a>scanf的返回值</h2><p>多组输入时，究竟会输入多少组数据，也不告诉你了，<strong>但是</strong>，此时<code>scanf</code>的返回值就派上用场了。和我们在终端手打输入不同,OJ的输入是喂一个文件进去，所以当<strong>输入结束时</strong>，<code>scanf</code>的返回值是<code>EOF</code><em>(意为文件结尾end of file)</em>,而当成功输入数据时，则会返回输入数据的个数(文档截图如下)</p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-10-20_20-46-54.jpg"></p><h2 id="结合循环"><a href="#结合循环" class="headerlink" title="结合循环"></a>结合循环</h2><p>那么就把<code>scanf</code>放入<code>while</code>循环吧,每次试图获取下一组输入时，检测是否返回值为<code>EOF</code>,若是，则跳出循环，结束程序；若否，则继续循环</p><p><em>以下面这个一次求和3个数的程序为例</em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;<span class="comment">//先声明至少一个待输入的变量</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n) != EOF)<span class="comment">//创建循环，每次循环开始时scanf一次，并检测是否返回EOF</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//开始构建循坏体</span></span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        sum+=n;</span><br><span class="line">        <span class="comment">//完成剩下的两次输入</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>; i &lt; <span class="number">3</span> - <span class="number">1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">            sum+=n</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,sum);<span class="comment">//完成一次输出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//scanf返回EOF后跳出循环</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="基本架构"><a href="#基本架构" class="headerlink" title="基本架构"></a>基本架构</h2><p>以后再要写<code>多组输入</code>，基本就像上面那个程序一样</p><p>1.先声明至少一个待输入的变量</p><p>2.创建循环，每次循环开始时scanf一次，并检测是否返回EOF</p><p>3.开始构建循坏体(包括完成剩下的输入,完成一组输出)<strong>别忘了回车！！！</strong></p><p>4.直至scanf返回EOF后跳出循环</p><h1 id="想模拟一下多组输入看看？"><a href="#想模拟一下多组输入看看？" class="headerlink" title="想模拟一下多组输入看看？"></a>想模拟一下多组输入看看？</h1><p>像下图一样每组数据间加个<code>空格</code>就行，什么？题目的样例输入有<code>回车</code>？不用管它，放心大胆地<code>换成空格</code>就行。自己<code>测试</code>程序，只需要<strong>输出</strong>一样就行，至于怎么输入，<strong>没必要</strong>和题目一模一样</p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/mutiInpuut.gif"></p><h1 id="注意！！！不要试图在终端停止程序"><a href="#注意！！！不要试图在终端停止程序" class="headerlink" title="注意！！！不要试图在终端停止程序"></a>注意！！！不要试图在终端停止程序</h1><p>因为和OJ不同，在本地运行程序时，不是文件输入，而是终端输入,没法让<code>scanf</code>返回<code>EOF</code>,<del>炫迈，根本停不来</del></p><p>你要是想立即<code>中断</code>程序，那就按<code>ctrl+c</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> C语言 多组输入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>=C语言= 整型变量与过大的整数</title>
      <link href="/2023/10/14/BiiigInt/"/>
      <url>/2023/10/14/BiiigInt/</url>
      
        <content type="html"><![CDATA[<h2 id="整型家族"><a href="#整型家族" class="headerlink" title="整型家族"></a>整型家族</h2><p>在使用C语言写程序时，会储存各种长度的整型,而在整型家族中，长度的比较如下</p><p><code>char &lt; short &lt;= int &lt;= long &lt;long long </code></p><h2 id="整型是如何储存在内存中的"><a href="#整型是如何储存在内存中的" class="headerlink" title="整型是如何储存在内存中的"></a>整型是如何储存在内存中的</h2><p><em>以<code>char</code>为例</em><br><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-10-14_15-33-30.jpg" alt="char"></p><p><code>char</code>的长度为1个<code>字节</code>，8个<code>比特位</code>,其中<strong>最高位</strong>是<strong>符号位</strong>,<code>0</code>表示正数，<code>1</code>表示负数，剩下的位数用于储存变量的<strong>绝对值</strong></p><hr><p>而当使用无符号整型(带前缀<code>unsigned</code>)时，只需把符号位也用于存值即可</p><h2 id="能够储存的最大正整数"><a href="#能够储存的最大正整数" class="headerlink" title="能够储存的最大正整数"></a>能够储存的最大正整数</h2><p><code>int</code>长度为4<code>字节</code>,能够储存的最大值为<code>2的31次方-1</code>,即<strong>2,147,483,647</strong></p><p><code>unsigned int</code>能够储存的最大值为<strong>4294967295</strong></p><p><code>unsigned long long</code>长度为8<code>字节</code>,能够储存的最大值为<code>2的64次方-1</code>,即<strong>18,446,744,073,709,551,615</strong></p><hr><h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><p>虽然<code>unsigned long long</code>已经很大了，但当遇到<code>指数</code>,<code>阶乘</code>之类的运算时仍然可能<strong>存不下!</strong>(光<code>21!</code>就比<code>unsigned long long</code>长了)</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>过大的整数，可能出现在<strong>程序的过程</strong>中，也可能出现在<strong>输出</strong>中，对于过程，可以尝试<strong>改变实现思路</strong>，让过程中不出现过大的整数；对于输出，可以尝试<strong>改变输出的类型</strong>，采用输出<strong>字符或字符串</strong></p><h1 id="以下皆为例题"><a href="#以下皆为例题" class="headerlink" title="以下皆为例题"></a>以下皆为例题</h1><h2 id="1-求n-的结尾有多少个0"><a href="#1-求n-的结尾有多少个0" class="headerlink" title="1.求n!的结尾有多少个0"></a>1.求n!的结尾有多少个0</h2><p>最直白的思路就是把<code>n!</code>算出来，然后用<code>%10</code>再<code>/=10</code>的方法统计末尾的<code>0</code>,想法很简单，“实现”起来也不难，<strong>但不幸的是</strong>，<code>21!</code>就已经储存不了了，所以不能暴力求解</p><p>所以要<strong>改变思路</strong>，先从末尾0是怎么来的下手。末尾的n个0来自因式分解后10的n次方，而采用质因数分解的方法，可以发现<code>0</code>来自分解后<code>2的n次方</code>和<code>5的n次方</code>,而一个数分解后<code>2的n次方</code>必定比<code>5的n次方</code> 多，所以只需统计<code>5的n次方</code>。<strong>注意</strong>：就别再倒回去，想着先算出阶乘再求<code>5的n次方</code>了。</p><p><strong>这里采用逐步计数的方法</strong>：结果中的<code>5的n次方</code>来自各个因数中<code>5的N次方</code>的累乘,所以只需要历遍每个因数，并统计其中<code>因数5</code>的次数。这样过程中就不会有过大的数字了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码实现</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">count_num0</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> copy = i<span class="comment">//防止改变循环变量</span></span><br><span class="line">        <span class="keyword">while</span>(copy%<span class="number">5</span> == <span class="number">0</span>)<span class="comment">//统计因数5的出现次数</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(copy%<span class="number">5</span> == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            copy/=<span class="number">5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="快速输出1-2-……-10-n"><a href="#快速输出1-2-……-10-n" class="headerlink" title="快速输出1+2+……+10^n"></a>快速输出1+2+……+10^n</h2><p><em>如下图</em>：当我们试图算一算答案时，发现<code>n</code>到了<code>10</code>时就已经算不出答案了</p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/gao_si.png" alt="计算结果"></p><p>所以要<strong>改变输出答案答案的方式</strong>,观察一下<code>n</code>在<code>1~9</code>时的输出</p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-10-19_07-26-54.jpg" alt="输出"></p><p>这时我们发现<strong>答案颇有规律</strong>：每个输出都是<strong>两段</strong><code>先一个5，然后n-1个0</code>！</p><p>这样我们只需<strong>从最高位往最低位</strong>逐位打印即可,代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">printChar</span><span class="params">(<span class="type">int</span> n)</span><span class="comment">//版本一，逐位打印字符(串)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;5&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//再重复一段</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;5&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printNum</span><span class="params">(<span class="type">int</span> n)</span><span class="comment">//版本二，逐位打印整型</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//再重复一段</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何在VS里使用scanf</title>
      <link href="/2023/10/05/useScanf/"/>
      <url>/2023/10/05/useScanf/</url>
      
        <content type="html"><![CDATA[<h1 id="VS里怎么连scanf都用不了？"><a href="#VS里怎么连scanf都用不了？" class="headerlink" title="VS里怎么连scanf都用不了？"></a>VS里怎么连scanf都用不了？</h1><p>不少刚接触<a href="https://visualstudio.microsoft.com/zh-hans/free-developer-offers/">Visual Studio</a>的可能发现使用scanf会报错(如下)</p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/VS_scanf.jpg" alt="报错图片"></p><p>vs告诉你说<code>scanf</code>不安全，然后你会发现vs给你提供了<code>scanf_s</code>去代替<code>scanf</code>,<strong>但是</strong>,只有vs能编译<code>scanf_s</code>,<strong>可移植性</strong>太差了，所以我们要用回<code>scanf</code>,所以要怎么不让它报错呢？<strong>可以在源文件开头添加一行宏定义(如下)</strong></p><p><code>#define  _CRT_SECURE_NO_WARNINGS 1</code></p><p>这样就能<strong>关闭报错</strong>了,但请先<strong>别急着走</strong>,每次都要复制粘贴一句宏定义太麻烦了，想<strong>一劳永逸</strong>的请往下看。</p><h1 id="修改newc-file-cpp来自动添加宏定义"><a href="#修改newc-file-cpp来自动添加宏定义" class="headerlink" title="修改newc++file.cpp来自动添加宏定义"></a>修改newc++file.cpp来自动添加宏定义</h1><p><strong>先来看怎么做：</strong>首先搜索找到电脑中叫做<code>newc++file.cpp</code>的文件。（这里推荐使用<a href="https://www.voidtools.com/zh-cn/downloads/">everything</a>）</p><hr><p><em>后半段路径应与图片一致，注意不是快捷方式</em></p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/newcppfile.jpg" alt="c++文件的位置"></p><hr><p><strong>注意</strong>：由于权限原因，<strong>无法</strong>直接修改此文件</p><p>所以先将这个文件复制粘贴到别处，例如桌面，下文用<code>副本</code>代称。</p><p>用记事本类软件(记事本就行)打开<code>副本</code>,在第一行输入上文提到的宏定义代码<code>#define  _CRT_SECURE_NO_WARNINGS 1</code>,然后<code>ctrl+s</code>保存。</p><p><strong>关闭编辑窗口</strong>，将该<code>副本</code>移动到原始文件所在文件夹，弹出如下窗口，然后选择<strong>替换文件</strong></p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-10-08_12-28-18.jpg"></p><p>接着弹出下一个提示，点<strong>接续</strong></p><p><img src="https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-10-08_12-28-33.jpg"></p><p>等待它替换完成，然后<strong>大功告成！</strong>。之后新建的每一个<code>.c</code>或<code>.cpp</code> 文件都会自带那段宏定义，于是<code>scanf</code>从此任君使用。<del>当然平时删代码的时候记得别把那段宏定义删了</del></p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>VS所新建的<code>.c</code>和<code>.cpp</code>文件都源自于对上文<code>newc++file.cpp</code>文件的拷贝，通过修改它就能改变<code>VS新建文件</code>的初始内容</p>]]></content>
      
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>=回顾-前端=从简陋的html到单网页再到全栈开发</title>
      <link href="/2023/09/23/vueTheRoad/"/>
      <url>/2023/09/23/vueTheRoad/</url>
      
        <content type="html"><![CDATA[<p><a href="https://picbed.supdriver.top/html/prj_basis++/index.html">👉点我去作业一</a></p><p><a href="https://picbed.supdriver.top/html/adc_v2/index.html">👉点我去作业二</a></p><p><a href="http://localhost:5173/">👉点我去作业三</a>(抱歉，还没部署到服务器里，这个只能在我自己的电脑里用)</p><p><a href="https://picbed.supdriver.top/video/never.mp4">👉点我去作业四</a></p><p><del>其实这依然是个博客</del></p><hr><h1 id="粗糙的作业一"><a href="#粗糙的作业一" class="headerlink" title="粗糙的作业一"></a>粗糙的作业一</h1><p>当时只学过html,css,js的快速入门，对盒子<code>&lt;div&gt;</code>的玩法还不太熟，还只会用浮动盒子<code>float</code>和绝对定位,结局就是写两句html就得清除浮动<del>233</del>,甚至<code>&lt;lenged&gt;</code>也不认识，结果手动用css给实现了。总之就挺简陋的</p><h1 id="精致-并不-作业二"><a href="#精致-并不-作业二" class="headerlink" title="精致(并不)作业二"></a>精致<del>(并不)</del>作业二</h1><p>用vscode写作业二的时候，写一半发现鼠标悬停在<code>tag</code>时，它会给出去往<a href="https://developer.mozilla.org/zh-CN/"><em>MDN</em></a>对应参考页的连接,然后就开始一边写一边阅读MDN,结果一发不可收拾，开始读的时间比写的时间还长。最后成功学到神器<del>bushi</del><code>flex</code><strong>弹性盒子模型。</strong>。</p><p>但还没完，除了参阅文档，我还多次在B站首页和MC百度百科首页打开<code>F12</code>,查看，学习他们是如何布局盒子的，别说，学成品也挺有用的，对盒子的排版，嵌套的想法成熟多了</p><p>结合二者，照着图片做一个网页便没什么问题了。那个作业二我甚至直接弃掉了初版（已经把顶部做好了）version2基本完全采用<code>flex盒子</code>。比较遗憾的是，虽然每个菜单按钮都加了超链接，但是对应的网页并没有做出来（创作力有限）。但至少是个合格的花瓶，嘿嘿</p><h1 id="速成作业三"><a href="#速成作业三" class="headerlink" title="速成作业三"></a>速成作业三</h1><p>因为作业三没部署到服务器上，只能文字描述了（悲）</p><p>作业三我选的是用<code>vue</code>搭建个人博客，我先是自学了几天vue,结果发现光学vue就做不了个人博客，于是在B站上找了个时长6小时的全栈开发，用<code>js</code>写的服务端，数据库用<code>sqlite</code>,前端框架是<code>vue</code>.</p><p>好家伙，5天爆肝项目（包括但不限于<em>抄代码</em>,<em>找bug</em>,<em>找bug</em>,<em>找bug</em>），成功把博客的基本功能写完了。除了<code>Naive UI</code>的代码是复制<strong>组件库</strong>里的，剩下的代码基本都是我<strong>手打</strong>的，可以说忙得不亦乐乎，而且当时我并不太懂<code>js语法</code>，体验可以说是相当刺激了。</p><p>但<strong>回报不小</strong>，就算不能说入门吧，到时候自己加功能，照葫芦画瓢，自己写<code>js</code>的能力还是有了滴。而且这也是我首次<strong>接触数据库</strong>,混个脸熟，嘿嘿。而且<strong>最重要</strong>的一点，我成功增加了一个<strong>高自由度的个人博客</strong>，<del>讲真hexo的各自魔改我不太玩的懂</del>。</p><h2 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h2><p>作业三部曲之后，我大概就不太去碰前端了，至少一周爆肝一个全栈开发项目这种疯狂的行为不会再有了，权当是一次挑战罢，一次冒险，一次对边界的探索罢。重心很明确，对前端顶多写写像这篇博客一样的感悟，技术博客主要还是在后端语言，算法，数据结构之类</p>]]></content>
      
      
      
        <tags>
            
            <tag> 回顾 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>=算法=双指针的种种应用(更新中)</title>
      <link href="/2023/09/12/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
      <url>/2023/09/12/%E5%8F%8C%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<p><em>注：本文写于C语言学习早期，双指针的用法较为基础且不全面。本文章将涉及C语言数组至数据结构的链表</em></p><h2 id="Q-为什么要用双指针"><a href="#Q-为什么要用双指针" class="headerlink" title="Q:为什么要用双指针?"></a>Q:为什么要用双指针?</h2><p>A:因为<br>通过使用双指针可以使算法的<strong>时间复杂度降低</strong>(或者降低遍历次数),有时也能<strong>降低空间复杂度</strong></p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>根据双指针的用法，可分为<strong>前后双指针</strong>,<strong>头尾双指针</strong>,<strong>快慢双指针</strong>…..</p><hr><h1 id="以下为各种双指针的应用及介绍"><a href="#以下为各种双指针的应用及介绍" class="headerlink" title="以下为各种双指针的应用及介绍"></a>以下为各种双指针的应用及介绍</h1><h2 id="前后双指针"><a href="#前后双指针" class="headerlink" title="前后双指针"></a>前后双指针</h2><h4 id="应用一-删除排序数组中的重复项"><a href="#应用一-删除排序数组中的重复项" class="headerlink" title="应用一 删除排序数组中的重复项"></a>应用一 删除排序数组中的重复项</h4><p><strong>要求</strong>:原地删除,并返回新数组的长度，不需要考虑数组中超出新长度后面的元素。</p><p><strong>思路</strong>:通过创建一前一后两个指针，<strong>前指针</strong>指向<strong>上一个元素</strong>，<strong>后指针</strong>向后历遍,一旦<strong>找到</strong>不同的元素,前指针指向<strong>下一个位置，并视为空位</strong>，通过<strong>后指针</strong>找到目标元素,并存入前指针目前所指向的<strong>空位</strong>。然后<strong>后指针</strong>接着遍历，直至遍历整个数组.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码实现</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span>&#123;</span><br><span class="line">    <span class="type">int</span>* left = nums;</span><br><span class="line">    <span class="type">int</span>*right = nums+<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//遍历数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;numsSize<span class="number">-1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(*left != *right)</span><br><span class="line">        &#123;</span><br><span class="line">            left++;</span><br><span class="line">            *left = *right;</span><br><span class="line">            right++;</span><br><span class="line">            ret++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>分析</strong>:这个函数只遍历的一遍数组，没有复制数组,所以<strong>时间复杂度</strong>为<code>O(n)</code>,<strong>空间复杂度</strong>为<code>O(1)</code>;</p><hr><h2 id="头尾双指针"><a href="#头尾双指针" class="headerlink" title="头尾双指针"></a>头尾双指针</h2><h4 id="应用一-翻转数组-字符串"><a href="#应用一-翻转数组-字符串" class="headerlink" title="应用一 翻转数组&#x2F;字符串"></a>应用一 翻转数组&#x2F;字符串</h4><p>关于翻转，首先想到的应该是创建一个<strong>等长的空数组</strong>，再同时顺序遍历<strong>原数组</strong>和逆序遍历<strong>空数组</strong>，逐位储存到空数组，然后再同时顺序遍历两个数组，将<strong>已逆序</strong>的数组拷贝至原数组</p><p><strong>缺点</strong>：需要<strong>多次</strong>遍历，且<strong>空间复杂度</strong>为O(n)</p><p><strong>使用双指针优化</strong>：整个数组的翻转可逐步拆解为：第一个和最后一个互换、第二个和倒数第二个互换、、、第N个数和倒数第N个数互换，直至中间。此处便可使用<strong>双指针</strong>，头尾指针各自一边<strong>交换</strong>所指向的内容，一边<strong>向中间靠近</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码实现-这里是翻转字符串</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">reverseString</span><span class="params">(<span class="type">char</span>* s, <span class="type">int</span> sSize)</span>&#123;</span><br><span class="line">    <span class="type">int</span> *left = s;<span class="comment">//头指针</span></span><br><span class="line">    <span class="type">int</span> *right = s + sSize<span class="number">-1</span>;<span class="comment">//尾指针</span></span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)<span class="comment">//尚未到达中间时</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> tmp = *left;</span><br><span class="line">        *left = *right;</span><br><span class="line">        *right = tmp;</span><br><span class="line">        left++;</span><br><span class="line">        right--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="快慢双指针"><a href="#快慢双指针" class="headerlink" title="快慢双指针"></a>快慢双指针</h2><h4 id="应用一-删除链表倒数第K个节点"><a href="#应用一-删除链表倒数第K个节点" class="headerlink" title="应用一 删除链表倒数第K个节点"></a>应用一 删除链表倒数第K个节点</h4><p><strong>一般解法</strong>：先遍历一遍链表获得链表总数N,再二次遍历到N-K处的节点，并执行删除</p><p><strong>如何优化</strong>：使用快慢双指针，仅需遍历一次，就能用慢指针定位目标节点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码实现</span></span><br><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">removeNthFromEnd</span><span class="params">(<span class="keyword">struct</span> ListNode* head, <span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="comment">//创建哨兵位解决头删问题</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">dummy</span> =</span> (<span class="keyword">struct</span> ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> ListNode));</span><br><span class="line">    dummy-&gt;val = <span class="number">0</span>;</span><br><span class="line">    dummy-&gt;next = head;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">slow</span> =</span> dummy;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">fast</span> =</span> dummy;</span><br><span class="line">    <span class="keyword">while</span> (<span class="type">int</span> i = <span class="number">0</span>;i&lt;n+<span class="number">1</span>;n++)<span class="comment">//移动fast</span></span><br><span class="line">    &#123;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(fast != <span class="literal">NULL</span>)<span class="comment">//同时遍历</span></span><br><span class="line">    &#123;</span><br><span class="line">        fast= fast-&gt;next;</span><br><span class="line">        slow= slow-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//此时slow指向目标节点的前一个节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">tmp</span> =</span> slow-&gt;next;</span><br><span class="line">    slow-&gt;next = slow-&gt;next-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(tmp);</span><br><span class="line">    <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="应用二-找出并返回链表中间的节点"><a href="#应用二-找出并返回链表中间的节点" class="headerlink" title="应用二 找出并返回链表中间的节点"></a>应用二 找出并返回链表中间的节点</h4><p><strong>注</strong>:偶数个节点时删除<strong>前一个</strong>中间节点</p><p><strong>一般解法</strong>：依然是先遍历一遍链表，然后定位中间的节点,二次遍历</p><p><strong>如何优化</strong>：使用<strong>慢指针</strong>(一步走一个节点)和<strong>快指针</strong>(一步走两个节点)，二者同时遍历，直至<strong>快指针</strong>指向<code>NULL</code>或快指针指向<code>尾节点</code></p><p>当遍历结束时，慢指针指向目标中间节点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码实现</span></span><br><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">middleNode</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">slow</span> =</span> head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">fast</span> =</span> head;</span><br><span class="line">    <span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next-&gt;next; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="应用三-循环链表问题"><a href="#应用三-循环链表问题" class="headerlink" title="应用三 循环链表问题"></a>应用三 循环链表问题</h2>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>=算法=按位异或^的种种玩法</title>
      <link href="/2023/09/04/%E7%AE%97%E6%B3%95_%E6%8C%89%E4%BD%8D%E5%BC%82%E6%88%96/"/>
      <url>/2023/09/04/%E7%AE%97%E6%B3%95_%E6%8C%89%E4%BD%8D%E5%BC%82%E6%88%96/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是按位异或"><a href="#什么是按位异或" class="headerlink" title="什么是按位异或^"></a>什么是按位异或<code>^</code></h2><p>首先将不同数制的数写成<strong>二进制</strong>,例如<code>9-&gt;0b1001</code>.<br>然后最末位对齐，依次<strong>按位异或</strong>.<br>规则:<code>0 ^ 0= 0 ; 1 ^ 1 = 0; 1 ^ 0 = 1</code><br>推论:任意整数<code>x</code>,都有<code>0^x = x</code>  ;   <code>x ^ x = 0</code>\</p><hr><p><strong>来看看应用</strong></p><h2 id="寻找一个单身狗数"><a href="#寻找一个单身狗数" class="headerlink" title="寻找一个单身狗数"></a>寻找一个单身狗数</h2><p>像<code>[1,3,2,2,3]</code>这样除了某一个数<code>1</code>,剩下的数字都是成对的,也就是说遍历一次数组，把所有的元素<strong>按位异或</strong>在一起，结果便是落单的那个<code>1</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码实现</span></span><br><span class="line"><span class="type">int</span> arr[] = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span> sz = <span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);<span class="comment">//求数组大小</span></span><br><span class="line"><span class="type">int</span> ret  = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i =<span class="number">0</span>;i&lt;sz;i++)</span><br><span class="line">&#123;</span><br><span class="line">    ret^=arr[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret; <span class="comment">//此时ret即为落单的那个数</span></span><br></pre></td></tr></table></figure><p><strong><em>变形</em></strong></p><h2 id="消失的数"><a href="#消失的数" class="headerlink" title="消失的数"></a>消失的数</h2><p>已知一个由0~n(缺失一个数)填充的数组，例<code>[0,6,4,2,3,1]</code>,例中的数组少了一个<code>5</code>,而我们已知数组包含0~6中的5个数，就可以将数组元素与0~6<strong>按位异或</strong>到一起，将问题<em>消失的数</em>转化为问题<em>寻找单身狗</em>,消失的数变成剩下的那个单身狗</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码实现</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">missingNumber</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;numsSize;i++&gt;)</span><br><span class="line">    &#123;</span><br><span class="line">        ret^=nums[i];<span class="comment">//历遍nums的所有元素</span></span><br><span class="line">        ret^=i;<span class="comment">//历遍0~numsSize-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    ret^=numsSize;<span class="comment">//补上numsSize;</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>进阶</em></strong></p><h2 id="找到两个单身狗"><a href="#找到两个单身狗" class="headerlink" title="找到两个单身狗"></a>找到两个单身狗</h2><p>数组再升级，单身狗变成了<strong>两个</strong>，导致不能粗暴地把所有元素按位异或来求出两个数,但我们仍可以将问题简化：能否将两个单身狗分到两个数组，使之转化为两个独立的<em>求单个单身狗问题</em>。于是难点来到了如何<strong>分组</strong></p><h3 id="方案之一便是运用按位异或和右移运算符"><a href="#方案之一便是运用按位异或和右移运算符" class="headerlink" title="方案之一便是运用按位异或和右移运算符"></a>方案之一便是运用<strong>按位异或</strong>和<strong>右移运算符</strong></h3><p>因为两个不同的数，在二进制上作比较，就至少有一位是不同的，以那一位为<code>0</code>或<code>1</code>分成两组，便可将两个单身狗分开.而若要查找具体是哪一位，将列表中<strong>所有元素</strong>（就包括了两数）<strong>按位异或</strong>后再用<strong>右移运算符</strong>逐位检验是否为<code>1</code>,之后便可轻松分组，并直接<strong>按位异或</strong>得出结果</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码实现</span></span><br><span class="line"><span class="type">int</span>* <span class="title function_">singleNumber</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> ret[<span class="number">2</span>])</span>&#123;</span><br><span class="line">    <span class="type">int</span> ret1 = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> ret2 = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">0</span>;<span class="comment">//用于记录&quot;1&quot;在哪一位</span></span><br><span class="line">    <span class="type">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;numsSize;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp^=nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>((tmp&gt;&gt;n) !=<span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        n++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;nums;i++&gt;)<span class="comment">//再次历遍</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((nums[i]&gt;&gt;n ==<span class="number">1</span>))<span class="comment">//分组1</span></span><br><span class="line">        &#123;</span><br><span class="line">            ret1^=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>  <span class="comment">//分组2</span></span><br><span class="line">        &#123;</span><br><span class="line">            ret2^=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ret[<span class="number">0</span>] = ret1;</span><br><span class="line">    ret[<span class="number">1</span>] = ret2;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>思考:3个，4个….N个单身狗时呢？</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>=C语言=动态内存分配遇上函数-经典错误纠错</title>
      <link href="/2023/08/28/mistake1/"/>
      <url>/2023/08/28/mistake1/</url>
      
        <content type="html"><![CDATA[<h3 id="直接完整代码"><a href="#直接完整代码" class="headerlink" title="直接完整代码"></a>直接完整代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">GetMemory</span><span class="params">(<span class="type">char</span>* p)</span>   <span class="comment">//申请内存</span></span><br><span class="line">&#123;</span><br><span class="line">p = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="number">100</span>);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Test</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span>* str = <span class="literal">NULL</span>;</span><br><span class="line">GetMemory(str);</span><br><span class="line"><span class="built_in">strcpy</span>(str, <span class="string">&quot;hello world&quot;</span>); <span class="comment">//复制字符串</span></span><br><span class="line"><span class="built_in">printf</span>(str);  <span class="comment">//输出字符串</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">Test();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>推测这段代码的的目的是通过<code>GetMemory</code>函数申请内存，然后把返回的地址存入指针变量<code>str</code>,再把字符串<code>&quot;hello world&quot;</code>复制到<code>str</code>所指向的内存中，最后<code>printf</code>输出</p><h4 id="逐步纠错"><a href="#逐步纠错" class="headerlink" title="逐步纠错"></a>逐步纠错</h4><h5 id="GetMemory"><a href="#GetMemory" class="headerlink" title="GetMemory"></a><code>GetMemory</code></h5><ol><li>首先是传参错误。若在函数内修改外部的一级指针，不能直接将外部一级指针作为<strong>实参</strong>传入：因为函数会将<strong>实参</strong>赋给<strong>形参</strong>，程序运行到大括号外面后，<strong>形参</strong>被销毁，<strong>实参</strong>没有变化。所以应该使用<code>char** p</code>二级指针作为<strong>形参</strong>,储存地址时使用<code>*p</code>\</li><li>其次是内存泄漏。开辟的内存的地址并没有传递给实参，形参又最后销毁了，同时没有释放内存，函数运行完后申请的内存无法找到，导致最终无法释放，造成内存泄漏</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//更合适的代码</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GetMenmory</span><span class="params">(<span class="type">char</span>** p)</span></span><br><span class="line">&#123;</span><br><span class="line">    *p = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="Test"><a href="#Test" class="headerlink" title="Test"></a><code>Test</code></h5><ol><li>NULL的大问题。假设<code>malloc</code>返回的地址已经存入<code>str</code>,但任然缺少对空指针的判断,导致<code>strcmp</code>中传入了空指针-&gt;报错;<code>printf</code>中传入空指针-&gt;报错</li><li>没有释放内存-&gt;内存泄漏。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//更适合的代码</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Test</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span>* str = <span class="literal">NULL</span>;</span><br><span class="line">    GetMemory(str);</span><br><span class="line">    <span class="keyword">if</span>(str == MULL)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">strcpy</span>(str,<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,str);</span><br><span class="line">    <span class="built_in">free</span>(str); <span class="comment">//防止内存泄漏</span></span><br><span class="line">    str = <span class="literal">NULL</span>; <span class="comment">//清除野指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
